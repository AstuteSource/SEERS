filename,function_name,function_scope,patterns,mutants,mutation_score,check_ids,unique_patterns,pattern_existence,mutation_category,pattern_bool
101_sorting.json,bubble_sort,21-38,"[{'lineno': 21, 'coloffset': 0, 'linematch': 'def bubble_sort(array: List[int]) -> List[int]:', 'context': '# Make sure that you add comments to all of these functions\n# so as to make it clear that you understand how each step works\n\n\ndef bubble_sort(array: List[int]) -> List[int]:\n    """"""Sort an input list called array using bubble sort.""""""\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 21, 'coloffset': 0, 'linematch': 'def bubble_sort(array: List[int]) -> List[int]:', 'context': '# Make sure that you add comments to all of these functions\n# so as to make it clear that you understand how each step works\n\n\ndef bubble_sort(array: List[int]) -> List[int]:\n    """"""Sort an input list called array using bubble sort.""""""\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 36, 'coloffset': 8, 'linematch': 'if already_sorted:', 'context': '        for j in range(n - i - 1):\n            if array[j] > array[j + 1]:\n                array[j], array[j + 1] = array[j + 1], array[j]\n                already_sorted = False\n        if already_sorted:\n            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 33, 'coloffset': 12, 'linematch': 'if array[j] > array[j + 1]:', 'context': '        # Start looking at each item of the list one by one,\n        # comparing it with its adjacent value. With each iteration\n        # the portion of the array that you look at shrinks because the remaining items have already been sorted\n        for j in range(n - i - 1):\n            if array[j] > array[j + 1]:\n                array[j], array[j + 1] = array[j + 1], array[j]\n                already_sorted = False\n        if already_sorted:\n            break\n    return array', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 21, 'coloffset': 0, 'linematch': 'def bubble_sort(array: List[int]) -> List[int]:', 'context': '# Make sure that you add comments to all of these functions\n# so as to make it clear that you understand how each step works\n\n\ndef bubble_sort(array: List[int]) -> List[int]:\n    """"""Sort an input list called array using bubble sort.""""""\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 21, 'coloffset': 0, 'linematch': 'def bubble_sort(array: List[int]) -> List[int]:', 'context': '# Make sure that you add comments to all of these functions\n# so as to make it clear that you understand how each step works\n\n\ndef bubble_sort(array: List[int]) -> List[int]:\n    """"""Sort an input list called array using bubble sort.""""""\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):', 'pattern': '//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]', 'check_id': 'C002', 'check_name': 'The number of nested loop-conditions (e.g., for{if{}}) in a Function'}, {'lineno': 26, 'coloffset': 4, 'linematch': 'for i in range(n):', 'context': '    """"""Sort an input list called array using bubble sort.""""""\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):\n        # create a flag that will allow the function to terminate early if there\'s nothing left to sort\n        already_sorted = True\n        # Start looking at each item of the list one by one,\n        # comparing it with its adjacent value. With each iteration\n        # the portion of the array that you look at shrinks because the remaining items have already been sorted', 'pattern': '//FunctionDef//For[.//For]', 'check_id': 'F001', 'check_name': 'The number of nested loop-conditions (e.g., for{for{}}) in a Function'}, {'lineno': 22, 'coloffset': 4, 'linematch': '""""""Sort an input list called array using bubble sort.""""""', 'context': '# so as to make it clear that you understand how each step works\n\n\ndef bubble_sort(array: List[int]) -> List[int]:\n    """"""Sort an input list called array using bubble sort.""""""\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):\n        # create a flag that will allow the function to terminate early if there\'s nothing left to sort', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 24, 'coloffset': 4, 'linematch': 'n = len(array)', 'context': '\ndef bubble_sort(array: List[int]) -> List[int]:\n    """"""Sort an input list called array using bubble sort.""""""\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):\n        # create a flag that will allow the function to terminate early if there\'s nothing left to sort\n        already_sorted = True\n        # Start looking at each item of the list one by one,', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 26, 'coloffset': 4, 'linematch': 'for i in range(n):', 'context': '    """"""Sort an input list called array using bubble sort.""""""\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):\n        # create a flag that will allow the function to terminate early if there\'s nothing left to sort\n        already_sorted = True\n        # Start looking at each item of the list one by one,\n        # comparing it with its adjacent value. With each iteration\n        # the portion of the array that you look at shrinks because the remaining items have already been sorted', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 38, 'coloffset': 4, 'linematch': 'return array', 'context': '                array[j], array[j + 1] = array[j + 1], array[j]\n                already_sorted = False\n        if already_sorted:\n            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    """"""Run an insertion sort on the provided array.""""""\n    # Loop from the second element of the array until the last element', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #167', 'line': 21, 'description': ['console = Console()'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -18,7 +18,7 @@\n cli = typer.Typer()\n \n # create a Console objects\n-console = Console()\n+console = None\n \n # define name format\n UNDERSCORE = ""_""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #168', 'line': 24, 'description': ['UNDERSCORE = ""_""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -21,7 +21,7 @@\n console = Console()\n \n # define name format\n-UNDERSCORE = ""_""\n+UNDERSCORE = ""XX_XX""\n SORT = ""sort""\n \n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #169', 'line': 24, 'description': ['UNDERSCORE = ""_""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -21,7 +21,7 @@\n console = Console()\n \n # define name format\n-UNDERSCORE = ""_""\n+UNDERSCORE = None\n SORT = ""sort""\n \n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #170', 'line': 25, 'description': ['SORT = ""sort""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n \n # define name format\n UNDERSCORE = ""_""\n-SORT = ""sort""\n+SORT = ""XXsortXX""\n \n \n class ListSortingApproach(str, Enum):\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #171', 'line': 25, 'description': ['SORT = ""sort""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n \n # define name format\n UNDERSCORE = ""_""\n-SORT = ""sort""\n+SORT = None\n \n \n class ListSortingApproach(str, Enum):\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #172', 'line': 33, 'description': ['    BUBBLESORT = ""bubble""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -30,7 +30,7 @@\n \n     # define name for each approach\n \n-    BUBBLESORT = ""bubble""\n+    BUBBLESORT = ""XXbubbleXX""\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n     QUICKSORT = ""quick""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #173', 'line': 33, 'description': ['    BUBBLESORT = ""bubble""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -30,7 +30,7 @@\n \n     # define name for each approach\n \n-    BUBBLESORT = ""bubble""\n+    BUBBLESORT = None\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n     QUICKSORT = ""quick""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #174', 'line': 34, 'description': ['    INSERTIONSORT = ""insertion""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -31,7 +31,7 @@\n     # define name for each approach\n \n     BUBBLESORT = ""bubble""\n-    INSERTIONSORT = ""insertion""\n+    INSERTIONSORT = ""XXinsertionXX""\n     MERGESORT = ""merge""\n     QUICKSORT = ""quick""\n     TIMSORT = ""tim""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #175', 'line': 34, 'description': ['    INSERTIONSORT = ""insertion""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -31,7 +31,7 @@\n     # define name for each approach\n \n     BUBBLESORT = ""bubble""\n-    INSERTIONSORT = ""insertion""\n+    INSERTIONSORT = None\n     MERGESORT = ""merge""\n     QUICKSORT = ""quick""\n     TIMSORT = ""tim""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #176', 'line': 35, 'description': ['    MERGESORT = ""merge""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -32,7 +32,7 @@\n \n     BUBBLESORT = ""bubble""\n     INSERTIONSORT = ""insertion""\n-    MERGESORT = ""merge""\n+    MERGESORT = ""XXmergeXX""\n     QUICKSORT = ""quick""\n     TIMSORT = ""tim""\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #177', 'line': 35, 'description': ['    MERGESORT = ""merge""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -32,7 +32,7 @@\n \n     BUBBLESORT = ""bubble""\n     INSERTIONSORT = ""insertion""\n-    MERGESORT = ""merge""\n+    MERGESORT = None\n     QUICKSORT = ""quick""\n     TIMSORT = ""tim""\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #178', 'line': 36, 'description': ['    QUICKSORT = ""quick""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     BUBBLESORT = ""bubble""\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n-    QUICKSORT = ""quick""\n+    QUICKSORT = ""XXquickXX""\n     TIMSORT = ""tim""\n \n     def __str__(self):\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #179', 'line': 36, 'description': ['    QUICKSORT = ""quick""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     BUBBLESORT = ""bubble""\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n-    QUICKSORT = ""quick""\n+    QUICKSORT = None\n     TIMSORT = ""tim""\n \n     def __str__(self):\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #180', 'line': 37, 'description': ['    TIMSORT = ""tim""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -34,7 +34,7 @@\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n     QUICKSORT = ""quick""\n-    TIMSORT = ""tim""\n+    TIMSORT = ""XXtimXX""\n \n     def __str__(self):\n         """"""Define a default string representation.""""""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #181', 'line': 37, 'description': ['    TIMSORT = ""tim""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -34,7 +34,7 @@\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n     QUICKSORT = ""quick""\n-    TIMSORT = ""tim""\n+    TIMSORT = None\n \n     def __str__(self):\n         """"""Define a default string representation.""""""\n', 'type': 'failure', 'message': 'bad_survived'}]}]",0.0,['F001' 'F002' 'CL001' 'ANNOT001' 'C002' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]'
 '//FunctionDef//For[.//For]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 1, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 1, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",low,"[1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]"
101_sorting.json,insertion_sort,41-60,"[{'lineno': 41, 'coloffset': 0, 'linematch': 'def insertion_sort(array: List[int]) -> List[int]:', 'context': '            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    """"""Run an insertion sort on the provided array.""""""\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 41, 'coloffset': 0, 'linematch': 'def insertion_sort(array: List[int]) -> List[int]:', 'context': '            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    """"""Run an insertion sort on the provided array.""""""\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 41, 'coloffset': 0, 'linematch': 'def insertion_sort(array: List[int]) -> List[int]:', 'context': '            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    """"""Run an insertion sort on the provided array.""""""\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 41, 'coloffset': 0, 'linematch': 'def insertion_sort(array: List[int]) -> List[int]:', 'context': '            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    """"""Run an insertion sort on the provided array.""""""\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]', 'pattern': '//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]', 'check_id': 'C002', 'check_name': 'The number of nested loop-conditions (e.g., for{if{}}) in a Function'}, {'lineno': 42, 'coloffset': 4, 'linematch': '""""""Run an insertion sort on the provided array.""""""', 'context': '    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    """"""Run an insertion sort on the provided array.""""""\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]\n        # Initialize the variable that will be used to find the correct position of the element referenced by the `key_item`', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 44, 'coloffset': 4, 'linematch': 'for i in range(1, len(array)):', 'context': '\ndef insertion_sort(array: List[int]) -> List[int]:\n    """"""Run an insertion sort on the provided array.""""""\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]\n        # Initialize the variable that will be used to find the correct position of the element referenced by the `key_item`\n        j = i - 1\n        # Run through the list of the items (the left portion of the array) and find the correct position', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 60, 'coloffset': 4, 'linematch': 'return array', 'context': '            j -= 1\n        # When you finish shifting the elements, you can position\n        # `key_item` in its correct location\n        array[j + 1] = key_item\n    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    """"""Define a convenience method that supports the merging of lists.""""""\n    # If the first array is empty, then nothing needs to be merged', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #182', 'line': 44, 'description': ['@cli.command()'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -40,8 +40,6 @@\n         """"""Define a default string representation.""""""\n         return self.value\n \n-\n-@cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #183', 'line': 46, 'description': ['    starting_size: int = typer.Option(1000000),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -43,7 +43,7 @@\n \n @cli.command()\n def listsorting(\n-    starting_size: int = typer.Option(1000000),\n+    starting_size: int = typer.Option(1000001),\n     maximum_value: int = typer.Option(10000),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #184', 'line': 47, 'description': ['    maximum_value: int = typer.Option(10000),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -44,7 +44,7 @@\n @cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n-    maximum_value: int = typer.Option(10000),\n+    maximum_value: int = typer.Option(10001),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #185', 'line': 48, 'description': ['    number_doubles: int = typer.Option(10),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -45,7 +45,7 @@\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n-    number_doubles: int = typer.Option(10),\n+    number_doubles: int = typer.Option(11),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n     """"""Conduct a doubling experiment to measure the performance of list sorting for various algorithms.""""""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #186', 'line': 54, 'description': ['        ""✨ Conducting an experiment to measure the performance of list sorting!""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -51,7 +51,7 @@\n     """"""Conduct a doubling experiment to measure the performance of list sorting for various algorithms.""""""\n     # display diagnostics messages of the experiment\n     console.print(\n-        ""✨ Conducting an experiment to measure the performance of list sorting!""\n+        ""XX✨ Conducting an experiment to measure the performance of list sorting!XX""\n     )\n     console.print()\n     console.print(f""The chosen sorting algorithm: {approach}"")\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #187', 'line': 57, 'description': ['    console.print(f""The chosen sorting algorithm: {approach}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -54,7 +54,7 @@\n         ""✨ Conducting an experiment to measure the performance of list sorting!""\n     )\n     console.print()\n-    console.print(f""The chosen sorting algorithm: {approach}"")\n+    console.print(f""XXThe chosen sorting algorithm: {approach}XX"")\n     console.print(f""Starting size of the data container {starting_size}"")\n     console.print(f""Number of doubles to execute: {number_doubles}"")\n     console.print()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #188', 'line': 58, 'description': ['    console.print(f""Starting size of the data container {starting_size}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -55,7 +55,7 @@\n     )\n     console.print()\n     console.print(f""The chosen sorting algorithm: {approach}"")\n-    console.print(f""Starting size of the data container {starting_size}"")\n+    console.print(f""XXStarting size of the data container {starting_size}XX"")\n     console.print(f""Number of doubles to execute: {number_doubles}"")\n     console.print()\n     console.print(""✨ Here are the results from running the experiment!"")\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #189', 'line': 59, 'description': ['    console.print(f""Number of doubles to execute: {number_doubles}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -56,7 +56,7 @@\n     console.print()\n     console.print(f""The chosen sorting algorithm: {approach}"")\n     console.print(f""Starting size of the data container {starting_size}"")\n-    console.print(f""Number of doubles to execute: {number_doubles}"")\n+    console.print(f""XXNumber of doubles to execute: {number_doubles}XX"")\n     console.print()\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n', 'type': 'failure', 'message': 'bad_survived'}]}]",0.0,['F001' 'F002' 'ANNOT001' 'C002' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 1, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",low,"[1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_sorting.json,merge,63-93,"[{'lineno': 63, 'coloffset': 0, 'linematch': 'def merge(left: List[int], right: List[int]) -> List[int]:', 'context': '        array[j + 1] = key_item\n    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    """"""Define a convenience method that supports the merging of lists.""""""\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 63, 'coloffset': 0, 'linematch': 'def merge(left: List[int], right: List[int]) -> List[int]:', 'context': '        array[j + 1] = key_item\n    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    """"""Define a convenience method that supports the merging of lists.""""""\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 67, 'coloffset': 4, 'linematch': 'if len(left) == 0:', 'context': 'def merge(left: List[int], right: List[int]) -> List[int]:\n    """"""Define a convenience method that supports the merging of lists.""""""\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged\n    # and you can return the second array as the result\n    if len(right) == 0:\n        return left', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 71, 'coloffset': 4, 'linematch': 'if len(right) == 0:', 'context': '    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged\n    # and you can return the second array as the result\n    if len(right) == 0:\n        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 77, 'coloffset': 8, 'linematch': 'if left[index_left] <= right[index_right]:', 'context': '\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):\n        if left[index_left] <= right[index_right]:\n            result.append(left[index_left])\n            index_left += 1\n        else:\n            result.append(right[index_right])\n            index_right += 1', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 86, 'coloffset': 8, 'linematch': 'if index_right == len(right):', 'context': '            index_right += 1\n        # If the reach the end of either array, then you can\n        # add the remaining elements from the other array to\n        # the result and break the loop\n        if index_right == len(right):\n            result += left[index_left:]\n            break\n        if index_left == len(left):\n            result += right[index_right:]\n            break', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 89, 'coloffset': 8, 'linematch': 'if index_left == len(left):', 'context': '        # the result and break the loop\n        if index_right == len(right):\n            result += left[index_left:]\n            break\n        if index_left == len(left):\n            result += right[index_right:]\n            break\n\n    return result\n', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 63, 'coloffset': 0, 'linematch': 'def merge(left: List[int], right: List[int]) -> List[int]:', 'context': '        array[j + 1] = key_item\n    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    """"""Define a convenience method that supports the merging of lists.""""""\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 71, 'coloffset': 4, 'linematch': 'if len(right) == 0:', 'context': '    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged\n    # and you can return the second array as the result\n    if len(right) == 0:\n        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 86, 'coloffset': 8, 'linematch': 'if index_right == len(right):', 'context': '            index_right += 1\n        # If the reach the end of either array, then you can\n        # add the remaining elements from the other array to\n        # the result and break the loop\n        if index_right == len(right):\n            result += left[index_left:]\n            break\n        if index_left == len(left):\n            result += right[index_right:]\n            break', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 89, 'coloffset': 8, 'linematch': 'if index_left == len(left):', 'context': '        # the result and break the loop\n        if index_right == len(right):\n            result += left[index_left:]\n            break\n        if index_left == len(left):\n            result += right[index_right:]\n            break\n\n    return result\n', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 63, 'coloffset': 0, 'linematch': 'def merge(left: List[int], right: List[int]) -> List[int]:', 'context': '        array[j + 1] = key_item\n    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    """"""Define a convenience method that supports the merging of lists.""""""\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right', 'pattern': '//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]', 'check_id': 'C002', 'check_name': 'The number of nested loop-conditions (e.g., for{if{}}) in a Function'}, {'lineno': 64, 'coloffset': 4, 'linematch': '""""""Define a convenience method that supports the merging of lists.""""""', 'context': '    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    """"""Define a convenience method that supports the merging of lists.""""""\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 67, 'coloffset': 4, 'linematch': 'if len(left) == 0:', 'context': 'def merge(left: List[int], right: List[int]) -> List[int]:\n    """"""Define a convenience method that supports the merging of lists.""""""\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged\n    # and you can return the second array as the result\n    if len(right) == 0:\n        return left', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 71, 'coloffset': 4, 'linematch': 'if len(right) == 0:', 'context': '    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged\n    # and you can return the second array as the result\n    if len(right) == 0:\n        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 74, 'coloffset': 4, 'linematch': 'result: List[int] = []', 'context': '    # and you can return the second array as the result\n    if len(right) == 0:\n        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):\n        if left[index_left] <= right[index_right]:\n            result.append(left[index_left])\n            index_left += 1', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 75, 'coloffset': 4, 'linematch': 'index_left = index_right = 0', 'context': '    if len(right) == 0:\n        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):\n        if left[index_left] <= right[index_right]:\n            result.append(left[index_left])\n            index_left += 1\n        else:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 76, 'coloffset': 4, 'linematch': 'while len(result) < len(left) + len(right):', 'context': '        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):\n        if left[index_left] <= right[index_right]:\n            result.append(left[index_left])\n            index_left += 1\n        else:\n            result.append(right[index_right])', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 93, 'coloffset': 4, 'linematch': 'return result', 'context': '        if index_left == len(left):\n            result += right[index_right:]\n            break\n\n    return result\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    """"""Sort the provided list called array with the merge sort algorithm.""""""\n    if len(array) < 2:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #191', 'line': 64, 'description': ['    algorithm = approach + UNDERSCORE + SORT'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach - UNDERSCORE + SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #192', 'line': 64, 'description': ['    algorithm = approach + UNDERSCORE + SORT'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach + UNDERSCORE - SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #193', 'line': 64, 'description': ['    algorithm = approach + UNDERSCORE + SORT'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = None\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #194', 'line': 67, 'description': ['    )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -62,9 +62,7 @@\n     console.print()\n     # define the name approach\n     algorithm = approach + UNDERSCORE + SORT\n-    result = experiment.run_sorting_algorithm_experiment_campaign(\n-        algorithm, starting_size, maximum_value, number_doubles\n-    )\n+    result = None\n     data = [\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #195', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""XXInput SizeXX"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #196', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""Input Size"", ""XXMin time (s)XX"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #197', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""Input Size"", ""Min time (s)"", ""XXMax time (s)XX"", ""Avg time (s)""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #198', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""XXAvg time (s)XX""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #199', 'line': 70, 'description': ['        result[0],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -67,7 +67,7 @@\n     )\n     data = [\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n-        result[0],\n+        result[1],\n         result[1],\n         result[2],\n         result[3],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #200', 'line': 71, 'description': ['        result[1],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -68,7 +68,7 @@\n     data = [\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n-        result[1],\n+        result[2],\n         result[2],\n         result[3],\n         result[4],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #201', 'line': 72, 'description': ['        result[2],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -69,7 +69,7 @@\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n         result[1],\n-        result[2],\n+        result[3],\n         result[3],\n         result[4],\n     ]\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #202', 'line': 73, 'description': ['        result[3],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -70,7 +70,7 @@\n         result[0],\n         result[1],\n         result[2],\n-        result[3],\n+        result[4],\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #203', 'line': 74, 'description': ['        result[4],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -71,7 +71,7 @@\n         result[1],\n         result[2],\n         result[3],\n-        result[4],\n+        result[5],\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=""firstrow"")\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #204', 'line': 75, 'description': ['    ]'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -65,14 +65,7 @@\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n-    data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n-        result[0],\n-        result[1],\n-        result[2],\n-        result[3],\n-        result[4],\n-    ]\n+    data = None\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=""firstrow"")\n     print(table)\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #205', 'line': 77, 'description': ['    table = tabulate(data, headers=""firstrow"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=""firstrow"")\n+    table = tabulate(data, headers=""XXfirstrowXX"")\n     print(table)\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #206', 'line': 77, 'description': ['    table = tabulate(data, headers=""firstrow"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=""firstrow"")\n+    table = None\n     print(table)\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #207', 'line': 78, 'description': ['    print(table)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -75,5 +75,5 @@\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=""firstrow"")\n-    print(table)\n+    print(None)\n \n', 'type': 'failure', 'message': 'bad_survived'}]}]",0.0,['F001' 'F002' 'CL001' 'ANNOT001' 'C002' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else'
 '//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 1, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 1, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",low,"[1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_sorting.json,generate_random_number,17-22,"[{'lineno': 17, 'coloffset': 0, 'linematch': 'def generate_random_number(maximum: int) -> int:', 'context': '    format_float = ""{:.5f}"".format(number)\n    return format_float\n\n\ndef generate_random_number(maximum: int) -> int:\n    """"""Generate a random list defined by the size.""""""\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 17, 'coloffset': 0, 'linematch': 'def generate_random_number(maximum: int) -> int:', 'context': '    format_float = ""{:.5f}"".format(number)\n    return format_float\n\n\ndef generate_random_number(maximum: int) -> int:\n    """"""Generate a random list defined by the size.""""""\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 17, 'coloffset': 0, 'linematch': 'def generate_random_number(maximum: int) -> int:', 'context': '    format_float = ""{:.5f}"".format(number)\n    return format_float\n\n\ndef generate_random_number(maximum: int) -> int:\n    """"""Generate a random list defined by the size.""""""\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 18, 'coloffset': 4, 'linematch': '""""""Generate a random list defined by the size.""""""', 'context': '    return format_float\n\n\ndef generate_random_number(maximum: int) -> int:\n    """"""Generate a random list defined by the size.""""""\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 20, 'coloffset': 4, 'linematch': 'random_value = random.randint(0, maximum)', 'context': '\ndef generate_random_number(maximum: int) -> int:\n    """"""Generate a random list defined by the size.""""""\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 22, 'coloffset': 4, 'linematch': 'return random_value', 'context': '    """"""Generate a random list defined by the size.""""""\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(\n    size: int,\n    maximum: int,', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #166', 'line': 18, 'description': ['cli = typer.Typer()'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -15,7 +15,7 @@\n from listsorting import experiment\n \n # create a Typer object\n-cli = typer.Typer()\n+cli = None\n \n # create a Console objects\n console = Console()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #167', 'line': 21, 'description': ['console = Console()'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -18,7 +18,7 @@\n cli = typer.Typer()\n \n # create a Console objects\n-console = Console()\n+console = None\n \n # define name format\n UNDERSCORE = ""_""\n', 'type': 'failure', 'message': 'bad_survived'}]}]",0.0,['F001' 'F002' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",low,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_sorting.json,generate_random_container,25-33,"[{'lineno': 25, 'coloffset': 0, 'linematch': 'def generate_random_container(', 'context': '    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(\n    size: int,\n    maximum: int,\n) -> List[int]:\n    """"""Generate a random list defined by the size.""""""\n    # generate a list of random values for a specific size', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 25, 'coloffset': 0, 'linematch': 'def generate_random_container(', 'context': '    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(\n    size: int,\n    maximum: int,\n) -> List[int]:\n    """"""Generate a random list defined by the size.""""""\n    # generate a list of random values for a specific size', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 25, 'coloffset': 0, 'linematch': 'def generate_random_container(', 'context': '    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(\n    size: int,\n    maximum: int,\n) -> List[int]:\n    """"""Generate a random list defined by the size.""""""\n    # generate a list of random values for a specific size', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 25, 'coloffset': 0, 'linematch': 'def generate_random_container(', 'context': '    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(\n    size: int,\n    maximum: int,\n) -> List[int]:\n    """"""Generate a random list defined by the size.""""""\n    # generate a list of random values for a specific size', 'pattern': '//FunctionDef[body//comprehension/target/Name]', 'check_id': 'FLV001', 'check_name': 'Function uses loop variable'}, {'lineno': 29, 'coloffset': 4, 'linematch': '""""""Generate a random list defined by the size.""""""', 'context': 'def generate_random_container(\n    size: int,\n    maximum: int,\n) -> List[int]:\n    """"""Generate a random list defined by the size.""""""\n    # generate a list of random values for a specific size\n    # and with a number up to a specific maximum\n    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 32, 'coloffset': 4, 'linematch': 'random_list = [random.randrange(1, maximum, 1) for _ in range(size)]', 'context': ') -> List[int]:\n    """"""Generate a random list defined by the size.""""""\n    # generate a list of random values for a specific size\n    # and with a number up to a specific maximum\n    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    """"""Run a sorting algorithm and profile it with the timeit package.""""""', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 33, 'coloffset': 4, 'linematch': 'return random_list', 'context': '    """"""Generate a random list defined by the size.""""""\n    # generate a list of random values for a specific size\n    # and with a number up to a specific maximum\n    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    """"""Run a sorting algorithm and profile it with the timeit package.""""""\n    # set up the context and prepare the call to the specified', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #170', 'line': 25, 'description': ['SORT = ""sort""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n \n # define name format\n UNDERSCORE = ""_""\n-SORT = ""sort""\n+SORT = ""XXsortXX""\n \n \n class ListSortingApproach(str, Enum):\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #171', 'line': 25, 'description': ['SORT = ""sort""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n \n # define name format\n UNDERSCORE = ""_""\n-SORT = ""sort""\n+SORT = None\n \n \n class ListSortingApproach(str, Enum):\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #172', 'line': 33, 'description': ['    BUBBLESORT = ""bubble""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -30,7 +30,7 @@\n \n     # define name for each approach\n \n-    BUBBLESORT = ""bubble""\n+    BUBBLESORT = ""XXbubbleXX""\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n     QUICKSORT = ""quick""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #173', 'line': 33, 'description': ['    BUBBLESORT = ""bubble""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -30,7 +30,7 @@\n \n     # define name for each approach\n \n-    BUBBLESORT = ""bubble""\n+    BUBBLESORT = None\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n     QUICKSORT = ""quick""\n', 'type': 'failure', 'message': 'bad_survived'}]}]",0.0,['F001' 'F002' 'ANNOT001' 'FLV001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef[body//comprehension/target/Name]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 1, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",low,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_sorting.json,run_sorting_algorithm,36-52,"[{'lineno': 36, 'coloffset': 0, 'linematch': 'def run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:', 'context': '    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    """"""Run a sorting algorithm and profile it with the timeit package.""""""\n    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it\'s not the built-in `sorted()`.\n    setup_code = f""from listsorting.sorting import {algorithm}""', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 36, 'coloffset': 0, 'linematch': 'def run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:', 'context': '    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    """"""Run a sorting algorithm and profile it with the timeit package.""""""\n    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it\'s not the built-in `sorted()`.\n    setup_code = f""from listsorting.sorting import {algorithm}""', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 36, 'coloffset': 0, 'linematch': 'def run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:', 'context': '    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    """"""Run a sorting algorithm and profile it with the timeit package.""""""\n    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it\'s not the built-in `sorted()`.\n    setup_code = f""from listsorting.sorting import {algorithm}""', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 37, 'coloffset': 4, 'linematch': '""""""Run a sorting algorithm and profile it with the timeit package.""""""', 'context': '    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    """"""Run a sorting algorithm and profile it with the timeit package.""""""\n    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it\'s not the built-in `sorted()`.\n    setup_code = f""from listsorting.sorting import {algorithm}""\n    stmt = f""{algorithm}({array})""', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 41, 'coloffset': 4, 'linematch': 'setup_code = f""from listsorting.sorting import {algorithm}""', 'context': '    """"""Run a sorting algorithm and profile it with the timeit package.""""""\n    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it\'s not the built-in `sorted()`.\n    setup_code = f""from listsorting.sorting import {algorithm}""\n    stmt = f""{algorithm}({array})""\n    # execute the code ten different times and return the time\n    # in seconds that each execution took\n    times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)\n    # finally, return the amount of execution time summarized as:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 42, 'coloffset': 4, 'linematch': 'stmt = f""{algorithm}({array})""', 'context': '    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it\'s not the built-in `sorted()`.\n    setup_code = f""from listsorting.sorting import {algorithm}""\n    stmt = f""{algorithm}({array})""\n    # execute the code ten different times and return the time\n    # in seconds that each execution took\n    times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)\n    # finally, return the amount of execution time summarized as:\n    # (minimum execution time, maximum execution time, average execution time)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 45, 'coloffset': 4, 'linematch': 'times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)', 'context': '    setup_code = f""from listsorting.sorting import {algorithm}""\n    stmt = f""{algorithm}({array})""\n    # execute the code ten different times and return the time\n    # in seconds that each execution took\n    times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)\n    # finally, return the amount of execution time summarized as:\n    # (minimum execution time, maximum execution time, average execution time)\n    return (\n        format_decimal(min(times)),\n        format_decimal(max(times)),', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 48, 'coloffset': 4, 'linematch': 'return (', 'context': '    # in seconds that each execution took\n    times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)\n    # finally, return the amount of execution time summarized as:\n    # (minimum execution time, maximum execution time, average execution time)\n    return (\n        format_decimal(min(times)),\n        format_decimal(max(times)),\n        format_decimal((sum(times) / len(times))),\n    )\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #178', 'line': 36, 'description': ['    QUICKSORT = ""quick""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     BUBBLESORT = ""bubble""\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n-    QUICKSORT = ""quick""\n+    QUICKSORT = ""XXquickXX""\n     TIMSORT = ""tim""\n \n     def __str__(self):\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #179', 'line': 36, 'description': ['    QUICKSORT = ""quick""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     BUBBLESORT = ""bubble""\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n-    QUICKSORT = ""quick""\n+    QUICKSORT = None\n     TIMSORT = ""tim""\n \n     def __str__(self):\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #180', 'line': 37, 'description': ['    TIMSORT = ""tim""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -34,7 +34,7 @@\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n     QUICKSORT = ""quick""\n-    TIMSORT = ""tim""\n+    TIMSORT = ""XXtimXX""\n \n     def __str__(self):\n         """"""Define a default string representation.""""""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #181', 'line': 37, 'description': ['    TIMSORT = ""tim""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -34,7 +34,7 @@\n     INSERTIONSORT = ""insertion""\n     MERGESORT = ""merge""\n     QUICKSORT = ""quick""\n-    TIMSORT = ""tim""\n+    TIMSORT = None\n \n     def __str__(self):\n         """"""Define a default string representation.""""""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #182', 'line': 44, 'description': ['@cli.command()'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -40,8 +40,6 @@\n         """"""Define a default string representation.""""""\n         return self.value\n \n-\n-@cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #183', 'line': 46, 'description': ['    starting_size: int = typer.Option(1000000),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -43,7 +43,7 @@\n \n @cli.command()\n def listsorting(\n-    starting_size: int = typer.Option(1000000),\n+    starting_size: int = typer.Option(1000001),\n     maximum_value: int = typer.Option(10000),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #184', 'line': 47, 'description': ['    maximum_value: int = typer.Option(10000),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -44,7 +44,7 @@\n @cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n-    maximum_value: int = typer.Option(10000),\n+    maximum_value: int = typer.Option(10001),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #185', 'line': 48, 'description': ['    number_doubles: int = typer.Option(10),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -45,7 +45,7 @@\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n-    number_doubles: int = typer.Option(10),\n+    number_doubles: int = typer.Option(11),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n     """"""Conduct a doubling experiment to measure the performance of list sorting for various algorithms.""""""\n', 'type': 'failure', 'message': 'bad_survived'}]}]",0.0,['F001' 'F002' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",low,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_sorting.json,run_sorting_algorithm_experiment_campaign,55-81,"[{'lineno': 55, 'coloffset': 0, 'linematch': 'def run_sorting_algorithm_experiment_campaign(', 'context': '        format_decimal((sum(times) / len(times))),\n    )\n\n\ndef run_sorting_algorithm_experiment_campaign(\n    algorithm: str,\n    starting_size: int,\n    maximum_value: int,\n    number_doubles: int,\n) -> List[List[Any]]:', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 55, 'coloffset': 0, 'linematch': 'def run_sorting_algorithm_experiment_campaign(', 'context': '        format_decimal((sum(times) / len(times))),\n    )\n\n\ndef run_sorting_algorithm_experiment_campaign(\n    algorithm: str,\n    starting_size: int,\n    maximum_value: int,\n    number_doubles: int,\n) -> List[List[Any]]:', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 55, 'coloffset': 0, 'linematch': 'def run_sorting_algorithm_experiment_campaign(', 'context': '        format_decimal((sum(times) / len(times))),\n    )\n\n\ndef run_sorting_algorithm_experiment_campaign(\n    algorithm: str,\n    starting_size: int,\n    maximum_value: int,\n    number_doubles: int,\n) -> List[List[Any]]:', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 61, 'coloffset': 4, 'linematch': '""""""Run an entire sorting algorithm experiment campaign.""""""', 'context': '    starting_size: int,\n    maximum_value: int,\n    number_doubles: int,\n) -> List[List[Any]]:\n    """"""Run an entire sorting algorithm experiment campaign.""""""\n    data_table = []\n    # run a total of number_doubles number of doubles for the input size\n    while number_doubles > 0:\n        # generate a random list based on the current size of the data\n        random_list = generate_random_container(starting_size, maximum_value)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 62, 'coloffset': 4, 'linematch': 'data_table = []', 'context': '    maximum_value: int,\n    number_doubles: int,\n) -> List[List[Any]]:\n    """"""Run an entire sorting algorithm experiment campaign.""""""\n    data_table = []\n    # run a total of number_doubles number of doubles for the input size\n    while number_doubles > 0:\n        # generate a random list based on the current size of the data\n        random_list = generate_random_container(starting_size, maximum_value)\n        # run the sorting algorithm and collect the timing data from timeit', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 64, 'coloffset': 4, 'linematch': 'while number_doubles > 0:', 'context': ') -> List[List[Any]]:\n    """"""Run an entire sorting algorithm experiment campaign.""""""\n    data_table = []\n    # run a total of number_doubles number of doubles for the input size\n    while number_doubles > 0:\n        # generate a random list based on the current size of the data\n        random_list = generate_random_container(starting_size, maximum_value)\n        # run the sorting algorithm and collect the timing data from timeit\n        performance_data = run_sorting_algorithm(algorithm, random_list)\n        # create the row of data from this specific execution of the algorithm', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 81, 'coloffset': 4, 'linematch': 'return data_table', 'context': '        data_table.append(data_table_row)\n        # move to the next round of the doubling experiment\n        number_doubles = number_doubles - 1\n        starting_size = starting_size * 2\n    return data_table', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #187', 'line': 57, 'description': ['    console.print(f""The chosen sorting algorithm: {approach}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -54,7 +54,7 @@\n         ""✨ Conducting an experiment to measure the performance of list sorting!""\n     )\n     console.print()\n-    console.print(f""The chosen sorting algorithm: {approach}"")\n+    console.print(f""XXThe chosen sorting algorithm: {approach}XX"")\n     console.print(f""Starting size of the data container {starting_size}"")\n     console.print(f""Number of doubles to execute: {number_doubles}"")\n     console.print()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #188', 'line': 58, 'description': ['    console.print(f""Starting size of the data container {starting_size}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -55,7 +55,7 @@\n     )\n     console.print()\n     console.print(f""The chosen sorting algorithm: {approach}"")\n-    console.print(f""Starting size of the data container {starting_size}"")\n+    console.print(f""XXStarting size of the data container {starting_size}XX"")\n     console.print(f""Number of doubles to execute: {number_doubles}"")\n     console.print()\n     console.print(""✨ Here are the results from running the experiment!"")\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #189', 'line': 59, 'description': ['    console.print(f""Number of doubles to execute: {number_doubles}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -56,7 +56,7 @@\n     console.print()\n     console.print(f""The chosen sorting algorithm: {approach}"")\n     console.print(f""Starting size of the data container {starting_size}"")\n-    console.print(f""Number of doubles to execute: {number_doubles}"")\n+    console.print(f""XXNumber of doubles to execute: {number_doubles}XX"")\n     console.print()\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #190', 'line': 61, 'description': ['    console.print(""✨ Here are the results from running the experiment!"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -58,7 +58,7 @@\n     console.print(f""Starting size of the data container {starting_size}"")\n     console.print(f""Number of doubles to execute: {number_doubles}"")\n     console.print()\n-    console.print(""✨ Here are the results from running the experiment!"")\n+    console.print(""XX✨ Here are the results from running the experiment!XX"")\n     console.print()\n     # define the name approach\n     algorithm = approach + UNDERSCORE + SORT\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #191', 'line': 64, 'description': ['    algorithm = approach + UNDERSCORE + SORT'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach - UNDERSCORE + SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #192', 'line': 64, 'description': ['    algorithm = approach + UNDERSCORE + SORT'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach + UNDERSCORE - SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #193', 'line': 64, 'description': ['    algorithm = approach + UNDERSCORE + SORT'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = None\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #194', 'line': 67, 'description': ['    )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -62,9 +62,7 @@\n     console.print()\n     # define the name approach\n     algorithm = approach + UNDERSCORE + SORT\n-    result = experiment.run_sorting_algorithm_experiment_campaign(\n-        algorithm, starting_size, maximum_value, number_doubles\n-    )\n+    result = None\n     data = [\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #195', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""XXInput SizeXX"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #196', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""Input Size"", ""XXMin time (s)XX"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #197', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""Input Size"", ""Min time (s)"", ""XXMax time (s)XX"", ""Avg time (s)""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #198', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""XXAvg time (s)XX""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #199', 'line': 70, 'description': ['        result[0],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -67,7 +67,7 @@\n     )\n     data = [\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n-        result[0],\n+        result[1],\n         result[1],\n         result[2],\n         result[3],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #200', 'line': 71, 'description': ['        result[1],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -68,7 +68,7 @@\n     data = [\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n-        result[1],\n+        result[2],\n         result[2],\n         result[3],\n         result[4],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #201', 'line': 72, 'description': ['        result[2],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -69,7 +69,7 @@\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n         result[1],\n-        result[2],\n+        result[3],\n         result[3],\n         result[4],\n     ]\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #202', 'line': 73, 'description': ['        result[3],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -70,7 +70,7 @@\n         result[0],\n         result[1],\n         result[2],\n-        result[3],\n+        result[4],\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #203', 'line': 74, 'description': ['        result[4],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -71,7 +71,7 @@\n         result[1],\n         result[2],\n         result[3],\n-        result[4],\n+        result[5],\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=""firstrow"")\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #204', 'line': 75, 'description': ['    ]'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -65,14 +65,7 @@\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n-    data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n-        result[0],\n-        result[1],\n-        result[2],\n-        result[3],\n-        result[4],\n-    ]\n+    data = None\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=""firstrow"")\n     print(table)\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #205', 'line': 77, 'description': ['    table = tabulate(data, headers=""firstrow"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=""firstrow"")\n+    table = tabulate(data, headers=""XXfirstrowXX"")\n     print(table)\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #206', 'line': 77, 'description': ['    table = tabulate(data, headers=""firstrow"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=""firstrow"")\n+    table = None\n     print(table)\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #207', 'line': 78, 'description': ['    print(table)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -75,5 +75,5 @@\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=""firstrow"")\n-    print(table)\n+    print(None)\n \n', 'type': 'failure', 'message': 'bad_survived'}]}]",0.0,['F001' 'F002' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",low,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_sorting.json,listsorting,45-78,"[{'lineno': 45, 'coloffset': 0, 'linematch': 'def listsorting(', 'context': '        return self.value\n\n\n@cli.command()\ndef listsorting(\n    starting_size: int = typer.Option(1000000),\n    maximum_value: int = typer.Option(10000),\n    number_doubles: int = typer.Option(10),\n    approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n) -> None:', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 45, 'coloffset': 0, 'linematch': 'def listsorting(', 'context': '        return self.value\n\n\n@cli.command()\ndef listsorting(\n    starting_size: int = typer.Option(1000000),\n    maximum_value: int = typer.Option(10000),\n    number_doubles: int = typer.Option(10),\n    approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n) -> None:', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 45, 'coloffset': 0, 'linematch': 'def listsorting(', 'context': '        return self.value\n\n\n@cli.command()\ndef listsorting(\n    starting_size: int = typer.Option(1000000),\n    maximum_value: int = typer.Option(10000),\n    number_doubles: int = typer.Option(10),\n    approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n) -> None:', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 51, 'coloffset': 4, 'linematch': '""""""Conduct a doubling experiment to measure the performance of list sorting for various algorithms.""""""', 'context': '    maximum_value: int = typer.Option(10000),\n    number_doubles: int = typer.Option(10),\n    approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n) -> None:\n    """"""Conduct a doubling experiment to measure the performance of list sorting for various algorithms.""""""\n    # display diagnostics messages of the experiment\n    console.print(\n        ""✨ Conducting an experiment to measure the performance of list sorting!""\n    )\n    console.print()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 53, 'coloffset': 4, 'linematch': 'console.print(', 'context': '    approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n) -> None:\n    """"""Conduct a doubling experiment to measure the performance of list sorting for various algorithms.""""""\n    # display diagnostics messages of the experiment\n    console.print(\n        ""✨ Conducting an experiment to measure the performance of list sorting!""\n    )\n    console.print()\n    console.print(f""The chosen sorting algorithm: {approach}"")\n    console.print(f""Starting size of the data container {starting_size}"")', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 56, 'coloffset': 4, 'linematch': 'console.print()', 'context': '    # display diagnostics messages of the experiment\n    console.print(\n        ""✨ Conducting an experiment to measure the performance of list sorting!""\n    )\n    console.print()\n    console.print(f""The chosen sorting algorithm: {approach}"")\n    console.print(f""Starting size of the data container {starting_size}"")\n    console.print(f""Number of doubles to execute: {number_doubles}"")\n    console.print()\n    console.print(""✨ Here are the results from running the experiment!"")', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 57, 'coloffset': 4, 'linematch': 'console.print(f""The chosen sorting algorithm: {approach}"")', 'context': '    console.print(\n        ""✨ Conducting an experiment to measure the performance of list sorting!""\n    )\n    console.print()\n    console.print(f""The chosen sorting algorithm: {approach}"")\n    console.print(f""Starting size of the data container {starting_size}"")\n    console.print(f""Number of doubles to execute: {number_doubles}"")\n    console.print()\n    console.print(""✨ Here are the results from running the experiment!"")\n    console.print()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 58, 'coloffset': 4, 'linematch': 'console.print(f""Starting size of the data container {starting_size}"")', 'context': '        ""✨ Conducting an experiment to measure the performance of list sorting!""\n    )\n    console.print()\n    console.print(f""The chosen sorting algorithm: {approach}"")\n    console.print(f""Starting size of the data container {starting_size}"")\n    console.print(f""Number of doubles to execute: {number_doubles}"")\n    console.print()\n    console.print(""✨ Here are the results from running the experiment!"")\n    console.print()\n    # define the name approach', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 59, 'coloffset': 4, 'linematch': 'console.print(f""Number of doubles to execute: {number_doubles}"")', 'context': '    )\n    console.print()\n    console.print(f""The chosen sorting algorithm: {approach}"")\n    console.print(f""Starting size of the data container {starting_size}"")\n    console.print(f""Number of doubles to execute: {number_doubles}"")\n    console.print()\n    console.print(""✨ Here are the results from running the experiment!"")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 60, 'coloffset': 4, 'linematch': 'console.print()', 'context': '    console.print()\n    console.print(f""The chosen sorting algorithm: {approach}"")\n    console.print(f""Starting size of the data container {starting_size}"")\n    console.print(f""Number of doubles to execute: {number_doubles}"")\n    console.print()\n    console.print(""✨ Here are the results from running the experiment!"")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 61, 'coloffset': 4, 'linematch': 'console.print(""✨ Here are the results from running the experiment!"")', 'context': '    console.print(f""The chosen sorting algorithm: {approach}"")\n    console.print(f""Starting size of the data container {starting_size}"")\n    console.print(f""Number of doubles to execute: {number_doubles}"")\n    console.print()\n    console.print(""✨ Here are the results from running the experiment!"")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(\n        algorithm, starting_size, maximum_value, number_doubles', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 62, 'coloffset': 4, 'linematch': 'console.print()', 'context': '    console.print(f""Starting size of the data container {starting_size}"")\n    console.print(f""Number of doubles to execute: {number_doubles}"")\n    console.print()\n    console.print(""✨ Here are the results from running the experiment!"")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(\n        algorithm, starting_size, maximum_value, number_doubles\n    )', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 64, 'coloffset': 4, 'linematch': 'algorithm = approach + UNDERSCORE + SORT', 'context': '    console.print()\n    console.print(""✨ Here are the results from running the experiment!"")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(\n        algorithm, starting_size, maximum_value, number_doubles\n    )\n    data = [\n        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 65, 'coloffset': 4, 'linematch': 'result = experiment.run_sorting_algorithm_experiment_campaign(', 'context': '    console.print(""✨ Here are the results from running the experiment!"")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(\n        algorithm, starting_size, maximum_value, number_doubles\n    )\n    data = [\n        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n        result[0],', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 68, 'coloffset': 4, 'linematch': 'data = [', 'context': '    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(\n        algorithm, starting_size, maximum_value, number_doubles\n    )\n    data = [\n        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n        result[0],\n        result[1],\n        result[2],\n        result[3],', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 77, 'coloffset': 4, 'linematch': 'table = tabulate(data, headers=""firstrow"")', 'context': '        result[3],\n        result[4],\n    ]\n    # call tabulate function to construct a table based of data\n    table = tabulate(data, headers=""firstrow"")\n    print(table)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 78, 'coloffset': 4, 'linematch': 'print(table)', 'context': '        result[4],\n    ]\n    # call tabulate function to construct a table based of data\n    table = tabulate(data, headers=""firstrow"")\n    print(table)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #183', 'line': 46, 'description': ['    starting_size: int = typer.Option(1000000),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -43,7 +43,7 @@\n \n @cli.command()\n def listsorting(\n-    starting_size: int = typer.Option(1000000),\n+    starting_size: int = typer.Option(1000001),\n     maximum_value: int = typer.Option(10000),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #184', 'line': 47, 'description': ['    maximum_value: int = typer.Option(10000),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -44,7 +44,7 @@\n @cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n-    maximum_value: int = typer.Option(10000),\n+    maximum_value: int = typer.Option(10001),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #185', 'line': 48, 'description': ['    number_doubles: int = typer.Option(10),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -45,7 +45,7 @@\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n-    number_doubles: int = typer.Option(10),\n+    number_doubles: int = typer.Option(11),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n     """"""Conduct a doubling experiment to measure the performance of list sorting for various algorithms.""""""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #186', 'line': 54, 'description': ['        ""✨ Conducting an experiment to measure the performance of list sorting!""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -51,7 +51,7 @@\n     """"""Conduct a doubling experiment to measure the performance of list sorting for various algorithms.""""""\n     # display diagnostics messages of the experiment\n     console.print(\n-        ""✨ Conducting an experiment to measure the performance of list sorting!""\n+        ""XX✨ Conducting an experiment to measure the performance of list sorting!XX""\n     )\n     console.print()\n     console.print(f""The chosen sorting algorithm: {approach}"")\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #187', 'line': 57, 'description': ['    console.print(f""The chosen sorting algorithm: {approach}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -54,7 +54,7 @@\n         ""✨ Conducting an experiment to measure the performance of list sorting!""\n     )\n     console.print()\n-    console.print(f""The chosen sorting algorithm: {approach}"")\n+    console.print(f""XXThe chosen sorting algorithm: {approach}XX"")\n     console.print(f""Starting size of the data container {starting_size}"")\n     console.print(f""Number of doubles to execute: {number_doubles}"")\n     console.print()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #188', 'line': 58, 'description': ['    console.print(f""Starting size of the data container {starting_size}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -55,7 +55,7 @@\n     )\n     console.print()\n     console.print(f""The chosen sorting algorithm: {approach}"")\n-    console.print(f""Starting size of the data container {starting_size}"")\n+    console.print(f""XXStarting size of the data container {starting_size}XX"")\n     console.print(f""Number of doubles to execute: {number_doubles}"")\n     console.print()\n     console.print(""✨ Here are the results from running the experiment!"")\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #189', 'line': 59, 'description': ['    console.print(f""Number of doubles to execute: {number_doubles}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -56,7 +56,7 @@\n     console.print()\n     console.print(f""The chosen sorting algorithm: {approach}"")\n     console.print(f""Starting size of the data container {starting_size}"")\n-    console.print(f""Number of doubles to execute: {number_doubles}"")\n+    console.print(f""XXNumber of doubles to execute: {number_doubles}XX"")\n     console.print()\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #190', 'line': 61, 'description': ['    console.print(""✨ Here are the results from running the experiment!"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -58,7 +58,7 @@\n     console.print(f""Starting size of the data container {starting_size}"")\n     console.print(f""Number of doubles to execute: {number_doubles}"")\n     console.print()\n-    console.print(""✨ Here are the results from running the experiment!"")\n+    console.print(""XX✨ Here are the results from running the experiment!XX"")\n     console.print()\n     # define the name approach\n     algorithm = approach + UNDERSCORE + SORT\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #191', 'line': 64, 'description': ['    algorithm = approach + UNDERSCORE + SORT'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach - UNDERSCORE + SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #192', 'line': 64, 'description': ['    algorithm = approach + UNDERSCORE + SORT'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach + UNDERSCORE - SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #193', 'line': 64, 'description': ['    algorithm = approach + UNDERSCORE + SORT'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(""✨ Here are the results from running the experiment!"")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = None\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #194', 'line': 67, 'description': ['    )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -62,9 +62,7 @@\n     console.print()\n     # define the name approach\n     algorithm = approach + UNDERSCORE + SORT\n-    result = experiment.run_sorting_algorithm_experiment_campaign(\n-        algorithm, starting_size, maximum_value, number_doubles\n-    )\n+    result = None\n     data = [\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #195', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""XXInput SizeXX"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #196', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""Input Size"", ""XXMin time (s)XX"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #197', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""Input Size"", ""Min time (s)"", ""XXMax time (s)XX"", ""Avg time (s)""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #198', 'line': 69, 'description': ['        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n+        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""XXAvg time (s)XX""],\n         result[0],\n         result[1],\n         result[2],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #199', 'line': 70, 'description': ['        result[0],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -67,7 +67,7 @@\n     )\n     data = [\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n-        result[0],\n+        result[1],\n         result[1],\n         result[2],\n         result[3],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #200', 'line': 71, 'description': ['        result[1],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -68,7 +68,7 @@\n     data = [\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n-        result[1],\n+        result[2],\n         result[2],\n         result[3],\n         result[4],\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #201', 'line': 72, 'description': ['        result[2],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -69,7 +69,7 @@\n         [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n         result[0],\n         result[1],\n-        result[2],\n+        result[3],\n         result[3],\n         result[4],\n     ]\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #202', 'line': 73, 'description': ['        result[3],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -70,7 +70,7 @@\n         result[0],\n         result[1],\n         result[2],\n-        result[3],\n+        result[4],\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #203', 'line': 74, 'description': ['        result[4],'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -71,7 +71,7 @@\n         result[1],\n         result[2],\n         result[3],\n-        result[4],\n+        result[5],\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=""firstrow"")\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #204', 'line': 75, 'description': ['    ]'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -65,14 +65,7 @@\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n-    data = [\n-        [""Input Size"", ""Min time (s)"", ""Max time (s)"", ""Avg time (s)""],\n-        result[0],\n-        result[1],\n-        result[2],\n-        result[3],\n-        result[4],\n-    ]\n+    data = None\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=""firstrow"")\n     print(table)\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #205', 'line': 77, 'description': ['    table = tabulate(data, headers=""firstrow"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=""firstrow"")\n+    table = tabulate(data, headers=""XXfirstrowXX"")\n     print(table)\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #206', 'line': 77, 'description': ['    table = tabulate(data, headers=""firstrow"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=""firstrow"")\n+    table = None\n     print(table)\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #207', 'line': 78, 'description': ['    print(table)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -75,5 +75,5 @@\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=""firstrow"")\n-    print(table)\n+    print(None)\n \n', 'type': 'failure', 'message': 'bad_survived'}]}]",0.0,['F001' 'F002' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",low,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_intersection.json,human_readable_boolean,30-36,"[{'lineno': 30, 'coloffset': 0, 'linematch': 'def human_readable_boolean(answer: bool) -> str:', 'context': '    LIST_DOUBLE = ""ListDouble""\n    TUPLE_DOUBLE = ""TupleDouble""\n\n\ndef human_readable_boolean(answer: bool) -> str:\n    """"""Produce a human-readable Yes or No for a boolean value of True or False.""""""\n    # the provided answer is True\n    if answer:\n        return ""Yes""\n    # the provided answer is False', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 30, 'coloffset': 0, 'linematch': 'def human_readable_boolean(answer: bool) -> str:', 'context': '    LIST_DOUBLE = ""ListDouble""\n    TUPLE_DOUBLE = ""TupleDouble""\n\n\ndef human_readable_boolean(answer: bool) -> str:\n    """"""Produce a human-readable Yes or No for a boolean value of True or False.""""""\n    # the provided answer is True\n    if answer:\n        return ""Yes""\n    # the provided answer is False', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 33, 'coloffset': 4, 'linematch': 'if answer:', 'context': '\ndef human_readable_boolean(answer: bool) -> str:\n    """"""Produce a human-readable Yes or No for a boolean value of True or False.""""""\n    # the provided answer is True\n    if answer:\n        return ""Yes""\n    # the provided answer is False\n    return ""No""\n\n', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 30, 'coloffset': 0, 'linematch': 'def human_readable_boolean(answer: bool) -> str:', 'context': '    LIST_DOUBLE = ""ListDouble""\n    TUPLE_DOUBLE = ""TupleDouble""\n\n\ndef human_readable_boolean(answer: bool) -> str:\n    """"""Produce a human-readable Yes or No for a boolean value of True or False.""""""\n    # the provided answer is True\n    if answer:\n        return ""Yes""\n    # the provided answer is False', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 31, 'coloffset': 4, 'linematch': '""""""Produce a human-readable Yes or No for a boolean value of True or False.""""""', 'context': '    TUPLE_DOUBLE = ""TupleDouble""\n\n\ndef human_readable_boolean(answer: bool) -> str:\n    """"""Produce a human-readable Yes or No for a boolean value of True or False.""""""\n    # the provided answer is True\n    if answer:\n        return ""Yes""\n    # the provided answer is False\n    return ""No""', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 33, 'coloffset': 4, 'linematch': 'if answer:', 'context': '\ndef human_readable_boolean(answer: bool) -> str:\n    """"""Produce a human-readable Yes or No for a boolean value of True or False.""""""\n    # the provided answer is True\n    if answer:\n        return ""Yes""\n    # the provided answer is False\n    return ""No""\n\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 36, 'coloffset': 4, 'linematch': 'return ""No""', 'context': '    # the provided answer is True\n    if answer:\n        return ""Yes""\n    # the provided answer is False\n    return ""No""\n\n\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #11', 'line': 34, 'description': ['        return ""Yes""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -31,7 +31,7 @@\n     """"""Produce a human-readable Yes or No for a boolean value of True or False.""""""\n     # the provided answer is True\n     if answer:\n-        return ""Yes""\n+        return ""XXYesXX""\n     # the provided answer is False\n     return ""No""\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #12', 'line': 36, 'description': ['    return ""No""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     if answer:\n         return ""Yes""\n     # the provided answer is False\n-    return ""No""\n+    return ""XXNoXX""\n \n \n def generate_random_container(\n', 'type': 'failure', 'message': 'bad_survived'}]}]",0.0,['F001' 'F002' 'CL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",low,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_intersection.json,generate_random_container,39-47,"[{'lineno': 39, 'coloffset': 0, 'linematch': 'def generate_random_container(', 'context': '    # the provided answer is False\n    return ""No""\n\n\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    """"""Generate a random list defined by the size and with no number bigger than maximum.""""""\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 39, 'coloffset': 0, 'linematch': 'def generate_random_container(', 'context': '    # the provided answer is False\n    return ""No""\n\n\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    """"""Generate a random list defined by the size and with no number bigger than maximum.""""""\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 45, 'coloffset': 4, 'linematch': 'if make_tuple:', 'context': ') -> Union[List[int], Tuple[int, ...]]:\n    """"""Generate a random list defined by the size and with no number bigger than maximum.""""""\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]\n    if make_tuple:\n        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 39, 'coloffset': 0, 'linematch': 'def generate_random_container(', 'context': '    # the provided answer is False\n    return ""No""\n\n\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    """"""Generate a random list defined by the size and with no number bigger than maximum.""""""\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 39, 'coloffset': 0, 'linematch': 'def generate_random_container(', 'context': '    # the provided answer is False\n    return ""No""\n\n\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    """"""Generate a random list defined by the size and with no number bigger than maximum.""""""\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]', 'pattern': '//FunctionDef[body//comprehension/target/Name]', 'check_id': 'FLV001', 'check_name': 'Function uses loop variable'}, {'lineno': 42, 'coloffset': 4, 'linematch': '""""""Generate a random list defined by the size and with no number bigger than maximum.""""""', 'context': '\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    """"""Generate a random list defined by the size and with no number bigger than maximum.""""""\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]\n    if make_tuple:\n        return tuple(list_builder)\n    return list_builder', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 44, 'coloffset': 4, 'linematch': 'list_builder = [random.randint(0, maximum) for _ in range(size)]', 'context': '    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    """"""Generate a random list defined by the size and with no number bigger than maximum.""""""\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]\n    if make_tuple:\n        return tuple(list_builder)\n    return list_builder\n\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 45, 'coloffset': 4, 'linematch': 'if make_tuple:', 'context': ') -> Union[List[int], Tuple[int, ...]]:\n    """"""Generate a random list defined by the size and with no number bigger than maximum.""""""\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]\n    if make_tuple:\n        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 47, 'coloffset': 4, 'linematch': 'return list_builder', 'context': '    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]\n    if make_tuple:\n        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #13', 'line': 40, 'description': ['    size: int, maximum: int, make_tuple: bool = False'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -37,7 +37,7 @@\n \n \n def generate_random_container(\n-    size: int, maximum: int, make_tuple: bool = False\n+    size: int, maximum: int, make_tuple: bool = True\n ) -> Union[List[int], Tuple[int, ...]]:\n     """"""Generate a random list defined by the size and with no number bigger than maximum.""""""\n     # generate a list of random values\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #14', 'line': 44, 'description': ['    list_builder = [random.randint(0, maximum) for _ in range(size)]'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -41,7 +41,7 @@\n ) -> Union[List[int], Tuple[int, ...]]:\n     """"""Generate a random list defined by the size and with no number bigger than maximum.""""""\n     # generate a list of random values\n-    list_builder = [random.randint(0, maximum) for _ in range(size)]\n+    list_builder = [random.randint(1, maximum) for _ in range(size)]\n     if make_tuple:\n         return tuple(list_builder)\n     return list_builder\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #15', 'line': 44, 'description': ['    list_builder = [random.randint(0, maximum) for _ in range(size)]'], 'failure': []}]",33.33333333333333,['F001' 'F002' 'CL001' 'ANNOT001' 'FLV001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef[body//comprehension/target/Name]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 1, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",medium,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_intersection.json,compute_intersection_list_double,50-59,"[{'lineno': 50, 'coloffset': 0, 'linematch': 'def compute_intersection_list_double(', 'context': '        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    result = []\n    for x in input_one:', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 50, 'coloffset': 0, 'linematch': 'def compute_intersection_list_double(', 'context': '        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    result = []\n    for x in input_one:', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 57, 'coloffset': 12, 'linematch': 'if x == y:', 'context': '    """"""Compute the intersection of two provided lists.""""""\n    result = []\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)\n    return result\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_double\n    # this function must use a double for loop', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 50, 'coloffset': 0, 'linematch': 'def compute_intersection_list_double(', 'context': '        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    result = []\n    for x in input_one:', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 55, 'coloffset': 4, 'linematch': 'for x in input_one:', 'context': '    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    result = []\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)\n    return result\n    # implement this function in a manner', 'pattern': '//FunctionDef//For[.//For]', 'check_id': 'F001', 'check_name': 'The number of nested loop-conditions (e.g., for{for{}}) in a Function'}, {'lineno': 53, 'coloffset': 4, 'linematch': '""""""Compute the intersection of two provided lists.""""""', 'context': '\ndef compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    result = []\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 54, 'coloffset': 4, 'linematch': 'result = []', 'context': 'def compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    result = []\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)\n    return result', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 55, 'coloffset': 4, 'linematch': 'for x in input_one:', 'context': '    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    result = []\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)\n    return result\n    # implement this function in a manner', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 59, 'coloffset': 4, 'linematch': 'return result', 'context': '    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)\n    return result\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_double\n    # this function must use a double for loop\n    # delete this placeholder return statement\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #16', 'line': 54, 'description': ['    result = []'], 'failure': []}, {'name': 'Mutant #17', 'line': 57, 'description': ['            if x == y:'], 'failure': []}]",100.0,['F001' 'F002' 'CL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef//For[.//For]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 1, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]"
101_intersection.json,compute_intersection_list_single,66-78,"[{'lineno': 66, 'coloffset': 0, 'linematch': 'def compute_intersection_list_single(', 'context': '    # this function must use a double for loop\n    # delete this placeholder return statement\n\n\ndef compute_intersection_list_single(\n    input_one: List[Any], input_two: List[Any]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_single', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 66, 'coloffset': 0, 'linematch': 'def compute_intersection_list_single(', 'context': '    # this function must use a double for loop\n    # delete this placeholder return statement\n\n\ndef compute_intersection_list_single(\n    input_one: List[Any], input_two: List[Any]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_single', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 76, 'coloffset': 8, 'linematch': 'if element in input_two:', 'context': '    # this function must use a single for loop and an if statement\n    # delete this placeholder return statement\n    result = []\n    for element in input_one:\n        if element in input_two:\n            result.append(element)\n    return result\n\n\ndef compute_intersection_tuple_double(', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 66, 'coloffset': 0, 'linematch': 'def compute_intersection_list_single(', 'context': '    # this function must use a double for loop\n    # delete this placeholder return statement\n\n\ndef compute_intersection_list_single(\n    input_one: List[Any], input_two: List[Any]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_single', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 69, 'coloffset': 4, 'linematch': '""""""Compute the intersection of two provided lists.""""""', 'context': '\ndef compute_intersection_list_single(\n    input_one: List[Any], input_two: List[Any]\n) -> List[Any]:\n    """"""Compute the intersection of two provided lists.""""""\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_single\n    # this function must use a single for loop and an if statement\n    # delete this placeholder return statement\n    result = []', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 74, 'coloffset': 4, 'linematch': 'result = []', 'context': '    # implement this function in a manner\n    # that follows the compute_intersection_tuple_single\n    # this function must use a single for loop and an if statement\n    # delete this placeholder return statement\n    result = []\n    for element in input_one:\n        if element in input_two:\n            result.append(element)\n    return result\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 75, 'coloffset': 4, 'linematch': 'for element in input_one:', 'context': '    # that follows the compute_intersection_tuple_single\n    # this function must use a single for loop and an if statement\n    # delete this placeholder return statement\n    result = []\n    for element in input_one:\n        if element in input_two:\n            result.append(element)\n    return result\n\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 78, 'coloffset': 4, 'linematch': 'return result', 'context': '    result = []\n    for element in input_one:\n        if element in input_two:\n            result.append(element)\n    return result\n\n\ndef compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #18', 'line': 74, 'description': ['    result = []'], 'failure': []}, {'name': 'Mutant #19', 'line': 76, 'description': ['        if element in input_two:'], 'failure': []}]",100.0,['F001' 'F002' 'CL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_intersection.json,compute_intersection_tuple_double,81-91,"[{'lineno': 81, 'coloffset': 0, 'linematch': 'def compute_intersection_tuple_double(', 'context': '            result.append(element)\n    return result\n\n\ndef compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided lists.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 81, 'coloffset': 0, 'linematch': 'def compute_intersection_tuple_double(', 'context': '            result.append(element)\n    return result\n\n\ndef compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided lists.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 89, 'coloffset': 12, 'linematch': 'if x == y:', 'context': '    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result += (y,)\n    return result\n\n\ndef compute_intersection_tuple_single(', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 81, 'coloffset': 0, 'linematch': 'def compute_intersection_tuple_double(', 'context': '            result.append(element)\n    return result\n\n\ndef compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided lists.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 87, 'coloffset': 4, 'linematch': 'for x in input_one:', 'context': ') -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided lists.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result += (y,)\n    return result\n', 'pattern': '//FunctionDef//For[.//For]', 'check_id': 'F001', 'check_name': 'The number of nested loop-conditions (e.g., for{for{}}) in a Function'}, {'lineno': 84, 'coloffset': 4, 'linematch': '""""""Compute the intersection of two provided lists.""""""', 'context': '\ndef compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided lists.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for x in input_one:\n        for y in input_two:\n            if x == y:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 85, 'coloffset': 4, 'linematch': 'result: Tuple[Any, ...] = ()', 'context': 'def compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided lists.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result += (y,)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 87, 'coloffset': 4, 'linematch': 'for x in input_one:', 'context': ') -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided lists.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result += (y,)\n    return result\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 91, 'coloffset': 4, 'linematch': 'return result', 'context': '    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result += (y,)\n    return result\n\n\ndef compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #20', 'line': 85, 'description': ['    result: Tuple[Any, ...] = ()'], 'failure': []}, {'name': 'Mutant #21', 'line': 89, 'description': ['            if x == y:'], 'failure': []}, {'name': 'Mutant #22', 'line': 90, 'description': ['                result += (y,)'], 'failure': []}, {'name': 'Mutant #23', 'line': 90, 'description': ['                result += (y,)'], 'failure': []}]",100.0,['F001' 'F002' 'CL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef//For[.//For]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 1, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]"
101_intersection.json,compute_intersection_tuple_single,94-103,"[{'lineno': 94, 'coloffset': 0, 'linematch': 'def compute_intersection_tuple_single(', 'context': '                result += (y,)\n    return result\n\n\ndef compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided tuples.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 94, 'coloffset': 0, 'linematch': 'def compute_intersection_tuple_single(', 'context': '                result += (y,)\n    return result\n\n\ndef compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided tuples.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 101, 'coloffset': 8, 'linematch': 'if element in input_two:', 'context': '    """"""Compute the intersection of two provided tuples.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for element in input_one:\n        if element in input_two:\n            result += (element,)\n    return result\n\n\n@cli.command()', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 94, 'coloffset': 0, 'linematch': 'def compute_intersection_tuple_single(', 'context': '                result += (y,)\n    return result\n\n\ndef compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided tuples.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 97, 'coloffset': 4, 'linematch': '""""""Compute the intersection of two provided tuples.""""""', 'context': '\ndef compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided tuples.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for element in input_one:\n        if element in input_two:\n            result += (element,)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 98, 'coloffset': 4, 'linematch': 'result: Tuple[Any, ...] = ()', 'context': 'def compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided tuples.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for element in input_one:\n        if element in input_two:\n            result += (element,)\n    return result', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 100, 'coloffset': 4, 'linematch': 'for element in input_one:', 'context': ') -> Tuple[Any, ...]:\n    """"""Compute the intersection of two provided tuples.""""""\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for element in input_one:\n        if element in input_two:\n            result += (element,)\n    return result\n\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 103, 'coloffset': 4, 'linematch': 'return result', 'context': '    # make sure that you understand how this function works\n    for element in input_one:\n        if element in input_two:\n            result += (element,)\n    return result\n\n\n@cli.command()\ndef intersection(\n    number: int = typer.Option(5),', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #24', 'line': 98, 'description': ['    result: Tuple[Any, ...] = ()'], 'failure': []}, {'name': 'Mutant #25', 'line': 101, 'description': ['        if element in input_two:'], 'failure': []}, {'name': 'Mutant #26', 'line': 102, 'description': ['            result += (element,)'], 'failure': []}, {'name': 'Mutant #27', 'line': 102, 'description': ['            result += (element,)'], 'failure': []}]",100.0,['F001' 'F002' 'CL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_intersection.json,intersection,107-209,"[{'lineno': 107, 'coloffset': 0, 'linematch': 'def intersection(', 'context': '    return result\n\n\n@cli.command()\ndef intersection(\n    number: int = typer.Option(5),\n    maximum: int = typer.Option(25),\n    profile: bool = typer.Option(False),\n    display: bool = typer.Option(False),\n    approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 107, 'coloffset': 0, 'linematch': 'def intersection(', 'context': '    return result\n\n\n@cli.command()\ndef intersection(\n    number: int = typer.Option(5),\n    maximum: int = typer.Option(25),\n    profile: bool = typer.Option(False),\n    display: bool = typer.Option(False),\n    approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 124, 'coloffset': 4, 'linematch': 'if approach.value == IntersectionApproach.TUPLE_SINGLE:', 'context': '    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]\n    # TupleSingle: the intersection algorithm that works on an input list\n    if approach.value == IntersectionApproach.TUPLE_SINGLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 192, 'coloffset': 4, 'linematch': 'if display:', 'context': '            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n    # display the input sets and the result of running the computation\n    if display:\n        console.print(\n            "":sparkles: Here are the details about the intersection computation!""\n        )\n        console.print()\n        console.print(""Performed intersection with:"")', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 204, 'coloffset': 4, 'linematch': 'if profile:', 'context': '        console.print(\n            f""Computed the intersection as the data container: {intersection_output}""\n        )\n    # display the results of the profiling if that option was requested\n    if profile:\n        console.print()\n        console.print(\n            f"":microscope: Here\'s profiling data from computing an intersection with random data containers of {number}!""\n        )\n        profiler.print()', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 129, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_single(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 141, 'coloffset': 4, 'linematch': 'elif approach.value == IntersectionApproach.TUPLE_DOUBLE:', 'context': '            intersection_output = compute_intersection_tuple_single(\n                tuple(input_one), tuple(input_two)\n            )\n    # TupleDouble: use the intersection algorithm that works on an input tuple\n    elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n        # generate the two tuples of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 146, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two tuples of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_double(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 158, 'coloffset': 4, 'linematch': 'elif approach.value == IntersectionApproach.LIST_SINGLE:', 'context': '            intersection_output = compute_intersection_tuple_double(\n                tuple(input_one), tuple(input_two)\n            )\n    # ListSingle: the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_SINGLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 163, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 175, 'coloffset': 4, 'linematch': 'elif approach.value == IntersectionApproach.LIST_DOUBLE:', 'context': '            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 180, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 129, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_single(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()', 'pattern': './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]', 'check_id': 'CL002', 'check_name': 'dummy-test-double-nested-if'}, {'lineno': 146, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two tuples of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_double(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()', 'pattern': './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]', 'check_id': 'CL002', 'check_name': 'dummy-test-double-nested-if'}, {'lineno': 163, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()', 'pattern': './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]', 'check_id': 'CL002', 'check_name': 'dummy-test-double-nested-if'}, {'lineno': 180, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()', 'pattern': './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]', 'check_id': 'CL002', 'check_name': 'dummy-test-double-nested-if'}, {'lineno': 175, 'coloffset': 9, 'linematch': 'elif approach.value == IntersectionApproach.LIST_DOUBLE:', 'context': '            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 175, 'coloffset': 9, 'linematch': 'elif approach.value == IntersectionApproach.LIST_DOUBLE:', 'context': '            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 175, 'coloffset': 9, 'linematch': 'elif approach.value == IntersectionApproach.LIST_DOUBLE:', 'context': '            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 175, 'coloffset': 9, 'linematch': 'elif approach.value == IntersectionApproach.LIST_DOUBLE:', 'context': '            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 175, 'coloffset': 9, 'linematch': 'elif approach.value == IntersectionApproach.LIST_DOUBLE:', 'context': '            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 175, 'coloffset': 9, 'linematch': 'elif approach.value == IntersectionApproach.LIST_DOUBLE:', 'context': '            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 107, 'coloffset': 0, 'linematch': 'def intersection(', 'context': '    return result\n\n\n@cli.command()\ndef intersection(\n    number: int = typer.Option(5),\n    maximum: int = typer.Option(25),\n    profile: bool = typer.Option(False),\n    display: bool = typer.Option(False),\n    approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 192, 'coloffset': 4, 'linematch': 'if display:', 'context': '            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n    # display the input sets and the result of running the computation\n    if display:\n        console.print(\n            "":sparkles: Here are the details about the intersection computation!""\n        )\n        console.print()\n        console.print(""Performed intersection with:"")', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 204, 'coloffset': 4, 'linematch': 'if profile:', 'context': '        console.print(\n            f""Computed the intersection as the data container: {intersection_output}""\n        )\n    # display the results of the profiling if that option was requested\n    if profile:\n        console.print()\n        console.print(\n            f"":microscope: Here\'s profiling data from computing an intersection with random data containers of {number}!""\n        )\n        profiler.print()', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 129, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_single(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 141, 'coloffset': 4, 'linematch': 'elif approach.value == IntersectionApproach.TUPLE_DOUBLE:', 'context': '            intersection_output = compute_intersection_tuple_single(\n                tuple(input_one), tuple(input_two)\n            )\n    # TupleDouble: use the intersection algorithm that works on an input tuple\n    elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n        # generate the two tuples of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 146, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two tuples of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_double(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 158, 'coloffset': 4, 'linematch': 'elif approach.value == IntersectionApproach.LIST_SINGLE:', 'context': '            intersection_output = compute_intersection_tuple_double(\n                tuple(input_one), tuple(input_two)\n            )\n    # ListSingle: the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_SINGLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 163, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 175, 'coloffset': 4, 'linematch': 'elif approach.value == IntersectionApproach.LIST_DOUBLE:', 'context': '            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 180, 'coloffset': 8, 'linematch': 'if profile:', 'context': '        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 114, 'coloffset': 4, 'linematch': '""""""Compute the intersection of data containers.""""""', 'context': '    profile: bool = typer.Option(False),\n    display: bool = typer.Option(False),\n    approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,\n) -> None:\n    """"""Compute the intersection of data containers.""""""\n    # make sure that you understand how this function works\n    # create a console for rich text output\n    console = Console()\n    # create the starting data containers with no contents\n    input_one = None', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 117, 'coloffset': 4, 'linematch': 'console = Console()', 'context': ') -> None:\n    """"""Compute the intersection of data containers.""""""\n    # make sure that you understand how this function works\n    # create a console for rich text output\n    console = Console()\n    # create the starting data containers with no contents\n    input_one = None\n    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 119, 'coloffset': 4, 'linematch': 'input_one = None', 'context': '    # make sure that you understand how this function works\n    # create a console for rich text output\n    console = Console()\n    # create the starting data containers with no contents\n    input_one = None\n    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]\n    # TupleSingle: the intersection algorithm that works on an input list\n    if approach.value == IntersectionApproach.TUPLE_SINGLE:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 120, 'coloffset': 4, 'linematch': 'input_two = None', 'context': '    # create a console for rich text output\n    console = Console()\n    # create the starting data containers with no contents\n    input_one = None\n    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]\n    # TupleSingle: the intersection algorithm that works on an input list\n    if approach.value == IntersectionApproach.TUPLE_SINGLE:\n        # generate the two inputs consisting of random values', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 122, 'coloffset': 4, 'linematch': 'intersection_output: Union[List[Any], Tuple[Any, ...]]', 'context': '    # create the starting data containers with no contents\n    input_one = None\n    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]\n    # TupleSingle: the intersection algorithm that works on an input list\n    if approach.value == IntersectionApproach.TUPLE_SINGLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 124, 'coloffset': 4, 'linematch': 'if approach.value == IntersectionApproach.TUPLE_SINGLE:', 'context': '    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]\n    # TupleSingle: the intersection algorithm that works on an input list\n    if approach.value == IntersectionApproach.TUPLE_SINGLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 192, 'coloffset': 4, 'linematch': 'if display:', 'context': '            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n    # display the input sets and the result of running the computation\n    if display:\n        console.print(\n            "":sparkles: Here are the details about the intersection computation!""\n        )\n        console.print()\n        console.print(""Performed intersection with:"")', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 204, 'coloffset': 4, 'linematch': 'if profile:', 'context': '        console.print(\n            f""Computed the intersection as the data container: {intersection_output}""\n        )\n    # display the results of the profiling if that option was requested\n    if profile:\n        console.print()\n        console.print(\n            f"":microscope: Here\'s profiling data from computing an intersection with random data containers of {number}!""\n        )\n        profiler.print()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #29', 'line': 108, 'description': ['    number: int = typer.Option(5),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -105,7 +105,7 @@\n \n @cli.command()\n def intersection(\n-    number: int = typer.Option(5),\n+    number: int = typer.Option(6),\n     maximum: int = typer.Option(25),\n     profile: bool = typer.Option(False),\n     display: bool = typer.Option(False),\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #30', 'line': 109, 'description': ['    maximum: int = typer.Option(25),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -106,7 +106,7 @@\n @cli.command()\n def intersection(\n     number: int = typer.Option(5),\n-    maximum: int = typer.Option(25),\n+    maximum: int = typer.Option(26),\n     profile: bool = typer.Option(False),\n     display: bool = typer.Option(False),\n     approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #31', 'line': 110, 'description': ['    profile: bool = typer.Option(False),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -107,7 +107,7 @@\n def intersection(\n     number: int = typer.Option(5),\n     maximum: int = typer.Option(25),\n-    profile: bool = typer.Option(False),\n+    profile: bool = typer.Option(True),\n     display: bool = typer.Option(False),\n     approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,\n ) -> None:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #32', 'line': 111, 'description': ['    display: bool = typer.Option(False),'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -108,7 +108,7 @@\n     number: int = typer.Option(5),\n     maximum: int = typer.Option(25),\n     profile: bool = typer.Option(False),\n-    display: bool = typer.Option(False),\n+    display: bool = typer.Option(True),\n     approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,\n ) -> None:\n     """"""Compute the intersection of data containers.""""""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #33', 'line': 117, 'description': ['    console = Console()'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -114,7 +114,7 @@\n     """"""Compute the intersection of data containers.""""""\n     # make sure that you understand how this function works\n     # create a console for rich text output\n-    console = Console()\n+    console = None\n     # create the starting data containers with no contents\n     input_one = None\n     input_two = None\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #34', 'line': 119, 'description': ['    input_one = None'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -116,7 +116,7 @@\n     # create a console for rich text output\n     console = Console()\n     # create the starting data containers with no contents\n-    input_one = None\n+    input_one = """"\n     input_two = None\n     # create a starting output variable for the intersection computation\n     intersection_output: Union[List[Any], Tuple[Any, ...]]\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #35', 'line': 120, 'description': ['    input_two = None'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -117,7 +117,7 @@\n     console = Console()\n     # create the starting data containers with no contents\n     input_one = None\n-    input_two = None\n+    input_two = """"\n     # create a starting output variable for the intersection computation\n     intersection_output: Union[List[Any], Tuple[Any, ...]]\n     # TupleSingle: the intersection algorithm that works on an input list\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #36', 'line': 124, 'description': ['    if approach.value == IntersectionApproach.TUPLE_SINGLE:'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -121,7 +121,7 @@\n     # create a starting output variable for the intersection computation\n     intersection_output: Union[List[Any], Tuple[Any, ...]]\n     # TupleSingle: the intersection algorithm that works on an input list\n-    if approach.value == IntersectionApproach.TUPLE_SINGLE:\n+    if approach.value != IntersectionApproach.TUPLE_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #37', 'line': 126, 'description': ['        input_one = generate_random_container(number, maximum, make_tuple=True)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -123,7 +123,7 @@\n     # TupleSingle: the intersection algorithm that works on an input list\n     if approach.value == IntersectionApproach.TUPLE_SINGLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=True)\n+        input_one = generate_random_container(number, maximum, make_tuple=False)\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #38', 'line': 126, 'description': ['        input_one = generate_random_container(number, maximum, make_tuple=True)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -123,7 +123,7 @@\n     # TupleSingle: the intersection algorithm that works on an input list\n     if approach.value == IntersectionApproach.TUPLE_SINGLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=True)\n+        input_one = None\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #39', 'line': 127, 'description': ['        input_two = generate_random_container(number, maximum, make_tuple=True)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -124,7 +124,7 @@\n     if approach.value == IntersectionApproach.TUPLE_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n-        input_two = generate_random_container(number, maximum, make_tuple=True)\n+        input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #40', 'line': 127, 'description': ['        input_two = generate_random_container(number, maximum, make_tuple=True)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -124,7 +124,7 @@\n     if approach.value == IntersectionApproach.TUPLE_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n-        input_two = generate_random_container(number, maximum, make_tuple=True)\n+        input_two = None\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #41', 'line': 133, 'description': ['            )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -128,9 +128,7 @@\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n-            intersection_output = compute_intersection_tuple_single(\n-                tuple(input_one), tuple(input_two)\n-            )\n+            intersection_output = None\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #42', 'line': 139, 'description': ['            )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -134,9 +134,7 @@\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n-            intersection_output = compute_intersection_tuple_single(\n-                tuple(input_one), tuple(input_two)\n-            )\n+            intersection_output = None\n     # TupleDouble: use the intersection algorithm that works on an input tuple\n     elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #43', 'line': 141, 'description': ['    elif approach.value == IntersectionApproach.TUPLE_DOUBLE:'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -138,7 +138,7 @@\n                 tuple(input_one), tuple(input_two)\n             )\n     # TupleDouble: use the intersection algorithm that works on an input tuple\n-    elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n+    elif approach.value != IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #44', 'line': 143, 'description': ['        input_one = generate_random_container(number, maximum, make_tuple=True)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -140,7 +140,7 @@\n     # TupleDouble: use the intersection algorithm that works on an input tuple\n     elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=True)\n+        input_one = generate_random_container(number, maximum, make_tuple=False)\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #45', 'line': 143, 'description': ['        input_one = generate_random_container(number, maximum, make_tuple=True)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -140,7 +140,7 @@\n     # TupleDouble: use the intersection algorithm that works on an input tuple\n     elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=True)\n+        input_one = None\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #46', 'line': 144, 'description': ['        input_two = generate_random_container(number, maximum, make_tuple=True)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -141,7 +141,7 @@\n     elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n-        input_two = generate_random_container(number, maximum, make_tuple=True)\n+        input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #47', 'line': 144, 'description': ['        input_two = generate_random_container(number, maximum, make_tuple=True)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -141,7 +141,7 @@\n     elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n-        input_two = generate_random_container(number, maximum, make_tuple=True)\n+        input_two = None\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #48', 'line': 150, 'description': ['            )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -145,9 +145,7 @@\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n-            intersection_output = compute_intersection_tuple_double(\n-                tuple(input_one), tuple(input_two)\n-            )\n+            intersection_output = None\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #49', 'line': 156, 'description': ['            )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -151,9 +151,7 @@\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n-            intersection_output = compute_intersection_tuple_double(\n-                tuple(input_one), tuple(input_two)\n-            )\n+            intersection_output = None\n     # ListSingle: the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #50', 'line': 158, 'description': ['    elif approach.value == IntersectionApproach.LIST_SINGLE:'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -155,7 +155,7 @@\n                 tuple(input_one), tuple(input_two)\n             )\n     # ListSingle: the intersection algorithm that works on an input list\n-    elif approach.value == IntersectionApproach.LIST_SINGLE:\n+    elif approach.value != IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #51', 'line': 160, 'description': ['        input_one = generate_random_container(number, maximum, make_tuple=False)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -157,7 +157,7 @@\n     # ListSingle: the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=False)\n+        input_one = generate_random_container(number, maximum, make_tuple=True)\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #52', 'line': 160, 'description': ['        input_one = generate_random_container(number, maximum, make_tuple=False)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -157,7 +157,7 @@\n     # ListSingle: the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=False)\n+        input_one = None\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #53', 'line': 161, 'description': ['        input_two = generate_random_container(number, maximum, make_tuple=False)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -158,7 +158,7 @@\n     elif approach.value == IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n-        input_two = generate_random_container(number, maximum, make_tuple=False)\n+        input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #54', 'line': 161, 'description': ['        input_two = generate_random_container(number, maximum, make_tuple=False)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -158,7 +158,7 @@\n     elif approach.value == IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n-        input_two = generate_random_container(number, maximum, make_tuple=False)\n+        input_two = None\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #55', 'line': 167, 'description': ['            )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -162,9 +162,7 @@\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n-            intersection_output = compute_intersection_list_single(\n-                list(input_one), list(input_two)\n-            )\n+            intersection_output = None\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #56', 'line': 173, 'description': ['            )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -168,9 +168,7 @@\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n-            intersection_output = compute_intersection_list_single(\n-                list(input_one), list(input_two)\n-            )\n+            intersection_output = None\n     # ListDouble: use the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #57', 'line': 175, 'description': ['    elif approach.value == IntersectionApproach.LIST_DOUBLE:'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -172,7 +172,7 @@\n                 list(input_one), list(input_two)\n             )\n     # ListDouble: use the intersection algorithm that works on an input list\n-    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n+    elif approach.value != IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #58', 'line': 177, 'description': ['        input_one = generate_random_container(number, maximum, make_tuple=False)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -174,7 +174,7 @@\n     # ListDouble: use the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=False)\n+        input_one = generate_random_container(number, maximum, make_tuple=True)\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #59', 'line': 177, 'description': ['        input_one = generate_random_container(number, maximum, make_tuple=False)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -174,7 +174,7 @@\n     # ListDouble: use the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=False)\n+        input_one = None\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #60', 'line': 178, 'description': ['        input_two = generate_random_container(number, maximum, make_tuple=False)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -175,7 +175,7 @@\n     elif approach.value == IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n-        input_two = generate_random_container(number, maximum, make_tuple=False)\n+        input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #61', 'line': 178, 'description': ['        input_two = generate_random_container(number, maximum, make_tuple=False)'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -175,7 +175,7 @@\n     elif approach.value == IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n-        input_two = generate_random_container(number, maximum, make_tuple=False)\n+        input_two = None\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #62', 'line': 184, 'description': ['            )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -179,9 +179,7 @@\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n-            intersection_output = compute_intersection_list_double(\n-                list(input_one), list(input_two)\n-            )\n+            intersection_output = None\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #63', 'line': 190, 'description': ['            )'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -185,9 +185,7 @@\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n-            intersection_output = compute_intersection_list_double(\n-                list(input_one), list(input_two)\n-            )\n+            intersection_output = None\n     # display the input sets and the result of running the computation\n     if display:\n         console.print(\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #64', 'line': 194, 'description': ['            "":sparkles: Here are the details about the intersection computation!""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -191,7 +191,7 @@\n     # display the input sets and the result of running the computation\n     if display:\n         console.print(\n-            "":sparkles: Here are the details about the intersection computation!""\n+            ""XX:sparkles: Here are the details about the intersection computation!XX""\n         )\n         console.print()\n         console.print(""Performed intersection with:"")\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #65', 'line': 197, 'description': ['        console.print(""Performed intersection with:"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -194,7 +194,7 @@\n             "":sparkles: Here are the details about the intersection computation!""\n         )\n         console.print()\n-        console.print(""Performed intersection with:"")\n+        console.print(""XXPerformed intersection with:XX"")\n         console.print(f""---> the first data container: {input_one}"")\n         console.print(f""---> the second data container: {input_two}"")\n         console.print(\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #66', 'line': 198, 'description': ['        console.print(f""---> the first data container: {input_one}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -195,7 +195,7 @@\n         )\n         console.print()\n         console.print(""Performed intersection with:"")\n-        console.print(f""---> the first data container: {input_one}"")\n+        console.print(f""XX---> the first data container: {input_one}XX"")\n         console.print(f""---> the second data container: {input_two}"")\n         console.print(\n             f""Computed the intersection as the data container: {intersection_output}""\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #67', 'line': 199, 'description': ['        console.print(f""---> the second data container: {input_two}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -196,7 +196,7 @@\n         console.print()\n         console.print(""Performed intersection with:"")\n         console.print(f""---> the first data container: {input_one}"")\n-        console.print(f""---> the second data container: {input_two}"")\n+        console.print(f""XX---> the second data container: {input_two}XX"")\n         console.print(\n             f""Computed the intersection as the data container: {intersection_output}""\n         )\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #68', 'line': 201, 'description': ['            f""Computed the intersection as the data container: {intersection_output}""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -198,7 +198,7 @@\n         console.print(f""---> the first data container: {input_one}"")\n         console.print(f""---> the second data container: {input_two}"")\n         console.print(\n-            f""Computed the intersection as the data container: {intersection_output}""\n+            f""XXComputed the intersection as the data container: {intersection_output}XX""\n         )\n     # display the results of the profiling if that option was requested\n     if profile:\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #69', 'line': 207, 'description': ['            f"":microscope: Here\'s profiling data from computing an intersection with random data containers of {number}!""'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -204,7 +204,7 @@\n     if profile:\n         console.print()\n         console.print(\n-            f"":microscope: Here\'s profiling data from computing an intersection with random data containers of {number}!""\n+            f""XX:microscope: Here\'s profiling data from computing an intersection with random data containers of {number}!XX""\n         )\n         profiler.print()\n \n', 'type': 'failure', 'message': 'bad_survived'}]}]",0.0,['F001' 'F002' 'CL001' 'CL002' 'BOOL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]'
 '//Compare/ops/Is | //Compare/ops/Eq'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else'
 '//FunctionDef//If/descendant::If'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 1, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 1, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 1, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 1, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",low,"[0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]"
101_palindrome.json,to_char,7-14,"[{'lineno': 7, 'coloffset': 0, 'linematch': 'def to_char(word: str) -> str:', 'context': '# Reference:\n# https://en.wikipedia.org/wiki/Palindrome\n\n\ndef to_char(word: str) -> str:\n    """"""Convert string to character.""""""\n    word = word.lower()\n    letters = """"\n    for char in word:\n        if char in ""abcdefghijklmnopqrstuvwxyz"":', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 7, 'coloffset': 0, 'linematch': 'def to_char(word: str) -> str:', 'context': '# Reference:\n# https://en.wikipedia.org/wiki/Palindrome\n\n\ndef to_char(word: str) -> str:\n    """"""Convert string to character.""""""\n    word = word.lower()\n    letters = """"\n    for char in word:\n        if char in ""abcdefghijklmnopqrstuvwxyz"":', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 12, 'coloffset': 8, 'linematch': 'if char in ""abcdefghijklmnopqrstuvwxyz"":', 'context': '    """"""Convert string to character.""""""\n    word = word.lower()\n    letters = """"\n    for char in word:\n        if char in ""abcdefghijklmnopqrstuvwxyz"":\n            letters = letters + char\n    return letters\n\n\n# implement def is_palindrome(word: str) -> bool:', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 7, 'coloffset': 0, 'linematch': 'def to_char(word: str) -> str:', 'context': '# Reference:\n# https://en.wikipedia.org/wiki/Palindrome\n\n\ndef to_char(word: str) -> str:\n    """"""Convert string to character.""""""\n    word = word.lower()\n    letters = """"\n    for char in word:\n        if char in ""abcdefghijklmnopqrstuvwxyz"":', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 8, 'coloffset': 4, 'linematch': '""""""Convert string to character.""""""', 'context': '# https://en.wikipedia.org/wiki/Palindrome\n\n\ndef to_char(word: str) -> str:\n    """"""Convert string to character.""""""\n    word = word.lower()\n    letters = """"\n    for char in word:\n        if char in ""abcdefghijklmnopqrstuvwxyz"":\n            letters = letters + char', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 9, 'coloffset': 4, 'linematch': 'word = word.lower()', 'context': '\n\ndef to_char(word: str) -> str:\n    """"""Convert string to character.""""""\n    word = word.lower()\n    letters = """"\n    for char in word:\n        if char in ""abcdefghijklmnopqrstuvwxyz"":\n            letters = letters + char\n    return letters', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 10, 'coloffset': 4, 'linematch': 'letters = """"', 'context': '\ndef to_char(word: str) -> str:\n    """"""Convert string to character.""""""\n    word = word.lower()\n    letters = """"\n    for char in word:\n        if char in ""abcdefghijklmnopqrstuvwxyz"":\n            letters = letters + char\n    return letters\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 11, 'coloffset': 4, 'linematch': 'for char in word:', 'context': 'def to_char(word: str) -> str:\n    """"""Convert string to character.""""""\n    word = word.lower()\n    letters = """"\n    for char in word:\n        if char in ""abcdefghijklmnopqrstuvwxyz"":\n            letters = letters + char\n    return letters\n\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 14, 'coloffset': 4, 'linematch': 'return letters', 'context': '    letters = """"\n    for char in word:\n        if char in ""abcdefghijklmnopqrstuvwxyz"":\n            letters = letters + char\n    return letters\n\n\n# implement def is_palindrome(word: str) -> bool:\ndef is_palindrome(word: str) -> bool:\n    """"""Check palindrome.""""""', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #23', 'line': 14, 'description': ['cli = typer.Typer()'], 'failure': []}]",100.0,['F001' 'F002' 'CL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
101_palindrome.json,palindrome_check,39-58,"[{'lineno': 39, 'coloffset': 0, 'linematch': 'def palindrome_check(', 'context': '# https://github.com/tiangolo/typer/issues/290\n\n\n@cli.command()\ndef palindrome_check(\n    word: str = typer.Option(...),\n    approach: PalindromeApproach = PalindromeApproach.RECURSIVE,\n) -> None:\n    """"""Test an input string to be a Palindrome.""""""\n    # create a console for rich text output', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 39, 'coloffset': 0, 'linematch': 'def palindrome_check(', 'context': '# https://github.com/tiangolo/typer/issues/290\n\n\n@cli.command()\ndef palindrome_check(\n    word: str = typer.Option(...),\n    approach: PalindromeApproach = PalindromeApproach.RECURSIVE,\n) -> None:\n    """"""Test an input string to be a Palindrome.""""""\n    # create a console for rich text output', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 48, 'coloffset': 4, 'linematch': 'if approach == PalindromeApproach.RECURSIVE:', 'context': '    # create a console for rich text output\n    console = Console()\n\n    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 51, 'coloffset': 4, 'linematch': 'elif approach == PalindromeApproach.REVERSE:', 'context': '    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n    console.print()\n    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 51, 'coloffset': 9, 'linematch': 'elif approach == PalindromeApproach.REVERSE:', 'context': '    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n    console.print()\n    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 51, 'coloffset': 9, 'linematch': 'elif approach == PalindromeApproach.REVERSE:', 'context': '    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n    console.print()\n    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 39, 'coloffset': 0, 'linematch': 'def palindrome_check(', 'context': '# https://github.com/tiangolo/typer/issues/290\n\n\n@cli.command()\ndef palindrome_check(\n    word: str = typer.Option(...),\n    approach: PalindromeApproach = PalindromeApproach.RECURSIVE,\n) -> None:\n    """"""Test an input string to be a Palindrome.""""""\n    # create a console for rich text output', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 51, 'coloffset': 4, 'linematch': 'elif approach == PalindromeApproach.REVERSE:', 'context': '    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n    console.print()\n    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 43, 'coloffset': 4, 'linematch': '""""""Test an input string to be a Palindrome.""""""', 'context': 'def palindrome_check(\n    word: str = typer.Option(...),\n    approach: PalindromeApproach = PalindromeApproach.RECURSIVE,\n) -> None:\n    """"""Test an input string to be a Palindrome.""""""\n    # create a console for rich text output\n    console = Console()\n\n    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 45, 'coloffset': 4, 'linematch': 'console = Console()', 'context': '    approach: PalindromeApproach = PalindromeApproach.RECURSIVE,\n) -> None:\n    """"""Test an input string to be a Palindrome.""""""\n    # create a console for rich text output\n    console = Console()\n\n    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 48, 'coloffset': 4, 'linematch': 'if approach == PalindromeApproach.RECURSIVE:', 'context': '    # create a console for rich text output\n    console = Console()\n\n    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 54, 'coloffset': 4, 'linematch': 'console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")', 'context': '    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n    console.print()\n    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")\n    console.print()\n    console.print(f""😆 Is this word a palindrome? {util.human_readable_boolean(result)}"")\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 55, 'coloffset': 4, 'linematch': 'console.print()', 'context': '    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n    console.print()\n    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")\n    console.print()\n    console.print(f""😆 Is this word a palindrome? {util.human_readable_boolean(result)}"")\n\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 56, 'coloffset': 4, 'linematch': 'console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")', 'context': '        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n    console.print()\n    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")\n    console.print()\n    console.print(f""😆 Is this word a palindrome? {util.human_readable_boolean(result)}"")\n\n\n# implement a command-line interface using typer that produces', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 57, 'coloffset': 4, 'linematch': 'console.print()', 'context': '\n    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n    console.print()\n    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")\n    console.print()\n    console.print(f""😆 Is this word a palindrome? {util.human_readable_boolean(result)}"")\n\n\n# implement a command-line interface using typer that produces\n# output like those examples included in the remainder of this file', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 58, 'coloffset': 4, 'linematch': 'console.print(f""😆 Is this word a palindrome? {util.human_readable_boolean(result)}"")', 'context': '    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n    console.print()\n    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")\n    console.print()\n    console.print(f""😆 Is this word a palindrome? {util.human_readable_boolean(result)}"")\n\n\n# implement a command-line interface using typer that produces\n# output like those examples included in the remainder of this file\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #31', 'line': 45, 'description': ['    console = Console()'], 'failure': []}, {'name': 'Mutant #32', 'line': 48, 'description': ['    if approach == PalindromeApproach.RECURSIVE:'], 'failure': []}, {'name': 'Mutant #33', 'line': 49, 'description': ['        result = palindrome.is_palindrome_recursive(word)'], 'failure': []}, {'name': 'Mutant #34', 'line': 51, 'description': ['    elif approach == PalindromeApproach.REVERSE:'], 'failure': []}, {'name': 'Mutant #35', 'line': 52, 'description': ['        result = palindrome.is_palindrome_reverse(word)'], 'failure': []}, {'name': 'Mutant #36', 'line': 54, 'description': ['    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -51,7 +51,7 @@\n     elif approach == PalindromeApproach.REVERSE:\n         result = palindrome.is_palindrome_reverse(word)\n \n-    console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n+    console.print(f""XX✨ Awesome, using the {approach} approach for palindrome checking!XX"")\n     console.print()\n     console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")\n     console.print()\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #37', 'line': 56, 'description': ['    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -53,7 +53,7 @@\n \n     console.print(f""✨ Awesome, using the {approach} approach for palindrome checking!"")\n     console.print()\n-    console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")\n+    console.print(f""XX🔖 Going to check to see if the word {word} is a palindrome!XX"")\n     console.print()\n     console.print(f""😆 Is this word a palindrome? {util.human_readable_boolean(result)}"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #38', 'line': 58, 'description': ['    console.print(f""😆 Is this word a palindrome? {util.human_readable_boolean(result)}"")'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -55,7 +55,7 @@\n     console.print()\n     console.print(f""🔖 Going to check to see if the word {word} is a palindrome!"")\n     console.print()\n-    console.print(f""😆 Is this word a palindrome? {util.human_readable_boolean(result)}"")\n+    console.print(f""XX😆 Is this word a palindrome? {util.human_readable_boolean(result)}XX"")\n \n \n # implement a command-line interface using typer that produces\n', 'type': 'failure', 'message': 'bad_survived'}]}]",62.5,['F001' 'F002' 'CL001' 'BOOL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If' '//Compare/ops/Is | //Compare/ops/Eq'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef//If/descendant::If'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 1, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 1, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",medium,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]"
101_palindrome.json,__str__,27-29,"[{'lineno': 27, 'coloffset': 4, 'linematch': 'def __str__(self):', 'context': '\n    RECURSIVE = ""recursive""\n    REVERSE = ""reverse""\n\n    def __str__(self):\n        """"""Create string function.""""""\n        return self.value if self is not None else """"\n\n\n# When you are setting the default values of the --approach variable', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 27, 'coloffset': 4, 'linematch': 'def __str__(self):', 'context': '\n    RECURSIVE = ""recursive""\n    REVERSE = ""reverse""\n\n    def __str__(self):\n        """"""Create string function.""""""\n        return self.value if self is not None else """"\n\n\n# When you are setting the default values of the --approach variable', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 27, 'coloffset': 4, 'linematch': 'def __str__(self):', 'context': '\n    RECURSIVE = ""recursive""\n    REVERSE = ""reverse""\n\n    def __str__(self):\n        """"""Create string function.""""""\n        return self.value if self is not None else """"\n\n\n# When you are setting the default values of the --approach variable', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 28, 'coloffset': 8, 'linematch': '""""""Create string function.""""""', 'context': '    RECURSIVE = ""recursive""\n    REVERSE = ""reverse""\n\n    def __str__(self):\n        """"""Create string function.""""""\n        return self.value if self is not None else """"\n\n\n# When you are setting the default values of the --approach variable\n# you may need to consider how to extract a value from PalindromeCheckingApproach', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 29, 'coloffset': 8, 'linematch': 'return self.value if self is not None else """"', 'context': '    REVERSE = ""reverse""\n\n    def __str__(self):\n        """"""Create string function.""""""\n        return self.value if self is not None else """"\n\n\n# When you are setting the default values of the --approach variable\n# you may need to consider how to extract a value from PalindromeCheckingApproach\n# Please refer to this GitHub issue tracker discussion for more details:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #28', 'line': 29, 'description': ['        return self.value if self is not None else """"'], 'failure': []}, {'name': 'Mutant #29', 'line': 29, 'description': ['        return self.value if self is not None else """"'], 'failure': [{'inner': '--- src/main.py\n+++ src/main.py\n@@ -26,7 +26,7 @@\n \n     def __str__(self):\n         """"""Create string function.""""""\n-        return self.value if self is not None else """"\n+        return self.value if self is not None else ""XXXX""\n \n \n # When you are setting the default values of the --approach variable\n', 'type': 'failure', 'message': 'bad_survived'}]}]",50.0,['F001' 'F002' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",medium,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
lazytracker.json,get_function_name_from_diff,8-15,"[{'lineno': 8, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # Matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 9, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # This regular expression matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 8, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # Matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 9, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # This regular expression matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 12, 'coloffset': 4, 'linematch': 'if match:', 'context': ""def get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 13, 'coloffset': 4, 'linematch': 'if match:', 'context': ""def get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 8, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # Matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 9, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # This regular expression matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 10, 'coloffset': 4, 'linematch': ""pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)"", 'context': ""    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 11, 'coloffset': 4, 'linematch': 'match = pattern.search(diff)', 'context': ""\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 12, 'coloffset': 4, 'linematch': 'if match:', 'context': ""def get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 11, 'coloffset': 4, 'linematch': ""pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)"", 'context': ""    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 12, 'coloffset': 4, 'linematch': 'match = pattern.search(diff)', 'context': ""\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 13, 'coloffset': 4, 'linematch': 'if match:', 'context': ""def get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #120', 'line': 11, 'description': ['            input_dirs=[""input_dir""],'], 'failure': []}, {'name': 'Mutant #121', 'line': 12, 'description': ['            output_dirs=[""output_dir""]'], 'failure': []}, {'name': 'Mutant #122', 'line': 13, 'description': ['        )'], 'failure': []}]",100.0,['F001' 'F002' 'CL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
lazytracker.json,main,17-51,"[{'lineno': 17, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 18, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 17, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}"", 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 18, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {"", 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 32, 'coloffset': 8, 'linematch': ""if 'Survived' in diff:"", 'context': ""        diff = subprocess.run(['mutmut', 'show', str(mutant_id)], capture_output=True, text=True).stdout\n        function_name = get_function_name_from_diff(diff)\n\n        # Determine if the mutant was killed or survived\n        if 'Survived' in diff:\n            survived_count += 1\n        elif 'Killed' in diff:\n            killed_count += 1\n\n        if function_name not in mutants_by_function:"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 37, 'coloffset': 8, 'linematch': 'if function_name not in mutants_by_function:', 'context': ""            survived_count += 1\n        elif 'Killed' in diff:\n            killed_count += 1\n\n        if function_name not in mutants_by_function:\n            mutants_by_function[function_name] = []\n        mutants_by_function[function_name].append((mutant_id, diff))\n\n    # Write the organized mutants and summary to a file\n    with open('mutants_by_function.txt', 'w') as file:"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 34, 'coloffset': 8, 'linematch': ""elif 'Killed' in diff:"", 'context': ""\n        # Determine if the mutant was killed or survived\n        if 'Survived' in diff:\n            survived_count += 1\n        elif 'Killed' in diff:\n            killed_count += 1\n\n        if function_name not in mutants_by_function:\n            mutants_by_function[function_name] = []\n        mutants_by_function[function_name].append((mutant_id, diff))"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 36, 'coloffset': 8, 'linematch': ""if status == 'Killed':"", 'context': ""        function_name = get_function_name_from_diff(diff)\n        status = 'Survived' if 'Survived' in diff else 'Killed'\n        \n        # Update counts\n        if status == 'Killed':\n            mutants_summary['total_killed'] += 1\n        else:\n            mutants_summary['total_survived'] += 1\n        \n        # Organize by function"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 42, 'coloffset': 8, 'linematch': ""if function_name not in mutants_summary['functions']:"", 'context': ""        else:\n            mutants_summary['total_survived'] += 1\n        \n        # Organize by function\n        if function_name not in mutants_summary['functions']:\n            mutants_summary['functions'][function_name] = {'killed': 0, 'survived': 0}\n        mutants_summary['functions'][function_name][status.lower()] += 1\n\n    # Write the summary to a JSON file\n    with open('mutants_summary.json', 'w') as file:"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 36, 'coloffset': 11, 'linematch': ""if status == 'Killed':"", 'context': ""        function_name = get_function_name_from_diff(diff)\n        status = 'Survived' if 'Survived' in diff else 'Killed'\n        \n        # Update counts\n        if status == 'Killed':\n            mutants_summary['total_killed'] += 1\n        else:\n            mutants_summary['total_survived'] += 1\n        \n        # Organize by function"", 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 36, 'coloffset': 11, 'linematch': ""if status == 'Killed':"", 'context': ""        function_name = get_function_name_from_diff(diff)\n        status = 'Survived' if 'Survived' in diff else 'Killed'\n        \n        # Update counts\n        if status == 'Killed':\n            mutants_summary['total_killed'] += 1\n        else:\n            mutants_summary['total_survived'] += 1\n        \n        # Organize by function"", 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 17, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 18, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 37, 'coloffset': 8, 'linematch': 'if function_name not in mutants_by_function:', 'context': ""            survived_count += 1\n        elif 'Killed' in diff:\n            killed_count += 1\n\n        if function_name not in mutants_by_function:\n            mutants_by_function[function_name] = []\n        mutants_by_function[function_name].append((mutant_id, diff))\n\n    # Write the organized mutants and summary to a file\n    with open('mutants_by_function.txt', 'w') as file:"", 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 42, 'coloffset': 8, 'linematch': ""if function_name not in mutants_summary['functions']:"", 'context': ""        else:\n            mutants_summary['total_survived'] += 1\n        \n        # Organize by function\n        if function_name not in mutants_summary['functions']:\n            mutants_summary['functions'][function_name] = {'killed': 0, 'survived': 0}\n        mutants_summary['functions'][function_name][status.lower()] += 1\n\n    # Write the summary to a JSON file\n    with open('mutants_summary.json', 'w') as file:"", 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 34, 'coloffset': 8, 'linematch': ""elif 'Killed' in diff:"", 'context': ""\n        # Determine if the mutant was killed or survived\n        if 'Survived' in diff:\n            survived_count += 1\n        elif 'Killed' in diff:\n            killed_count += 1\n\n        if function_name not in mutants_by_function:\n            mutants_by_function[function_name] = []\n        mutants_by_function[function_name].append((mutant_id, diff))"", 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 46, 'coloffset': 8, 'linematch': 'for function, mutants in mutants_by_function.items():', 'context': '    with open(\'mutants_by_function.txt\', \'w\') as file:\n        file.write(f""Total Mutants Killed: {killed_count}\\n"")\n        file.write(f""Total Mutants Survived: {survived_count}\\n\\n"")\n        \n        for function, mutants in mutants_by_function.items():\n            file.write(f""Function: {function}\\n"")\n            for mutant_id, diff in mutants:\n                status = \'Survived\' if \'Survived\' in diff else \'Killed\'\n                file.write(f""Mutant ID: {mutant_id} - {status}\\nDiff:\\n{diff}\\n"")\n            file.write(""\\n"")', 'pattern': '//FunctionDef//For[.//For]', 'check_id': 'F001', 'check_name': 'The number of nested loop-conditions (e.g., for{for{}}) in a Function'}, {'lineno': 19, 'coloffset': 4, 'linematch': ""result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)"", 'context': ""        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}\n    killed_count = 0\n    survived_count = 0"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 20, 'coloffset': 4, 'linematch': 'mutant_ids = parse_mutant_ids(result.stdout)', 'context': ""\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}\n    killed_count = 0\n    survived_count = 0\n"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 22, 'coloffset': 4, 'linematch': 'mutants_by_function = {}', 'context': ""    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}\n    killed_count = 0\n    survived_count = 0\n\n    # Get the diff for each mutant and organize by function\n    for mutant_id in mutant_ids:"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 23, 'coloffset': 4, 'linematch': 'killed_count = 0', 'context': ""    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}\n    killed_count = 0\n    survived_count = 0\n\n    # Get the diff for each mutant and organize by function\n    for mutant_id in mutant_ids:\n        diff = subprocess.run(['mutmut', 'show', str(mutant_id)], capture_output=True, text=True).stdout"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 24, 'coloffset': 4, 'linematch': 'survived_count = 0', 'context': ""    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}\n    killed_count = 0\n    survived_count = 0\n\n    # Get the diff for each mutant and organize by function\n    for mutant_id in mutant_ids:\n        diff = subprocess.run(['mutmut', 'show', str(mutant_id)], capture_output=True, text=True).stdout\n        function_name = get_function_name_from_diff(diff)"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 27, 'coloffset': 4, 'linematch': 'for mutant_id in mutant_ids:', 'context': ""    killed_count = 0\n    survived_count = 0\n\n    # Get the diff for each mutant and organize by function\n    for mutant_id in mutant_ids:\n        diff = subprocess.run(['mutmut', 'show', str(mutant_id)], capture_output=True, text=True).stdout\n        function_name = get_function_name_from_diff(diff)\n\n        # Determine if the mutant was killed or survived\n        if 'Survived' in diff:"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 42, 'coloffset': 4, 'linematch': ""with open('mutants_by_function.txt', 'w') as file:"", 'context': '            mutants_by_function[function_name] = []\n        mutants_by_function[function_name].append((mutant_id, diff))\n\n    # Write the organized mutants and summary to a file\n    with open(\'mutants_by_function.txt\', \'w\') as file:\n        file.write(f""Total Mutants Killed: {killed_count}\\n"")\n        file.write(f""Total Mutants Survived: {survived_count}\\n\\n"")\n        \n        for function, mutants in mutants_by_function.items():\n            file.write(f""Function: {function}\\n"")', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 20, 'coloffset': 4, 'linematch': ""result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)"", 'context': ""        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {\n        'total_killed': 0,\n        'total_survived': 0,"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 21, 'coloffset': 4, 'linematch': 'mutant_ids = parse_mutant_ids(result.stdout)', 'context': ""\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {\n        'total_killed': 0,\n        'total_survived': 0,\n        'functions': {}"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 23, 'coloffset': 4, 'linematch': 'mutants_summary = {', 'context': ""    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {\n        'total_killed': 0,\n        'total_survived': 0,\n        'functions': {}\n    }\n"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 30, 'coloffset': 4, 'linematch': 'for mutant_id in mutant_ids:', 'context': ""        'functions': {}\n    }\n\n    # Get the diff for each mutant and organize by function\n    for mutant_id in mutant_ids:\n        diff = subprocess.run(['mutmut', 'show', str(mutant_id)], capture_output=True, text=True).stdout\n        function_name = get_function_name_from_diff(diff)\n        status = 'Survived' if 'Survived' in diff else 'Killed'\n        \n        # Update counts"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 47, 'coloffset': 4, 'linematch': ""with open('mutants_summary.json', 'w') as file:"", 'context': '            mutants_summary[\'functions\'][function_name] = {\'killed\': 0, \'survived\': 0}\n        mutants_summary[\'functions\'][function_name][status.lower()] += 1\n\n    # Write the summary to a JSON file\n    with open(\'mutants_summary.json\', \'w\') as file:\n        json.dump(mutants_summary, file, indent=4)\n\nif __name__ == ""__main__"":\n    main()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #123', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #124', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #125', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #126', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #127', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #128', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #129', 'line': 25, 'description': ['                f.write(""test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -22,7 +22,7 @@\n \n         with TemporaryDirectory() as input_dir:\n             with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                f.write(""test_file"")\n+                f.write(""XXtest_fileXX"")\n \n             with TemporaryDirectory() as output_dir:\n                 assert test_function(\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #130', 'line': 31, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #131', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #132', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #133', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #134', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #135', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #136', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #137', 'line': 40, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #138', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #139', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #140', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #141', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #142', 'line': 48, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #143', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #144', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #145', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #146', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}]",95.83333333333334,['F001' 'F002' 'CL001' 'BOOL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If' '//Compare/ops/Is | //Compare/ops/Eq'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else'
 '//FunctionDef//If/descendant::If' '//FunctionDef//For[.//For]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 1, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 1, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 1, '//FunctionDef//For[.//For]': 1, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]"
lazytracker.json,__init__,9-11,"[{'lineno': 9, 'coloffset': 4, 'linematch': 'def __init__(self):', 'context': 'from pathlib import Path\n\n\nclass LazyTracker:\n    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 9, 'coloffset': 4, 'linematch': 'def __init__(self):', 'context': 'from pathlib import Path\n\n\nclass LazyTracker:\n    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 9, 'coloffset': 4, 'linematch': 'def __init__(self):', 'context': 'from pathlib import Path\n\n\nclass LazyTracker:\n    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 10, 'coloffset': 8, 'linematch': '""""""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""', 'context': '\n\nclass LazyTracker:\n    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 11, 'coloffset': 8, 'linematch': 'self._hasher = hashlib.md5()', 'context': '\nclass LazyTracker:\n    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n\n        Args:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #120', 'line': 11, 'description': ['            input_dirs=[""input_dir""],'], 'failure': []}]",100.0,['F001' 'F002' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
lazytracker.json,add_directories,13-27,"[{'lineno': 13, 'coloffset': 4, 'linematch': 'def add_directories(self, directories: List[str], chunk_num_blocks=128):', 'context': '    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n\n        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 13, 'coloffset': 4, 'linematch': 'def add_directories(self, directories: List[str], chunk_num_blocks=128):', 'context': '    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n\n        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 13, 'coloffset': 4, 'linematch': 'def add_directories(self, directories: List[str], chunk_num_blocks=128):', 'context': '    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n\n        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 14, 'coloffset': 8, 'linematch': '""""""Include hash of all files inside directory (including files in subdirectories)', 'context': '        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n\n        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 20, 'coloffset': 8, 'linematch': 'files_to_check = []', 'context': '        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""\n        files_to_check = []\n\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(""*"")))\n\n        files_to_check = sorted(files_to_check)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 22, 'coloffset': 8, 'linematch': 'for directory in directories:', 'context': '            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""\n        files_to_check = []\n\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(""*"")))\n\n        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 25, 'coloffset': 8, 'linematch': 'files_to_check = sorted(files_to_check)', 'context': '\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(""*"")))\n\n        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 27, 'coloffset': 8, 'linematch': 'self.add_files(files_to_check, chunk_num_blocks)', 'context': '            files_to_check.extend(list(Path(directory).rglob(""*"")))\n\n        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files\n\n        Args:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #122', 'line': 13, 'description': ['        )'], 'failure': []}, {'name': 'Mutant #123', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #124', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #125', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #126', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #127', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #128', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #129', 'line': 25, 'description': ['                f.write(""test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -22,7 +22,7 @@\n \n         with TemporaryDirectory() as input_dir:\n             with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                f.write(""test_file"")\n+                f.write(""XXtest_fileXX"")\n \n             with TemporaryDirectory() as output_dir:\n                 assert test_function(\n', 'type': 'failure', 'message': 'bad_survived'}]}]",87.5,['F001' 'F002' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
lazytracker.json,add_files,29-42,"[{'lineno': 29, 'coloffset': 4, 'linematch': 'def add_files(self, filepaths: List[str], chunk_num_blocks=128):', 'context': '        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files\n\n        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 29, 'coloffset': 4, 'linematch': 'def add_files(self, filepaths: List[str], chunk_num_blocks=128):', 'context': '        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files\n\n        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 37, 'coloffset': 12, 'linematch': 'if os.path.exists(p):', 'context': '            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, ""rb"") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:\n                self._hasher.update(dill.dumps(None))', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 29, 'coloffset': 4, 'linematch': 'def add_files(self, filepaths: List[str], chunk_num_blocks=128):', 'context': '        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files\n\n        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 30, 'coloffset': 8, 'linematch': '""""""Include hash of files', 'context': '\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files\n\n        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 36, 'coloffset': 8, 'linematch': 'for p in filepaths:', 'context': '        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, ""rb"") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #130', 'line': 31, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #131', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #132', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #133', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #134', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #135', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #136', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #137', 'line': 40, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #138', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #139', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #140', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #141', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}]",100.0,['F001' 'F002' 'CL001' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
lazytracker.json,add_hparams,44-50,"[{'lineno': 44, 'coloffset': 4, 'linematch': 'def add_hparams(self, hparams: dict):', 'context': '                        self._hasher.update(chunk)\n            else:\n                self._hasher.update(dill.dumps(None))\n\n    def add_hparams(self, hparams: dict):\n        """"""Add hash of python dictionary. Utility function for storing pickable\n\n        Args:\n            hparams (dict): A dictionary to be included\n        """"""', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 44, 'coloffset': 4, 'linematch': 'def add_hparams(self, hparams: dict):', 'context': '                        self._hasher.update(chunk)\n            else:\n                self._hasher.update(dill.dumps(None))\n\n    def add_hparams(self, hparams: dict):\n        """"""Add hash of python dictionary. Utility function for storing pickable\n\n        Args:\n            hparams (dict): A dictionary to be included\n        """"""', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 44, 'coloffset': 4, 'linematch': 'def add_hparams(self, hparams: dict):', 'context': '                        self._hasher.update(chunk)\n            else:\n                self._hasher.update(dill.dumps(None))\n\n    def add_hparams(self, hparams: dict):\n        """"""Add hash of python dictionary. Utility function for storing pickable\n\n        Args:\n            hparams (dict): A dictionary to be included\n        """"""', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 45, 'coloffset': 8, 'linematch': '""""""Add hash of python dictionary. Utility function for storing pickable', 'context': '            else:\n                self._hasher.update(dill.dumps(None))\n\n    def add_hparams(self, hparams: dict):\n        """"""Add hash of python dictionary. Utility function for storing pickable\n\n        Args:\n            hparams (dict): A dictionary to be included\n        """"""\n        self.add_picklables([hparams])', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 50, 'coloffset': 8, 'linematch': 'self.add_picklables([hparams])', 'context': '\n        Args:\n            hparams (dict): A dictionary to be included\n        """"""\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        """"""Include hash of any picklable python objects (pickable by dill)\n\n        Args:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #142', 'line': 48, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #143', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #144', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #145', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #146', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}]",100.0,['F001' 'F002' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
lazytracker.json,add_picklables,52-61,"[{'lineno': 52, 'coloffset': 4, 'linematch': 'def add_picklables(self, objects: List[Any], recursive: bool=False):', 'context': '            hparams (dict): A dictionary to be included\n        """"""\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        """"""Include hash of any picklable python objects (pickable by dill)\n\n        Args:\n            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if ', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 52, 'coloffset': 4, 'linematch': 'def add_picklables(self, objects: List[Any], recursive: bool=False):', 'context': '            hparams (dict): A dictionary to be included\n        """"""\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        """"""Include hash of any picklable python objects (pickable by dill)\n\n        Args:\n            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if ', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 52, 'coloffset': 4, 'linematch': 'def add_picklables(self, objects: List[Any], recursive: bool=False):', 'context': '            hparams (dict): A dictionary to be included\n        """"""\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        """"""Include hash of any picklable python objects (pickable by dill)\n\n        Args:\n            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if ', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 53, 'coloffset': 8, 'linematch': '""""""Include hash of any picklable python objects (pickable by dill)', 'context': '        """"""\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        """"""Include hash of any picklable python objects (pickable by dill)\n\n        Args:\n            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if \n                recursive is set to true the changes in inner function are also tracked', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 60, 'coloffset': 8, 'linematch': 'for obj in objects:', 'context': '            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if \n                recursive is set to true the changes in inner function are also tracked\n        """"""\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        """"""Compute hash\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #147', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = True\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #148', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = None\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #149', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #150', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #151', 'line': 55, 'description': ['                    f.write(""changed_test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -52,7 +52,7 @@\n                 # Change input dependency\n                 updated = False\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                    f.write(""changed_test_file"")\n+                    f.write(""XXchanged_test_fileXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #152', 'line': 60, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #153', 'line': 61, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #154', 'line': 61, 'description': ['                ) == 5'], 'failure': []}]",62.5,['F001' 'F002' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",medium,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
lazytracker.json,hash,63-70,"[{'lineno': 63, 'coloffset': 4, 'linematch': 'def hash(self) -> str:', 'context': '        """"""\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        """"""Compute hash\n\n        Returns:\n            str: Computed checksum of all things tracked\n        """"""', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 63, 'coloffset': 4, 'linematch': 'def hash(self) -> str:', 'context': '        """"""\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        """"""Compute hash\n\n        Returns:\n            str: Computed checksum of all things tracked\n        """"""', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 63, 'coloffset': 4, 'linematch': 'def hash(self) -> str:', 'context': '        """"""\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        """"""Compute hash\n\n        Returns:\n            str: Computed checksum of all things tracked\n        """"""', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 64, 'coloffset': 8, 'linematch': '""""""Compute hash', 'context': '        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        """"""Compute hash\n\n        Returns:\n            str: Computed checksum of all things tracked\n        """"""\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 70, 'coloffset': 8, 'linematch': 'return self._hasher.hexdigest()', 'context': '        Returns:\n            str: Computed checksum of all things tracked\n        """"""\n\n        return self._hasher.hexdigest()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #157', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #158', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #159', 'line': 66, 'description': ['                    f.write(""corrupted output"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -63,7 +63,7 @@\n \n                 # Corrupt output\n                 with open(f""{output_dir}/test.txt"", \'w\') as f:\n-                    f.write(""corrupted output"")\n+                    f.write(""XXcorrupted outputXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}]",66.66666666666666,['F001' 'F002' 'ANNOT001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 0, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 0, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 0, '//FunctionDef[body//comprehension/target/Name]': 0, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 0, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
lazytracker.json,cached,14-91,"[{'lineno': 14, 'coloffset': 0, 'linematch': 'def cached(', 'context': 'shelve.Pickler = Pickler\nshelve.Unpickler = Unpickler\n\n\ndef cached(\n    cache_dir: str = "".lazytracker"",\n    input_files: Optional[List[str]] = None,\n    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 33, 'coloffset': 8, 'linematch': 'def wrapper(*args, **kwargs):', 'context': '    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 14, 'coloffset': 0, 'linematch': 'def cached(', 'context': 'shelve.Pickler = Pickler\nshelve.Unpickler = Unpickler\n\n\ndef cached(\n    cache_dir: str = "".lazytracker"",\n    input_files: Optional[List[str]] = None,\n    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 33, 'coloffset': 8, 'linematch': 'def wrapper(*args, **kwargs):', 'context': '    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 41, 'coloffset': 16, 'linematch': 'if input_dirs is not None:', 'context': '            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)\n                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]\n                    input_tracker.add_directories(input_dirs_values)\n                if input_files is not None:\n                    input_files_values = [\n                        kwargs[input_file] for input_file in input_files', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 44, 'coloffset': 16, 'linematch': 'if input_files is not None:', 'context': '                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]\n                    input_tracker.add_directories(input_dirs_values)\n                if input_files is not None:\n                    input_files_values = [\n                        kwargs[input_file] for input_file in input_files\n                    ]\n                    input_tracker.add_files(input_files_values)\n', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 51, 'coloffset': 16, 'linematch': 'if output_dirs is not None:', 'context': '                    ]\n                    input_tracker.add_files(input_files_values)\n\n                test_output_tracker = LazyTracker()\n                if output_dirs is not None:\n                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 56, 'coloffset': 16, 'linematch': 'if output_files is not None:', 'context': '                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:\n                    output_files_values = [\n                        kwargs[output_file] for output_file in output_files\n                    ]\n                    test_output_tracker.add_files(output_files_values)\n', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 65, 'coloffset': 16, 'linematch': 'if input_hash in db and db[input_hash][""hash""] == output_hash:', 'context': '\n                input_hash = input_tracker.hash()\n                output_hash = test_output_tracker.hash()\n\n                if input_hash in db and db[input_hash][""hash""] == output_hash:\n                    return db[input_hash][""return_value""]\n                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 71, 'coloffset': 20, 'linematch': 'if output_dirs is not None:', 'context': '                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()\n                    if output_dirs is not None:\n                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 76, 'coloffset': 20, 'linematch': 'if output_files is not None:', 'context': '                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:\n                        output_files_values = [\n                            kwargs[output_file] for output_file in output_files\n                        ]\n                        output_tracker.add_files(output_files_values)\n', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 65, 'coloffset': 40, 'linematch': 'if input_hash in db and db[input_hash][""hash""] == output_hash:', 'context': '\n                input_hash = input_tracker.hash()\n                output_hash = test_output_tracker.hash()\n\n                if input_hash in db and db[input_hash][""hash""] == output_hash:\n                    return db[input_hash][""return_value""]\n                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 14, 'coloffset': 0, 'linematch': 'def cached(', 'context': 'shelve.Pickler = Pickler\nshelve.Unpickler = Unpickler\n\n\ndef cached(\n    cache_dir: str = "".lazytracker"",\n    input_files: Optional[List[str]] = None,\n    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 33, 'coloffset': 8, 'linematch': 'def wrapper(*args, **kwargs):', 'context': '    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 14, 'coloffset': 0, 'linematch': 'def cached(', 'context': 'shelve.Pickler = Pickler\nshelve.Unpickler = Unpickler\n\n\ndef cached(\n    cache_dir: str = "".lazytracker"",\n    input_files: Optional[List[str]] = None,\n    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,', 'pattern': '//FunctionDef[body//comprehension/target/Name]', 'check_id': 'FLV001', 'check_name': 'Function uses loop variable'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': '//FunctionDef[body//comprehension/target/Name]', 'check_id': 'FLV001', 'check_name': 'Function uses loop variable'}, {'lineno': 33, 'coloffset': 8, 'linematch': 'def wrapper(*args, **kwargs):', 'context': '    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()', 'pattern': '//FunctionDef[body//comprehension/target/Name]', 'check_id': 'FLV001', 'check_name': 'Function uses loop variable'}, {'lineno': 14, 'coloffset': 0, 'linematch': 'def cached(', 'context': 'shelve.Pickler = Pickler\nshelve.Unpickler = Unpickler\n\n\ndef cached(\n    cache_dir: str = "".lazytracker"",\n    input_files: Optional[List[str]] = None,\n    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,', 'pattern': '//FunctionDef//FunctionDef/ancestor::*', 'check_id': 'F001', 'check_name': 'Nested Depth (Set value)'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': '//FunctionDef//FunctionDef/ancestor::*', 'check_id': 'F001', 'check_name': 'Nested Depth (Set value)'}, {'lineno': 44, 'coloffset': 16, 'linematch': 'if input_files is not None:', 'context': '                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]\n                    input_tracker.add_directories(input_dirs_values)\n                if input_files is not None:\n                    input_files_values = [\n                        kwargs[input_file] for input_file in input_files\n                    ]\n                    input_tracker.add_files(input_files_values)\n', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 51, 'coloffset': 16, 'linematch': 'if output_dirs is not None:', 'context': '                    ]\n                    input_tracker.add_files(input_files_values)\n\n                test_output_tracker = LazyTracker()\n                if output_dirs is not None:\n                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 56, 'coloffset': 16, 'linematch': 'if output_files is not None:', 'context': '                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:\n                    output_files_values = [\n                        kwargs[output_file] for output_file in output_files\n                    ]\n                    test_output_tracker.add_files(output_files_values)\n', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 65, 'coloffset': 16, 'linematch': 'if input_hash in db and db[input_hash][""hash""] == output_hash:', 'context': '\n                input_hash = input_tracker.hash()\n                output_hash = test_output_tracker.hash()\n\n                if input_hash in db and db[input_hash][""hash""] == output_hash:\n                    return db[input_hash][""return_value""]\n                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 76, 'coloffset': 20, 'linematch': 'if output_files is not None:', 'context': '                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:\n                        output_files_values = [\n                            kwargs[output_file] for output_file in output_files\n                        ]\n                        output_tracker.add_files(output_files_values)\n', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 71, 'coloffset': 20, 'linematch': 'if output_dirs is not None:', 'context': '                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()\n                    if output_dirs is not None:\n                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 76, 'coloffset': 20, 'linematch': 'if output_files is not None:', 'context': '                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:\n                        output_files_values = [\n                            kwargs[output_file] for output_file in output_files\n                        ]\n                        output_tracker.add_files(output_files_values)\n', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 21, 'coloffset': 4, 'linematch': '""""""Function decorator for caching execution', 'context': '    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,\n):\n    """"""Function decorator for caching execution\n\n    Args:\n        cache_dir (str, optional): Directory where the lazytracker cache information will be stored. Defaults to "".lazytracker"".\n        input_files (Optional[List[str]], optional): name of function parameters, that are paths to input files. Defaults to None.\n        input_dirs (Optional[List[str]], optional): name of function parameters, that are paths to directories with input files. Defaults to None.', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 33, 'coloffset': 8, 'linematch': 'def wrapper(*args, **kwargs):', 'context': '    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 34, 'coloffset': 12, 'linematch': 'kwargs.update(dict(zip(function.__code__.co_varnames, args)))', 'context': '\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 36, 'coloffset': 12, 'linematch': 'os.makedirs(f""{cache_dir}"", exist_ok=True)', 'context': '        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)\n                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 37, 'coloffset': 12, 'linematch': 'with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:', 'context': '        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)\n                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 89, 'coloffset': 8, 'linematch': 'return wrapper', 'context': '                    }\n\n                    return return_value\n\n        return wrapper\n\n    return inner_func', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 91, 'coloffset': 4, 'linematch': 'return inner_func', 'context': '                    return return_value\n\n        return wrapper\n\n    return inner_func', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #123', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #124', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #125', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #126', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #127', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #128', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #129', 'line': 25, 'description': ['                f.write(""test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -22,7 +22,7 @@\n \n         with TemporaryDirectory() as input_dir:\n             with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                f.write(""test_file"")\n+                f.write(""XXtest_fileXX"")\n \n             with TemporaryDirectory() as output_dir:\n                 assert test_function(\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #130', 'line': 31, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #131', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #132', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #133', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #134', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #135', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #136', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #137', 'line': 40, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #138', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #139', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #140', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #141', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #142', 'line': 48, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #143', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #144', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #145', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #146', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #147', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = True\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #148', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = None\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #149', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #150', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #151', 'line': 55, 'description': ['                    f.write(""changed_test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -52,7 +52,7 @@\n                 # Change input dependency\n                 updated = False\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                    f.write(""changed_test_file"")\n+                    f.write(""XXchanged_test_fileXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #152', 'line': 60, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #153', 'line': 61, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #154', 'line': 61, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #155', 'line': 62, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #156', 'line': 62, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #157', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #158', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #159', 'line': 66, 'description': ['                    f.write(""corrupted output"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -63,7 +63,7 @@\n \n                 # Corrupt output\n                 with open(f""{output_dir}/test.txt"", \'w\') as f:\n-                    f.write(""corrupted output"")\n+                    f.write(""XXcorrupted outputXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #160', 'line': 71, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #161', 'line': 72, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #162', 'line': 72, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #163', 'line': 73, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #164', 'line': 73, 'description': ['                assert updated == True'], 'failure': []}]",88.09523809523809,['F001' 'F002' 'CL001' 'BOOL001' 'ANNOT001' 'FLV001' 'CML001'],"['.//FunctionDef' './/FunctionDef[not(contains(@name, ""test_""))]'
 './/FunctionDef/body//If' '//Compare/ops/Is | //Compare/ops/Eq'
 '//FunctionDef[not(args/arg/annotation) or not(returns)]'
 '//FunctionDef[body//comprehension/target/Name]'
 '//FunctionDef//FunctionDef/ancestor::*'
 '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else'
 '//FunctionDef//If/descendant::If'
 ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return""]","{'//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]': 0, './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]': 0, '//FunctionDef[@name=""tp""]/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]': 0, './/FunctionDef': 1, '//FunctionDef//FunctionDef/ancestor::*': 1, ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"": 1, './/FunctionDef[not(args/arg/annotation) or not(returns)]': 0, './/FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/Call[count(./func/Attribute) > 3]': 0, '//FunctionDef[./body/Assert/test/Tuple]': 0, ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"": 0, './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]': 0, './/FunctionDef//If/descendant::If': 0, './/FunctionDef/body//If': 1, ""//FunctionDef[@type='str']/body/Assert"": 0, './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]': 0, ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"": 0, '//FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, ""//function[@name='your_function_name']/*[your_xpath_condition]"": 0, './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]': 0, './/Num': 0, './/FunctionDef/body/Assert': 0, './/FunctionDef[not(contains(@name, ""test_""))]': 1, './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]': 0, '//FunctionDef//if//For': 0, './/FunctionDef[@name=""__init__""]/body/Return': 0, './/Try/ExceptHandler[not(ExceptHandler/type)]': 0, './/FunctionDef[count(./args/args) > 5]': 0, './/Global': 0, './/FunctionDef//For[.//For]': 0, './/FunctionDef[starts-with(@name, ""test_"")]/body/*': 0, './/FunctionDef//*[starts-with(., ""with open"")]': 0, ""//*[starts-with(., 'with open')]"": 0, './/ClassDef[count(./body/*) > 50]': 0, ""//ImportFrom[@module='__future']/alias[not(starts-with(@name, 'division') or starts-with(@name, 'absolute_import') or starts-with(@name, 'print_function') or starts-with(@name, 'unicode_literals'))]"": 0, '//FunctionDef[BreakStmt[count(ancestor::For|ancestor::While|ancestor::If) = 0]]': 0, './/FunctionDef/body/* | .//FunctionDef/body/Return': 0, './/ExceptHandler[not(./body/*)]': 0, '//ImportFrom/keyword[@name=""from""]': 0, ""//FunctionDef//ImportFrom[starts-with(@module, 'import') and @names=('*')]"": 0, './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq': 0, '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else': 1, './/FunctionDef[./body/Assert/test/Tuple]': 0, '//FunctionDef[not(args/arg/annotation) or not(returns)]': 1, './/FunctionDef[count(./body/*) > 100]': 0, '//Try/ExceptHandler[not(ExceptHandler/type)]': 0, '//Compare/ops/Is | //Compare/ops/Eq': 1, '//FunctionDef[body//comprehension/target/Name]': 1, './/FunctionDef//if//For': 0, './/FunctionDef//BinOp[count(descendant::BinOp) > 2]': 0, './/FunctionDef[count(./body/*) > 50]': 0, './/FunctionDef//FunctionDef/ancestor::*': 0, './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else': 0, './/FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name/@id=""test_function""]) > 0]': 0, '//FunctionDef[starts-with(@name, ""test_"")]//Assert[count(.//Call[func/Name]) > 0]': 0, './/ClassDef': 0, '//FunctionDef//If/descendant::If': 1, '//FunctionDef//For[.//For]': 0, './/FunctionDef[body//comprehension/target/Name]': 0, '//FunctionDef//Call/func/Attribute[@attr=""keys""]': 0, './/FunctionDef//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0, './/FunctionDef[count(body//Return) > 2]': 0, '//FunctionDef[@name=""init""]/body/Return': 0, '//Compare/left[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq | //Compare/comparators[@id=""input_dirs""]/following-sibling::Compare/ops/NotEq': 0}",high,"[0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]"
