function_name,function_scope,patterns,mutants,mutation_score
parse_mutant_ids,4-6,"[{'lineno': 4, 'coloffset': 0, 'linematch': 'def parse_mutant_ids(output):', 'context': ""import subprocess\nimport re\n\ndef parse_mutant_ids(output):\n    # Matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 5, 'coloffset': 0, 'linematch': 'def parse_mutant_ids(output):', 'context': ""import subprocess\nimport re\nimport json\n\ndef parse_mutant_ids(output):\n    # This regular expression matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 4, 'coloffset': 0, 'linematch': 'def parse_mutant_ids(output):', 'context': ""import subprocess\nimport re\n\ndef parse_mutant_ids(output):\n    # Matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name"", 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 5, 'coloffset': 0, 'linematch': 'def parse_mutant_ids(output):', 'context': ""import subprocess\nimport re\nimport json\n\ndef parse_mutant_ids(output):\n    # This regular expression matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name"", 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 4, 'coloffset': 0, 'linematch': 'def parse_mutant_ids(output):', 'context': ""import subprocess\nimport re\n\ndef parse_mutant_ids(output):\n    # Matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 5, 'coloffset': 0, 'linematch': 'def parse_mutant_ids(output):', 'context': ""import subprocess\nimport re\nimport json\n\ndef parse_mutant_ids(output):\n    # This regular expression matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 6, 'coloffset': 4, 'linematch': ""return re.findall(r'^\\d+', output, re.MULTILINE)"", 'context': ""import re\n\ndef parse_mutant_ids(output):\n    # Matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 7, 'coloffset': 4, 'linematch': ""return re.findall(r'^\\d+', output, re.MULTILINE)"", 'context': ""import json\n\ndef parse_mutant_ids(output):\n    # This regular expression matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]",[],
get_function_name_from_diff,8-15,"[{'lineno': 8, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # Matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 9, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # This regular expression matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 8, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # Matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 9, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # This regular expression matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 12, 'coloffset': 4, 'linematch': 'if match:', 'context': ""def get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 13, 'coloffset': 4, 'linematch': 'if match:', 'context': ""def get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 8, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # Matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 9, 'coloffset': 0, 'linematch': 'def get_function_name_from_diff(diff):', 'context': ""def parse_mutant_ids(output):\n    # This regular expression matches numbers at the start of each line\n    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 10, 'coloffset': 4, 'linematch': ""pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)"", 'context': ""    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 11, 'coloffset': 4, 'linematch': 'match = pattern.search(diff)', 'context': ""\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 12, 'coloffset': 4, 'linematch': 'if match:', 'context': ""def get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 11, 'coloffset': 4, 'linematch': ""pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)"", 'context': ""    return re.findall(r'^\\d+', output, re.MULTILINE)\n\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 12, 'coloffset': 4, 'linematch': 'match = pattern.search(diff)', 'context': ""\ndef get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 13, 'coloffset': 4, 'linematch': 'if match:', 'context': ""def get_function_name_from_diff(diff):\n    # Matches the 'def' keyword and captures the function name\n    pattern = re.compile(r'^\\+.*def (\\w+)\\(.*\\):', re.MULTILINE)\n    match = pattern.search(diff)\n    if match:\n        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #120', 'line': 11, 'description': ['            input_dirs=[""input_dir""],'], 'failure': []}, {'name': 'Mutant #121', 'line': 12, 'description': ['            output_dirs=[""output_dir""]'], 'failure': []}, {'name': 'Mutant #122', 'line': 13, 'description': ['        )'], 'failure': []}]",100.0
main,17-51,"[{'lineno': 17, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 18, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 17, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}"", 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 18, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {"", 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 32, 'coloffset': 8, 'linematch': ""if 'Survived' in diff:"", 'context': ""        diff = subprocess.run(['mutmut', 'show', str(mutant_id)], capture_output=True, text=True).stdout\n        function_name = get_function_name_from_diff(diff)\n\n        # Determine if the mutant was killed or survived\n        if 'Survived' in diff:\n            survived_count += 1\n        elif 'Killed' in diff:\n            killed_count += 1\n\n        if function_name not in mutants_by_function:"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 37, 'coloffset': 8, 'linematch': 'if function_name not in mutants_by_function:', 'context': ""            survived_count += 1\n        elif 'Killed' in diff:\n            killed_count += 1\n\n        if function_name not in mutants_by_function:\n            mutants_by_function[function_name] = []\n        mutants_by_function[function_name].append((mutant_id, diff))\n\n    # Write the organized mutants and summary to a file\n    with open('mutants_by_function.txt', 'w') as file:"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 34, 'coloffset': 8, 'linematch': ""elif 'Killed' in diff:"", 'context': ""\n        # Determine if the mutant was killed or survived\n        if 'Survived' in diff:\n            survived_count += 1\n        elif 'Killed' in diff:\n            killed_count += 1\n\n        if function_name not in mutants_by_function:\n            mutants_by_function[function_name] = []\n        mutants_by_function[function_name].append((mutant_id, diff))"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 36, 'coloffset': 8, 'linematch': ""if status == 'Killed':"", 'context': ""        function_name = get_function_name_from_diff(diff)\n        status = 'Survived' if 'Survived' in diff else 'Killed'\n        \n        # Update counts\n        if status == 'Killed':\n            mutants_summary['total_killed'] += 1\n        else:\n            mutants_summary['total_survived'] += 1\n        \n        # Organize by function"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 42, 'coloffset': 8, 'linematch': ""if function_name not in mutants_summary['functions']:"", 'context': ""        else:\n            mutants_summary['total_survived'] += 1\n        \n        # Organize by function\n        if function_name not in mutants_summary['functions']:\n            mutants_summary['functions'][function_name] = {'killed': 0, 'survived': 0}\n        mutants_summary['functions'][function_name][status.lower()] += 1\n\n    # Write the summary to a JSON file\n    with open('mutants_summary.json', 'w') as file:"", 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 36, 'coloffset': 11, 'linematch': ""if status == 'Killed':"", 'context': ""        function_name = get_function_name_from_diff(diff)\n        status = 'Survived' if 'Survived' in diff else 'Killed'\n        \n        # Update counts\n        if status == 'Killed':\n            mutants_summary['total_killed'] += 1\n        else:\n            mutants_summary['total_survived'] += 1\n        \n        # Organize by function"", 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 36, 'coloffset': 11, 'linematch': ""if status == 'Killed':"", 'context': ""        function_name = get_function_name_from_diff(diff)\n        status = 'Survived' if 'Survived' in diff else 'Killed'\n        \n        # Update counts\n        if status == 'Killed':\n            mutants_summary['total_killed'] += 1\n        else:\n            mutants_summary['total_survived'] += 1\n        \n        # Organize by function"", 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 17, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 18, 'coloffset': 0, 'linematch': 'def main():', 'context': ""        return match.group(1)\n    else:\n        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 37, 'coloffset': 8, 'linematch': 'if function_name not in mutants_by_function:', 'context': ""            survived_count += 1\n        elif 'Killed' in diff:\n            killed_count += 1\n\n        if function_name not in mutants_by_function:\n            mutants_by_function[function_name] = []\n        mutants_by_function[function_name].append((mutant_id, diff))\n\n    # Write the organized mutants and summary to a file\n    with open('mutants_by_function.txt', 'w') as file:"", 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 42, 'coloffset': 8, 'linematch': ""if function_name not in mutants_summary['functions']:"", 'context': ""        else:\n            mutants_summary['total_survived'] += 1\n        \n        # Organize by function\n        if function_name not in mutants_summary['functions']:\n            mutants_summary['functions'][function_name] = {'killed': 0, 'survived': 0}\n        mutants_summary['functions'][function_name][status.lower()] += 1\n\n    # Write the summary to a JSON file\n    with open('mutants_summary.json', 'w') as file:"", 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 34, 'coloffset': 8, 'linematch': ""elif 'Killed' in diff:"", 'context': ""\n        # Determine if the mutant was killed or survived\n        if 'Survived' in diff:\n            survived_count += 1\n        elif 'Killed' in diff:\n            killed_count += 1\n\n        if function_name not in mutants_by_function:\n            mutants_by_function[function_name] = []\n        mutants_by_function[function_name].append((mutant_id, diff))"", 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 46, 'coloffset': 8, 'linematch': 'for function, mutants in mutants_by_function.items():', 'context': '    with open(\'mutants_by_function.txt\', \'w\') as file:\n        file.write(f""Total Mutants Killed: {killed_count}\\n"")\n        file.write(f""Total Mutants Survived: {survived_count}\\n\\n"")\n        \n        for function, mutants in mutants_by_function.items():\n            file.write(f""Function: {function}\\n"")\n            for mutant_id, diff in mutants:\n                status = \'Survived\' if \'Survived\' in diff else \'Killed\'\n                file.write(f""Mutant ID: {mutant_id} - {status}\\nDiff:\\n{diff}\\n"")\n            file.write(""\\n"")', 'pattern': '//FunctionDef//For[.//For]', 'check_id': 'F001', 'check_name': 'The number of nested loop-conditions (e.g., for{for{}}) in a Function'}, {'lineno': 19, 'coloffset': 4, 'linematch': ""result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)"", 'context': ""        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}\n    killed_count = 0\n    survived_count = 0"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 20, 'coloffset': 4, 'linematch': 'mutant_ids = parse_mutant_ids(result.stdout)', 'context': ""\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}\n    killed_count = 0\n    survived_count = 0\n"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 22, 'coloffset': 4, 'linematch': 'mutants_by_function = {}', 'context': ""    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}\n    killed_count = 0\n    survived_count = 0\n\n    # Get the diff for each mutant and organize by function\n    for mutant_id in mutant_ids:"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 23, 'coloffset': 4, 'linematch': 'killed_count = 0', 'context': ""    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}\n    killed_count = 0\n    survived_count = 0\n\n    # Get the diff for each mutant and organize by function\n    for mutant_id in mutant_ids:\n        diff = subprocess.run(['mutmut', 'show', str(mutant_id)], capture_output=True, text=True).stdout"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 24, 'coloffset': 4, 'linematch': 'survived_count = 0', 'context': ""    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_by_function = {}\n    killed_count = 0\n    survived_count = 0\n\n    # Get the diff for each mutant and organize by function\n    for mutant_id in mutant_ids:\n        diff = subprocess.run(['mutmut', 'show', str(mutant_id)], capture_output=True, text=True).stdout\n        function_name = get_function_name_from_diff(diff)"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 27, 'coloffset': 4, 'linematch': 'for mutant_id in mutant_ids:', 'context': ""    killed_count = 0\n    survived_count = 0\n\n    # Get the diff for each mutant and organize by function\n    for mutant_id in mutant_ids:\n        diff = subprocess.run(['mutmut', 'show', str(mutant_id)], capture_output=True, text=True).stdout\n        function_name = get_function_name_from_diff(diff)\n\n        # Determine if the mutant was killed or survived\n        if 'Survived' in diff:"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 42, 'coloffset': 4, 'linematch': ""with open('mutants_by_function.txt', 'w') as file:"", 'context': '            mutants_by_function[function_name] = []\n        mutants_by_function[function_name].append((mutant_id, diff))\n\n    # Write the organized mutants and summary to a file\n    with open(\'mutants_by_function.txt\', \'w\') as file:\n        file.write(f""Total Mutants Killed: {killed_count}\\n"")\n        file.write(f""Total Mutants Survived: {survived_count}\\n\\n"")\n        \n        for function, mutants in mutants_by_function.items():\n            file.write(f""Function: {function}\\n"")', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 20, 'coloffset': 4, 'linematch': ""result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)"", 'context': ""        return 'Unknown function'  # Default value if function name is not found\n\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {\n        'total_killed': 0,\n        'total_survived': 0,"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 21, 'coloffset': 4, 'linematch': 'mutant_ids = parse_mutant_ids(result.stdout)', 'context': ""\ndef main():\n    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {\n        'total_killed': 0,\n        'total_survived': 0,\n        'functions': {}"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 23, 'coloffset': 4, 'linematch': 'mutants_summary = {', 'context': ""    # Get the list of all mutants from mutmut results\n    result = subprocess.run(['mutmut', 'results'], capture_output=True, text=True)\n    mutant_ids = parse_mutant_ids(result.stdout)\n\n    mutants_summary = {\n        'total_killed': 0,\n        'total_survived': 0,\n        'functions': {}\n    }\n"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 30, 'coloffset': 4, 'linematch': 'for mutant_id in mutant_ids:', 'context': ""        'functions': {}\n    }\n\n    # Get the diff for each mutant and organize by function\n    for mutant_id in mutant_ids:\n        diff = subprocess.run(['mutmut', 'show', str(mutant_id)], capture_output=True, text=True).stdout\n        function_name = get_function_name_from_diff(diff)\n        status = 'Survived' if 'Survived' in diff else 'Killed'\n        \n        # Update counts"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 47, 'coloffset': 4, 'linematch': ""with open('mutants_summary.json', 'w') as file:"", 'context': '            mutants_summary[\'functions\'][function_name] = {\'killed\': 0, \'survived\': 0}\n        mutants_summary[\'functions\'][function_name][status.lower()] += 1\n\n    # Write the summary to a JSON file\n    with open(\'mutants_summary.json\', \'w\') as file:\n        json.dump(mutants_summary, file, indent=4)\n\nif __name__ == ""__main__"":\n    main()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #123', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #124', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #125', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #126', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #127', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #128', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #129', 'line': 25, 'description': ['                f.write(""test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -22,7 +22,7 @@\n \n         with TemporaryDirectory() as input_dir:\n             with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                f.write(""test_file"")\n+                f.write(""XXtest_fileXX"")\n \n             with TemporaryDirectory() as output_dir:\n                 assert test_function(\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #130', 'line': 31, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #131', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #132', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #133', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #134', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #135', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #136', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #137', 'line': 40, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #138', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #139', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #140', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #141', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #142', 'line': 48, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #143', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #144', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #145', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #146', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}]",95.83333333333334
test_hparams,6-33,"[{'lineno': 6, 'coloffset': 0, 'linematch': 'def test_hparams():', 'context': ""import shutil\nfrom tempfile import TemporaryDirectory, tempdir\nfrom lazytracker import LazyTracker\n\ndef test_hparams():\n    hparams_1 = {\n        'a': 1,\n        'b': 2,\n        'c': {\n            'd': 1"", 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 6, 'coloffset': 0, 'linematch': 'def test_hparams():', 'context': ""import shutil\nfrom tempfile import TemporaryDirectory, tempdir\nfrom lazytracker import LazyTracker\n\ndef test_hparams():\n    hparams_1 = {\n        'a': 1,\n        'b': 2,\n        'c': {\n            'd': 1"", 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 32, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() == tracker_2.hash()', 'context': '\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1', 'pattern': ""//FunctionDef[@type='str']/body/Assert"", 'check_id': 'NOA001', 'check_name': 'number-of-assertions'}, {'lineno': 33, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() != tracker_3.hash()', 'context': '    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):', 'pattern': ""//FunctionDef[@type='str']/body/Assert"", 'check_id': 'NOA001', 'check_name': 'number-of-assertions'}, {'lineno': 7, 'coloffset': 4, 'linematch': 'hparams_1 = {', 'context': ""from tempfile import TemporaryDirectory, tempdir\nfrom lazytracker import LazyTracker\n\ndef test_hparams():\n    hparams_1 = {\n        'a': 1,\n        'b': 2,\n        'c': {\n            'd': 1\n        }"", 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 15, 'coloffset': 4, 'linematch': 'hparams_2 = {', 'context': ""            'd': 1\n        }\n    }\n\n    hparams_2 = {\n        'a': 1,\n        'b': 2,\n        'c': {\n            'd': 2\n        }"", 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 23, 'coloffset': 4, 'linematch': 'tracker_1 = LazyTracker()', 'context': ""            'd': 2\n        }\n    }\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_hparams(hparams_1)\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n"", 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 24, 'coloffset': 4, 'linematch': 'tracker_1.add_hparams(hparams_1)', 'context': '        }\n    }\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_hparams(hparams_1)\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n\n    tracker_3 = LazyTracker()', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 26, 'coloffset': 4, 'linematch': 'tracker_2 = LazyTracker()', 'context': '\n    tracker_1 = LazyTracker()\n    tracker_1.add_hparams(hparams_1)\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 27, 'coloffset': 4, 'linematch': 'tracker_2.add_hparams(hparams_1)', 'context': '    tracker_1 = LazyTracker()\n    tracker_1.add_hparams(hparams_1)\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 29, 'coloffset': 4, 'linematch': 'tracker_3 = LazyTracker()', 'context': '\n    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 30, 'coloffset': 4, 'linematch': 'tracker_3.add_hparams(hparams_2)', 'context': '    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 32, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() == tracker_2.hash()', 'context': '\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 33, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() != tracker_3.hash()', 'context': '    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 7, 'coloffset': 4, 'linematch': 'hparams_1 = {', 'context': ""from tempfile import TemporaryDirectory, tempdir\nfrom lazytracker import LazyTracker\n\ndef test_hparams():\n    hparams_1 = {\n        'a': 1,\n        'b': 2,\n        'c': {\n            'd': 1\n        }"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 15, 'coloffset': 4, 'linematch': 'hparams_2 = {', 'context': ""            'd': 1\n        }\n    }\n\n    hparams_2 = {\n        'a': 1,\n        'b': 2,\n        'c': {\n            'd': 2\n        }"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 23, 'coloffset': 4, 'linematch': 'tracker_1 = LazyTracker()', 'context': ""            'd': 2\n        }\n    }\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_hparams(hparams_1)\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 24, 'coloffset': 4, 'linematch': 'tracker_1.add_hparams(hparams_1)', 'context': '        }\n    }\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_hparams(hparams_1)\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n\n    tracker_3 = LazyTracker()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 26, 'coloffset': 4, 'linematch': 'tracker_2 = LazyTracker()', 'context': '\n    tracker_1 = LazyTracker()\n    tracker_1.add_hparams(hparams_1)\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 27, 'coloffset': 4, 'linematch': 'tracker_2.add_hparams(hparams_1)', 'context': '    tracker_1 = LazyTracker()\n    tracker_1.add_hparams(hparams_1)\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 29, 'coloffset': 4, 'linematch': 'tracker_3 = LazyTracker()', 'context': '\n    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 30, 'coloffset': 4, 'linematch': 'tracker_3.add_hparams(hparams_2)', 'context': '    tracker_2 = LazyTracker()\n    tracker_2.add_hparams(hparams_1)\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 32, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() == tracker_2.hash()', 'context': '\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 33, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() != tracker_3.hash()', 'context': '    tracker_3 = LazyTracker()\n    tracker_3.add_hparams(hparams_2)\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #118', 'line': 7, 'description': ['        updated = False'], 'failure': []}, {'name': 'Mutant #119', 'line': 7, 'description': ['        updated = False'], 'failure': []}, {'name': 'Mutant #120', 'line': 11, 'description': ['            input_dirs=[""input_dir""],'], 'failure': []}, {'name': 'Mutant #121', 'line': 12, 'description': ['            output_dirs=[""output_dir""]'], 'failure': []}, {'name': 'Mutant #122', 'line': 13, 'description': ['        )'], 'failure': []}, {'name': 'Mutant #123', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #124', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #125', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #126', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #127', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #128', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #129', 'line': 25, 'description': ['                f.write(""test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -22,7 +22,7 @@\n \n         with TemporaryDirectory() as input_dir:\n             with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                f.write(""test_file"")\n+                f.write(""XXtest_fileXX"")\n \n             with TemporaryDirectory() as output_dir:\n                 assert test_function(\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #130', 'line': 31, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #131', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #132', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #133', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #134', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}]",94.11764705882352
test_picable_function,35-51,"[{'lineno': 35, 'coloffset': 0, 'linematch': 'def test_picable_function():', 'context': '\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 36, 'coloffset': 4, 'linematch': 'def func_1(x):', 'context': '    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 38, 'coloffset': 4, 'linematch': 'def func_2(x):', 'context': '\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 36, 'coloffset': 4, 'linematch': 'def func_1(x):', 'context': '    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 38, 'coloffset': 4, 'linematch': 'def func_2(x):', 'context': '\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 35, 'coloffset': 0, 'linematch': 'def test_picable_function():', 'context': '\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 36, 'coloffset': 4, 'linematch': 'def func_1(x):', 'context': '    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 38, 'coloffset': 4, 'linematch': 'def func_2(x):', 'context': '\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 35, 'coloffset': 0, 'linematch': 'def test_picable_function():', 'context': '\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n', 'pattern': '//FunctionDef//FunctionDef/ancestor::*', 'check_id': 'F001', 'check_name': 'Nested Depth (Set value)'}, {'lineno': 50, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() == tracker_2.hash()', 'context': ""\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f'{tmpdir}/a.txt', 'w') as f:"", 'pattern': ""//FunctionDef[@type='str']/body/Assert"", 'check_id': 'NOA001', 'check_name': 'number-of-assertions'}, {'lineno': 51, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() != tracker_3.hash()', 'context': '    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f\'{tmpdir}/a.txt\', \'w\') as f:\n            f.write(""test file 1"")', 'pattern': ""//FunctionDef[@type='str']/body/Assert"", 'check_id': 'NOA001', 'check_name': 'number-of-assertions'}, {'lineno': 36, 'coloffset': 4, 'linematch': 'def func_1(x):', 'context': '    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 38, 'coloffset': 4, 'linematch': 'def func_2(x):', 'context': '\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 41, 'coloffset': 4, 'linematch': 'tracker_1 = LazyTracker()', 'context': '        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 42, 'coloffset': 4, 'linematch': 'tracker_1.add_picklables([func_1])', 'context': '    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n\n    tracker_3 = LazyTracker()', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 44, 'coloffset': 4, 'linematch': 'tracker_2 = LazyTracker()', 'context': '\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 45, 'coloffset': 4, 'linematch': 'tracker_2.add_picklables([func_1])', 'context': '    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 47, 'coloffset': 4, 'linematch': 'tracker_3 = LazyTracker()', 'context': '\n    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 48, 'coloffset': 4, 'linematch': 'tracker_3.add_hparams([func_2])', 'context': '    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 50, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() == tracker_2.hash()', 'context': ""\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f'{tmpdir}/a.txt', 'w') as f:"", 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 51, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() != tracker_3.hash()', 'context': '    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f\'{tmpdir}/a.txt\', \'w\') as f:\n            f.write(""test file 1"")', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 36, 'coloffset': 4, 'linematch': 'def func_1(x):', 'context': '    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 37, 'coloffset': 8, 'linematch': 'return x+1', 'context': '    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 38, 'coloffset': 4, 'linematch': 'def func_2(x):', 'context': '\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 39, 'coloffset': 8, 'linematch': 'return x+2', 'context': 'def test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 41, 'coloffset': 4, 'linematch': 'tracker_1 = LazyTracker()', 'context': '        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 42, 'coloffset': 4, 'linematch': 'tracker_1.add_picklables([func_1])', 'context': '    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n\n    tracker_3 = LazyTracker()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 44, 'coloffset': 4, 'linematch': 'tracker_2 = LazyTracker()', 'context': '\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 45, 'coloffset': 4, 'linematch': 'tracker_2.add_picklables([func_1])', 'context': '    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 47, 'coloffset': 4, 'linematch': 'tracker_3 = LazyTracker()', 'context': '\n    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 48, 'coloffset': 4, 'linematch': 'tracker_3.add_hparams([func_2])', 'context': '    tracker_2 = LazyTracker()\n    tracker_2.add_picklables([func_1])\n\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 50, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() == tracker_2.hash()', 'context': ""\n    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f'{tmpdir}/a.txt', 'w') as f:"", 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 51, 'coloffset': 4, 'linematch': 'assert tracker_1.hash() != tracker_3.hash()', 'context': '    tracker_3 = LazyTracker()\n    tracker_3.add_hparams([func_2])\n\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f\'{tmpdir}/a.txt\', \'w\') as f:\n            f.write(""test file 1"")', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #135', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #136', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #137', 'line': 40, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #138', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #139', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #140', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #141', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #142', 'line': 48, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #143', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #144', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #145', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #146', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}]",100.0
test_files,53-74,"[{'lineno': 53, 'coloffset': 0, 'linematch': 'def test_files():', 'context': '\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f\'{tmpdir}/a.txt\', \'w\') as f:\n            f.write(""test file 1"")\n\n        with open(f\'{tmpdir}/b.txt\', \'w\') as f:', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 53, 'coloffset': 0, 'linematch': 'def test_files():', 'context': '\n    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f\'{tmpdir}/a.txt\', \'w\') as f:\n            f.write(""test file 1"")\n\n        with open(f\'{tmpdir}/b.txt\', \'w\') as f:', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 54, 'coloffset': 4, 'linematch': 'with TemporaryDirectory() as tmpdir:', 'context': '    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f\'{tmpdir}/a.txt\', \'w\') as f:\n            f.write(""test file 1"")\n\n        with open(f\'{tmpdir}/b.txt\', \'w\') as f:\n            f.write(""test file 1"")', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 54, 'coloffset': 4, 'linematch': 'with TemporaryDirectory() as tmpdir:', 'context': '    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f\'{tmpdir}/a.txt\', \'w\') as f:\n            f.write(""test file 1"")\n\n        with open(f\'{tmpdir}/b.txt\', \'w\') as f:\n            f.write(""test file 1"")', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #147', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = True\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #148', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = None\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #149', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #150', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #151', 'line': 55, 'description': ['                    f.write(""changed_test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -52,7 +52,7 @@\n                 # Change input dependency\n                 updated = False\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                    f.write(""changed_test_file"")\n+                    f.write(""XXchanged_test_fileXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #152', 'line': 60, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #153', 'line': 61, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #154', 'line': 61, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #155', 'line': 62, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #156', 'line': 62, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #157', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #158', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #159', 'line': 66, 'description': ['                    f.write(""corrupted output"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -63,7 +63,7 @@\n \n                 # Corrupt output\n                 with open(f""{output_dir}/test.txt"", \'w\') as f:\n-                    f.write(""corrupted output"")\n+                    f.write(""XXcorrupted outputXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #160', 'line': 71, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #161', 'line': 72, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #162', 'line': 72, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #163', 'line': 73, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #164', 'line': 73, 'description': ['                assert updated == True'], 'failure': []}]",77.77777777777779
test_directories,76-105,"[{'lineno': 76, 'coloffset': 0, 'linematch': 'def test_directories():', 'context': '\n        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()\n\ndef test_directories():\n    with TemporaryDirectory() as tmpdir:\n        os.makedirs(f""{tmpdir}/1"", exist_ok=True)\n\n        with open(f\'{tmpdir}/1/a.txt\', \'w\') as f:\n            f.write(""test file 1"")', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 104, 'coloffset': 15, 'linematch': 'assert tracker_1.hash() == tracker_2.hash()', 'context': '\n        tracker_3 = LazyTracker()\n        tracker_3.add_directories([f""{tmpdir}/3""])\n\n        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 104, 'coloffset': 15, 'linematch': 'assert tracker_1.hash() == tracker_2.hash()', 'context': '\n        tracker_3 = LazyTracker()\n        tracker_3.add_directories([f""{tmpdir}/3""])\n\n        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 104, 'coloffset': 15, 'linematch': 'assert tracker_1.hash() == tracker_2.hash()', 'context': '\n        tracker_3 = LazyTracker()\n        tracker_3.add_directories([f""{tmpdir}/3""])\n\n        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 104, 'coloffset': 15, 'linematch': 'assert tracker_1.hash() == tracker_2.hash()', 'context': '\n        tracker_3 = LazyTracker()\n        tracker_3.add_directories([f""{tmpdir}/3""])\n\n        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 76, 'coloffset': 0, 'linematch': 'def test_directories():', 'context': '\n        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()\n\ndef test_directories():\n    with TemporaryDirectory() as tmpdir:\n        os.makedirs(f""{tmpdir}/1"", exist_ok=True)\n\n        with open(f\'{tmpdir}/1/a.txt\', \'w\') as f:\n            f.write(""test file 1"")', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 77, 'coloffset': 4, 'linematch': 'with TemporaryDirectory() as tmpdir:', 'context': '        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()\n\ndef test_directories():\n    with TemporaryDirectory() as tmpdir:\n        os.makedirs(f""{tmpdir}/1"", exist_ok=True)\n\n        with open(f\'{tmpdir}/1/a.txt\', \'w\') as f:\n            f.write(""test file 1"")\n', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 77, 'coloffset': 4, 'linematch': 'with TemporaryDirectory() as tmpdir:', 'context': '        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()\n\ndef test_directories():\n    with TemporaryDirectory() as tmpdir:\n        os.makedirs(f""{tmpdir}/1"", exist_ok=True)\n\n        with open(f\'{tmpdir}/1/a.txt\', \'w\') as f:\n            f.write(""test file 1"")\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]",[],
test_cached,5-73,"[{'lineno': 5, 'coloffset': 0, 'linematch': 'def test_cached():', 'context': 'from tempfile import TemporaryDirectory\nfrom lazytracker import cached\n\n\ndef test_cached():\n    with TemporaryDirectory() as cache_dir:\n        updated = False\n\n        @cached(\n            cache_dir=cache_dir,', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 14, 'coloffset': 8, 'linematch': 'def test_function(input_dir: str, output_dir: str, parameter: int):', 'context': '            cache_dir=cache_dir,\n            input_dirs=[""input_dir""],\n            output_dirs=[""output_dir""]\n        )\n        def test_function(input_dir: str, output_dir: str, parameter: int):\n            nonlocal updated\n\n            with open(f""{output_dir}/test.txt"", \'w\') as f:\n                f.write(str(parameter))\n', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 73, 'coloffset': 23, 'linematch': 'assert updated == True', 'context': '                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 73, 'coloffset': 23, 'linematch': 'assert updated == True', 'context': '                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 73, 'coloffset': 23, 'linematch': 'assert updated == True', 'context': '                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 73, 'coloffset': 23, 'linematch': 'assert updated == True', 'context': '                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 73, 'coloffset': 23, 'linematch': 'assert updated == True', 'context': '                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 73, 'coloffset': 23, 'linematch': 'assert updated == True', 'context': '                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 73, 'coloffset': 23, 'linematch': 'assert updated == True', 'context': '                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 73, 'coloffset': 23, 'linematch': 'assert updated == True', 'context': '                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 73, 'coloffset': 23, 'linematch': 'assert updated == True', 'context': '                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 73, 'coloffset': 23, 'linematch': 'assert updated == True', 'context': '                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 5, 'coloffset': 0, 'linematch': 'def test_cached():', 'context': 'from tempfile import TemporaryDirectory\nfrom lazytracker import cached\n\n\ndef test_cached():\n    with TemporaryDirectory() as cache_dir:\n        updated = False\n\n        @cached(\n            cache_dir=cache_dir,', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 14, 'coloffset': 8, 'linematch': 'def test_function(input_dir: str, output_dir: str, parameter: int):', 'context': '            cache_dir=cache_dir,\n            input_dirs=[""input_dir""],\n            output_dirs=[""output_dir""]\n        )\n        def test_function(input_dir: str, output_dir: str, parameter: int):\n            nonlocal updated\n\n            with open(f""{output_dir}/test.txt"", \'w\') as f:\n                f.write(str(parameter))\n', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 5, 'coloffset': 0, 'linematch': 'def test_cached():', 'context': 'from tempfile import TemporaryDirectory\nfrom lazytracker import cached\n\n\ndef test_cached():\n    with TemporaryDirectory() as cache_dir:\n        updated = False\n\n        @cached(\n            cache_dir=cache_dir,', 'pattern': '//FunctionDef//FunctionDef/ancestor::*', 'check_id': 'F001', 'check_name': 'Nested Depth (Set value)'}, {'lineno': 6, 'coloffset': 4, 'linematch': 'with TemporaryDirectory() as cache_dir:', 'context': 'from lazytracker import cached\n\n\ndef test_cached():\n    with TemporaryDirectory() as cache_dir:\n        updated = False\n\n        @cached(\n            cache_dir=cache_dir,\n            input_dirs=[""input_dir""],', 'pattern': '//FunctionDef//FunctionDef/ancestor::*', 'check_id': 'F001', 'check_name': 'Nested Depth (Set value)'}, {'lineno': 6, 'coloffset': 4, 'linematch': 'with TemporaryDirectory() as cache_dir:', 'context': 'from lazytracker import cached\n\n\ndef test_cached():\n    with TemporaryDirectory() as cache_dir:\n        updated = False\n\n        @cached(\n            cache_dir=cache_dir,\n            input_dirs=[""input_dir""],', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 15, 'coloffset': 12, 'linematch': 'nonlocal updated', 'context': '            input_dirs=[""input_dir""],\n            output_dirs=[""output_dir""]\n        )\n        def test_function(input_dir: str, output_dir: str, parameter: int):\n            nonlocal updated\n\n            with open(f""{output_dir}/test.txt"", \'w\') as f:\n                f.write(str(parameter))\n\n            updated = True', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 17, 'coloffset': 12, 'linematch': 'with open(f""{output_dir}/test.txt"", \'w\') as f:', 'context': '        )\n        def test_function(input_dir: str, output_dir: str, parameter: int):\n            nonlocal updated\n\n            with open(f""{output_dir}/test.txt"", \'w\') as f:\n                f.write(str(parameter))\n\n            updated = True\n            return parameter\n', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 20, 'coloffset': 12, 'linematch': 'updated = True', 'context': '\n            with open(f""{output_dir}/test.txt"", \'w\') as f:\n                f.write(str(parameter))\n\n            updated = True\n            return parameter\n\n        with TemporaryDirectory() as input_dir:\n            with open(f""{input_dir}/test.txt"", \'w\') as f:\n                f.write(""test_file"")', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 21, 'coloffset': 12, 'linematch': 'return parameter', 'context': '            with open(f""{output_dir}/test.txt"", \'w\') as f:\n                f.write(str(parameter))\n\n            updated = True\n            return parameter\n\n        with TemporaryDirectory() as input_dir:\n            with open(f""{input_dir}/test.txt"", \'w\') as f:\n                f.write(""test_file"")\n', 'pattern': ""//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*"", 'check_id': 'LOF001', 'check_name': 'count-test-method-lines'}, {'lineno': 6, 'coloffset': 4, 'linematch': 'with TemporaryDirectory() as cache_dir:', 'context': 'from lazytracker import cached\n\n\ndef test_cached():\n    with TemporaryDirectory() as cache_dir:\n        updated = False\n\n        @cached(\n            cache_dir=cache_dir,\n            input_dirs=[""input_dir""],', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 15, 'coloffset': 12, 'linematch': 'nonlocal updated', 'context': '            input_dirs=[""input_dir""],\n            output_dirs=[""output_dir""]\n        )\n        def test_function(input_dir: str, output_dir: str, parameter: int):\n            nonlocal updated\n\n            with open(f""{output_dir}/test.txt"", \'w\') as f:\n                f.write(str(parameter))\n\n            updated = True', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 17, 'coloffset': 12, 'linematch': 'with open(f""{output_dir}/test.txt"", \'w\') as f:', 'context': '        )\n        def test_function(input_dir: str, output_dir: str, parameter: int):\n            nonlocal updated\n\n            with open(f""{output_dir}/test.txt"", \'w\') as f:\n                f.write(str(parameter))\n\n            updated = True\n            return parameter\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 20, 'coloffset': 12, 'linematch': 'updated = True', 'context': '\n            with open(f""{output_dir}/test.txt"", \'w\') as f:\n                f.write(str(parameter))\n\n            updated = True\n            return parameter\n\n        with TemporaryDirectory() as input_dir:\n            with open(f""{input_dir}/test.txt"", \'w\') as f:\n                f.write(""test_file"")', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 21, 'coloffset': 12, 'linematch': 'return parameter', 'context': '            with open(f""{output_dir}/test.txt"", \'w\') as f:\n                f.write(str(parameter))\n\n            updated = True\n            return parameter\n\n        with TemporaryDirectory() as input_dir:\n            with open(f""{input_dir}/test.txt"", \'w\') as f:\n                f.write(""test_file"")\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 28, 'coloffset': 16, 'linematch': 'assert test_function(', 'context': '            with open(f""{input_dir}/test.txt"", \'w\') as f:\n                f.write(""test_file"")\n\n            with TemporaryDirectory() as output_dir:\n                assert test_function(\n                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=3\n                ) == 3\n                assert updated == True', 'pattern': ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"", 'check_id': 'TMIM001', 'check_name': 'test-methods-invoking-method'}, {'lineno': 37, 'coloffset': 16, 'linematch': 'assert test_function(', 'context': ""                assert updated == True\n\n                # Don't change antything\n                updated = False\n                assert test_function(\n                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=3\n                ) == 3\n                assert updated == False"", 'pattern': ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"", 'check_id': 'TMIM001', 'check_name': 'test-methods-invoking-method'}, {'lineno': 45, 'coloffset': 16, 'linematch': 'assert test_function(', 'context': '                ) == 3\n                assert updated == False\n\n                # Change parameter\n                assert test_function(\n                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"", 'check_id': 'TMIM001', 'check_name': 'test-methods-invoking-method'}, {'lineno': 57, 'coloffset': 16, 'linematch': 'assert test_function(', 'context': '                updated = False\n                with open(f""{input_dir}/test.txt"", \'w\') as f:\n                    f.write(""changed_test_file"")\n\n                assert test_function(\n                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"", 'check_id': 'TMIM001', 'check_name': 'test-methods-invoking-method'}, {'lineno': 68, 'coloffset': 16, 'linematch': 'assert test_function(', 'context': '                # Corrupt output\n                with open(f""{output_dir}/test.txt"", \'w\') as f:\n                    f.write(""corrupted output"")\n\n                assert test_function(\n                    input_dir=input_dir, \n                    output_dir=output_dir, \n                    parameter=5\n                ) == 5\n                assert updated == True', 'pattern': ""//Assert[count(.//Call[func/Name/@id='test_function']) > 0]"", 'check_id': 'TMIM001', 'check_name': 'test-methods-invoking-method'}]","[{'name': 'Mutant #118', 'line': 7, 'description': ['        updated = False'], 'failure': []}, {'name': 'Mutant #119', 'line': 7, 'description': ['        updated = False'], 'failure': []}, {'name': 'Mutant #120', 'line': 11, 'description': ['            input_dirs=[""input_dir""],'], 'failure': []}, {'name': 'Mutant #121', 'line': 12, 'description': ['            output_dirs=[""output_dir""]'], 'failure': []}, {'name': 'Mutant #122', 'line': 13, 'description': ['        )'], 'failure': []}, {'name': 'Mutant #123', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #124', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #125', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #126', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #127', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #128', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #129', 'line': 25, 'description': ['                f.write(""test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -22,7 +22,7 @@\n \n         with TemporaryDirectory() as input_dir:\n             with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                f.write(""test_file"")\n+                f.write(""XXtest_fileXX"")\n \n             with TemporaryDirectory() as output_dir:\n                 assert test_function(\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #130', 'line': 31, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #131', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #132', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #133', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #134', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #135', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #136', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #137', 'line': 40, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #138', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #139', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #140', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #141', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #142', 'line': 48, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #143', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #144', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #145', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #146', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #147', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = True\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #148', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = None\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #149', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #150', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #151', 'line': 55, 'description': ['                    f.write(""changed_test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -52,7 +52,7 @@\n                 # Change input dependency\n                 updated = False\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                    f.write(""changed_test_file"")\n+                    f.write(""XXchanged_test_fileXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #152', 'line': 60, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #153', 'line': 61, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #154', 'line': 61, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #155', 'line': 62, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #156', 'line': 62, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #157', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #158', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #159', 'line': 66, 'description': ['                    f.write(""corrupted output"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -63,7 +63,7 @@\n \n                 # Corrupt output\n                 with open(f""{output_dir}/test.txt"", \'w\') as f:\n-                    f.write(""corrupted output"")\n+                    f.write(""XXcorrupted outputXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #160', 'line': 71, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #161', 'line': 72, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #162', 'line': 72, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #163', 'line': 73, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #164', 'line': 73, 'description': ['                assert updated == True'], 'failure': []}]",89.36170212765957
__init__,9-11,"[{'lineno': 9, 'coloffset': 4, 'linematch': 'def __init__(self):', 'context': 'from pathlib import Path\n\n\nclass LazyTracker:\n    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 9, 'coloffset': 4, 'linematch': 'def __init__(self):', 'context': 'from pathlib import Path\n\n\nclass LazyTracker:\n    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 9, 'coloffset': 4, 'linematch': 'def __init__(self):', 'context': 'from pathlib import Path\n\n\nclass LazyTracker:\n    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 10, 'coloffset': 8, 'linematch': '""""""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""', 'context': '\n\nclass LazyTracker:\n    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 11, 'coloffset': 8, 'linematch': 'self._hasher = hashlib.md5()', 'context': '\nclass LazyTracker:\n    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n\n        Args:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #120', 'line': 11, 'description': ['            input_dirs=[""input_dir""],'], 'failure': []}]",100.0
add_directories,13-27,"[{'lineno': 13, 'coloffset': 4, 'linematch': 'def add_directories(self, directories: List[str], chunk_num_blocks=128):', 'context': '    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n\n        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 13, 'coloffset': 4, 'linematch': 'def add_directories(self, directories: List[str], chunk_num_blocks=128):', 'context': '    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n\n        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 13, 'coloffset': 4, 'linematch': 'def add_directories(self, directories: List[str], chunk_num_blocks=128):', 'context': '    def __init__(self):\n        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n\n        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 14, 'coloffset': 8, 'linematch': '""""""Include hash of all files inside directory (including files in subdirectories)', 'context': '        """"""LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.""""""\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        """"""Include hash of all files inside directory (including files in subdirectories)\n\n        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 20, 'coloffset': 8, 'linematch': 'files_to_check = []', 'context': '        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""\n        files_to_check = []\n\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(""*"")))\n\n        files_to_check = sorted(files_to_check)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 22, 'coloffset': 8, 'linematch': 'for directory in directories:', 'context': '            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""\n        files_to_check = []\n\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(""*"")))\n\n        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 25, 'coloffset': 8, 'linematch': 'files_to_check = sorted(files_to_check)', 'context': '\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(""*"")))\n\n        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 27, 'coloffset': 8, 'linematch': 'self.add_files(files_to_check, chunk_num_blocks)', 'context': '            files_to_check.extend(list(Path(directory).rglob(""*"")))\n\n        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files\n\n        Args:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #122', 'line': 13, 'description': ['        )'], 'failure': []}, {'name': 'Mutant #123', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #124', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #125', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #126', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #127', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #128', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #129', 'line': 25, 'description': ['                f.write(""test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -22,7 +22,7 @@\n \n         with TemporaryDirectory() as input_dir:\n             with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                f.write(""test_file"")\n+                f.write(""XXtest_fileXX"")\n \n             with TemporaryDirectory() as output_dir:\n                 assert test_function(\n', 'type': 'failure', 'message': 'bad_survived'}]}]",87.5
add_files,29-42,"[{'lineno': 29, 'coloffset': 4, 'linematch': 'def add_files(self, filepaths: List[str], chunk_num_blocks=128):', 'context': '        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files\n\n        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 29, 'coloffset': 4, 'linematch': 'def add_files(self, filepaths: List[str], chunk_num_blocks=128):', 'context': '        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files\n\n        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 37, 'coloffset': 12, 'linematch': 'if os.path.exists(p):', 'context': '            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, ""rb"") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:\n                self._hasher.update(dill.dumps(None))', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 29, 'coloffset': 4, 'linematch': 'def add_files(self, filepaths: List[str], chunk_num_blocks=128):', 'context': '        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files\n\n        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 30, 'coloffset': 8, 'linematch': '""""""Include hash of files', 'context': '\n        self.add_files(files_to_check, chunk_num_blocks)\n\n    def add_files(self, filepaths: List[str], chunk_num_blocks=128):\n        """"""Include hash of files\n\n        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 36, 'coloffset': 8, 'linematch': 'for p in filepaths:', 'context': '        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        """"""\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, ""rb"") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #130', 'line': 31, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #131', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #132', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #133', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #134', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #135', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #136', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #137', 'line': 40, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #138', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #139', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #140', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #141', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}]",100.0
add_hparams,44-50,"[{'lineno': 44, 'coloffset': 4, 'linematch': 'def add_hparams(self, hparams: dict):', 'context': '                        self._hasher.update(chunk)\n            else:\n                self._hasher.update(dill.dumps(None))\n\n    def add_hparams(self, hparams: dict):\n        """"""Add hash of python dictionary. Utility function for storing pickable\n\n        Args:\n            hparams (dict): A dictionary to be included\n        """"""', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 44, 'coloffset': 4, 'linematch': 'def add_hparams(self, hparams: dict):', 'context': '                        self._hasher.update(chunk)\n            else:\n                self._hasher.update(dill.dumps(None))\n\n    def add_hparams(self, hparams: dict):\n        """"""Add hash of python dictionary. Utility function for storing pickable\n\n        Args:\n            hparams (dict): A dictionary to be included\n        """"""', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 44, 'coloffset': 4, 'linematch': 'def add_hparams(self, hparams: dict):', 'context': '                        self._hasher.update(chunk)\n            else:\n                self._hasher.update(dill.dumps(None))\n\n    def add_hparams(self, hparams: dict):\n        """"""Add hash of python dictionary. Utility function for storing pickable\n\n        Args:\n            hparams (dict): A dictionary to be included\n        """"""', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 45, 'coloffset': 8, 'linematch': '""""""Add hash of python dictionary. Utility function for storing pickable', 'context': '            else:\n                self._hasher.update(dill.dumps(None))\n\n    def add_hparams(self, hparams: dict):\n        """"""Add hash of python dictionary. Utility function for storing pickable\n\n        Args:\n            hparams (dict): A dictionary to be included\n        """"""\n        self.add_picklables([hparams])', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 50, 'coloffset': 8, 'linematch': 'self.add_picklables([hparams])', 'context': '\n        Args:\n            hparams (dict): A dictionary to be included\n        """"""\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        """"""Include hash of any picklable python objects (pickable by dill)\n\n        Args:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #142', 'line': 48, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #143', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #144', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #145', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #146', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}]",100.0
add_picklables,52-61,"[{'lineno': 52, 'coloffset': 4, 'linematch': 'def add_picklables(self, objects: List[Any], recursive: bool=False):', 'context': '            hparams (dict): A dictionary to be included\n        """"""\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        """"""Include hash of any picklable python objects (pickable by dill)\n\n        Args:\n            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if ', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 52, 'coloffset': 4, 'linematch': 'def add_picklables(self, objects: List[Any], recursive: bool=False):', 'context': '            hparams (dict): A dictionary to be included\n        """"""\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        """"""Include hash of any picklable python objects (pickable by dill)\n\n        Args:\n            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if ', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 52, 'coloffset': 4, 'linematch': 'def add_picklables(self, objects: List[Any], recursive: bool=False):', 'context': '            hparams (dict): A dictionary to be included\n        """"""\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        """"""Include hash of any picklable python objects (pickable by dill)\n\n        Args:\n            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if ', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 53, 'coloffset': 8, 'linematch': '""""""Include hash of any picklable python objects (pickable by dill)', 'context': '        """"""\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        """"""Include hash of any picklable python objects (pickable by dill)\n\n        Args:\n            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if \n                recursive is set to true the changes in inner function are also tracked', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 60, 'coloffset': 8, 'linematch': 'for obj in objects:', 'context': '            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if \n                recursive is set to true the changes in inner function are also tracked\n        """"""\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        """"""Compute hash\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #147', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = True\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #148', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = None\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #149', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #150', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #151', 'line': 55, 'description': ['                    f.write(""changed_test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -52,7 +52,7 @@\n                 # Change input dependency\n                 updated = False\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                    f.write(""changed_test_file"")\n+                    f.write(""XXchanged_test_fileXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #152', 'line': 60, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #153', 'line': 61, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #154', 'line': 61, 'description': ['                ) == 5'], 'failure': []}]",62.5
hash,63-70,"[{'lineno': 63, 'coloffset': 4, 'linematch': 'def hash(self) -> str:', 'context': '        """"""\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        """"""Compute hash\n\n        Returns:\n            str: Computed checksum of all things tracked\n        """"""', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 63, 'coloffset': 4, 'linematch': 'def hash(self) -> str:', 'context': '        """"""\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        """"""Compute hash\n\n        Returns:\n            str: Computed checksum of all things tracked\n        """"""', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 63, 'coloffset': 4, 'linematch': 'def hash(self) -> str:', 'context': '        """"""\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        """"""Compute hash\n\n        Returns:\n            str: Computed checksum of all things tracked\n        """"""', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 64, 'coloffset': 8, 'linematch': '""""""Compute hash', 'context': '        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        """"""Compute hash\n\n        Returns:\n            str: Computed checksum of all things tracked\n        """"""\n', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 70, 'coloffset': 8, 'linematch': 'return self._hasher.hexdigest()', 'context': '        Returns:\n            str: Computed checksum of all things tracked\n        """"""\n\n        return self._hasher.hexdigest()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #157', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #158', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #159', 'line': 66, 'description': ['                    f.write(""corrupted output"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -63,7 +63,7 @@\n \n                 # Corrupt output\n                 with open(f""{output_dir}/test.txt"", \'w\') as f:\n-                    f.write(""corrupted output"")\n+                    f.write(""XXcorrupted outputXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}]",66.66666666666666
cached,14-91,"[{'lineno': 14, 'coloffset': 0, 'linematch': 'def cached(', 'context': 'shelve.Pickler = Pickler\nshelve.Unpickler = Unpickler\n\n\ndef cached(\n    cache_dir: str = "".lazytracker"",\n    input_files: Optional[List[str]] = None,\n    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 33, 'coloffset': 8, 'linematch': 'def wrapper(*args, **kwargs):', 'context': '    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()', 'pattern': './/FunctionDef', 'check_id': 'F001', 'check_name': 'all-function-definition'}, {'lineno': 14, 'coloffset': 0, 'linematch': 'def cached(', 'context': 'shelve.Pickler = Pickler\nshelve.Unpickler = Unpickler\n\n\ndef cached(\n    cache_dir: str = "".lazytracker"",\n    input_files: Optional[List[str]] = None,\n    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 33, 'coloffset': 8, 'linematch': 'def wrapper(*args, **kwargs):', 'context': '    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()', 'pattern': './/FunctionDef[not(contains(@name, ""test_""))]', 'check_id': 'F002', 'check_name': 'dummy-test-non-test-function-definition'}, {'lineno': 41, 'coloffset': 16, 'linematch': 'if input_dirs is not None:', 'context': '            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)\n                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]\n                    input_tracker.add_directories(input_dirs_values)\n                if input_files is not None:\n                    input_files_values = [\n                        kwargs[input_file] for input_file in input_files', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 44, 'coloffset': 16, 'linematch': 'if input_files is not None:', 'context': '                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]\n                    input_tracker.add_directories(input_dirs_values)\n                if input_files is not None:\n                    input_files_values = [\n                        kwargs[input_file] for input_file in input_files\n                    ]\n                    input_tracker.add_files(input_files_values)\n', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 51, 'coloffset': 16, 'linematch': 'if output_dirs is not None:', 'context': '                    ]\n                    input_tracker.add_files(input_files_values)\n\n                test_output_tracker = LazyTracker()\n                if output_dirs is not None:\n                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 56, 'coloffset': 16, 'linematch': 'if output_files is not None:', 'context': '                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:\n                    output_files_values = [\n                        kwargs[output_file] for output_file in output_files\n                    ]\n                    test_output_tracker.add_files(output_files_values)\n', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 65, 'coloffset': 16, 'linematch': 'if input_hash in db and db[input_hash][""hash""] == output_hash:', 'context': '\n                input_hash = input_tracker.hash()\n                output_hash = test_output_tracker.hash()\n\n                if input_hash in db and db[input_hash][""hash""] == output_hash:\n                    return db[input_hash][""return_value""]\n                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 71, 'coloffset': 20, 'linematch': 'if output_dirs is not None:', 'context': '                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()\n                    if output_dirs is not None:\n                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 76, 'coloffset': 20, 'linematch': 'if output_files is not None:', 'context': '                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:\n                        output_files_values = [\n                            kwargs[output_file] for output_file in output_files\n                        ]\n                        output_tracker.add_files(output_files_values)\n', 'pattern': './/FunctionDef/body//If', 'check_id': 'CL001', 'check_name': 'dummy-test-single-nested-if'}, {'lineno': 65, 'coloffset': 40, 'linematch': 'if input_hash in db and db[input_hash][""hash""] == output_hash:', 'context': '\n                input_hash = input_tracker.hash()\n                output_hash = test_output_tracker.hash()\n\n                if input_hash in db and db[input_hash][""hash""] == output_hash:\n                    return db[input_hash][""return_value""]\n                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()', 'pattern': '//Compare/ops/Is | //Compare/ops/Eq', 'check_id': 'BOOL001', 'check_name': 'boolean-comparison'}, {'lineno': 14, 'coloffset': 0, 'linematch': 'def cached(', 'context': 'shelve.Pickler = Pickler\nshelve.Unpickler = Unpickler\n\n\ndef cached(\n    cache_dir: str = "".lazytracker"",\n    input_files: Optional[List[str]] = None,\n    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 33, 'coloffset': 8, 'linematch': 'def wrapper(*args, **kwargs):', 'context': '    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()', 'pattern': '//FunctionDef[not(args/arg/annotation) or not(returns)]', 'check_id': 'ANNOT001', 'check_name': 'missing-annotations'}, {'lineno': 14, 'coloffset': 0, 'linematch': 'def cached(', 'context': 'shelve.Pickler = Pickler\nshelve.Unpickler = Unpickler\n\n\ndef cached(\n    cache_dir: str = "".lazytracker"",\n    input_files: Optional[List[str]] = None,\n    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,', 'pattern': '//FunctionDef[body//comprehension/target/Name]', 'check_id': 'FLV001', 'check_name': 'Function uses loop variable'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': '//FunctionDef[body//comprehension/target/Name]', 'check_id': 'FLV001', 'check_name': 'Function uses loop variable'}, {'lineno': 33, 'coloffset': 8, 'linematch': 'def wrapper(*args, **kwargs):', 'context': '    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()', 'pattern': '//FunctionDef[body//comprehension/target/Name]', 'check_id': 'FLV001', 'check_name': 'Function uses loop variable'}, {'lineno': 14, 'coloffset': 0, 'linematch': 'def cached(', 'context': 'shelve.Pickler = Pickler\nshelve.Unpickler = Unpickler\n\n\ndef cached(\n    cache_dir: str = "".lazytracker"",\n    input_files: Optional[List[str]] = None,\n    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,', 'pattern': '//FunctionDef//FunctionDef/ancestor::*', 'check_id': 'F001', 'check_name': 'Nested Depth (Set value)'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': '//FunctionDef//FunctionDef/ancestor::*', 'check_id': 'F001', 'check_name': 'Nested Depth (Set value)'}, {'lineno': 44, 'coloffset': 16, 'linematch': 'if input_files is not None:', 'context': '                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]\n                    input_tracker.add_directories(input_dirs_values)\n                if input_files is not None:\n                    input_files_values = [\n                        kwargs[input_file] for input_file in input_files\n                    ]\n                    input_tracker.add_files(input_files_values)\n', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 51, 'coloffset': 16, 'linematch': 'if output_dirs is not None:', 'context': '                    ]\n                    input_tracker.add_files(input_files_values)\n\n                test_output_tracker = LazyTracker()\n                if output_dirs is not None:\n                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 56, 'coloffset': 16, 'linematch': 'if output_files is not None:', 'context': '                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:\n                    output_files_values = [\n                        kwargs[output_file] for output_file in output_files\n                    ]\n                    test_output_tracker.add_files(output_files_values)\n', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 65, 'coloffset': 16, 'linematch': 'if input_hash in db and db[input_hash][""hash""] == output_hash:', 'context': '\n                input_hash = input_tracker.hash()\n                output_hash = test_output_tracker.hash()\n\n                if input_hash in db and db[input_hash][""hash""] == output_hash:\n                    return db[input_hash][""return_value""]\n                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 76, 'coloffset': 20, 'linematch': 'if output_files is not None:', 'context': '                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:\n                        output_files_values = [\n                            kwargs[output_file] for output_file in output_files\n                        ]\n                        output_tracker.add_files(output_files_values)\n', 'pattern': '//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else', 'check_id': 'F002', 'check_name': 'Number of conditions (if, if-else, and switch) in a Function'}, {'lineno': 71, 'coloffset': 20, 'linematch': 'if output_dirs is not None:', 'context': '                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()\n                    if output_dirs is not None:\n                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 76, 'coloffset': 20, 'linematch': 'if output_files is not None:', 'context': '                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:\n                        output_files_values = [\n                            kwargs[output_file] for output_file in output_files\n                        ]\n                        output_tracker.add_files(output_files_values)\n', 'pattern': '//FunctionDef//If/descendant::If', 'check_id': 'CL001', 'check_name': 'The number of nested conditions (e.g., if{if{}}) in a Function'}, {'lineno': 21, 'coloffset': 4, 'linematch': '""""""Function decorator for caching execution', 'context': '    input_dirs: Optional[List[str]] = None,\n    output_dirs: Optional[List[str]] = None,\n    output_files: Optional[List[str]] = None,\n):\n    """"""Function decorator for caching execution\n\n    Args:\n        cache_dir (str, optional): Directory where the lazytracker cache information will be stored. Defaults to "".lazytracker"".\n        input_files (Optional[List[str]], optional): name of function parameters, that are paths to input files. Defaults to None.\n        input_dirs (Optional[List[str]], optional): name of function parameters, that are paths to directories with input files. Defaults to None.', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 31, 'coloffset': 4, 'linematch': 'def inner_func(function: Callable):', 'context': '        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 33, 'coloffset': 8, 'linematch': 'def wrapper(*args, **kwargs):', 'context': '    """"""\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 34, 'coloffset': 12, 'linematch': 'kwargs.update(dict(zip(function.__code__.co_varnames, args)))', 'context': '\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 36, 'coloffset': 12, 'linematch': 'os.makedirs(f""{cache_dir}"", exist_ok=True)', 'context': '        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)\n                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 37, 'coloffset': 12, 'linematch': 'with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:', 'context': '        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f""{cache_dir}"", exist_ok=True)\n            with shelve.open(f""{cache_dir}/tracked_functions"", ""c"") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)\n                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 89, 'coloffset': 8, 'linematch': 'return wrapper', 'context': '                    }\n\n                    return return_value\n\n        return wrapper\n\n    return inner_func', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}, {'lineno': 91, 'coloffset': 4, 'linematch': 'return inner_func', 'context': '                    return return_value\n\n        return wrapper\n\n    return inner_func', 'pattern': ""//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return"", 'check_id': 'CML001', 'check_name': 'count-method-lines'}]","[{'name': 'Mutant #123', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #124', 'line': 17, 'description': ['            with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #125', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #126', 'line': 20, 'description': ['            updated = True'], 'failure': []}, {'name': 'Mutant #127', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #128', 'line': 24, 'description': ['            with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #129', 'line': 25, 'description': ['                f.write(""test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -22,7 +22,7 @@\n \n         with TemporaryDirectory() as input_dir:\n             with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                f.write(""test_file"")\n+                f.write(""XXtest_fileXX"")\n \n             with TemporaryDirectory() as output_dir:\n                 assert test_function(\n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #130', 'line': 31, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #131', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #132', 'line': 32, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #133', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #134', 'line': 33, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #135', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #136', 'line': 36, 'description': ['                updated = False'], 'failure': []}, {'name': 'Mutant #137', 'line': 40, 'description': ['                    parameter=3'], 'failure': []}, {'name': 'Mutant #138', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #139', 'line': 41, 'description': ['                ) == 3'], 'failure': []}, {'name': 'Mutant #140', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #141', 'line': 42, 'description': ['                assert updated == False'], 'failure': []}, {'name': 'Mutant #142', 'line': 48, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #143', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #144', 'line': 49, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #145', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #146', 'line': 50, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #147', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = True\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #148', 'line': 53, 'description': ['                updated = False'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -50,7 +50,7 @@\n                 assert updated == True\n \n                 # Change input dependency\n-                updated = False\n+                updated = None\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n                     f.write(""changed_test_file"")\n \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #149', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #150', 'line': 54, 'description': ['                with open(f""{input_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #151', 'line': 55, 'description': ['                    f.write(""changed_test_file"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -52,7 +52,7 @@\n                 # Change input dependency\n                 updated = False\n                 with open(f""{input_dir}/test.txt"", \'w\') as f:\n-                    f.write(""changed_test_file"")\n+                    f.write(""XXchanged_test_fileXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #152', 'line': 60, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #153', 'line': 61, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #154', 'line': 61, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #155', 'line': 62, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #156', 'line': 62, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #157', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #158', 'line': 65, 'description': ['                with open(f""{output_dir}/test.txt"", \'w\') as f:'], 'failure': []}, {'name': 'Mutant #159', 'line': 66, 'description': ['                    f.write(""corrupted output"")'], 'failure': [{'inner': '--- tests/test_tracked.py\n+++ tests/test_tracked.py\n@@ -63,7 +63,7 @@\n \n                 # Corrupt output\n                 with open(f""{output_dir}/test.txt"", \'w\') as f:\n-                    f.write(""corrupted output"")\n+                    f.write(""XXcorrupted outputXX"")\n \n                 assert test_function(\n                     input_dir=input_dir, \n', 'type': 'failure', 'message': 'bad_survived'}]}, {'name': 'Mutant #160', 'line': 71, 'description': ['                    parameter=5'], 'failure': []}, {'name': 'Mutant #161', 'line': 72, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #162', 'line': 72, 'description': ['                ) == 5'], 'failure': []}, {'name': 'Mutant #163', 'line': 73, 'description': ['                assert updated == True'], 'failure': []}, {'name': 'Mutant #164', 'line': 73, 'description': ['                assert updated == True'], 'failure': []}]",88.09523809523809
