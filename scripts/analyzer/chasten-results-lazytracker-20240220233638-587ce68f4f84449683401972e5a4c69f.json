{
  "configuration": {
    "chastenversion": "1.0.0",
    "debuglevel": "ERROR",
    "debugdestination": "CONSOLE",
    "projectname": "lazytracker",
    "configdirectory": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\chasten-configuration",
    "searchpath": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker",
    "fileuuid": "587ce68f4f84449683401972e5a4c69f",
    "datetime": "2024-02-20 23:36:38.977292",
    "checkinclude": {
      "attribute": "",
      "value": "",
      "confidence": 0
    },
    "checkexclude": {
      "attribute": "",
      "value": "",
      "confidence": 0
    }
  },
  "sources": [
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\lazytracker.py",
      "check": {
        "id": "CLS001",
        "name": "class-definition",
        "description": "First line of a class definition",
        "min": null,
        "max": null,
        "pattern": ".//ClassDef",
        "passed": true,
        "matches": [
          {
            "lineno": 8,
            "coloffset": 0,
            "linematch": "class LazyTracker:",
            "linematch_context": "import dill\nfrom pathlib import Path\n\n\nclass LazyTracker:\n    def __init__(self):\n        \"\"\"LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.\"\"\"\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\lazytracker.py",
      "check": {
        "id": "FUNC001",
        "name": "all-function-definition",
        "description": "First executable line of a function, skipping over docstrings and/or comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef/body/Expr[value/Constant]/following-sibling::*[1] | //FunctionDef/body[not(Expr/value/Constant)]/*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 11,
            "coloffset": 8,
            "linematch": "self._hasher = hashlib.md5()",
            "linematch_context": "\nclass LazyTracker:\n    def __init__(self):\n        \"\"\"LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.\"\"\"\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        \"\"\"Include hash of all files inside directory (including files in subdirectories)\n\n        Args:"
          },
          {
            "lineno": 20,
            "coloffset": 8,
            "linematch": "files_to_check = []",
            "linematch_context": "        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        files_to_check = []\n\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(\"*\")))\n\n        files_to_check = sorted(files_to_check)"
          },
          {
            "lineno": 36,
            "coloffset": 8,
            "linematch": "for p in filepaths:",
            "linematch_context": "        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, \"rb\") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:"
          },
          {
            "lineno": 50,
            "coloffset": 8,
            "linematch": "self.add_picklables([hparams])",
            "linematch_context": "\n        Args:\n            hparams (dict): A dictionary to be included\n        \"\"\"\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        \"\"\"Include hash of any picklable python objects (pickable by dill)\n\n        Args:"
          },
          {
            "lineno": 60,
            "coloffset": 8,
            "linematch": "for obj in objects:",
            "linematch_context": "            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if \n                recursive is set to true the changes in inner function are also tracked\n        \"\"\"\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        \"\"\"Compute hash\n"
          },
          {
            "lineno": 70,
            "coloffset": 8,
            "linematch": "return self._hasher.hexdigest()",
            "linematch_context": "        Returns:\n            str: Computed checksum of all things tracked\n        \"\"\"\n\n        return self._hasher.hexdigest()"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\tracked.py",
      "check": {
        "id": "FUNC001",
        "name": "all-function-definition",
        "description": "First executable line of a function, skipping over docstrings and/or comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef/body/Expr[value/Constant]/following-sibling::*[1] | //FunctionDef/body[not(Expr/value/Constant)]/*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 31,
            "coloffset": 4,
            "linematch": "def inner_func(function: Callable):",
            "linematch_context": "        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    \"\"\"\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f\"{cache_dir}\", exist_ok=True)"
          },
          {
            "lineno": 33,
            "coloffset": 8,
            "linematch": "def wrapper(*args, **kwargs):",
            "linematch_context": "    \"\"\"\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f\"{cache_dir}\", exist_ok=True)\n            with shelve.open(f\"{cache_dir}/tracked_functions\", \"c\") as db:\n                input_tracker = LazyTracker()"
          },
          {
            "lineno": 34,
            "coloffset": 12,
            "linematch": "kwargs.update(dict(zip(function.__code__.co_varnames, args)))",
            "linematch_context": "\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f\"{cache_dir}\", exist_ok=True)\n            with shelve.open(f\"{cache_dir}/tracked_functions\", \"c\") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\tests\\test_lazytracker.py",
      "check": {
        "id": "FUNC001",
        "name": "all-function-definition",
        "description": "First executable line of a function, skipping over docstrings and/or comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef/body/Expr[value/Constant]/following-sibling::*[1] | //FunctionDef/body[not(Expr/value/Constant)]/*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 7,
            "coloffset": 4,
            "linematch": "hparams_1 = {",
            "linematch_context": "from tempfile import TemporaryDirectory, tempdir\nfrom lazytracker import LazyTracker\n\ndef test_hparams():\n    hparams_1 = {\n        'a': 1,\n        'b': 2,\n        'c': {\n            'd': 1\n        }"
          },
          {
            "lineno": 36,
            "coloffset": 4,
            "linematch": "def func_1(x):",
            "linematch_context": "    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()"
          },
          {
            "lineno": 37,
            "coloffset": 8,
            "linematch": "return x+1",
            "linematch_context": "    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])"
          },
          {
            "lineno": 39,
            "coloffset": 8,
            "linematch": "return x+2",
            "linematch_context": "def test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()"
          },
          {
            "lineno": 54,
            "coloffset": 4,
            "linematch": "with TemporaryDirectory() as tmpdir:",
            "linematch_context": "    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f'{tmpdir}/a.txt', 'w') as f:\n            f.write(\"test file 1\")\n\n        with open(f'{tmpdir}/b.txt', 'w') as f:\n            f.write(\"test file 1\")"
          },
          {
            "lineno": 77,
            "coloffset": 4,
            "linematch": "with TemporaryDirectory() as tmpdir:",
            "linematch_context": "        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()\n\ndef test_directories():\n    with TemporaryDirectory() as tmpdir:\n        os.makedirs(f\"{tmpdir}/1\", exist_ok=True)\n\n        with open(f'{tmpdir}/1/a.txt', 'w') as f:\n            f.write(\"test file 1\")\n"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\tests\\test_tracked.py",
      "check": {
        "id": "FUNC001",
        "name": "all-function-definition",
        "description": "First executable line of a function, skipping over docstrings and/or comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef/body/Expr[value/Constant]/following-sibling::*[1] | //FunctionDef/body[not(Expr/value/Constant)]/*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 6,
            "coloffset": 4,
            "linematch": "with TemporaryDirectory() as cache_dir:",
            "linematch_context": "from lazytracker import cached\n\n\ndef test_cached():\n    with TemporaryDirectory() as cache_dir:\n        updated = False\n\n        @cached(\n            cache_dir=cache_dir,\n            input_dirs=[\"input_dir\"],"
          },
          {
            "lineno": 15,
            "coloffset": 12,
            "linematch": "nonlocal updated",
            "linematch_context": "            input_dirs=[\"input_dir\"],\n            output_dirs=[\"output_dir\"]\n        )\n        def test_function(input_dir: str, output_dir: str, parameter: int):\n            nonlocal updated\n\n            with open(f\"{output_dir}/test.txt\", 'w') as f:\n                f.write(str(parameter))\n\n            updated = True"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\lazytracker.py",
      "check": {
        "id": "FUNC002",
        "name": "all-function-definition-with-docstring",
        "description": "First executable line of a function with a docstring, skipping over docstrings and/or comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef/body/Expr[value/Constant]/following-sibling::*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 11,
            "coloffset": 8,
            "linematch": "self._hasher = hashlib.md5()",
            "linematch_context": "\nclass LazyTracker:\n    def __init__(self):\n        \"\"\"LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.\"\"\"\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        \"\"\"Include hash of all files inside directory (including files in subdirectories)\n\n        Args:"
          },
          {
            "lineno": 20,
            "coloffset": 8,
            "linematch": "files_to_check = []",
            "linematch_context": "        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        files_to_check = []\n\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(\"*\")))\n\n        files_to_check = sorted(files_to_check)"
          },
          {
            "lineno": 36,
            "coloffset": 8,
            "linematch": "for p in filepaths:",
            "linematch_context": "        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, \"rb\") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:"
          },
          {
            "lineno": 50,
            "coloffset": 8,
            "linematch": "self.add_picklables([hparams])",
            "linematch_context": "\n        Args:\n            hparams (dict): A dictionary to be included\n        \"\"\"\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        \"\"\"Include hash of any picklable python objects (pickable by dill)\n\n        Args:"
          },
          {
            "lineno": 60,
            "coloffset": 8,
            "linematch": "for obj in objects:",
            "linematch_context": "            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if \n                recursive is set to true the changes in inner function are also tracked\n        \"\"\"\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        \"\"\"Compute hash\n"
          },
          {
            "lineno": 70,
            "coloffset": 8,
            "linematch": "return self._hasher.hexdigest()",
            "linematch_context": "        Returns:\n            str: Computed checksum of all things tracked\n        \"\"\"\n\n        return self._hasher.hexdigest()"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\tracked.py",
      "check": {
        "id": "FUNC002",
        "name": "all-function-definition-with-docstring",
        "description": "First executable line of a function with a docstring, skipping over docstrings and/or comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef/body/Expr[value/Constant]/following-sibling::*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 31,
            "coloffset": 4,
            "linematch": "def inner_func(function: Callable):",
            "linematch_context": "        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    \"\"\"\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f\"{cache_dir}\", exist_ok=True)"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\tracked.py",
      "check": {
        "id": "FUNC003",
        "name": "all-function-definition-with-no-docstring",
        "description": "First executable line of a function without a docstring, skipping over comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef/body[not(Expr/value/Constant)]/*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 33,
            "coloffset": 8,
            "linematch": "def wrapper(*args, **kwargs):",
            "linematch_context": "    \"\"\"\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f\"{cache_dir}\", exist_ok=True)\n            with shelve.open(f\"{cache_dir}/tracked_functions\", \"c\") as db:\n                input_tracker = LazyTracker()"
          },
          {
            "lineno": 34,
            "coloffset": 12,
            "linematch": "kwargs.update(dict(zip(function.__code__.co_varnames, args)))",
            "linematch_context": "\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f\"{cache_dir}\", exist_ok=True)\n            with shelve.open(f\"{cache_dir}/tracked_functions\", \"c\") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\tests\\test_lazytracker.py",
      "check": {
        "id": "FUNC003",
        "name": "all-function-definition-with-no-docstring",
        "description": "First executable line of a function without a docstring, skipping over comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef/body[not(Expr/value/Constant)]/*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 7,
            "coloffset": 4,
            "linematch": "hparams_1 = {",
            "linematch_context": "from tempfile import TemporaryDirectory, tempdir\nfrom lazytracker import LazyTracker\n\ndef test_hparams():\n    hparams_1 = {\n        'a': 1,\n        'b': 2,\n        'c': {\n            'd': 1\n        }"
          },
          {
            "lineno": 36,
            "coloffset": 4,
            "linematch": "def func_1(x):",
            "linematch_context": "    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()"
          },
          {
            "lineno": 37,
            "coloffset": 8,
            "linematch": "return x+1",
            "linematch_context": "    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])"
          },
          {
            "lineno": 39,
            "coloffset": 8,
            "linematch": "return x+2",
            "linematch_context": "def test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()"
          },
          {
            "lineno": 54,
            "coloffset": 4,
            "linematch": "with TemporaryDirectory() as tmpdir:",
            "linematch_context": "    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f'{tmpdir}/a.txt', 'w') as f:\n            f.write(\"test file 1\")\n\n        with open(f'{tmpdir}/b.txt', 'w') as f:\n            f.write(\"test file 1\")"
          },
          {
            "lineno": 77,
            "coloffset": 4,
            "linematch": "with TemporaryDirectory() as tmpdir:",
            "linematch_context": "        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()\n\ndef test_directories():\n    with TemporaryDirectory() as tmpdir:\n        os.makedirs(f\"{tmpdir}/1\", exist_ok=True)\n\n        with open(f'{tmpdir}/1/a.txt', 'w') as f:\n            f.write(\"test file 1\")\n"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\tests\\test_tracked.py",
      "check": {
        "id": "FUNC003",
        "name": "all-function-definition-with-no-docstring",
        "description": "First executable line of a function without a docstring, skipping over comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef/body[not(Expr/value/Constant)]/*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 6,
            "coloffset": 4,
            "linematch": "with TemporaryDirectory() as cache_dir:",
            "linematch_context": "from lazytracker import cached\n\n\ndef test_cached():\n    with TemporaryDirectory() as cache_dir:\n        updated = False\n\n        @cached(\n            cache_dir=cache_dir,\n            input_dirs=[\"input_dir\"],"
          },
          {
            "lineno": 15,
            "coloffset": 12,
            "linematch": "nonlocal updated",
            "linematch_context": "            input_dirs=[\"input_dir\"],\n            output_dirs=[\"output_dir\"]\n        )\n        def test_function(input_dir: str, output_dir: str, parameter: int):\n            nonlocal updated\n\n            with open(f\"{output_dir}/test.txt\", 'w') as f:\n                f.write(str(parameter))\n\n            updated = True"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\lazytracker.py",
      "check": {
        "id": "FUNC004",
        "name": "all-non-test-function-definition",
        "description": "First executable line of a non-test function, skipping over docstrings and/or comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef[not(contains(@name, \"test_\"))]/body/Expr[value/Constant]/following-sibling::*[1] | //FunctionDef[not(contains(@name, \"test_\"))]/body[not(Expr/value/Constant)]/*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 11,
            "coloffset": 8,
            "linematch": "self._hasher = hashlib.md5()",
            "linematch_context": "\nclass LazyTracker:\n    def __init__(self):\n        \"\"\"LazyTracked enables you to compute combined hash of things like files, directories, python objects etc.\"\"\"\n        self._hasher = hashlib.md5()\n\n    def add_directories(self, directories: List[str], chunk_num_blocks=128):\n        \"\"\"Include hash of all files inside directory (including files in subdirectories)\n\n        Args:"
          },
          {
            "lineno": 20,
            "coloffset": 8,
            "linematch": "files_to_check = []",
            "linematch_context": "        Args:\n            directories (List[str]): List of directories to take files from\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        files_to_check = []\n\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(\"*\")))\n\n        files_to_check = sorted(files_to_check)"
          },
          {
            "lineno": 36,
            "coloffset": 8,
            "linematch": "for p in filepaths:",
            "linematch_context": "        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, \"rb\") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:"
          },
          {
            "lineno": 50,
            "coloffset": 8,
            "linematch": "self.add_picklables([hparams])",
            "linematch_context": "\n        Args:\n            hparams (dict): A dictionary to be included\n        \"\"\"\n        self.add_picklables([hparams])\n\n    def add_picklables(self, objects: List[Any], recursive: bool=False):\n        \"\"\"Include hash of any picklable python objects (pickable by dill)\n\n        Args:"
          },
          {
            "lineno": 60,
            "coloffset": 8,
            "linematch": "for obj in objects:",
            "linematch_context": "            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if \n                recursive is set to true the changes in inner function are also tracked\n        \"\"\"\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        \"\"\"Compute hash\n"
          },
          {
            "lineno": 70,
            "coloffset": 8,
            "linematch": "return self._hasher.hexdigest()",
            "linematch_context": "        Returns:\n            str: Computed checksum of all things tracked\n        \"\"\"\n\n        return self._hasher.hexdigest()"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\tracked.py",
      "check": {
        "id": "FUNC004",
        "name": "all-non-test-function-definition",
        "description": "First executable line of a non-test function, skipping over docstrings and/or comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef[not(contains(@name, \"test_\"))]/body/Expr[value/Constant]/following-sibling::*[1] | //FunctionDef[not(contains(@name, \"test_\"))]/body[not(Expr/value/Constant)]/*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 31,
            "coloffset": 4,
            "linematch": "def inner_func(function: Callable):",
            "linematch_context": "        output_dirs (Optional[List[str]], optional): name of function parameters, that are paths to otuput files. Defaults to None.\n        output_files (Optional[List[str]], optional): name of function parameters, that are paths to directories with output files. Defaults to None.\n    \"\"\"\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f\"{cache_dir}\", exist_ok=True)"
          },
          {
            "lineno": 33,
            "coloffset": 8,
            "linematch": "def wrapper(*args, **kwargs):",
            "linematch_context": "    \"\"\"\n\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f\"{cache_dir}\", exist_ok=True)\n            with shelve.open(f\"{cache_dir}/tracked_functions\", \"c\") as db:\n                input_tracker = LazyTracker()"
          },
          {
            "lineno": 34,
            "coloffset": 12,
            "linematch": "kwargs.update(dict(zip(function.__code__.co_varnames, args)))",
            "linematch_context": "\n    def inner_func(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            kwargs.update(dict(zip(function.__code__.co_varnames, args)))\n\n            os.makedirs(f\"{cache_dir}\", exist_ok=True)\n            with shelve.open(f\"{cache_dir}/tracked_functions\", \"c\") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\tests\\test_lazytracker.py",
      "check": {
        "id": "FUNC004",
        "name": "all-non-test-function-definition",
        "description": "First executable line of a non-test function, skipping over docstrings and/or comments",
        "min": null,
        "max": null,
        "pattern": "//FunctionDef[not(contains(@name, \"test_\"))]/body/Expr[value/Constant]/following-sibling::*[1] | //FunctionDef[not(contains(@name, \"test_\"))]/body[not(Expr/value/Constant)]/*[1]",
        "passed": true,
        "matches": [
          {
            "lineno": 37,
            "coloffset": 8,
            "linematch": "return x+1",
            "linematch_context": "    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])"
          },
          {
            "lineno": 39,
            "coloffset": 8,
            "linematch": "return x+2",
            "linematch_context": "def test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()\n    tracker_1.add_picklables([func_1])\n\n    tracker_2 = LazyTracker()"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\tests\\test_lazytracker.py",
      "check": {
        "id": "FUNC004",
        "name": "all-test-function-definition",
        "description": "First executable line of a test function, skipping over docstrings and/or comments",
        "min": 7,
        "max": 22,
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]/body/Expr[value/Constant]/following-sibling::*[1] | //AsyncFunctionDef[starts-with(@name, \"test_\")]/body/Expr[value/Constant]/following-sibling::*[1] | //FunctionDef[starts-with(@name, \"test_\")]/body[not(Expr/value/Constant)]/*[1] | //AsyncFunctionDef[starts-with(@name, \"test_\")]/body[not(Expr/value/Constant)]/*[1]",
        "passed": false,
        "matches": [
          {
            "lineno": 7,
            "coloffset": 4,
            "linematch": "hparams_1 = {",
            "linematch_context": "from tempfile import TemporaryDirectory, tempdir\nfrom lazytracker import LazyTracker\n\ndef test_hparams():\n    hparams_1 = {\n        'a': 1,\n        'b': 2,\n        'c': {\n            'd': 1\n        }"
          },
          {
            "lineno": 36,
            "coloffset": 4,
            "linematch": "def func_1(x):",
            "linematch_context": "    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_picable_function():\n    def func_1(x):\n        return x+1\n    def func_2(x):\n        return x+2\n\n    tracker_1 = LazyTracker()"
          },
          {
            "lineno": 54,
            "coloffset": 4,
            "linematch": "with TemporaryDirectory() as tmpdir:",
            "linematch_context": "    assert tracker_1.hash() == tracker_2.hash()\n    assert tracker_1.hash() != tracker_3.hash()\n\ndef test_files():\n    with TemporaryDirectory() as tmpdir:\n        with open(f'{tmpdir}/a.txt', 'w') as f:\n            f.write(\"test file 1\")\n\n        with open(f'{tmpdir}/b.txt', 'w') as f:\n            f.write(\"test file 1\")"
          },
          {
            "lineno": 77,
            "coloffset": 4,
            "linematch": "with TemporaryDirectory() as tmpdir:",
            "linematch_context": "        assert tracker_1.hash() == tracker_2.hash()\n        assert tracker_1.hash() != tracker_3.hash()\n\ndef test_directories():\n    with TemporaryDirectory() as tmpdir:\n        os.makedirs(f\"{tmpdir}/1\", exist_ok=True)\n\n        with open(f'{tmpdir}/1/a.txt', 'w') as f:\n            f.write(\"test file 1\")\n"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\tests\\test_tracked.py",
      "check": {
        "id": "FUNC004",
        "name": "all-test-function-definition",
        "description": "First executable line of a test function, skipping over docstrings and/or comments",
        "min": 7,
        "max": 22,
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]/body/Expr[value/Constant]/following-sibling::*[1] | //AsyncFunctionDef[starts-with(@name, \"test_\")]/body/Expr[value/Constant]/following-sibling::*[1] | //FunctionDef[starts-with(@name, \"test_\")]/body[not(Expr/value/Constant)]/*[1] | //AsyncFunctionDef[starts-with(@name, \"test_\")]/body[not(Expr/value/Constant)]/*[1]",
        "passed": false,
        "matches": [
          {
            "lineno": 6,
            "coloffset": 4,
            "linematch": "with TemporaryDirectory() as cache_dir:",
            "linematch_context": "from lazytracker import cached\n\n\ndef test_cached():\n    with TemporaryDirectory() as cache_dir:\n        updated = False\n\n        @cached(\n            cache_dir=cache_dir,\n            input_dirs=[\"input_dir\"],"
          },
          {
            "lineno": 15,
            "coloffset": 12,
            "linematch": "nonlocal updated",
            "linematch_context": "            input_dirs=[\"input_dir\"],\n            output_dirs=[\"output_dir\"]\n        )\n        def test_function(input_dir: str, output_dir: str, parameter: int):\n            nonlocal updated\n\n            with open(f\"{output_dir}/test.txt\", 'w') as f:\n                f.write(str(parameter))\n\n            updated = True"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\lazytracker.py",
      "check": {
        "id": "CTRL001",
        "name": "single-nested-if-in-function",
        "description": "First line of an if statement only when defined in a function",
        "min": null,
        "max": null,
        "pattern": ".//FunctionDef/body//If",
        "passed": true,
        "matches": [
          {
            "lineno": 37,
            "coloffset": 12,
            "linematch": "if os.path.exists(p):",
            "linematch_context": "            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, \"rb\") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:\n                self._hasher.update(dill.dumps(None))"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\tracked.py",
      "check": {
        "id": "CTRL001",
        "name": "single-nested-if-in-function",
        "description": "First line of an if statement only when defined in a function",
        "min": null,
        "max": null,
        "pattern": ".//FunctionDef/body//If",
        "passed": true,
        "matches": [
          {
            "lineno": 41,
            "coloffset": 16,
            "linematch": "if input_dirs is not None:",
            "linematch_context": "            with shelve.open(f\"{cache_dir}/tracked_functions\", \"c\") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)\n                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]\n                    input_tracker.add_directories(input_dirs_values)\n                if input_files is not None:\n                    input_files_values = [\n                        kwargs[input_file] for input_file in input_files"
          },
          {
            "lineno": 44,
            "coloffset": 16,
            "linematch": "if input_files is not None:",
            "linematch_context": "                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]\n                    input_tracker.add_directories(input_dirs_values)\n                if input_files is not None:\n                    input_files_values = [\n                        kwargs[input_file] for input_file in input_files\n                    ]\n                    input_tracker.add_files(input_files_values)\n"
          },
          {
            "lineno": 51,
            "coloffset": 16,
            "linematch": "if output_dirs is not None:",
            "linematch_context": "                    ]\n                    input_tracker.add_files(input_files_values)\n\n                test_output_tracker = LazyTracker()\n                if output_dirs is not None:\n                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:"
          },
          {
            "lineno": 56,
            "coloffset": 16,
            "linematch": "if output_files is not None:",
            "linematch_context": "                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:\n                    output_files_values = [\n                        kwargs[output_file] for output_file in output_files\n                    ]\n                    test_output_tracker.add_files(output_files_values)\n"
          },
          {
            "lineno": 65,
            "coloffset": 16,
            "linematch": "if input_hash in db and db[input_hash][\"hash\"] == output_hash:",
            "linematch_context": "\n                input_hash = input_tracker.hash()\n                output_hash = test_output_tracker.hash()\n\n                if input_hash in db and db[input_hash][\"hash\"] == output_hash:\n                    return db[input_hash][\"return_value\"]\n                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()"
          },
          {
            "lineno": 71,
            "coloffset": 20,
            "linematch": "if output_dirs is not None:",
            "linematch_context": "                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()\n                    if output_dirs is not None:\n                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:"
          },
          {
            "lineno": 76,
            "coloffset": 20,
            "linematch": "if output_files is not None:",
            "linematch_context": "                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:\n                        output_files_values = [\n                            kwargs[output_file] for output_file in output_files\n                        ]\n                        output_tracker.add_files(output_files_values)\n"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\lazytracker.py",
      "check": {
        "id": "CTRL002",
        "name": "single-nested-if-anywhere-in-module",
        "description": "First line of an if statement defined anywhere in a module",
        "min": null,
        "max": null,
        "pattern": ".//If",
        "passed": true,
        "matches": [
          {
            "lineno": 37,
            "coloffset": 12,
            "linematch": "if os.path.exists(p):",
            "linematch_context": "            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, \"rb\") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:\n                self._hasher.update(dill.dumps(None))"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\tracked.py",
      "check": {
        "id": "CTRL002",
        "name": "single-nested-if-anywhere-in-module",
        "description": "First line of an if statement defined anywhere in a module",
        "min": null,
        "max": null,
        "pattern": ".//If",
        "passed": true,
        "matches": [
          {
            "lineno": 41,
            "coloffset": 16,
            "linematch": "if input_dirs is not None:",
            "linematch_context": "            with shelve.open(f\"{cache_dir}/tracked_functions\", \"c\") as db:\n                input_tracker = LazyTracker()\n                input_tracker.add_picklables([function], recursive=True)\n                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]\n                    input_tracker.add_directories(input_dirs_values)\n                if input_files is not None:\n                    input_files_values = [\n                        kwargs[input_file] for input_file in input_files"
          },
          {
            "lineno": 44,
            "coloffset": 16,
            "linematch": "if input_files is not None:",
            "linematch_context": "                input_tracker.add_hparams(kwargs)\n                if input_dirs is not None:\n                    input_dirs_values = [kwargs[input_dir] for input_dir in input_dirs]\n                    input_tracker.add_directories(input_dirs_values)\n                if input_files is not None:\n                    input_files_values = [\n                        kwargs[input_file] for input_file in input_files\n                    ]\n                    input_tracker.add_files(input_files_values)\n"
          },
          {
            "lineno": 51,
            "coloffset": 16,
            "linematch": "if output_dirs is not None:",
            "linematch_context": "                    ]\n                    input_tracker.add_files(input_files_values)\n\n                test_output_tracker = LazyTracker()\n                if output_dirs is not None:\n                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:"
          },
          {
            "lineno": 56,
            "coloffset": 16,
            "linematch": "if output_files is not None:",
            "linematch_context": "                    output_dirs_values = [\n                        kwargs[output_dir] for output_dir in output_dirs\n                    ]\n                    test_output_tracker.add_directories(output_dirs_values)\n                if output_files is not None:\n                    output_files_values = [\n                        kwargs[output_file] for output_file in output_files\n                    ]\n                    test_output_tracker.add_files(output_files_values)\n"
          },
          {
            "lineno": 65,
            "coloffset": 16,
            "linematch": "if input_hash in db and db[input_hash][\"hash\"] == output_hash:",
            "linematch_context": "\n                input_hash = input_tracker.hash()\n                output_hash = test_output_tracker.hash()\n\n                if input_hash in db and db[input_hash][\"hash\"] == output_hash:\n                    return db[input_hash][\"return_value\"]\n                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()"
          },
          {
            "lineno": 71,
            "coloffset": 20,
            "linematch": "if output_dirs is not None:",
            "linematch_context": "                else:\n                    return_value = function(**kwargs)\n\n                    output_tracker = LazyTracker()\n                    if output_dirs is not None:\n                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:"
          },
          {
            "lineno": 76,
            "coloffset": 20,
            "linematch": "if output_files is not None:",
            "linematch_context": "                        output_dirs_values = [\n                            kwargs[output_dir] for output_dir in output_dirs\n                        ]\n                        output_tracker.add_directories(output_dirs_values)\n                    if output_files is not None:\n                        output_files_values = [\n                            kwargs[output_file] for output_file in output_files\n                        ]\n                        output_tracker.add_files(output_files_values)\n"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\lazytracker.py",
      "check": {
        "id": "CTRL005",
        "name": "single-nested-for-target",
        "description": "First line of a single-nested for statement defined anywhere in a module",
        "min": null,
        "max": null,
        "pattern": ".//For/target/Name",
        "passed": true,
        "matches": [
          {
            "lineno": 22,
            "coloffset": 12,
            "linematch": "for directory in directories:",
            "linematch_context": "            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        files_to_check = []\n\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(\"*\")))\n\n        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)"
          },
          {
            "lineno": 36,
            "coloffset": 12,
            "linematch": "for p in filepaths:",
            "linematch_context": "        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, \"rb\") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:"
          },
          {
            "lineno": 60,
            "coloffset": 12,
            "linematch": "for obj in objects:",
            "linematch_context": "            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if \n                recursive is set to true the changes in inner function are also tracked\n        \"\"\"\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        \"\"\"Compute hash\n"
          }
        ]
      }
    },
    {
      "filename": "C:\\Users\\Exalt\\cmpsci\\SEERS\\scripts\\lazytracker\\lazytracker\\lazytracker.py",
      "check": {
        "id": "CTRL006",
        "name": "single-nested-for-target-no-count",
        "description": "First line of a single-nested for statement defined anywhere in a module (no min or max)",
        "min": null,
        "max": null,
        "pattern": ".//For/target/Name",
        "passed": true,
        "matches": [
          {
            "lineno": 22,
            "coloffset": 12,
            "linematch": "for directory in directories:",
            "linematch_context": "            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        files_to_check = []\n\n        for directory in directories:\n            files_to_check.extend(list(Path(directory).rglob(\"*\")))\n\n        files_to_check = sorted(files_to_check)\n\n        self.add_files(files_to_check, chunk_num_blocks)"
          },
          {
            "lineno": 36,
            "coloffset": 12,
            "linematch": "for p in filepaths:",
            "linematch_context": "        Args:\n            filepaths (List[str]): List of paths to files\n            chunk_num_blocks (int, optional): How many chunks to read at once. Defaults to 128.\n        \"\"\"\n        for p in filepaths:\n            if os.path.exists(p):\n                with open(p, \"rb\") as f:\n                    while chunk := f.read(chunk_num_blocks * self._hasher.block_size):\n                        self._hasher.update(chunk)\n            else:"
          },
          {
            "lineno": 60,
            "coloffset": 12,
            "linematch": "for obj in objects:",
            "linematch_context": "            objects (List[Any]): List of python objects to hash\n            recursive (bool): Wheter to track dependencies of object. Eg.: if function calls another function, if \n                recursive is set to true the changes in inner function are also tracked\n        \"\"\"\n        for obj in objects:\n            self._hasher.update(dill.dumps(obj, recurse=recursive))\n\n    def hash(self) -> str:\n        \"\"\"Compute hash\n"
          }
        ]
      }
    }
  ]
}