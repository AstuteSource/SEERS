import { parseStringPromise, processors } from 'xml2js';
export const parse = async (xmlString, xml2jsOptions) => {
    const options = xml2jsOptions !== null && xml2jsOptions !== void 0 ? xml2jsOptions : {
        attrValueProcessors: [processors.parseNumbers]
    };
    const result = await parseStringPromise(xmlString, options);
    if (result === null)
        return null;
    if ('testsuites' in result) {
        return _parse(result['testsuites']);
    }
    else if ('testsuite' in result) {
        return _parse(result['testsuite']);
    }
};
const _parse = (objOrArray) => {
    if (Array.isArray(objOrArray)) {
        return objOrArray.map((_obj) => {
            // Do recursive call when _obj is nested array OR object that key is "$"
            if (Array.isArray(_obj) || typeof (_obj) === 'object') {
                return _parse(_obj);
            }
            // Return object that has only "inner" field when _obj is String
            return { inner: _obj };
        });
    }
    let output = {};
    Object.keys(objOrArray).forEach((key) => {
        var _a;
        const nested = objOrArray[key];
        if (key === '$') {
            output = { ...output, ..._parse(nested) };
        }
        else if (key === 'system-out' || key === 'system-err') {
            output[key] = nested.map((inner) => inner);
        }
        else if (key === 'properties') {
            output[key] = _parse(((_a = nested[0]) === null || _a === void 0 ? void 0 : _a.property) || []);
        }
        else if (typeof (nested) === 'object') {
            output[key] = _parse(nested);
        }
        else if (key === '_') {
            output['inner'] = nested;
        }
        else {
            output[key] = nested;
        }
    });
    return output;
};
//# sourceMappingURL=index.js.map