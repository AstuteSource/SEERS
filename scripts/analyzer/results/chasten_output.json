[
  {
    "function_name": "pre_mutation",
    "function_scope": "3-17",
    "patterns": [
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "if context.mutation_id.operator == \"delete\":",
        "context": "    \n    # Debugging: Print statement to ensure this function is executed\n    print(f\"Mutating: {context.mutation_id}\")\n    \n    if context.mutation_id.operator == \"delete\":\n        # Allow statement deletion mutations\n        return\n    elif any(op in context.source for op in arithmetic_operators):\n        # Allow arithmetic operator mutations\n        return",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 12,
        "coloffset": 4,
        "linematch": "elif any(op in context.source for op in arithmetic_operators):",
        "context": "    \n    if context.mutation_id.operator == \"delete\":\n        # Allow statement deletion mutations\n        return\n    elif any(op in context.source for op in arithmetic_operators):\n        # Allow arithmetic operator mutations\n        return\n    else:\n        # Skip all other mutations\n        context.skip = True",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 9,
        "coloffset": 7,
        "linematch": "if context.mutation_id.operator == \"delete\":",
        "context": "    \n    # Debugging: Print statement to ensure this function is executed\n    print(f\"Mutating: {context.mutation_id}\")\n    \n    if context.mutation_id.operator == \"delete\":\n        # Allow statement deletion mutations\n        return\n    elif any(op in context.source for op in arithmetic_operators):\n        # Allow arithmetic operator mutations\n        return",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 3,
        "coloffset": 0,
        "linematch": "def pre_mutation(context):",
        "context": "from mutmut import context\n\ndef pre_mutation(context):\n    arithmetic_operators = ['+', '-', '*', '/']\n    \n    # Debugging: Print statement to ensure this function is executed\n    print(f\"Mutating: {context.mutation_id}\")\n    ",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 3,
        "coloffset": 0,
        "linematch": "def pre_mutation(context):",
        "context": "from mutmut import context\n\ndef pre_mutation(context):\n    arithmetic_operators = ['+', '-', '*', '/']\n    \n    # Debugging: Print statement to ensure this function is executed\n    print(f\"Mutating: {context.mutation_id}\")\n    ",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 12,
        "coloffset": 4,
        "linematch": "elif any(op in context.source for op in arithmetic_operators):",
        "context": "    \n    if context.mutation_id.operator == \"delete\":\n        # Allow statement deletion mutations\n        return\n    elif any(op in context.source for op in arithmetic_operators):\n        # Allow arithmetic operator mutations\n        return\n    else:\n        # Skip all other mutations\n        context.skip = True",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 4,
        "coloffset": 4,
        "linematch": "arithmetic_operators = ['+', '-', '*', '/']",
        "context": "from mutmut import context\n\ndef pre_mutation(context):\n    arithmetic_operators = ['+', '-', '*', '/']\n    \n    # Debugging: Print statement to ensure this function is executed\n    print(f\"Mutating: {context.mutation_id}\")\n    \n    if context.mutation_id.operator == \"delete\":",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 7,
        "coloffset": 4,
        "linematch": "print(f\"Mutating: {context.mutation_id}\")",
        "context": "def pre_mutation(context):\n    arithmetic_operators = ['+', '-', '*', '/']\n    \n    # Debugging: Print statement to ensure this function is executed\n    print(f\"Mutating: {context.mutation_id}\")\n    \n    if context.mutation_id.operator == \"delete\":\n        # Allow statement deletion mutations\n        return\n    elif any(op in context.source for op in arithmetic_operators):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "if context.mutation_id.operator == \"delete\":",
        "context": "    \n    # Debugging: Print statement to ensure this function is executed\n    print(f\"Mutating: {context.mutation_id}\")\n    \n    if context.mutation_id.operator == \"delete\":\n        # Allow statement deletion mutations\n        return\n    elif any(op in context.source for op in arithmetic_operators):\n        # Allow arithmetic operator mutations\n        return",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1360",
        "line": 16,
        "description": [
          "logger: logging.Logger = logging.getLogger()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_fuzz_human_readable_boolean_correct_string",
    "function_scope": "27-33",
    "patterns": [
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the conversion to human-readable works.\"\"\"\n    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 33,
        "coloffset": 15,
        "linematch": "assert str_answer == \"No\"",
        "context": "    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"\n\n\n@given(url=provisional.urls())\n@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 33,
        "coloffset": 15,
        "linematch": "assert str_answer == \"No\"",
        "context": "    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"\n\n\n@given(url=provisional.urls())\n@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 33,
        "coloffset": 15,
        "linematch": "assert str_answer == \"No\"",
        "context": "    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"\n\n\n@given(url=provisional.urls())\n@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 33,
        "coloffset": 15,
        "linematch": "assert str_answer == \"No\"",
        "context": "    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"\n\n\n@given(url=provisional.urls())\n@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 27,
        "coloffset": 0,
        "linematch": "def test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:",
        "context": "\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the conversion to human-readable works.\"\"\"\n    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the conversion to human-readable works.\"\"\"",
        "context": "\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the conversion to human-readable works.\"\"\"\n    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "str_answer = util.get_human_readable_boolean(answer=answer)",
        "context": "@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the conversion to human-readable works.\"\"\"\n    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the conversion to human-readable works.\"\"\"\n    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the conversion to human-readable works.\"\"\"",
        "context": "\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the conversion to human-readable works.\"\"\"\n    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "str_answer = util.get_human_readable_boolean(answer=answer)",
        "context": "@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the conversion to human-readable works.\"\"\"\n    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the conversion to human-readable works.\"\"\"\n    str_answer = util.get_human_readable_boolean(answer=answer)\n    if answer:\n        assert str_answer == \"Yes\"\n    else:\n        assert str_answer == \"No\"\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_valid_api_key",
    "function_scope": "15-22",
    "patterns": [
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "if not valid_api_key:",
        "context": "@pytest.mark.api\ndef test_valid_api_key():\n    \"\"\"Test is_valid_api_key function with a valid api key.\"\"\"\n    valid_api_key = get_valid_api_key()\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 22,
        "coloffset": 11,
        "linematch": "assert result is True",
        "context": "    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True\n\n\n# @pytest.mark.api\n# def test_invalid_api_key():\n#     \"\"\"Test is_valid_api_key function with an invalid api key.\"\"\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 15,
        "coloffset": 0,
        "linematch": "def test_valid_api_key():",
        "context": "    return os.getenv(\"API_KEY\")\n\n\n@pytest.mark.api\ndef test_valid_api_key():\n    \"\"\"Test is_valid_api_key function with a valid api key.\"\"\"\n    valid_api_key = get_valid_api_key()\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True\n\n\n# @pytest.mark.api\n# def test_invalid_api_key():\n#     \"\"\"Test is_valid_api_key function with an invalid api key.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "\"\"\"Test is_valid_api_key function with a valid api key.\"\"\"",
        "context": "\n\n@pytest.mark.api\ndef test_valid_api_key():\n    \"\"\"Test is_valid_api_key function with a valid api key.\"\"\"\n    valid_api_key = get_valid_api_key()\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "valid_api_key = get_valid_api_key()",
        "context": "\n@pytest.mark.api\ndef test_valid_api_key():\n    \"\"\"Test is_valid_api_key function with a valid api key.\"\"\"\n    valid_api_key = get_valid_api_key()\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "if not valid_api_key:",
        "context": "@pytest.mark.api\ndef test_valid_api_key():\n    \"\"\"Test is_valid_api_key function with a valid api key.\"\"\"\n    valid_api_key = get_valid_api_key()\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "result = is_valid_api_key(valid_api_key)",
        "context": "    valid_api_key = get_valid_api_key()\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True\n\n\n# @pytest.mark.api\n# def test_invalid_api_key():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True\n\n\n# @pytest.mark.api\n# def test_invalid_api_key():\n#     \"\"\"Test is_valid_api_key function with an invalid api key.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "\"\"\"Test is_valid_api_key function with a valid api key.\"\"\"",
        "context": "\n\n@pytest.mark.api\ndef test_valid_api_key():\n    \"\"\"Test is_valid_api_key function with a valid api key.\"\"\"\n    valid_api_key = get_valid_api_key()\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "valid_api_key = get_valid_api_key()",
        "context": "\n@pytest.mark.api\ndef test_valid_api_key():\n    \"\"\"Test is_valid_api_key function with a valid api key.\"\"\"\n    valid_api_key = get_valid_api_key()\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "if not valid_api_key:",
        "context": "@pytest.mark.api\ndef test_valid_api_key():\n    \"\"\"Test is_valid_api_key function with a valid api key.\"\"\"\n    valid_api_key = get_valid_api_key()\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "result = is_valid_api_key(valid_api_key)",
        "context": "    valid_api_key = get_valid_api_key()\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True\n\n\n# @pytest.mark.api\n# def test_invalid_api_key():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    result = is_valid_api_key(valid_api_key)\n    assert result is True\n\n\n# @pytest.mark.api\n# def test_invalid_api_key():\n#     \"\"\"Test is_valid_api_key function with an invalid api key.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #299",
        "line": 19,
        "description": [
          "console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1360",
        "line": 16,
        "description": [
          "logger: logging.Logger = logging.getLogger()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_generate_yaml_config",
    "function_scope": "34-52",
    "patterns": [
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "if not valid_api_key:",
        "context": "    valid_api_key = get_valid_api_key()\n    test_genscript = \"Write: 'Hello, World'\"\n    file_path = \"test_checks.yml\"\n\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    file_path = Path(file_path)\n\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 34,
        "coloffset": 0,
        "linematch": "def test_generate_yaml_config():",
        "context": "#     assert result is False\n\n\n@pytest.mark.api\ndef test_generate_yaml_config():\n    valid_api_key = get_valid_api_key()\n    test_genscript = \"Write: 'Hello, World'\"\n    file_path = \"test_checks.yml\"\n\n    if not valid_api_key:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert result is not None",
        "context": "    file_path = Path(file_path)\n\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)\n\n    assert result is not None\n    assert file_path.is_file()\n\n    # Check the content of the generated file\n    with open(file_path, \"r\") as f:\n        content = f.read()",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "assert file_path.is_file()",
        "context": "\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)\n\n    assert result is not None\n    assert file_path.is_file()\n\n    # Check the content of the generated file\n    with open(file_path, \"r\") as f:\n        content = f.read()\n        assert \"Hello, World\" in content",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "valid_api_key = get_valid_api_key()",
        "context": "\n\n@pytest.mark.api\ndef test_generate_yaml_config():\n    valid_api_key = get_valid_api_key()\n    test_genscript = \"Write: 'Hello, World'\"\n    file_path = \"test_checks.yml\"\n\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "test_genscript = \"Write: 'Hello, World'\"",
        "context": "\n@pytest.mark.api\ndef test_generate_yaml_config():\n    valid_api_key = get_valid_api_key()\n    test_genscript = \"Write: 'Hello, World'\"\n    file_path = \"test_checks.yml\"\n\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "file_path = \"test_checks.yml\"",
        "context": "@pytest.mark.api\ndef test_generate_yaml_config():\n    valid_api_key = get_valid_api_key()\n    test_genscript = \"Write: 'Hello, World'\"\n    file_path = \"test_checks.yml\"\n\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    file_path = Path(file_path)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "if not valid_api_key:",
        "context": "    valid_api_key = get_valid_api_key()\n    test_genscript = \"Write: 'Hello, World'\"\n    file_path = \"test_checks.yml\"\n\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    file_path = Path(file_path)\n\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "file_path = Path(file_path)",
        "context": "\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    file_path = Path(file_path)\n\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)\n\n    assert result is not None\n    assert file_path.is_file()",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "result = generate_yaml_config(file_path, valid_api_key, test_genscript)",
        "context": "        pytest.skip(\"No valid API key found in the environment variables\")\n\n    file_path = Path(file_path)\n\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)\n\n    assert result is not None\n    assert file_path.is_file()\n\n    # Check the content of the generated file",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert result is not None",
        "context": "    file_path = Path(file_path)\n\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)\n\n    assert result is not None\n    assert file_path.is_file()\n\n    # Check the content of the generated file\n    with open(file_path, \"r\") as f:\n        content = f.read()",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "assert file_path.is_file()",
        "context": "\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)\n\n    assert result is not None\n    assert file_path.is_file()\n\n    # Check the content of the generated file\n    with open(file_path, \"r\") as f:\n        content = f.read()\n        assert \"Hello, World\" in content",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "with open(file_path, \"r\") as f:",
        "context": "    assert result is not None\n    assert file_path.is_file()\n\n    # Check the content of the generated file\n    with open(file_path, \"r\") as f:\n        content = f.read()\n        assert \"Hello, World\" in content",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "valid_api_key = get_valid_api_key()",
        "context": "\n\n@pytest.mark.api\ndef test_generate_yaml_config():\n    valid_api_key = get_valid_api_key()\n    test_genscript = \"Write: 'Hello, World'\"\n    file_path = \"test_checks.yml\"\n\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "test_genscript = \"Write: 'Hello, World'\"",
        "context": "\n@pytest.mark.api\ndef test_generate_yaml_config():\n    valid_api_key = get_valid_api_key()\n    test_genscript = \"Write: 'Hello, World'\"\n    file_path = \"test_checks.yml\"\n\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "file_path = \"test_checks.yml\"",
        "context": "@pytest.mark.api\ndef test_generate_yaml_config():\n    valid_api_key = get_valid_api_key()\n    test_genscript = \"Write: 'Hello, World'\"\n    file_path = \"test_checks.yml\"\n\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    file_path = Path(file_path)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "if not valid_api_key:",
        "context": "    valid_api_key = get_valid_api_key()\n    test_genscript = \"Write: 'Hello, World'\"\n    file_path = \"test_checks.yml\"\n\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    file_path = Path(file_path)\n\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "file_path = Path(file_path)",
        "context": "\n    if not valid_api_key:\n        pytest.skip(\"No valid API key found in the environment variables\")\n\n    file_path = Path(file_path)\n\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)\n\n    assert result is not None\n    assert file_path.is_file()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "result = generate_yaml_config(file_path, valid_api_key, test_genscript)",
        "context": "        pytest.skip(\"No valid API key found in the environment variables\")\n\n    file_path = Path(file_path)\n\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)\n\n    assert result is not None\n    assert file_path.is_file()\n\n    # Check the content of the generated file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert result is not None",
        "context": "    file_path = Path(file_path)\n\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)\n\n    assert result is not None\n    assert file_path.is_file()\n\n    # Check the content of the generated file\n    with open(file_path, \"r\") as f:\n        content = f.read()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "assert file_path.is_file()",
        "context": "\n    result = generate_yaml_config(file_path, valid_api_key, test_genscript)\n\n    assert result is not None\n    assert file_path.is_file()\n\n    # Check the content of the generated file\n    with open(file_path, \"r\") as f:\n        content = f.read()\n        assert \"Hello, World\" in content",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "with open(file_path, \"r\") as f:",
        "context": "    assert result is not None\n    assert file_path.is_file()\n\n    # Check the content of the generated file\n    with open(file_path, \"r\") as f:\n        content = f.read()\n        assert \"Hello, World\" in content",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_fuzz_create_directory_tree",
    "function_scope": "90-107",
    "patterns": [
      {
        "lineno": 101,
        "coloffset": 8,
        "linematch": "if \":open_file_folder:\" in node.label:  # type: ignore",
        "context": "    dirs = []\n    files = []\n    # build up a list of all of the directories and files\n    for node in tree.children:\n        if \":open_file_folder:\" in node.label:  # type: ignore\n            dirs.append(node.label[19:])  # type: ignore\n        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names\n    assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 90,
        "coloffset": 0,
        "linematch": "def test_fuzz_create_directory_tree(directory):",
        "context": "\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_create_directory_tree(directory):\n    \"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"\n    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 90,
        "coloffset": 0,
        "linematch": "def test_fuzz_create_directory_tree(directory):",
        "context": "\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_create_directory_tree(directory):\n    \"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"\n    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "assert isinstance(tree, Tree)",
        "context": "def test_fuzz_create_directory_tree(directory):\n    \"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"\n    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "assert tree.label == f\":open_file_folder: {directory.name}\"",
        "context": "    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files\n    for node in tree.children:\n        if \":open_file_folder:\" in node.label:  # type: ignore",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 106,
        "coloffset": 4,
        "linematch": "assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())",
        "context": "            dirs.append(node.label[19:])  # type: ignore\n        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names\n    assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())\n    assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 107,
        "coloffset": 4,
        "linematch": "assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())",
        "context": "        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names\n    assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())\n    assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 91,
        "coloffset": 4,
        "linematch": "\"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"",
        "context": "\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_create_directory_tree(directory):\n    \"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"\n    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 92,
        "coloffset": 4,
        "linematch": "tree = filesystem.create_directory_tree_visualization(directory)",
        "context": "@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_create_directory_tree(directory):\n    \"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"\n    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "assert isinstance(tree, Tree)",
        "context": "def test_fuzz_create_directory_tree(directory):\n    \"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"\n    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "assert tree.label == f\":open_file_folder: {directory.name}\"",
        "context": "    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files\n    for node in tree.children:\n        if \":open_file_folder:\" in node.label:  # type: ignore",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 97,
        "coloffset": 4,
        "linematch": "dirs = []",
        "context": "    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files\n    for node in tree.children:\n        if \":open_file_folder:\" in node.label:  # type: ignore\n            dirs.append(node.label[19:])  # type: ignore",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 98,
        "coloffset": 4,
        "linematch": "files = []",
        "context": "    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files\n    for node in tree.children:\n        if \":open_file_folder:\" in node.label:  # type: ignore\n            dirs.append(node.label[19:])  # type: ignore\n        else:",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 100,
        "coloffset": 4,
        "linematch": "for node in tree.children:",
        "context": "    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files\n    for node in tree.children:\n        if \":open_file_folder:\" in node.label:  # type: ignore\n            dirs.append(node.label[19:])  # type: ignore\n        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 106,
        "coloffset": 4,
        "linematch": "assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())",
        "context": "            dirs.append(node.label[19:])  # type: ignore\n        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names\n    assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())\n    assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 107,
        "coloffset": 4,
        "linematch": "assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())",
        "context": "        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names\n    assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())\n    assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 91,
        "coloffset": 4,
        "linematch": "\"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"",
        "context": "\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_create_directory_tree(directory):\n    \"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"\n    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 92,
        "coloffset": 4,
        "linematch": "tree = filesystem.create_directory_tree_visualization(directory)",
        "context": "@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_create_directory_tree(directory):\n    \"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"\n    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "assert isinstance(tree, Tree)",
        "context": "def test_fuzz_create_directory_tree(directory):\n    \"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"\n    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "assert tree.label == f\":open_file_folder: {directory.name}\"",
        "context": "    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files\n    for node in tree.children:\n        if \":open_file_folder:\" in node.label:  # type: ignore",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 97,
        "coloffset": 4,
        "linematch": "dirs = []",
        "context": "    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files\n    for node in tree.children:\n        if \":open_file_folder:\" in node.label:  # type: ignore\n            dirs.append(node.label[19:])  # type: ignore",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 98,
        "coloffset": 4,
        "linematch": "files = []",
        "context": "    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files\n    for node in tree.children:\n        if \":open_file_folder:\" in node.label:  # type: ignore\n            dirs.append(node.label[19:])  # type: ignore\n        else:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 100,
        "coloffset": 4,
        "linematch": "for node in tree.children:",
        "context": "    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files\n    for node in tree.children:\n        if \":open_file_folder:\" in node.label:  # type: ignore\n            dirs.append(node.label[19:])  # type: ignore\n        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 106,
        "coloffset": 4,
        "linematch": "assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())",
        "context": "            dirs.append(node.label[19:])  # type: ignore\n        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names\n    assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())\n    assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 107,
        "coloffset": 4,
        "linematch": "assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())",
        "context": "        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names\n    assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())\n    assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "assert isinstance(tree, Tree)",
        "context": "def test_fuzz_create_directory_tree(directory):\n    \"\"\"Using Hypothesis to confirm that the file system directory tree creation works.\"\"\"\n    tree = filesystem.create_directory_tree_visualization(directory)\n    # confirm that it is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm that it has the fully-qualified name as the main label\n    assert tree.label == f\":open_file_folder: {directory.name}\"\n    dirs = []\n    files = []\n    # build up a list of all of the directories and files",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 106,
        "coloffset": 4,
        "linematch": "assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())",
        "context": "            dirs.append(node.label[19:])  # type: ignore\n        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names\n    assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())\n    assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 107,
        "coloffset": 4,
        "linematch": "assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())",
        "context": "        else:\n            files.append(node.label[17:])  # type: ignore\n    # confirm that it contains all of the directory and file names\n    assert set(dirs) == set(p.name for p in directory.iterdir() if p.is_dir())\n    assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1365",
        "line": 95,
        "description": [
          "    console.print(\":sparkles: Finished running test suite for the specified program\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_filter_matches_only_int_matches",
    "function_scope": "51-57",
    "patterns": [
      {
        "lineno": 54,
        "coloffset": 4,
        "linematch": "if match_list == []:",
        "context": "@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 55,
        "coloffset": 15,
        "linematch": "assert filtered == []",
        "context": "def test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 55,
        "coloffset": 15,
        "linematch": "assert filtered == []",
        "context": "def test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 55,
        "coloffset": 15,
        "linematch": "assert filtered == []",
        "context": "def test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 55,
        "coloffset": 15,
        "linematch": "assert filtered == []",
        "context": "def test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 51,
        "coloffset": 0,
        "linematch": "def test_filter_matches_only_int_matches(match_list, data_type):",
        "context": "\n\n@given(match_list=st.lists(st.integers()), data_type=st.just(int))\n@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"",
        "context": "\n@given(match_list=st.lists(st.integers()), data_type=st.just(int))\n@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "filtered, _ = process.filter_matches(match_list, data_type)",
        "context": "@given(match_list=st.lists(st.integers()), data_type=st.just(int))\n@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 54,
        "coloffset": 4,
        "linematch": "if match_list == []:",
        "context": "@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"",
        "context": "\n@given(match_list=st.lists(st.integers()), data_type=st.just(int))\n@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "filtered, _ = process.filter_matches(match_list, data_type)",
        "context": "@given(match_list=st.lists(st.integers()), data_type=st.just(int))\n@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 54,
        "coloffset": 4,
        "linematch": "if match_list == []:",
        "context": "@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering works for integers.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    if match_list == []:\n        assert filtered == []\n    else:\n        assert filtered != []",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_check_match_count",
    "function_scope": "145-149",
    "patterns": [
      {
        "lineno": 148,
        "coloffset": 4,
        "linematch": "if is_in_closed_interval(count, min, max):",
        "context": "@pytest.mark.fuzz\ndef test_check_match_count(count, min, max):\n    \"\"\"Use Hypothesis to confirm that the count check works correctly.\"\"\"\n    confirmation = check_match_count(count, min, max)\n    if is_in_closed_interval(count, min, max):\n        assert confirmation",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 145,
        "coloffset": 0,
        "linematch": "def test_check_match_count(count, min, max):",
        "context": "    st.integers(min_value=0, max_value=25),\n    st.integers(min_value=0, max_value=25),\n)\n@pytest.mark.fuzz\ndef test_check_match_count(count, min, max):\n    \"\"\"Use Hypothesis to confirm that the count check works correctly.\"\"\"\n    confirmation = check_match_count(count, min, max)\n    if is_in_closed_interval(count, min, max):\n        assert confirmation",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 146,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the count check works correctly.\"\"\"",
        "context": "    st.integers(min_value=0, max_value=25),\n)\n@pytest.mark.fuzz\ndef test_check_match_count(count, min, max):\n    \"\"\"Use Hypothesis to confirm that the count check works correctly.\"\"\"\n    confirmation = check_match_count(count, min, max)\n    if is_in_closed_interval(count, min, max):\n        assert confirmation",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 147,
        "coloffset": 4,
        "linematch": "confirmation = check_match_count(count, min, max)",
        "context": ")\n@pytest.mark.fuzz\ndef test_check_match_count(count, min, max):\n    \"\"\"Use Hypothesis to confirm that the count check works correctly.\"\"\"\n    confirmation = check_match_count(count, min, max)\n    if is_in_closed_interval(count, min, max):\n        assert confirmation",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 148,
        "coloffset": 4,
        "linematch": "if is_in_closed_interval(count, min, max):",
        "context": "@pytest.mark.fuzz\ndef test_check_match_count(count, min, max):\n    \"\"\"Use Hypothesis to confirm that the count check works correctly.\"\"\"\n    confirmation = check_match_count(count, min, max)\n    if is_in_closed_interval(count, min, max):\n        assert confirmation",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 146,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the count check works correctly.\"\"\"",
        "context": "    st.integers(min_value=0, max_value=25),\n)\n@pytest.mark.fuzz\ndef test_check_match_count(count, min, max):\n    \"\"\"Use Hypothesis to confirm that the count check works correctly.\"\"\"\n    confirmation = check_match_count(count, min, max)\n    if is_in_closed_interval(count, min, max):\n        assert confirmation",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 147,
        "coloffset": 4,
        "linematch": "confirmation = check_match_count(count, min, max)",
        "context": ")\n@pytest.mark.fuzz\ndef test_check_match_count(count, min, max):\n    \"\"\"Use Hypothesis to confirm that the count check works correctly.\"\"\"\n    confirmation = check_match_count(count, min, max)\n    if is_in_closed_interval(count, min, max):\n        assert confirmation",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 148,
        "coloffset": 4,
        "linematch": "if is_in_closed_interval(count, min, max):",
        "context": "@pytest.mark.fuzz\ndef test_check_match_count(count, min, max):\n    \"\"\"Use Hypothesis to confirm that the count check works correctly.\"\"\"\n    confirmation = check_match_count(count, min, max)\n    if is_in_closed_interval(count, min, max):\n        assert confirmation",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #306",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1374",
        "line": 148,
        "description": [
          "        console.print(f\"{small_bullet_unicode} Directory: {directory}\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1375",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_fuzz_distinct",
    "function_scope": "62-73",
    "patterns": [
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "if dir1 != dir2:",
        "context": "    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 73,
        "coloffset": 15,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 73,
        "coloffset": 15,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 73,
        "coloffset": 15,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 73,
        "coloffset": 15,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 73,
        "coloffset": 15,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 73,
        "coloffset": 15,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 73,
        "coloffset": 15,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 73,
        "coloffset": 15,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 73,
        "coloffset": 15,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 73,
        "coloffset": 15,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 62,
        "coloffset": 0,
        "linematch": "def test_fuzz_distinct(dir1, dir2, filename, extra):",
        "context": "    filename=strategies.text(),\n    extra=strategies.text(),\n)\n@pytest.mark.fuzz\ndef test_fuzz_distinct(dir1, dir2, filename, extra):\n    \"\"\"Use Hypothesis to confirm equality when the inputs names are the same.\"\"\"\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm equality when the inputs names are the same.\"\"\"",
        "context": "    extra=strategies.text(),\n)\n@pytest.mark.fuzz\ndef test_fuzz_distinct(dir1, dir2, filename, extra):\n    \"\"\"Use Hypothesis to confirm equality when the inputs names are the same.\"\"\"\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 64,
        "coloffset": 4,
        "linematch": "fs1 = constants.Filesystem(",
        "context": ")\n@pytest.mark.fuzz\ndef test_fuzz_distinct(dir1, dir2, filename, extra):\n    \"\"\"Use Hypothesis to confirm equality when the inputs names are the same.\"\"\"\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 67,
        "coloffset": 4,
        "linematch": "fs2 = constants.Filesystem(",
        "context": "    \"\"\"Use Hypothesis to confirm equality when the inputs names are the same.\"\"\"\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "if dir1 != dir2:",
        "context": "    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm equality when the inputs names are the same.\"\"\"",
        "context": "    extra=strategies.text(),\n)\n@pytest.mark.fuzz\ndef test_fuzz_distinct(dir1, dir2, filename, extra):\n    \"\"\"Use Hypothesis to confirm equality when the inputs names are the same.\"\"\"\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 64,
        "coloffset": 4,
        "linematch": "fs1 = constants.Filesystem(",
        "context": ")\n@pytest.mark.fuzz\ndef test_fuzz_distinct(dir1, dir2, filename, extra):\n    \"\"\"Use Hypothesis to confirm equality when the inputs names are the same.\"\"\"\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 67,
        "coloffset": 4,
        "linematch": "fs2 = constants.Filesystem(",
        "context": "    \"\"\"Use Hypothesis to confirm equality when the inputs names are the same.\"\"\"\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "if dir1 != dir2:",
        "context": "    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    if dir1 != dir2:\n        assert fs1 != fs2\n    else:\n        assert fs1 == fs2\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "validate_checks_file",
    "function_scope": "103-174",
    "patterns": [
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "if util.is_url(checks_file_name):",
        "context": "    \"\"\"Validate a checks file.\"\"\"\n    checks_file_validated = False\n    checks_file_invalidates_entire_config = False\n    # specified check file is URL\n    if util.is_url(checks_file_name):\n        # extract the configuration details\n        (\n            checks_file_extracted_valid,\n            configuration_file_yaml_str,\n            yaml_data_dict,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 157,
        "coloffset": 4,
        "linematch": "if not checks_file_extracted_valid:",
        "context": "        return (checks_file_validated, checks_file_invalidates_entire_config, {})\n    # the checks file could not be extracted in a valid\n    # fashion and thus there is no need to continue the\n    # validation of this file or any of the other check file\n    if not checks_file_extracted_valid:\n        checks_file_validated = False\n    # the checks file could be extract and thus the\n    # function should proceed to validate a checks configuration file\n    else:\n        # validate checks file",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 126,
        "coloffset": 4,
        "linematch": "elif chasten_user_config_url_str != \"\":",
        "context": "        checks_file_source = checks_file_name\n    # assume check file name is a file path\n    # will not support checks files being local paths\n    # if config file is a URL\n    elif chasten_user_config_url_str != \"\":\n        output.logger.error(\n            f\"\\nChecks file directive was a Path when config was a URL (given: '{checks_file_name}')\\n\"\n        )\n        checks_file_validated = False\n        checks_file_invalidates_entire_config = True",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 134,
        "coloffset": 4,
        "linematch": "elif (Path(chasten_user_config_dir_str) / Path(checks_file_name)).exists():",
        "context": "        checks_file_validated = False\n        checks_file_invalidates_entire_config = True\n        return (checks_file_validated, checks_file_invalidates_entire_config, {})\n    # checks file exists in local filesystem\n    elif (Path(chasten_user_config_dir_str) / Path(checks_file_name)).exists():\n        # extract the configuration details\n        (\n            checks_file_extracted_valid,\n            configuration_file_path_str,\n            configuration_file_yaml_str,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 103,
        "coloffset": 0,
        "linematch": "def validate_checks_file(",
        "context": "    output.opt_print_log(verbose, tree=rich_path_tree)\n    output.opt_print_log(verbose, empty=\"\")\n\n\ndef validate_checks_file(\n    verbose: bool,\n    checks_file_name: str,\n    chasten_user_config_url_str: str,\n    chasten_user_config_dir_str: str,\n    chasten_user_config_file_str: str,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 157,
        "coloffset": 4,
        "linematch": "if not checks_file_extracted_valid:",
        "context": "        return (checks_file_validated, checks_file_invalidates_entire_config, {})\n    # the checks file could not be extracted in a valid\n    # fashion and thus there is no need to continue the\n    # validation of this file or any of the other check file\n    if not checks_file_extracted_valid:\n        checks_file_validated = False\n    # the checks file could be extract and thus the\n    # function should proceed to validate a checks configuration file\n    else:\n        # validate checks file",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 126,
        "coloffset": 4,
        "linematch": "elif chasten_user_config_url_str != \"\":",
        "context": "        checks_file_source = checks_file_name\n    # assume check file name is a file path\n    # will not support checks files being local paths\n    # if config file is a URL\n    elif chasten_user_config_url_str != \"\":\n        output.logger.error(\n            f\"\\nChecks file directive was a Path when config was a URL (given: '{checks_file_name}')\\n\"\n        )\n        checks_file_validated = False\n        checks_file_invalidates_entire_config = True",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 134,
        "coloffset": 4,
        "linematch": "elif (Path(chasten_user_config_dir_str) / Path(checks_file_name)).exists():",
        "context": "        checks_file_validated = False\n        checks_file_invalidates_entire_config = True\n        return (checks_file_validated, checks_file_invalidates_entire_config, {})\n    # checks file exists in local filesystem\n    elif (Path(chasten_user_config_dir_str) / Path(checks_file_name)).exists():\n        # extract the configuration details\n        (\n            checks_file_extracted_valid,\n            configuration_file_path_str,\n            configuration_file_yaml_str,",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 103,
        "coloffset": 0,
        "linematch": "def validate_checks_file(",
        "context": "    output.opt_print_log(verbose, tree=rich_path_tree)\n    output.opt_print_log(verbose, empty=\"\")\n\n\ndef validate_checks_file(\n    verbose: bool,\n    checks_file_name: str,\n    chasten_user_config_url_str: str,\n    chasten_user_config_dir_str: str,\n    chasten_user_config_file_str: str,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 110,
        "coloffset": 4,
        "linematch": "\"\"\"Validate a checks file.\"\"\"",
        "context": "    chasten_user_config_url_str: str,\n    chasten_user_config_dir_str: str,\n    chasten_user_config_file_str: str,\n) -> Tuple[bool, bool, Dict[str, Dict[str, Any]]]:\n    \"\"\"Validate a checks file.\"\"\"\n    checks_file_validated = False\n    checks_file_invalidates_entire_config = False\n    # specified check file is URL\n    if util.is_url(checks_file_name):\n        # extract the configuration details",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 111,
        "coloffset": 4,
        "linematch": "checks_file_validated = False",
        "context": "    chasten_user_config_dir_str: str,\n    chasten_user_config_file_str: str,\n) -> Tuple[bool, bool, Dict[str, Dict[str, Any]]]:\n    \"\"\"Validate a checks file.\"\"\"\n    checks_file_validated = False\n    checks_file_invalidates_entire_config = False\n    # specified check file is URL\n    if util.is_url(checks_file_name):\n        # extract the configuration details\n        (",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "checks_file_invalidates_entire_config = False",
        "context": "    chasten_user_config_file_str: str,\n) -> Tuple[bool, bool, Dict[str, Dict[str, Any]]]:\n    \"\"\"Validate a checks file.\"\"\"\n    checks_file_validated = False\n    checks_file_invalidates_entire_config = False\n    # specified check file is URL\n    if util.is_url(checks_file_name):\n        # extract the configuration details\n        (\n            checks_file_extracted_valid,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "if util.is_url(checks_file_name):",
        "context": "    \"\"\"Validate a checks file.\"\"\"\n    checks_file_validated = False\n    checks_file_invalidates_entire_config = False\n    # specified check file is URL\n    if util.is_url(checks_file_name):\n        # extract the configuration details\n        (\n            checks_file_extracted_valid,\n            configuration_file_yaml_str,\n            yaml_data_dict,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 157,
        "coloffset": 4,
        "linematch": "if not checks_file_extracted_valid:",
        "context": "        return (checks_file_validated, checks_file_invalidates_entire_config, {})\n    # the checks file could not be extracted in a valid\n    # fashion and thus there is no need to continue the\n    # validation of this file or any of the other check file\n    if not checks_file_extracted_valid:\n        checks_file_validated = False\n    # the checks file could be extract and thus the\n    # function should proceed to validate a checks configuration file\n    else:\n        # validate checks file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 170,
        "coloffset": 4,
        "linematch": "return (",
        "context": "            yaml_data_dict,\n            validate.JSON_SCHEMA_CHECKS,\n            verbose,\n        )\n    return (\n        checks_file_validated,\n        checks_file_invalidates_entire_config,\n        yaml_data_dict,\n    )\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 103,
        "coloffset": 0,
        "linematch": "def validate_checks_file(",
        "context": "    output.opt_print_log(verbose, tree=rich_path_tree)\n    output.opt_print_log(verbose, empty=\"\")\n\n\ndef validate_checks_file(\n    verbose: bool,\n    checks_file_name: str,\n    chasten_user_config_url_str: str,\n    chasten_user_config_dir_str: str,\n    chasten_user_config_file_str: str,",
        "pattern": ".//FunctionDef[count(body//Return) > 2]",
        "check_id": "MRET001",
        "check_name": "multiple-returns-in-function"
      },
      {
        "lineno": 103,
        "coloffset": 0,
        "linematch": "def validate_checks_file(",
        "context": "    output.opt_print_log(verbose, tree=rich_path_tree)\n    output.opt_print_log(verbose, empty=\"\")\n\n\ndef validate_checks_file(\n    verbose: bool,\n    checks_file_name: str,\n    chasten_user_config_url_str: str,\n    chasten_user_config_dir_str: str,\n    chasten_user_config_file_str: str,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 103,
        "coloffset": 0,
        "linematch": "def validate_checks_file(",
        "context": "    output.opt_print_log(verbose, tree=rich_path_tree)\n    output.opt_print_log(verbose, empty=\"\")\n\n\ndef validate_checks_file(\n    verbose: bool,\n    checks_file_name: str,\n    chasten_user_config_url_str: str,\n    chasten_user_config_dir_str: str,\n    chasten_user_config_file_str: str,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #304",
        "line": 123,
        "description": [
          "            grouped_files[directory] = []"
        ],
        "failure": []
      },
      {
        "name": "Mutant #305",
        "line": 143,
        "description": [
          "    grouped_files = group_files_by_directory(container)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #306",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #307",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1367",
        "line": 122,
        "description": [
          "        if directory not in grouped_files:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1368",
        "line": 132,
        "description": [
          "    if len(file_name) > max_length:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1369",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1370",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1371",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1372",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1373",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1374",
        "line": 148,
        "description": [
          "        console.print(f\"{small_bullet_unicode} Directory: {directory}\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1375",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1376",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1377",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1378",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1379",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1380",
        "line": 156,
        "description": [
          "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1381",
        "line": 160,
        "description": [
          "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1382",
        "line": 169,
        "description": [
          "    if not verbose:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1383",
        "line": 171,
        "description": [
          "    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "validate_configuration_files",
    "function_scope": "177-337",
    "patterns": [
      {
        "lineno": 188,
        "coloffset": 4,
        "linematch": "if config == \"\":",
        "context": "    chasten_user_config_url_str = \"\"\n    chasten_user_config_dir_str = \"\"\n    chasten_user_config_file_str = \"\"\n\n    if config == \"\":\n        # there is no configuration file specified and thus\n        # this function should access the platform-specific\n        # configuration directory detected by platformdirs\n        # detect and store the platform-specific user\n        # configuration directory by default",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 334,
        "coloffset": 4,
        "linematch": "if config_file_validated and check_files_validated:",
        "context": "    check_files_validated = all(checks_files_validated_list)\n    # the files validated correctly; return an indicator to\n    # show that validation worked and then return the overall\n    # dictionary that contains the listing of valid checks\n    if config_file_validated and check_files_validated:\n        return (True, overall_checks_dict)\n    # there was at least one validation error\n    return (False, {})\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 202,
        "coloffset": 4,
        "linematch": "elif util.is_url(config):",
        "context": "    # there is a specified configuration directory path or url;\n    # this overrides the use of the configuration files that\n    # may exist inside of the platform-specific directory.\n    # input configuration is valid URL\n    elif util.is_url(config):\n        # re-parse input config so it is of type URL\n        chasten_user_config_url_str = str(parse_url(config))\n        output.console.print(\n            \":sparkles: Configuration URL:\"\n            + constants.markers.Space",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 221,
        "coloffset": 4,
        "linematch": "elif Path(config).exists():",
        "context": "            parse_url(chasten_user_config_url_str)\n        )\n        configuration_file_source = chasten_user_config_url_str\n    # input configuration exists and is valid file path\n    elif Path(config).exists():\n        # input configuration is a directory\n        if Path(config).is_dir():\n            # re-parse input config so it is of type Path\n            chasten_user_config_dir_str = str(Path(config))\n        # input configuration is a file",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 223,
        "coloffset": 8,
        "linematch": "if Path(config).is_dir():",
        "context": "        configuration_file_source = chasten_user_config_url_str\n    # input configuration exists and is valid file path\n    elif Path(config).exists():\n        # input configuration is a directory\n        if Path(config).is_dir():\n            # re-parse input config so it is of type Path\n            chasten_user_config_dir_str = str(Path(config))\n        # input configuration is a file\n        elif Path(config).is_file():\n            # re-parse input config so it is of type Path",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 250,
        "coloffset": 8,
        "linematch": "if chasten_user_config_file_str != \"\":",
        "context": "        )\n        # optional argument if chasten_user_config_file_str is not empty\n        # argument will be supplied as unpacked dict\n        chasten_user_config_file_str_argument = {}\n        if chasten_user_config_file_str != \"\":\n            chasten_user_config_file_str_argument[\n                \"configuration_file\"\n            ] = chasten_user_config_file_str\n        # extract the configuration details\n        (",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 266,
        "coloffset": 8,
        "linematch": "if not configuration_valid:",
        "context": "        )\n        # it was not possible to extract the configuration details and\n        # thus this function should return immediately with False\n        # to indicate the failure and an empty configuration dictionary\n        if not configuration_valid:\n            return (False, {})\n        # create a visualization of the user's configuration directory;\n        # display details about the configuration directory in console\n        display_configuration_directory(chasten_user_config_dir_str, verbose)\n        configuration_file_source = chasten_user_config_dir_str",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 227,
        "coloffset": 8,
        "linematch": "elif Path(config).is_file():",
        "context": "        if Path(config).is_dir():\n            # re-parse input config so it is of type Path\n            chasten_user_config_dir_str = str(Path(config))\n        # input configuration is a file\n        elif Path(config).is_file():\n            # re-parse input config so it is of type Path\n            config_as_path = Path(config)\n            # get directory containing config file\n            chasten_user_config_dir_str = str(\n                Path(*config_as_path.parts[: len(config_as_path.parts) - 1])",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 321,
        "coloffset": 8,
        "linematch": "if checks_file_invalidates_entire_config:",
        "context": "            chasten_user_config_file_str,\n        )\n        # checks file invalidates entire configuration\n        # indicate invalid configuration\n        if checks_file_invalidates_entire_config:\n            return (False, {})\n        # keep track of the validation of all of validation\n        # records for each of the check files\n        checks_files_validated_list.append(checks_file_validated)\n        # add the listing of checks from the current yaml_data_dict to",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 223,
        "coloffset": 8,
        "linematch": "if Path(config).is_dir():",
        "context": "        configuration_file_source = chasten_user_config_url_str\n    # input configuration exists and is valid file path\n    elif Path(config).exists():\n        # input configuration is a directory\n        if Path(config).is_dir():\n            # re-parse input config so it is of type Path\n            chasten_user_config_dir_str = str(Path(config))\n        # input configuration is a file\n        elif Path(config).is_file():\n            # re-parse input config so it is of type Path",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 250,
        "coloffset": 8,
        "linematch": "if chasten_user_config_file_str != \"\":",
        "context": "        )\n        # optional argument if chasten_user_config_file_str is not empty\n        # argument will be supplied as unpacked dict\n        chasten_user_config_file_str_argument = {}\n        if chasten_user_config_file_str != \"\":\n            chasten_user_config_file_str_argument[\n                \"configuration_file\"\n            ] = chasten_user_config_file_str\n        # extract the configuration details\n        (",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 266,
        "coloffset": 8,
        "linematch": "if not configuration_valid:",
        "context": "        )\n        # it was not possible to extract the configuration details and\n        # thus this function should return immediately with False\n        # to indicate the failure and an empty configuration dictionary\n        if not configuration_valid:\n            return (False, {})\n        # create a visualization of the user's configuration directory;\n        # display details about the configuration directory in console\n        display_configuration_directory(chasten_user_config_dir_str, verbose)\n        configuration_file_source = chasten_user_config_dir_str",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 188,
        "coloffset": 7,
        "linematch": "if config == \"\":",
        "context": "    chasten_user_config_url_str = \"\"\n    chasten_user_config_dir_str = \"\"\n    chasten_user_config_file_str = \"\"\n\n    if config == \"\":\n        # there is no configuration file specified and thus\n        # this function should access the platform-specific\n        # configuration directory detected by platformdirs\n        # detect and store the platform-specific user\n        # configuration directory by default",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 177,
        "coloffset": 0,
        "linematch": "def validate_configuration_files(",
        "context": "        yaml_data_dict,\n    )\n\n\ndef validate_configuration_files(\n    config: str,\n    verbose: bool = False,\n) -> Tuple[\n    bool, Union[Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]]\n]:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 250,
        "coloffset": 8,
        "linematch": "if chasten_user_config_file_str != \"\":",
        "context": "        )\n        # optional argument if chasten_user_config_file_str is not empty\n        # argument will be supplied as unpacked dict\n        chasten_user_config_file_str_argument = {}\n        if chasten_user_config_file_str != \"\":\n            chasten_user_config_file_str_argument[\n                \"configuration_file\"\n            ] = chasten_user_config_file_str\n        # extract the configuration details\n        (",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 266,
        "coloffset": 8,
        "linematch": "if not configuration_valid:",
        "context": "        )\n        # it was not possible to extract the configuration details and\n        # thus this function should return immediately with False\n        # to indicate the failure and an empty configuration dictionary\n        if not configuration_valid:\n            return (False, {})\n        # create a visualization of the user's configuration directory;\n        # display details about the configuration directory in console\n        display_configuration_directory(chasten_user_config_dir_str, verbose)\n        configuration_file_source = chasten_user_config_dir_str",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 334,
        "coloffset": 4,
        "linematch": "if config_file_validated and check_files_validated:",
        "context": "    check_files_validated = all(checks_files_validated_list)\n    # the files validated correctly; return an indicator to\n    # show that validation worked and then return the overall\n    # dictionary that contains the listing of valid checks\n    if config_file_validated and check_files_validated:\n        return (True, overall_checks_dict)\n    # there was at least one validation error\n    return (False, {})\n\n",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 202,
        "coloffset": 4,
        "linematch": "elif util.is_url(config):",
        "context": "    # there is a specified configuration directory path or url;\n    # this overrides the use of the configuration files that\n    # may exist inside of the platform-specific directory.\n    # input configuration is valid URL\n    elif util.is_url(config):\n        # re-parse input config so it is of type URL\n        chasten_user_config_url_str = str(parse_url(config))\n        output.console.print(\n            \":sparkles: Configuration URL:\"\n            + constants.markers.Space",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 221,
        "coloffset": 4,
        "linematch": "elif Path(config).exists():",
        "context": "            parse_url(chasten_user_config_url_str)\n        )\n        configuration_file_source = chasten_user_config_url_str\n    # input configuration exists and is valid file path\n    elif Path(config).exists():\n        # input configuration is a directory\n        if Path(config).is_dir():\n            # re-parse input config so it is of type Path\n            chasten_user_config_dir_str = str(Path(config))\n        # input configuration is a file",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 223,
        "coloffset": 8,
        "linematch": "if Path(config).is_dir():",
        "context": "        configuration_file_source = chasten_user_config_url_str\n    # input configuration exists and is valid file path\n    elif Path(config).exists():\n        # input configuration is a directory\n        if Path(config).is_dir():\n            # re-parse input config so it is of type Path\n            chasten_user_config_dir_str = str(Path(config))\n        # input configuration is a file\n        elif Path(config).is_file():\n            # re-parse input config so it is of type Path",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 227,
        "coloffset": 8,
        "linematch": "elif Path(config).is_file():",
        "context": "        if Path(config).is_dir():\n            # re-parse input config so it is of type Path\n            chasten_user_config_dir_str = str(Path(config))\n        # input configuration is a file\n        elif Path(config).is_file():\n            # re-parse input config so it is of type Path\n            config_as_path = Path(config)\n            # get directory containing config file\n            chasten_user_config_dir_str = str(\n                Path(*config_as_path.parts[: len(config_as_path.parts) - 1])",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 250,
        "coloffset": 8,
        "linematch": "if chasten_user_config_file_str != \"\":",
        "context": "        )\n        # optional argument if chasten_user_config_file_str is not empty\n        # argument will be supplied as unpacked dict\n        chasten_user_config_file_str_argument = {}\n        if chasten_user_config_file_str != \"\":\n            chasten_user_config_file_str_argument[\n                \"configuration_file\"\n            ] = chasten_user_config_file_str\n        # extract the configuration details\n        (",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 266,
        "coloffset": 8,
        "linematch": "if not configuration_valid:",
        "context": "        )\n        # it was not possible to extract the configuration details and\n        # thus this function should return immediately with False\n        # to indicate the failure and an empty configuration dictionary\n        if not configuration_valid:\n            return (False, {})\n        # create a visualization of the user's configuration directory;\n        # display details about the configuration directory in console\n        display_configuration_directory(chasten_user_config_dir_str, verbose)\n        configuration_file_source = chasten_user_config_dir_str",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 177,
        "coloffset": 0,
        "linematch": "def validate_configuration_files(",
        "context": "        yaml_data_dict,\n    )\n\n\ndef validate_configuration_files(\n    config: str,\n    verbose: bool = False,\n) -> Tuple[\n    bool, Union[Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]]\n]:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 183,
        "coloffset": 4,
        "linematch": "\"\"\"Validate the configuration.\"\"\"",
        "context": "    verbose: bool = False,\n) -> Tuple[\n    bool, Union[Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]]\n]:\n    \"\"\"Validate the configuration.\"\"\"\n    chasten_user_config_url_str = \"\"\n    chasten_user_config_dir_str = \"\"\n    chasten_user_config_file_str = \"\"\n\n    if config == \"\":",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 184,
        "coloffset": 4,
        "linematch": "chasten_user_config_url_str = \"\"",
        "context": ") -> Tuple[\n    bool, Union[Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]]\n]:\n    \"\"\"Validate the configuration.\"\"\"\n    chasten_user_config_url_str = \"\"\n    chasten_user_config_dir_str = \"\"\n    chasten_user_config_file_str = \"\"\n\n    if config == \"\":\n        # there is no configuration file specified and thus",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 185,
        "coloffset": 4,
        "linematch": "chasten_user_config_dir_str = \"\"",
        "context": "    bool, Union[Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]]\n]:\n    \"\"\"Validate the configuration.\"\"\"\n    chasten_user_config_url_str = \"\"\n    chasten_user_config_dir_str = \"\"\n    chasten_user_config_file_str = \"\"\n\n    if config == \"\":\n        # there is no configuration file specified and thus\n        # this function should access the platform-specific",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 186,
        "coloffset": 4,
        "linematch": "chasten_user_config_file_str = \"\"",
        "context": "]:\n    \"\"\"Validate the configuration.\"\"\"\n    chasten_user_config_url_str = \"\"\n    chasten_user_config_dir_str = \"\"\n    chasten_user_config_file_str = \"\"\n\n    if config == \"\":\n        # there is no configuration file specified and thus\n        # this function should access the platform-specific\n        # configuration directory detected by platformdirs",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 188,
        "coloffset": 4,
        "linematch": "if config == \"\":",
        "context": "    chasten_user_config_url_str = \"\"\n    chasten_user_config_dir_str = \"\"\n    chasten_user_config_file_str = \"\"\n\n    if config == \"\":\n        # there is no configuration file specified and thus\n        # this function should access the platform-specific\n        # configuration directory detected by platformdirs\n        # detect and store the platform-specific user\n        # configuration directory by default",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 285,
        "coloffset": 4,
        "linematch": "config_file_validated = validate.validate_file(",
        "context": "    # --> Step 2: Validate the one or more checks files\n    # --> Step 3: If all files are valid, return overall validity\n    # --> Step 3: Otherwise, return an invalid configuration\n    # validate the user's configuration and display the results\n    config_file_validated = validate.validate_file(\n        configuration_file_source,\n        configuration_file_yaml_str,\n        yaml_data_dict,\n        validate.JSON_SCHEMA_CONFIG,\n        verbose,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 294,
        "coloffset": 4,
        "linematch": "(_, checks_file_name_list) = validate.extract_checks_file_name(yaml_data_dict)",
        "context": "        verbose,\n    )\n\n    # if one or more exist, retrieve the name of the checks files\n    (_, checks_file_name_list) = validate.extract_checks_file_name(yaml_data_dict)\n    # iteratively extract the contents of each checks file\n    # and then validate the contents of that checks file\n    checks_files_validated_list = []\n    check_files_validated = False\n    # create an empty dictionary that will store the list of checks",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 297,
        "coloffset": 4,
        "linematch": "checks_files_validated_list = []",
        "context": "    # if one or more exist, retrieve the name of the checks files\n    (_, checks_file_name_list) = validate.extract_checks_file_name(yaml_data_dict)\n    # iteratively extract the contents of each checks file\n    # and then validate the contents of that checks file\n    checks_files_validated_list = []\n    check_files_validated = False\n    # create an empty dictionary that will store the list of checks\n    overall_checks_dict: Union[\n        Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]\n    ] = {}",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 298,
        "coloffset": 4,
        "linematch": "check_files_validated = False",
        "context": "    (_, checks_file_name_list) = validate.extract_checks_file_name(yaml_data_dict)\n    # iteratively extract the contents of each checks file\n    # and then validate the contents of that checks file\n    checks_files_validated_list = []\n    check_files_validated = False\n    # create an empty dictionary that will store the list of checks\n    overall_checks_dict: Union[\n        Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]\n    ] = {}\n    # create an empty list that will store the dicts of checks",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 300,
        "coloffset": 4,
        "linematch": "overall_checks_dict: Union[",
        "context": "    # and then validate the contents of that checks file\n    checks_files_validated_list = []\n    check_files_validated = False\n    # create an empty dictionary that will store the list of checks\n    overall_checks_dict: Union[\n        Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]\n    ] = {}\n    # create an empty list that will store the dicts of checks\n    overall_checks_list: List[Dict[str, Union[str, Dict[str, int]]]] = []\n    # initialize the dictionary to contain the empty list",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 304,
        "coloffset": 4,
        "linematch": "overall_checks_list: List[Dict[str, Union[str, Dict[str, int]]]] = []",
        "context": "    overall_checks_dict: Union[\n        Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]\n    ] = {}\n    # create an empty list that will store the dicts of checks\n    overall_checks_list: List[Dict[str, Union[str, Dict[str, int]]]] = []\n    # initialize the dictionary to contain the empty list\n    overall_checks_dict[constants.checks.Checks_Label] = overall_checks_list\n    for checks_file_name in checks_file_name_list:\n        (\n            checks_file_validated,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 306,
        "coloffset": 4,
        "linematch": "overall_checks_dict[constants.checks.Checks_Label] = overall_checks_list",
        "context": "    ] = {}\n    # create an empty list that will store the dicts of checks\n    overall_checks_list: List[Dict[str, Union[str, Dict[str, int]]]] = []\n    # initialize the dictionary to contain the empty list\n    overall_checks_dict[constants.checks.Checks_Label] = overall_checks_list\n    for checks_file_name in checks_file_name_list:\n        (\n            checks_file_validated,\n            checks_file_invalidates_entire_config,\n            checks_file_yaml_data_dict,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 307,
        "coloffset": 4,
        "linematch": "for checks_file_name in checks_file_name_list:",
        "context": "    # create an empty list that will store the dicts of checks\n    overall_checks_list: List[Dict[str, Union[str, Dict[str, int]]]] = []\n    # initialize the dictionary to contain the empty list\n    overall_checks_dict[constants.checks.Checks_Label] = overall_checks_list\n    for checks_file_name in checks_file_name_list:\n        (\n            checks_file_validated,\n            checks_file_invalidates_entire_config,\n            checks_file_yaml_data_dict,\n        ) = validate_checks_file(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 330,
        "coloffset": 4,
        "linematch": "check_files_validated = all(checks_files_validated_list)",
        "context": "        # add the listing of checks from the current yaml_data_dict to\n        # the overall listing of checks in the main dictionary\n        overall_checks_dict[constants.checks.Checks_Label].extend(checks_file_yaml_data_dict[constants.checks.Checks_Label])  # type: ignore\n    # the check files are only validated if all of them are valid\n    check_files_validated = all(checks_files_validated_list)\n    # the files validated correctly; return an indicator to\n    # show that validation worked and then return the overall\n    # dictionary that contains the listing of valid checks\n    if config_file_validated and check_files_validated:\n        return (True, overall_checks_dict)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 334,
        "coloffset": 4,
        "linematch": "if config_file_validated and check_files_validated:",
        "context": "    check_files_validated = all(checks_files_validated_list)\n    # the files validated correctly; return an indicator to\n    # show that validation worked and then return the overall\n    # dictionary that contains the listing of valid checks\n    if config_file_validated and check_files_validated:\n        return (True, overall_checks_dict)\n    # there was at least one validation error\n    return (False, {})\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 337,
        "coloffset": 4,
        "linematch": "return (False, {})",
        "context": "    # dictionary that contains the listing of valid checks\n    if config_file_validated and check_files_validated:\n        return (True, overall_checks_dict)\n    # there was at least one validation error\n    return (False, {})\n\n\ndef extract_configuration_details_from_config_dir(\n    chasten_user_config_dir_str: Path,\n    configuration_file: str = constants.filesystem.Main_Configuration_File,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 177,
        "coloffset": 0,
        "linematch": "def validate_configuration_files(",
        "context": "        yaml_data_dict,\n    )\n\n\ndef validate_configuration_files(\n    config: str,\n    verbose: bool = False,\n) -> Tuple[\n    bool, Union[Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]]\n]:",
        "pattern": ".//FunctionDef[count(body//Return) > 2]",
        "check_id": "MRET001",
        "check_name": "multiple-returns-in-function"
      },
      {
        "lineno": 177,
        "coloffset": 0,
        "linematch": "def validate_configuration_files(",
        "context": "        yaml_data_dict,\n    )\n\n\ndef validate_configuration_files(\n    config: str,\n    verbose: bool = False,\n) -> Tuple[\n    bool, Union[Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]]\n]:",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]",
        "check_id": "F027",
        "check_name": "high-cyclomatic-complexity"
      },
      {
        "lineno": 177,
        "coloffset": 0,
        "linematch": "def validate_configuration_files(",
        "context": "        yaml_data_dict,\n    )\n\n\ndef validate_configuration_files(\n    config: str,\n    verbose: bool = False,\n) -> Tuple[\n    bool, Union[Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]]\n]:",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 177,
        "coloffset": 0,
        "linematch": "def validate_configuration_files(",
        "context": "        yaml_data_dict,\n    )\n\n\ndef validate_configuration_files(\n    config: str,\n    verbose: bool = False,\n) -> Tuple[\n    bool, Union[Dict[str, List[Dict[str, Union[str, Dict[str, int]]]]], Dict[Any, Any]]\n]:",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #309",
        "line": 182,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #310",
        "line": 187,
        "description": [
          "        min_count = current_check.min"
        ],
        "failure": []
      },
      {
        "name": "Mutant #311",
        "line": 188,
        "description": [
          "        max_count = current_check.max"
        ],
        "failure": []
      },
      {
        "name": "Mutant #312",
        "line": 189,
        "description": [
          "        min_label = checks.create_attribute_label(min_count, constants.checks.Check_Min)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #313",
        "line": 190,
        "description": [
          "        max_label = checks.create_attribute_label(max_count, constants.checks.Check_Max)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #314",
        "line": 193,
        "description": [
          "        check_id = current_check.id"
        ],
        "failure": []
      },
      {
        "name": "Mutant #315",
        "line": 194,
        "description": [
          "        check_id_label = checks.create_attribute_label(check_id, constants.checks.Check_Id)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #316",
        "line": 195,
        "description": [
          "        check_name = current_check.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #317",
        "line": 196,
        "description": [
          "        check_name_label = checks.create_attribute_label(check_name, constants.checks.Check_Name)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #318",
        "line": 200,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #319",
        "line": 223,
        "description": [
          "                    position_end = current_match.position.lineno"
        ],
        "failure": []
      },
      {
        "name": "Mutant #320",
        "line": 225,
        "description": [
          "                    column_offset = current_match.position.col_offset"
        ],
        "failure": []
      },
      {
        "name": "Mutant #321",
        "line": 230,
        "description": [
          "                    all_lines = current_match.file_lines"
        ],
        "failure": []
      },
      {
        "name": "Mutant #322",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #323",
        "line": 240,
        "description": [
          "                    ]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #324",
        "line": 258,
        "description": [
          "                    )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1385",
        "line": 177,
        "description": [
          "        console.print(\"\\n:tada: Check:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1386",
        "line": 205,
        "description": [
          "                expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1387",
        "line": 206,
        "description": [
          "                title=f\"{combined_attribute_label}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1388",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1389",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1390",
        "line": 214,
        "description": [
          "                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1391",
        "line": 221,
        "description": [
          "                    opt_print_log(verbose, label=\":sparkles: Matching source code:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1392",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1393",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1394",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1395",
        "line": 239,
        "description": [
          "                        + constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1396",
        "line": 249,
        "description": [
          "                        \"\\n\".join(str(line) for line in lines),"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1397",
        "line": 253,
        "description": [
          "                        line_numbers=True,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1398",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1399",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1400",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1401",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1402",
        "line": 264,
        "description": [
          "                            expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1403",
        "line": 265,
        "description": [
          "                            title=f\"{current_match.path}:{position_end}:{column_offset}\","
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "extract_configuration_details_from_config_dir",
    "function_scope": "340-380",
    "patterns": [
      {
        "lineno": 356,
        "coloffset": 4,
        "linematch": "if not configuration_file_path.exists():",
        "context": "    # the configuration file does not exist and thus\n    # the extraction process cannot continue, the use of\n    # these return values indicates that the extraction\n    # failed and any future steps cannot continue\n    if not configuration_file_path.exists():\n        output.logger.error(\n            f\"\\nFinding config or check file Path failed for {configuration_file_path}.\\n\"\n        )\n        return (False, None, None, None)  # type: ignore\n    configuration_file_yaml_str = configuration_file_path.read_text()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 368,
        "coloffset": 8,
        "linematch": "if yaml_success:",
        "context": "        (yaml_success, yaml_data) = convert_configuration_text_to_yaml(\n            user_configuration_file_text.read()\n        )\n        # return success status, filename, file contents, and yaml parsed data upon success\n        if yaml_success:\n            return (\n                True,\n                str(configuration_file_path),\n                configuration_file_yaml_str,\n                yaml_data,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 340,
        "coloffset": 0,
        "linematch": "def extract_configuration_details_from_config_dir(",
        "context": "    # there was at least one validation error\n    return (False, {})\n\n\ndef extract_configuration_details_from_config_dir(\n    chasten_user_config_dir_str: Path,\n    configuration_file: str = constants.filesystem.Main_Configuration_File,\n) -> Tuple[bool, str, str, Dict[str, Dict[str, Any]]]:\n    \"\"\"Extract details from the configuration given a config directory.\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 340,
        "coloffset": 0,
        "linematch": "def extract_configuration_details_from_config_dir(",
        "context": "    # there was at least one validation error\n    return (False, {})\n\n\ndef extract_configuration_details_from_config_dir(\n    chasten_user_config_dir_str: Path,\n    configuration_file: str = constants.filesystem.Main_Configuration_File,\n) -> Tuple[bool, str, str, Dict[str, Dict[str, Any]]]:\n    \"\"\"Extract details from the configuration given a config directory.\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 344,
        "coloffset": 4,
        "linematch": "\"\"\"Extract details from the configuration given a config directory.",
        "context": "def extract_configuration_details_from_config_dir(\n    chasten_user_config_dir_str: Path,\n    configuration_file: str = constants.filesystem.Main_Configuration_File,\n) -> Tuple[bool, str, str, Dict[str, Dict[str, Any]]]:\n    \"\"\"Extract details from the configuration given a config directory.\n\n    chasten_user_config_dir_str -- directory to search for config file\n    configuration_file -- optional configuration file to specify. If not supplied, a default location will be searched\n    \"\"\"\n    # create the name of the main configuration file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 351,
        "coloffset": 4,
        "linematch": "configuration_file_path = chasten_user_config_dir_str / configuration_file",
        "context": "    configuration_file -- optional configuration file to specify. If not supplied, a default location will be searched\n    \"\"\"\n    # create the name of the main configuration file\n    # load the text of the main configuration file\n    configuration_file_path = chasten_user_config_dir_str / configuration_file\n    # the configuration file does not exist and thus\n    # the extraction process cannot continue, the use of\n    # these return values indicates that the extraction\n    # failed and any future steps cannot continue\n    if not configuration_file_path.exists():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 356,
        "coloffset": 4,
        "linematch": "if not configuration_file_path.exists():",
        "context": "    # the configuration file does not exist and thus\n    # the extraction process cannot continue, the use of\n    # these return values indicates that the extraction\n    # failed and any future steps cannot continue\n    if not configuration_file_path.exists():\n        output.logger.error(\n            f\"\\nFinding config or check file Path failed for {configuration_file_path}.\\n\"\n        )\n        return (False, None, None, None)  # type: ignore\n    configuration_file_yaml_str = configuration_file_path.read_text()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 361,
        "coloffset": 4,
        "linematch": "configuration_file_yaml_str = configuration_file_path.read_text()",
        "context": "        output.logger.error(\n            f\"\\nFinding config or check file Path failed for {configuration_file_path}.\\n\"\n        )\n        return (False, None, None, None)  # type: ignore\n    configuration_file_yaml_str = configuration_file_path.read_text()\n    # load the contents of the main configuration file\n    with open(str(configuration_file_path)) as user_configuration_file_text:\n        (yaml_success, yaml_data) = convert_configuration_text_to_yaml(\n            user_configuration_file_text.read()\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 363,
        "coloffset": 4,
        "linematch": "with open(str(configuration_file_path)) as user_configuration_file_text:",
        "context": "        )\n        return (False, None, None, None)  # type: ignore\n    configuration_file_yaml_str = configuration_file_path.read_text()\n    # load the contents of the main configuration file\n    with open(str(configuration_file_path)) as user_configuration_file_text:\n        (yaml_success, yaml_data) = convert_configuration_text_to_yaml(\n            user_configuration_file_text.read()\n        )\n        # return success status, filename, file contents, and yaml parsed data upon success\n        if yaml_success:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 340,
        "coloffset": 0,
        "linematch": "def extract_configuration_details_from_config_dir(",
        "context": "    # there was at least one validation error\n    return (False, {})\n\n\ndef extract_configuration_details_from_config_dir(\n    chasten_user_config_dir_str: Path,\n    configuration_file: str = constants.filesystem.Main_Configuration_File,\n) -> Tuple[bool, str, str, Dict[str, Dict[str, Any]]]:\n    \"\"\"Extract details from the configuration given a config directory.\n",
        "pattern": ".//FunctionDef[count(body//Return) > 2]",
        "check_id": "MRET001",
        "check_name": "multiple-returns-in-function"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "extract_configuration_details_from_config_url",
    "function_scope": "383-412",
    "patterns": [
      {
        "lineno": 393,
        "coloffset": 4,
        "linematch": "if response.ok:",
        "context": "    \"\"\"\n    # create request with given URL as source\n    response = requests.get(str(chasten_user_config_url))\n    # the URL response is OK\n    if response.ok:\n        # assume URL endpoint returns raw text\n        configuration_file_yaml_str = response.text\n    # the URL indicates a problem with the response\n    else:\n        output.logger.error(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 406,
        "coloffset": 4,
        "linematch": "if yaml_success:",
        "context": "    (yaml_success, yaml_data) = convert_configuration_text_to_yaml(\n        configuration_file_yaml_str\n    )\n    # return success status, filename, file contents, and yaml parsed data upon success\n    if yaml_success:\n        return (True, configuration_file_yaml_str, yaml_data)\n    else:\n        output.logger.error(\n            f\"\\nParsing YAML from config or check file URL failed for {chasten_user_config_url}.\\n\"\n        )",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 383,
        "coloffset": 0,
        "linematch": "def extract_configuration_details_from_config_url(",
        "context": "            )\n            return (False, None, None, None)  # type: ignore\n\n\ndef extract_configuration_details_from_config_url(\n    chasten_user_config_url: Url,\n) -> Tuple[bool, str, Dict[str, Dict[str, Any]]]:\n    \"\"\"Extract details from the configuration given a config URL.\n\n    chasten_user_config_url -- URL to config or checks yaml file.",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 406,
        "coloffset": 4,
        "linematch": "if yaml_success:",
        "context": "    (yaml_success, yaml_data) = convert_configuration_text_to_yaml(\n        configuration_file_yaml_str\n    )\n    # return success status, filename, file contents, and yaml parsed data upon success\n    if yaml_success:\n        return (True, configuration_file_yaml_str, yaml_data)\n    else:\n        output.logger.error(\n            f\"\\nParsing YAML from config or check file URL failed for {chasten_user_config_url}.\\n\"\n        )",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 383,
        "coloffset": 0,
        "linematch": "def extract_configuration_details_from_config_url(",
        "context": "            )\n            return (False, None, None, None)  # type: ignore\n\n\ndef extract_configuration_details_from_config_url(\n    chasten_user_config_url: Url,\n) -> Tuple[bool, str, Dict[str, Dict[str, Any]]]:\n    \"\"\"Extract details from the configuration given a config URL.\n\n    chasten_user_config_url -- URL to config or checks yaml file.",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 386,
        "coloffset": 4,
        "linematch": "\"\"\"Extract details from the configuration given a config URL.",
        "context": "\ndef extract_configuration_details_from_config_url(\n    chasten_user_config_url: Url,\n) -> Tuple[bool, str, Dict[str, Dict[str, Any]]]:\n    \"\"\"Extract details from the configuration given a config URL.\n\n    chasten_user_config_url -- URL to config or checks yaml file.\n    \"\"\"\n    # create request with given URL as source\n    response = requests.get(str(chasten_user_config_url))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 391,
        "coloffset": 4,
        "linematch": "response = requests.get(str(chasten_user_config_url))",
        "context": "\n    chasten_user_config_url -- URL to config or checks yaml file.\n    \"\"\"\n    # create request with given URL as source\n    response = requests.get(str(chasten_user_config_url))\n    # the URL response is OK\n    if response.ok:\n        # assume URL endpoint returns raw text\n        configuration_file_yaml_str = response.text\n    # the URL indicates a problem with the response",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 393,
        "coloffset": 4,
        "linematch": "if response.ok:",
        "context": "    \"\"\"\n    # create request with given URL as source\n    response = requests.get(str(chasten_user_config_url))\n    # the URL response is OK\n    if response.ok:\n        # assume URL endpoint returns raw text\n        configuration_file_yaml_str = response.text\n    # the URL indicates a problem with the response\n    else:\n        output.logger.error(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 402,
        "coloffset": 4,
        "linematch": "(yaml_success, yaml_data) = convert_configuration_text_to_yaml(",
        "context": "        output.logger.error(\n            f\"\\nLoading config or check file URL failed for {chasten_user_config_url}.\\n\"\n        )\n        return (False, None, None)  # type: ignore\n    (yaml_success, yaml_data) = convert_configuration_text_to_yaml(\n        configuration_file_yaml_str\n    )\n    # return success status, filename, file contents, and yaml parsed data upon success\n    if yaml_success:\n        return (True, configuration_file_yaml_str, yaml_data)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 406,
        "coloffset": 4,
        "linematch": "if yaml_success:",
        "context": "    (yaml_success, yaml_data) = convert_configuration_text_to_yaml(\n        configuration_file_yaml_str\n    )\n    # return success status, filename, file contents, and yaml parsed data upon success\n    if yaml_success:\n        return (True, configuration_file_yaml_str, yaml_data)\n    else:\n        output.logger.error(\n            f\"\\nParsing YAML from config or check file URL failed for {chasten_user_config_url}.\\n\"\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 383,
        "coloffset": 0,
        "linematch": "def extract_configuration_details_from_config_url(",
        "context": "            )\n            return (False, None, None, None)  # type: ignore\n\n\ndef extract_configuration_details_from_config_url(\n    chasten_user_config_url: Url,\n) -> Tuple[bool, str, Dict[str, Dict[str, Any]]]:\n    \"\"\"Extract details from the configuration given a config URL.\n\n    chasten_user_config_url -- URL to config or checks yaml file.",
        "pattern": ".//FunctionDef[count(body//Return) > 2]",
        "check_id": "MRET001",
        "check_name": "multiple-returns-in-function"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "get_human_readable_boolean",
    "function_scope": "16-22",
    "patterns": [
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "\ndef get_human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is true\n    if answer:\n        return constants.humanreadable.Yes\n    # the provided answer is false\n    return constants.humanreadable.No\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 16,
        "coloffset": 0,
        "linematch": "def get_human_readable_boolean(answer: bool) -> str:",
        "context": "xmark_unicode = \"\\u2717\"\ndefault_chasten_semver = \"0.0.0\"\n\n\ndef get_human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is true\n    if answer:\n        return constants.humanreadable.Yes\n    # the provided answer is false",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 16,
        "coloffset": 0,
        "linematch": "def get_human_readable_boolean(answer: bool) -> str:",
        "context": "xmark_unicode = \"\\u2717\"\ndefault_chasten_semver = \"0.0.0\"\n\n\ndef get_human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is true\n    if answer:\n        return constants.humanreadable.Yes\n    # the provided answer is false",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "\"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"",
        "context": "default_chasten_semver = \"0.0.0\"\n\n\ndef get_human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is true\n    if answer:\n        return constants.humanreadable.Yes\n    # the provided answer is false\n    return constants.humanreadable.No",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "\ndef get_human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is true\n    if answer:\n        return constants.humanreadable.Yes\n    # the provided answer is false\n    return constants.humanreadable.No\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "return constants.humanreadable.No",
        "context": "    # the provided answer is true\n    if answer:\n        return constants.humanreadable.Yes\n    # the provided answer is false\n    return constants.humanreadable.No\n\n\ndef get_OS() -> str:\n    \"\"\"Gets the Operating system of the user.\"\"\"\n    OpSystem = platform.system()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #299",
        "line": 19,
        "description": [
          "console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1360",
        "line": 16,
        "description": [
          "logger: logging.Logger = logging.getLogger()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "executable_name",
    "function_scope": "31-39",
    "patterns": [
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "if OpSystem == \"Windows\":",
        "context": "def executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:\n    \"\"\"Get the executable directory depending on OS\"\"\"\n    exe_directory = \"/bin/\"\n    # Checks if the OS is windows and changed where to search if true\n    if OpSystem == \"Windows\":\n        exe_directory = \"/Scripts/\"\n        executable_name += \".exe\"\n    virtual_env_location = sys.prefix\n    return virtual_env_location + exe_directory + executable_name\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 31,
        "coloffset": 0,
        "linematch": "def executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:",
        "context": "    OpSystem = platform.system()\n    return OpSystem\n\n\ndef executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:\n    \"\"\"Get the executable directory depending on OS\"\"\"\n    exe_directory = \"/bin/\"\n    # Checks if the OS is windows and changed where to search if true\n    if OpSystem == \"Windows\":\n        exe_directory = \"/Scripts/\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 31,
        "coloffset": 0,
        "linematch": "def executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:",
        "context": "    OpSystem = platform.system()\n    return OpSystem\n\n\ndef executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:\n    \"\"\"Get the executable directory depending on OS\"\"\"\n    exe_directory = \"/bin/\"\n    # Checks if the OS is windows and changed where to search if true\n    if OpSystem == \"Windows\":\n        exe_directory = \"/Scripts/\"",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "\"\"\"Get the executable directory depending on OS\"\"\"",
        "context": "    return OpSystem\n\n\ndef executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:\n    \"\"\"Get the executable directory depending on OS\"\"\"\n    exe_directory = \"/bin/\"\n    # Checks if the OS is windows and changed where to search if true\n    if OpSystem == \"Windows\":\n        exe_directory = \"/Scripts/\"\n        executable_name += \".exe\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "exe_directory = \"/bin/\"",
        "context": "\n\ndef executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:\n    \"\"\"Get the executable directory depending on OS\"\"\"\n    exe_directory = \"/bin/\"\n    # Checks if the OS is windows and changed where to search if true\n    if OpSystem == \"Windows\":\n        exe_directory = \"/Scripts/\"\n        executable_name += \".exe\"\n    virtual_env_location = sys.prefix",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "if OpSystem == \"Windows\":",
        "context": "def executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:\n    \"\"\"Get the executable directory depending on OS\"\"\"\n    exe_directory = \"/bin/\"\n    # Checks if the OS is windows and changed where to search if true\n    if OpSystem == \"Windows\":\n        exe_directory = \"/Scripts/\"\n        executable_name += \".exe\"\n    virtual_env_location = sys.prefix\n    return virtual_env_location + exe_directory + executable_name\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 38,
        "coloffset": 4,
        "linematch": "virtual_env_location = sys.prefix",
        "context": "    # Checks if the OS is windows and changed where to search if true\n    if OpSystem == \"Windows\":\n        exe_directory = \"/Scripts/\"\n        executable_name += \".exe\"\n    virtual_env_location = sys.prefix\n    return virtual_env_location + exe_directory + executable_name\n\n\ndef get_symbol_boolean(answer: bool) -> str:\n    \"\"\"Produce a symbol-formatted version of a boolean value of True or False.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "return virtual_env_location + exe_directory + executable_name",
        "context": "    if OpSystem == \"Windows\":\n        exe_directory = \"/Scripts/\"\n        executable_name += \".exe\"\n    virtual_env_location = sys.prefix\n    return virtual_env_location + exe_directory + executable_name\n\n\ndef get_symbol_boolean(answer: bool) -> str:\n    \"\"\"Produce a symbol-formatted version of a boolean value of True or False.\"\"\"\n    if answer:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "get_symbol_boolean",
    "function_scope": "42-46",
    "patterns": [
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "\n\ndef get_symbol_boolean(answer: bool) -> str:\n    \"\"\"Produce a symbol-formatted version of a boolean value of True or False.\"\"\"\n    if answer:\n        return f\"[green]{checkmark_unicode}[/green]\"\n    return f\"[red]{xmark_unicode}[/red]\"\n\n\ndef get_chasten_version() -> str:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 42,
        "coloffset": 0,
        "linematch": "def get_symbol_boolean(answer: bool) -> str:",
        "context": "    virtual_env_location = sys.prefix\n    return virtual_env_location + exe_directory + executable_name\n\n\ndef get_symbol_boolean(answer: bool) -> str:\n    \"\"\"Produce a symbol-formatted version of a boolean value of True or False.\"\"\"\n    if answer:\n        return f\"[green]{checkmark_unicode}[/green]\"\n    return f\"[red]{xmark_unicode}[/red]\"\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 42,
        "coloffset": 0,
        "linematch": "def get_symbol_boolean(answer: bool) -> str:",
        "context": "    virtual_env_location = sys.prefix\n    return virtual_env_location + exe_directory + executable_name\n\n\ndef get_symbol_boolean(answer: bool) -> str:\n    \"\"\"Produce a symbol-formatted version of a boolean value of True or False.\"\"\"\n    if answer:\n        return f\"[green]{checkmark_unicode}[/green]\"\n    return f\"[red]{xmark_unicode}[/red]\"\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "\"\"\"Produce a symbol-formatted version of a boolean value of True or False.\"\"\"",
        "context": "    return virtual_env_location + exe_directory + executable_name\n\n\ndef get_symbol_boolean(answer: bool) -> str:\n    \"\"\"Produce a symbol-formatted version of a boolean value of True or False.\"\"\"\n    if answer:\n        return f\"[green]{checkmark_unicode}[/green]\"\n    return f\"[red]{xmark_unicode}[/red]\"\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "\n\ndef get_symbol_boolean(answer: bool) -> str:\n    \"\"\"Produce a symbol-formatted version of a boolean value of True or False.\"\"\"\n    if answer:\n        return f\"[green]{checkmark_unicode}[/green]\"\n    return f\"[red]{xmark_unicode}[/red]\"\n\n\ndef get_chasten_version() -> str:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "return f\"[red]{xmark_unicode}[/red]\"",
        "context": "def get_symbol_boolean(answer: bool) -> str:\n    \"\"\"Produce a symbol-formatted version of a boolean value of True or False.\"\"\"\n    if answer:\n        return f\"[green]{checkmark_unicode}[/green]\"\n    return f\"[red]{xmark_unicode}[/red]\"\n\n\ndef get_chasten_version() -> str:\n    \"\"\"Use importlib to extract the version of the package.\"\"\"\n    # attempt to determine the current version of the entire package,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "is_url",
    "function_scope": "73-103",
    "patterns": [
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "if url_parsed.scheme not in [\"http\", \"https\"]:",
        "context": "    \"\"\"Determine if string is valid URL.\"\"\"\n    # parse input url\n    url_parsed = parse_url(url)\n    # only allow http and https\n    if url_parsed.scheme not in [\"http\", \"https\"]:\n        return False\n    # only input characters for initiatig query and/or fragments if necessary\n    port_character = \":\" if url_parsed.port is not None else \"\"\n    query_character = \"?\" if url_parsed.query is not None else \"\"\n    fragment_character = \"#\" if url_parsed.fragment is not None else \"\"",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 100,
        "coloffset": 8,
        "linematch": "if url_piece is not None:",
        "context": "    # convert every item to a string and piece the url back together\n    # to make sure it matches what was given\n    url_reassembled = \"\"\n    for url_piece in url_pieces:\n        if url_piece is not None:\n            url_reassembled += str(url_piece)\n    # determine if parsed and reconstructed url matches original\n    return str(parse_url(url)).lower() == url_reassembled.lower()\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 103,
        "coloffset": 11,
        "linematch": "return str(parse_url(url)).lower() == url_reassembled.lower()",
        "context": "    for url_piece in url_pieces:\n        if url_piece is not None:\n            url_reassembled += str(url_piece)\n    # determine if parsed and reconstructed url matches original\n    return str(parse_url(url)).lower() == url_reassembled.lower()\n\n\ndef total_amount_passed(check_status_list: list[bool]) -> tuple[int, int, float]:\n    \"\"\"Calculate amount of checks passed in analyze\"\"\"\n    # attempt calculations for percentage of checks passed",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 103,
        "coloffset": 11,
        "linematch": "return str(parse_url(url)).lower() == url_reassembled.lower()",
        "context": "    for url_piece in url_pieces:\n        if url_piece is not None:\n            url_reassembled += str(url_piece)\n    # determine if parsed and reconstructed url matches original\n    return str(parse_url(url)).lower() == url_reassembled.lower()\n\n\ndef total_amount_passed(check_status_list: list[bool]) -> tuple[int, int, float]:\n    \"\"\"Calculate amount of checks passed in analyze\"\"\"\n    # attempt calculations for percentage of checks passed",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 73,
        "coloffset": 0,
        "linematch": "def is_url(url: str) -> bool:",
        "context": "    \"\"\"Join and preserve lines inside of a list.\"\"\"\n    return constants.markers.Newline.join(data[start:end])\n\n\ndef is_url(url: str) -> bool:\n    \"\"\"Determine if string is valid URL.\"\"\"\n    # parse input url\n    url_parsed = parse_url(url)\n    # only allow http and https\n    if url_parsed.scheme not in [\"http\", \"https\"]:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 73,
        "coloffset": 0,
        "linematch": "def is_url(url: str) -> bool:",
        "context": "    \"\"\"Join and preserve lines inside of a list.\"\"\"\n    return constants.markers.Newline.join(data[start:end])\n\n\ndef is_url(url: str) -> bool:\n    \"\"\"Determine if string is valid URL.\"\"\"\n    # parse input url\n    url_parsed = parse_url(url)\n    # only allow http and https\n    if url_parsed.scheme not in [\"http\", \"https\"]:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 74,
        "coloffset": 4,
        "linematch": "\"\"\"Determine if string is valid URL.\"\"\"",
        "context": "    return constants.markers.Newline.join(data[start:end])\n\n\ndef is_url(url: str) -> bool:\n    \"\"\"Determine if string is valid URL.\"\"\"\n    # parse input url\n    url_parsed = parse_url(url)\n    # only allow http and https\n    if url_parsed.scheme not in [\"http\", \"https\"]:\n        return False",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 76,
        "coloffset": 4,
        "linematch": "url_parsed = parse_url(url)",
        "context": "\ndef is_url(url: str) -> bool:\n    \"\"\"Determine if string is valid URL.\"\"\"\n    # parse input url\n    url_parsed = parse_url(url)\n    # only allow http and https\n    if url_parsed.scheme not in [\"http\", \"https\"]:\n        return False\n    # only input characters for initiatig query and/or fragments if necessary\n    port_character = \":\" if url_parsed.port is not None else \"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "if url_parsed.scheme not in [\"http\", \"https\"]:",
        "context": "    \"\"\"Determine if string is valid URL.\"\"\"\n    # parse input url\n    url_parsed = parse_url(url)\n    # only allow http and https\n    if url_parsed.scheme not in [\"http\", \"https\"]:\n        return False\n    # only input characters for initiatig query and/or fragments if necessary\n    port_character = \":\" if url_parsed.port is not None else \"\"\n    query_character = \"?\" if url_parsed.query is not None else \"\"\n    fragment_character = \"#\" if url_parsed.fragment is not None else \"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 81,
        "coloffset": 4,
        "linematch": "port_character = \":\" if url_parsed.port is not None else \"\"",
        "context": "    # only allow http and https\n    if url_parsed.scheme not in [\"http\", \"https\"]:\n        return False\n    # only input characters for initiatig query and/or fragments if necessary\n    port_character = \":\" if url_parsed.port is not None else \"\"\n    query_character = \"?\" if url_parsed.query is not None else \"\"\n    fragment_character = \"#\" if url_parsed.fragment is not None else \"\"\n    url_pieces = [\n        url_parsed.scheme,\n        \"://\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 82,
        "coloffset": 4,
        "linematch": "query_character = \"?\" if url_parsed.query is not None else \"\"",
        "context": "    if url_parsed.scheme not in [\"http\", \"https\"]:\n        return False\n    # only input characters for initiatig query and/or fragments if necessary\n    port_character = \":\" if url_parsed.port is not None else \"\"\n    query_character = \"?\" if url_parsed.query is not None else \"\"\n    fragment_character = \"#\" if url_parsed.fragment is not None else \"\"\n    url_pieces = [\n        url_parsed.scheme,\n        \"://\",\n        url_parsed.host,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "fragment_character = \"#\" if url_parsed.fragment is not None else \"\"",
        "context": "        return False\n    # only input characters for initiatig query and/or fragments if necessary\n    port_character = \":\" if url_parsed.port is not None else \"\"\n    query_character = \"?\" if url_parsed.query is not None else \"\"\n    fragment_character = \"#\" if url_parsed.fragment is not None else \"\"\n    url_pieces = [\n        url_parsed.scheme,\n        \"://\",\n        url_parsed.host,\n        port_character,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "url_pieces = [",
        "context": "    # only input characters for initiatig query and/or fragments if necessary\n    port_character = \":\" if url_parsed.port is not None else \"\"\n    query_character = \"?\" if url_parsed.query is not None else \"\"\n    fragment_character = \"#\" if url_parsed.fragment is not None else \"\"\n    url_pieces = [\n        url_parsed.scheme,\n        \"://\",\n        url_parsed.host,\n        port_character,\n        url_parsed.port,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 98,
        "coloffset": 4,
        "linematch": "url_reassembled = \"\"",
        "context": "        url_parsed.fragment,\n    ]\n    # convert every item to a string and piece the url back together\n    # to make sure it matches what was given\n    url_reassembled = \"\"\n    for url_piece in url_pieces:\n        if url_piece is not None:\n            url_reassembled += str(url_piece)\n    # determine if parsed and reconstructed url matches original\n    return str(parse_url(url)).lower() == url_reassembled.lower()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "for url_piece in url_pieces:",
        "context": "    ]\n    # convert every item to a string and piece the url back together\n    # to make sure it matches what was given\n    url_reassembled = \"\"\n    for url_piece in url_pieces:\n        if url_piece is not None:\n            url_reassembled += str(url_piece)\n    # determine if parsed and reconstructed url matches original\n    return str(parse_url(url)).lower() == url_reassembled.lower()\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 103,
        "coloffset": 4,
        "linematch": "return str(parse_url(url)).lower() == url_reassembled.lower()",
        "context": "    for url_piece in url_pieces:\n        if url_piece is not None:\n            url_reassembled += str(url_piece)\n    # determine if parsed and reconstructed url matches original\n    return str(parse_url(url)).lower() == url_reassembled.lower()\n\n\ndef total_amount_passed(check_status_list: list[bool]) -> tuple[int, int, float]:\n    \"\"\"Calculate amount of checks passed in analyze\"\"\"\n    # attempt calculations for percentage of checks passed",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1365",
        "line": 95,
        "description": [
          "    console.print(\":sparkles: Finished running test suite for the specified program\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "extract_description",
    "function_scope": "19-25",
    "patterns": [
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "if \"description\" in check:",
        "context": "def extract_description(check: Dict[str, Union[str, Dict[str, int]]]) -> str:\n    \"\"\"Extract the description that may optionally be stored in a check.\"\"\"\n    # the attribute is not None and thus the function\n    # should create the labelled attribute out of it\n    if \"description\" in check:\n        return str(check[\"description\"])\n    return \"\"\n\n\ndef create_attribute_label(attribute: Union[str, int, None], label: str) -> str:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 19,
        "coloffset": 0,
        "linematch": "def extract_description(check: Dict[str, Union[str, Dict[str, int]]]) -> str:",
        "context": "    max_count = check.get(\"count\", {}).get(\"max\")  # type: ignore\n    return (min_count, max_count)\n\n\ndef extract_description(check: Dict[str, Union[str, Dict[str, int]]]) -> str:\n    \"\"\"Extract the description that may optionally be stored in a check.\"\"\"\n    # the attribute is not None and thus the function\n    # should create the labelled attribute out of it\n    if \"description\" in check:\n        return str(check[\"description\"])",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "\"\"\"Extract the description that may optionally be stored in a check.\"\"\"",
        "context": "    return (min_count, max_count)\n\n\ndef extract_description(check: Dict[str, Union[str, Dict[str, int]]]) -> str:\n    \"\"\"Extract the description that may optionally be stored in a check.\"\"\"\n    # the attribute is not None and thus the function\n    # should create the labelled attribute out of it\n    if \"description\" in check:\n        return str(check[\"description\"])\n    return \"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "if \"description\" in check:",
        "context": "def extract_description(check: Dict[str, Union[str, Dict[str, int]]]) -> str:\n    \"\"\"Extract the description that may optionally be stored in a check.\"\"\"\n    # the attribute is not None and thus the function\n    # should create the labelled attribute out of it\n    if \"description\" in check:\n        return str(check[\"description\"])\n    return \"\"\n\n\ndef create_attribute_label(attribute: Union[str, int, None], label: str) -> str:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "return \"\"",
        "context": "    # the attribute is not None and thus the function\n    # should create the labelled attribute out of it\n    if \"description\" in check:\n        return str(check[\"description\"])\n    return \"\"\n\n\ndef create_attribute_label(attribute: Union[str, int, None], label: str) -> str:\n    \"\"\"Create an attribute label string for display as long as it is not null.\"\"\"\n    # define an empty attribute string, which is",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #299",
        "line": 19,
        "description": [
          "console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "create_attribute_label",
    "function_scope": "28-37",
    "patterns": [
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "if attribute:",
        "context": "    # the default in the case when attribute is None\n    labeled_attribute = \"\"\n    # the attribute is not None and thus the function\n    # should create the labelled attribute out of it\n    if attribute:\n        labeled_attribute = f\"{label} = {attribute}\"\n    return labeled_attribute\n\n\ndef join_attribute_labels(attribute_labels: List[str]) -> str:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 28,
        "coloffset": 0,
        "linematch": "def create_attribute_label(attribute: Union[str, int, None], label: str) -> str:",
        "context": "        return str(check[\"description\"])\n    return \"\"\n\n\ndef create_attribute_label(attribute: Union[str, int, None], label: str) -> str:\n    \"\"\"Create an attribute label string for display as long as it is not null.\"\"\"\n    # define an empty attribute string, which is\n    # the default in the case when attribute is None\n    labeled_attribute = \"\"\n    # the attribute is not None and thus the function",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "\"\"\"Create an attribute label string for display as long as it is not null.\"\"\"",
        "context": "    return \"\"\n\n\ndef create_attribute_label(attribute: Union[str, int, None], label: str) -> str:\n    \"\"\"Create an attribute label string for display as long as it is not null.\"\"\"\n    # define an empty attribute string, which is\n    # the default in the case when attribute is None\n    labeled_attribute = \"\"\n    # the attribute is not None and thus the function\n    # should create the labelled attribute out of it",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "labeled_attribute = \"\"",
        "context": "def create_attribute_label(attribute: Union[str, int, None], label: str) -> str:\n    \"\"\"Create an attribute label string for display as long as it is not null.\"\"\"\n    # define an empty attribute string, which is\n    # the default in the case when attribute is None\n    labeled_attribute = \"\"\n    # the attribute is not None and thus the function\n    # should create the labelled attribute out of it\n    if attribute:\n        labeled_attribute = f\"{label} = {attribute}\"\n    return labeled_attribute",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "if attribute:",
        "context": "    # the default in the case when attribute is None\n    labeled_attribute = \"\"\n    # the attribute is not None and thus the function\n    # should create the labelled attribute out of it\n    if attribute:\n        labeled_attribute = f\"{label} = {attribute}\"\n    return labeled_attribute\n\n\ndef join_attribute_labels(attribute_labels: List[str]) -> str:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "return labeled_attribute",
        "context": "    # the attribute is not None and thus the function\n    # should create the labelled attribute out of it\n    if attribute:\n        labeled_attribute = f\"{label} = {attribute}\"\n    return labeled_attribute\n\n\ndef join_attribute_labels(attribute_labels: List[str]) -> str:\n    \"\"\"Join all of the attribute labels in a comma-separated list.\"\"\"\n    # start the joined attribute labels with the empty string,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "join_attribute_labels",
    "function_scope": "40-56",
    "patterns": [
      {
        "lineno": 52,
        "coloffset": 8,
        "linematch": "if i > 0:",
        "context": "    # comma and space after it\n    for i, attribute_label in enumerate(attribute_labels):\n        # only add the comma and the space when the for loop\n        # is not dealing with the final value in the list of labels\n        if i > 0:\n            joined_attribute_labels += constants.markers.Comma_Space\n        # append the new attribute label to the running list\n        joined_attribute_labels += attribute_label  # type: ignore\n    return joined_attribute_labels\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 40,
        "coloffset": 0,
        "linematch": "def join_attribute_labels(attribute_labels: List[str]) -> str:",
        "context": "        labeled_attribute = f\"{label} = {attribute}\"\n    return labeled_attribute\n\n\ndef join_attribute_labels(attribute_labels: List[str]) -> str:\n    \"\"\"Join all of the attribute labels in a comma-separated list.\"\"\"\n    # start the joined attribute labels with the empty string,\n    # which is what it will be by default as well\n    joined_attribute_labels = constants.markers.Empty_String\n    # incrementally create the list of labelled attributes,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "\"\"\"Join all of the attribute labels in a comma-separated list.\"\"\"",
        "context": "    return labeled_attribute\n\n\ndef join_attribute_labels(attribute_labels: List[str]) -> str:\n    \"\"\"Join all of the attribute labels in a comma-separated list.\"\"\"\n    # start the joined attribute labels with the empty string,\n    # which is what it will be by default as well\n    joined_attribute_labels = constants.markers.Empty_String\n    # incrementally create the list of labelled attributes,\n    # separating each one with a comma and a space and",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "joined_attribute_labels = constants.markers.Empty_String",
        "context": "def join_attribute_labels(attribute_labels: List[str]) -> str:\n    \"\"\"Join all of the attribute labels in a comma-separated list.\"\"\"\n    # start the joined attribute labels with the empty string,\n    # which is what it will be by default as well\n    joined_attribute_labels = constants.markers.Empty_String\n    # incrementally create the list of labelled attributes,\n    # separating each one with a comma and a space and\n    # ensuring that the last one does not have a trailing\n    # comma and space after it\n    for i, attribute_label in enumerate(attribute_labels):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "for i, attribute_label in enumerate(attribute_labels):",
        "context": "    # incrementally create the list of labelled attributes,\n    # separating each one with a comma and a space and\n    # ensuring that the last one does not have a trailing\n    # comma and space after it\n    for i, attribute_label in enumerate(attribute_labels):\n        # only add the comma and the space when the for loop\n        # is not dealing with the final value in the list of labels\n        if i > 0:\n            joined_attribute_labels += constants.markers.Comma_Space\n        # append the new attribute label to the running list",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "return joined_attribute_labels",
        "context": "        if i > 0:\n            joined_attribute_labels += constants.markers.Comma_Space\n        # append the new attribute label to the running list\n        joined_attribute_labels += attribute_label  # type: ignore\n    return joined_attribute_labels\n\n\ndef is_checkable(min_value: Union[int, None], max_value: Union[int, None]) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    if min_value is None and max_value is None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "is_checkable",
    "function_scope": "59-63",
    "patterns": [
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "if min_value is None and max_value is None:",
        "context": "\n\ndef is_checkable(min_value: Union[int, None], max_value: Union[int, None]) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    if min_value is None and max_value is None:\n        return False\n    return True\n\n\ndef is_in_closed_interval(value: int, min_value: int, max_value: int) -> bool:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 59,
        "coloffset": 0,
        "linematch": "def is_checkable(min_value: Union[int, None], max_value: Union[int, None]) -> bool:",
        "context": "        joined_attribute_labels += attribute_label  # type: ignore\n    return joined_attribute_labels\n\n\ndef is_checkable(min_value: Union[int, None], max_value: Union[int, None]) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    if min_value is None and max_value is None:\n        return False\n    return True\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 60,
        "coloffset": 4,
        "linematch": "\"\"\"Help to see if the value is in the closed interval.\"\"\"",
        "context": "    return joined_attribute_labels\n\n\ndef is_checkable(min_value: Union[int, None], max_value: Union[int, None]) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    if min_value is None and max_value is None:\n        return False\n    return True\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "if min_value is None and max_value is None:",
        "context": "\n\ndef is_checkable(min_value: Union[int, None], max_value: Union[int, None]) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    if min_value is None and max_value is None:\n        return False\n    return True\n\n\ndef is_in_closed_interval(value: int, min_value: int, max_value: int) -> bool:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "return True",
        "context": "def is_checkable(min_value: Union[int, None], max_value: Union[int, None]) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    if min_value is None and max_value is None:\n        return False\n    return True\n\n\ndef is_in_closed_interval(value: int, min_value: int, max_value: int) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    return min(max_value, value) == value and max(min_value, value) == value",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "check_match_count",
    "function_scope": "71-94",
    "patterns": [
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "if min_value is None and max_value is None:",
        "context": "    \"\"\"Confirm that the count is between min_value and max_value.\"\"\"\n    # Overall description: if min_value is not None then count must be >= min_value.\n    # If max_value is not None then count must be <= max_value\n    # both of the values are None and thus the comparision is vacuously true\n    if min_value is None and max_value is None:\n        return True\n    # both are not None and thus the count must be in the closed interval\n    if min_value is not None and max_value is not None:\n        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 81,
        "coloffset": 4,
        "linematch": "if min_value is not None and max_value is not None:",
        "context": "    # both of the values are None and thus the comparision is vacuously true\n    if min_value is None and max_value is None:\n        return True\n    # both are not None and thus the count must be in the closed interval\n    if min_value is not None and max_value is not None:\n        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None\n    # if min_value is not None, then confirm that it is greater than or equal\n    if min_value is not None:\n        if count >= min_value:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 85,
        "coloffset": 4,
        "linematch": "if min_value is not None:",
        "context": "    if min_value is not None and max_value is not None:\n        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None\n    # if min_value is not None, then confirm that it is greater than or equal\n    if min_value is not None:\n        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 89,
        "coloffset": 4,
        "linematch": "if max_value is not None:",
        "context": "    if min_value is not None:\n        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:\n            return True\n    # if none of those conditions were true, then the count is not\n    # between the minimum and the maximum value, inclusively\n    return False",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 86,
        "coloffset": 8,
        "linematch": "if count >= min_value:",
        "context": "        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None\n    # if min_value is not None, then confirm that it is greater than or equal\n    if min_value is not None:\n        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:\n            return True",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 90,
        "coloffset": 8,
        "linematch": "if count <= max_value:",
        "context": "        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:\n            return True\n    # if none of those conditions were true, then the count is not\n    # between the minimum and the maximum value, inclusively\n    return False\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 86,
        "coloffset": 8,
        "linematch": "if count >= min_value:",
        "context": "        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None\n    # if min_value is not None, then confirm that it is greater than or equal\n    if min_value is not None:\n        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:\n            return True",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 90,
        "coloffset": 8,
        "linematch": "if count <= max_value:",
        "context": "        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:\n            return True\n    # if none of those conditions were true, then the count is not\n    # between the minimum and the maximum value, inclusively\n    return False\n",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 71,
        "coloffset": 0,
        "linematch": "def check_match_count(",
        "context": "    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    return min(max_value, value) == value and max(min_value, value) == value\n\n\ndef check_match_count(\n    count: int, min_value: Union[int, None] = None, max_value: Union[int, None] = None\n) -> bool:\n    \"\"\"Confirm that the count is between min_value and max_value.\"\"\"\n    # Overall description: if min_value is not None then count must be >= min_value.\n    # If max_value is not None then count must be <= max_value",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 81,
        "coloffset": 4,
        "linematch": "if min_value is not None and max_value is not None:",
        "context": "    # both of the values are None and thus the comparision is vacuously true\n    if min_value is None and max_value is None:\n        return True\n    # both are not None and thus the count must be in the closed interval\n    if min_value is not None and max_value is not None:\n        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None\n    # if min_value is not None, then confirm that it is greater than or equal\n    if min_value is not None:\n        if count >= min_value:",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 85,
        "coloffset": 4,
        "linematch": "if min_value is not None:",
        "context": "    if min_value is not None and max_value is not None:\n        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None\n    # if min_value is not None, then confirm that it is greater than or equal\n    if min_value is not None:\n        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 89,
        "coloffset": 4,
        "linematch": "if max_value is not None:",
        "context": "    if min_value is not None:\n        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:\n            return True\n    # if none of those conditions were true, then the count is not\n    # between the minimum and the maximum value, inclusively\n    return False",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 86,
        "coloffset": 8,
        "linematch": "if count >= min_value:",
        "context": "        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None\n    # if min_value is not None, then confirm that it is greater than or equal\n    if min_value is not None:\n        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:\n            return True",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 90,
        "coloffset": 8,
        "linematch": "if count <= max_value:",
        "context": "        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:\n            return True\n    # if none of those conditions were true, then the count is not\n    # between the minimum and the maximum value, inclusively\n    return False\n",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 74,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the count is between min_value and max_value.\"\"\"",
        "context": "\ndef check_match_count(\n    count: int, min_value: Union[int, None] = None, max_value: Union[int, None] = None\n) -> bool:\n    \"\"\"Confirm that the count is between min_value and max_value.\"\"\"\n    # Overall description: if min_value is not None then count must be >= min_value.\n    # If max_value is not None then count must be <= max_value\n    # both of the values are None and thus the comparision is vacuously true\n    if min_value is None and max_value is None:\n        return True",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "if min_value is None and max_value is None:",
        "context": "    \"\"\"Confirm that the count is between min_value and max_value.\"\"\"\n    # Overall description: if min_value is not None then count must be >= min_value.\n    # If max_value is not None then count must be <= max_value\n    # both of the values are None and thus the comparision is vacuously true\n    if min_value is None and max_value is None:\n        return True\n    # both are not None and thus the count must be in the closed interval\n    if min_value is not None and max_value is not None:\n        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 81,
        "coloffset": 4,
        "linematch": "if min_value is not None and max_value is not None:",
        "context": "    # both of the values are None and thus the comparision is vacuously true\n    if min_value is None and max_value is None:\n        return True\n    # both are not None and thus the count must be in the closed interval\n    if min_value is not None and max_value is not None:\n        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None\n    # if min_value is not None, then confirm that it is greater than or equal\n    if min_value is not None:\n        if count >= min_value:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 85,
        "coloffset": 4,
        "linematch": "if min_value is not None:",
        "context": "    if min_value is not None and max_value is not None:\n        return is_in_closed_interval(count, min_value, max_value)\n    # at this point, only one of the values might not be None\n    # if min_value is not None, then confirm that it is greater than or equal\n    if min_value is not None:\n        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 89,
        "coloffset": 4,
        "linematch": "if max_value is not None:",
        "context": "    if min_value is not None:\n        if count >= min_value:\n            return True\n    # if max_value is not None, then confirm that it is less than or equal\n    if max_value is not None:\n        if count <= max_value:\n            return True\n    # if none of those conditions were true, then the count is not\n    # between the minimum and the maximum value, inclusively\n    return False",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "return False",
        "context": "        if count <= max_value:\n            return True\n    # if none of those conditions were true, then the count is not\n    # between the minimum and the maximum value, inclusively\n    return False\n\n\ndef make_checks_status_message(check_status: bool) -> str:\n    \"\"\"Make a check status message in human readable format.\"\"\"\n    if check_status:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 71,
        "coloffset": 0,
        "linematch": "def check_match_count(",
        "context": "    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    return min(max_value, value) == value and max(min_value, value) == value\n\n\ndef check_match_count(\n    count: int, min_value: Union[int, None] = None, max_value: Union[int, None] = None\n) -> bool:\n    \"\"\"Confirm that the count is between min_value and max_value.\"\"\"\n    # Overall description: if min_value is not None then count must be >= min_value.\n    # If max_value is not None then count must be <= max_value",
        "pattern": ".//FunctionDef[count(body//Return) > 2]",
        "check_id": "MRET001",
        "check_name": "multiple-returns-in-function"
      },
      {
        "lineno": 71,
        "coloffset": 0,
        "linematch": "def check_match_count(",
        "context": "    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    return min(max_value, value) == value and max(min_value, value) == value\n\n\ndef check_match_count(\n    count: int, min_value: Union[int, None] = None, max_value: Union[int, None] = None\n) -> bool:\n    \"\"\"Confirm that the count is between min_value and max_value.\"\"\"\n    # Overall description: if min_value is not None then count must be >= min_value.\n    # If max_value is not None then count must be <= max_value",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 71,
        "coloffset": 0,
        "linematch": "def check_match_count(",
        "context": "    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    return min(max_value, value) == value and max(min_value, value) == value\n\n\ndef check_match_count(\n    count: int, min_value: Union[int, None] = None, max_value: Union[int, None] = None\n) -> bool:\n    \"\"\"Confirm that the count is between min_value and max_value.\"\"\"\n    # Overall description: if min_value is not None then count must be >= min_value.\n    # If max_value is not None then count must be <= max_value",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "make_checks_status_message",
    "function_scope": "97-103",
    "patterns": [
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "if check_status:",
        "context": "\n\ndef make_checks_status_message(check_status: bool) -> str:\n    \"\"\"Make a check status message in human readable format.\"\"\"\n    if check_status:\n        return f\":smiley: Did the check pass? {util.get_human_readable_boolean(check_status)}\"\n    return (\n        f\":worried: Did the check pass? {util.get_human_readable_boolean(check_status)}\"\n    )\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 97,
        "coloffset": 0,
        "linematch": "def make_checks_status_message(check_status: bool) -> str:",
        "context": "    # between the minimum and the maximum value, inclusively\n    return False\n\n\ndef make_checks_status_message(check_status: bool) -> str:\n    \"\"\"Make a check status message in human readable format.\"\"\"\n    if check_status:\n        return f\":smiley: Did the check pass? {util.get_human_readable_boolean(check_status)}\"\n    return (\n        f\":worried: Did the check pass? {util.get_human_readable_boolean(check_status)}\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 98,
        "coloffset": 4,
        "linematch": "\"\"\"Make a check status message in human readable format.\"\"\"",
        "context": "    return False\n\n\ndef make_checks_status_message(check_status: bool) -> str:\n    \"\"\"Make a check status message in human readable format.\"\"\"\n    if check_status:\n        return f\":smiley: Did the check pass? {util.get_human_readable_boolean(check_status)}\"\n    return (\n        f\":worried: Did the check pass? {util.get_human_readable_boolean(check_status)}\"\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "if check_status:",
        "context": "\n\ndef make_checks_status_message(check_status: bool) -> str:\n    \"\"\"Make a check status message in human readable format.\"\"\"\n    if check_status:\n        return f\":smiley: Did the check pass? {util.get_human_readable_boolean(check_status)}\"\n    return (\n        f\":worried: Did the check pass? {util.get_human_readable_boolean(check_status)}\"\n    )\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 101,
        "coloffset": 4,
        "linematch": "return (",
        "context": "def make_checks_status_message(check_status: bool) -> str:\n    \"\"\"Make a check status message in human readable format.\"\"\"\n    if check_status:\n        return f\":smiley: Did the check pass? {util.get_human_readable_boolean(check_status)}\"\n    return (\n        f\":worried: Did the check pass? {util.get_human_readable_boolean(check_status)}\"\n    )\n\n\ndef fix_check_criterion(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "fix_check_criterion",
    "function_scope": "106-122",
    "patterns": [
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "if criterion is not None:",
        "context": "    # the converted criterion's default is an empty string\n    new_criterion: Union[str, int] = \"\"\n    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:\n            new_criterion = criterion.value\n        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 116,
        "coloffset": 8,
        "linematch": "if type(criterion) is enumerations.FilterableAttribute:",
        "context": "    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:\n            new_criterion = criterion.value\n        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly\n        else:\n            new_criterion = criterion  # type: ignore",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 116,
        "coloffset": 8,
        "linematch": "if type(criterion) is enumerations.FilterableAttribute:",
        "context": "    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:\n            new_criterion = criterion.value\n        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly\n        else:\n            new_criterion = criterion  # type: ignore",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 116,
        "coloffset": 11,
        "linematch": "if type(criterion) is enumerations.FilterableAttribute:",
        "context": "    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:\n            new_criterion = criterion.value\n        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly\n        else:\n            new_criterion = criterion  # type: ignore",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 116,
        "coloffset": 11,
        "linematch": "if type(criterion) is enumerations.FilterableAttribute:",
        "context": "    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:\n            new_criterion = criterion.value\n        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly\n        else:\n            new_criterion = criterion  # type: ignore",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 116,
        "coloffset": 11,
        "linematch": "if type(criterion) is enumerations.FilterableAttribute:",
        "context": "    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:\n            new_criterion = criterion.value\n        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly\n        else:\n            new_criterion = criterion  # type: ignore",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 116,
        "coloffset": 11,
        "linematch": "if type(criterion) is enumerations.FilterableAttribute:",
        "context": "    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:\n            new_criterion = criterion.value\n        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly\n        else:\n            new_criterion = criterion  # type: ignore",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 116,
        "coloffset": 11,
        "linematch": "if type(criterion) is enumerations.FilterableAttribute:",
        "context": "    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:\n            new_criterion = criterion.value\n        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly\n        else:\n            new_criterion = criterion  # type: ignore",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 106,
        "coloffset": 0,
        "linematch": "def fix_check_criterion(",
        "context": "        f\":worried: Did the check pass? {util.get_human_readable_boolean(check_status)}\"\n    )\n\n\ndef fix_check_criterion(\n    criterion: Union[enumerations.FilterableAttribute, str, int]\n) -> Union[str, int]:\n    \"\"\"Remove null values from a criterion.\"\"\"\n    # the converted criterion's default is an empty string\n    new_criterion: Union[str, int] = \"\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 116,
        "coloffset": 8,
        "linematch": "if type(criterion) is enumerations.FilterableAttribute:",
        "context": "    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:\n            new_criterion = criterion.value\n        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly\n        else:\n            new_criterion = criterion  # type: ignore",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 109,
        "coloffset": 4,
        "linematch": "\"\"\"Remove null values from a criterion.\"\"\"",
        "context": "\ndef fix_check_criterion(\n    criterion: Union[enumerations.FilterableAttribute, str, int]\n) -> Union[str, int]:\n    \"\"\"Remove null values from a criterion.\"\"\"\n    # the converted criterion's default is an empty string\n    new_criterion: Union[str, int] = \"\"\n    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 111,
        "coloffset": 4,
        "linematch": "new_criterion: Union[str, int] = \"\"",
        "context": "    criterion: Union[enumerations.FilterableAttribute, str, int]\n) -> Union[str, int]:\n    \"\"\"Remove null values from a criterion.\"\"\"\n    # the converted criterion's default is an empty string\n    new_criterion: Union[str, int] = \"\"\n    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "if criterion is not None:",
        "context": "    # the converted criterion's default is an empty string\n    new_criterion: Union[str, int] = \"\"\n    # if the criterion is not None, then it should either be\n    # the value in the enumeration or the value of a string or int\n    if criterion is not None:\n        # the criterion is an enum and thus the value must be extracted\n        if type(criterion) is enumerations.FilterableAttribute:\n            new_criterion = criterion.value\n        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 122,
        "coloffset": 4,
        "linematch": "return new_criterion",
        "context": "        # the criterion is not an enum and thus it must be\n        # an int or a string that can be stored directly\n        else:\n            new_criterion = criterion  # type: ignore\n    return new_criterion",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1367",
        "line": 122,
        "description": [
          "        if directory not in grouped_files:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "display_final_diagnostic_message",
    "function_scope": "87-101",
    "patterns": [
      {
        "lineno": 92,
        "coloffset": 4,
        "linematch": "if publish:",
        "context": "    \"\"\"Output the final diagnostic message before control is given to a different tool.\"\"\"\n    # output a \"final\" prompt about either the publication platform of a reminder\n    # that the remainder of the output comes from running a local datasette instance\n    # the database will be published to an external platform\n    if publish:\n        output.console.print(\n            f\":sparkles: Debugging output from publishing datasette to '{datasette_platform}':\"\n        )\n    # the database will be displayed through a localhost-based server\n    else:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 87,
        "coloffset": 0,
        "linematch": "def display_final_diagnostic_message(datasette_platform: str, publish: bool):",
        "context": "    # note that sqlite-utils does not support the enabling of\n    # full-text search on the view called chasten_complete\n\n\ndef display_final_diagnostic_message(datasette_platform: str, publish: bool):\n    \"\"\"Output the final diagnostic message before control is given to a different tool.\"\"\"\n    # output a \"final\" prompt about either the publication platform of a reminder\n    # that the remainder of the output comes from running a local datasette instance\n    # the database will be published to an external platform\n    if publish:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 88,
        "coloffset": 4,
        "linematch": "\"\"\"Output the final diagnostic message before control is given to a different tool.\"\"\"",
        "context": "    # full-text search on the view called chasten_complete\n\n\ndef display_final_diagnostic_message(datasette_platform: str, publish: bool):\n    \"\"\"Output the final diagnostic message before control is given to a different tool.\"\"\"\n    # output a \"final\" prompt about either the publication platform of a reminder\n    # that the remainder of the output comes from running a local datasette instance\n    # the database will be published to an external platform\n    if publish:\n        output.console.print(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 92,
        "coloffset": 4,
        "linematch": "if publish:",
        "context": "    \"\"\"Output the final diagnostic message before control is given to a different tool.\"\"\"\n    # output a \"final\" prompt about either the publication platform of a reminder\n    # that the remainder of the output comes from running a local datasette instance\n    # the database will be published to an external platform\n    if publish:\n        output.console.print(\n            f\":sparkles: Debugging output from publishing datasette to '{datasette_platform}':\"\n        )\n    # the database will be displayed through a localhost-based server\n    else:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 101,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "    else:\n        output.console.print(\n            \":sparkles: Debugging output from the local datasette server:\"\n        )\n    output.console.print()\n\n\ndef display_datasette_details(\n    label: str,\n    virtual_env_location: str,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1365",
        "line": 95,
        "description": [
          "    console.print(\":sparkles: Finished running test suite for the specified program\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "display_datasette_details",
    "function_scope": "104-128",
    "patterns": [
      {
        "lineno": 120,
        "coloffset": 4,
        "linematch": "if executable_path:",
        "context": "    output.console.print(label)\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Venv: '{output.shorten_file_name(str(virtual_env_location), 120)}'\"\n    )\n    if executable_path:\n        output.console.print(\n            f\"{constants.markers.Indent}{small_bullet_unicode} Program: '{output.shorten_file_name(executable_path, 120)}'\"\n        )\n    else:\n        output.console.print(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 104,
        "coloffset": 0,
        "linematch": "def display_datasette_details(",
        "context": "        )\n    output.console.print()\n\n\ndef display_datasette_details(\n    label: str,\n    virtual_env_location: str,\n    executable_path: str,\n    full_executable_name: str,\n) -> None:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 110,
        "coloffset": 4,
        "linematch": "\"\"\"Display details about the current datasette configuration.\"\"\"",
        "context": "    virtual_env_location: str,\n    executable_path: str,\n    full_executable_name: str,\n) -> None:\n    \"\"\"Display details about the current datasette configuration.\"\"\"\n    # output diagnostic information about the datasette instance; note\n    # that the output must appear here and not from the calling function\n    # because once the datasette instance starts the chasten tool can\n    # no longer produce output in the console\n    output.console.print()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "    # output diagnostic information about the datasette instance; note\n    # that the output must appear here and not from the calling function\n    # because once the datasette instance starts the chasten tool can\n    # no longer produce output in the console\n    output.console.print()\n    output.console.print(label)\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Venv: '{output.shorten_file_name(str(virtual_env_location), 120)}'\"\n    )\n    if executable_path:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 116,
        "coloffset": 4,
        "linematch": "output.console.print(label)",
        "context": "    # that the output must appear here and not from the calling function\n    # because once the datasette instance starts the chasten tool can\n    # no longer produce output in the console\n    output.console.print()\n    output.console.print(label)\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Venv: '{output.shorten_file_name(str(virtual_env_location), 120)}'\"\n    )\n    if executable_path:\n        output.console.print(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 117,
        "coloffset": 4,
        "linematch": "output.console.print(",
        "context": "    # because once the datasette instance starts the chasten tool can\n    # no longer produce output in the console\n    output.console.print()\n    output.console.print(label)\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Venv: '{output.shorten_file_name(str(virtual_env_location), 120)}'\"\n    )\n    if executable_path:\n        output.console.print(\n            f\"{constants.markers.Indent}{small_bullet_unicode} Program: '{output.shorten_file_name(executable_path, 120)}'\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 120,
        "coloffset": 4,
        "linematch": "if executable_path:",
        "context": "    output.console.print(label)\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Venv: '{output.shorten_file_name(str(virtual_env_location), 120)}'\"\n    )\n    if executable_path:\n        output.console.print(\n            f\"{constants.markers.Indent}{small_bullet_unicode} Program: '{output.shorten_file_name(executable_path, 120)}'\"\n        )\n    else:\n        output.console.print(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 128,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "    else:\n        output.console.print(\n            f\"{constants.markers.Indent}{small_bullet_unicode} Cannot find: '{output.shorten_file_name(full_executable_name, 120)}'\"\n        )\n    output.console.print()\n\n\ndef start_datasette_server(  # noqa: PLR0912, PLR0913\n    database_path: Path,\n    datasette_metadata: Path,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #304",
        "line": 123,
        "description": [
          "            grouped_files[directory] = []"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1367",
        "line": 122,
        "description": [
          "        if directory not in grouped_files:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "start_datasette_server",
    "function_scope": "131-267",
    "patterns": [
      {
        "lineno": 160,
        "coloffset": 4,
        "linematch": "if publish:",
        "context": "    # output diagnostic information about the datasette instance; note\n    # that the output must appear here and not from the calling function\n    # because once the datasette instance starts the chasten tool can\n    # no longer produce output in the console\n    if publish:\n        label = \":sparkles: Details for datasette publishing:\"\n    else:\n        label = \":sparkles: Details for datasette startup:\"\n    display_datasette_details(\n        label,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 172,
        "coloffset": 4,
        "linematch": "if not found_executable:",
        "context": "        full_executable_name,\n    )\n    # since it was not possible to find the executable for datasette, display and\n    # error message and then exit this function since no further steps are possible\n    if not found_executable:\n        output.console.print(\n            f\":person_shrugging: Was not able to find {constants.datasette.Datasette_Executable}\"\n        )\n        return None\n    # run the localhost server because the",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 179,
        "coloffset": 4,
        "linematch": "if not publish:",
        "context": "        )\n        return None\n    # run the localhost server because the\n    # function was not asked to publish a database\n    if not publish:\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        if metadata is not None:\n            cmd = [\n                str(full_executable_name),",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 182,
        "coloffset": 8,
        "linematch": "if metadata is not None:",
        "context": "    # function was not asked to publish a database\n    if not publish:\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        if metadata is not None:\n            cmd = [\n                str(full_executable_name),\n                str(database_path),\n                \"-m\",\n                str(metadata),",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 204,
        "coloffset": 4,
        "linematch": "elif publish:",
        "context": "        # there is debugging output in the console to indicate this option.\n        proc = subprocess.Popen(cmd)\n        proc.wait()\n    # publish the datasette instance to the chosen datasette platform\n    elif publish:\n        # get information about the datasette executable, confirming that\n        # it is available in the virtual environment created by chasten\n        (\n            found_publish_platform_executable,\n            publish_platform_executable,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 214,
        "coloffset": 8,
        "linematch": "if not found_publish_platform_executable:",
        "context": "        ) = filesystem.can_find_executable(util.executable_name(datasette_platform))\n        # was not able to find the fly or vercel executable (the person using this\n        # program has to install separately, following the instructions for the\n        # datasette-publish-fly plugin) and thus need to exit and not proceed\n        if not found_publish_platform_executable:\n            output.console.print(\n                f\":person_shrugging: Was not able to find '{datasette_platform}'\"\n            )\n            return None\n        # was able to find the fly or vercel executable that will support the",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 231,
        "coloffset": 8,
        "linematch": "if datasette_platform == constants.chasten.Executable_Fly:",
        "context": "        # create the customized running argument for either fly or vercel; note\n        # that these programs take different arguments for specifying the name\n        # of the application as it will be deployed on the platform\n        running_argument = \"\"\n        if datasette_platform == constants.chasten.Executable_Fly:\n            running_argument = \"--app=chasten\"\n        elif datasette_platform == constants.chasten.Executable_Vercel:\n            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 238,
        "coloffset": 8,
        "linematch": "if metadata is not None:",
        "context": "            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        # there was a metadata parameter, so include it\n        if metadata is not None:\n            cmd = [\n                str(full_executable_name),\n                \"publish\",\n                datasette_platform,\n                str(database_path),",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 233,
        "coloffset": 8,
        "linematch": "elif datasette_platform == constants.chasten.Executable_Vercel:",
        "context": "        # of the application as it will be deployed on the platform\n        running_argument = \"\"\n        if datasette_platform == constants.chasten.Executable_Fly:\n            running_argument = \"--app=chasten\"\n        elif datasette_platform == constants.chasten.Executable_Vercel:\n            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        # there was a metadata parameter, so include it\n        if metadata is not None:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 182,
        "coloffset": 8,
        "linematch": "if metadata is not None:",
        "context": "    # function was not asked to publish a database\n    if not publish:\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        if metadata is not None:\n            cmd = [\n                str(full_executable_name),\n                str(database_path),\n                \"-m\",\n                str(metadata),",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 214,
        "coloffset": 8,
        "linematch": "if not found_publish_platform_executable:",
        "context": "        ) = filesystem.can_find_executable(util.executable_name(datasette_platform))\n        # was not able to find the fly or vercel executable (the person using this\n        # program has to install separately, following the instructions for the\n        # datasette-publish-fly plugin) and thus need to exit and not proceed\n        if not found_publish_platform_executable:\n            output.console.print(\n                f\":person_shrugging: Was not able to find '{datasette_platform}'\"\n            )\n            return None\n        # was able to find the fly or vercel executable that will support the",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 231,
        "coloffset": 8,
        "linematch": "if datasette_platform == constants.chasten.Executable_Fly:",
        "context": "        # create the customized running argument for either fly or vercel; note\n        # that these programs take different arguments for specifying the name\n        # of the application as it will be deployed on the platform\n        running_argument = \"\"\n        if datasette_platform == constants.chasten.Executable_Fly:\n            running_argument = \"--app=chasten\"\n        elif datasette_platform == constants.chasten.Executable_Vercel:\n            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 238,
        "coloffset": 8,
        "linematch": "if metadata is not None:",
        "context": "            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        # there was a metadata parameter, so include it\n        if metadata is not None:\n            cmd = [\n                str(full_executable_name),\n                \"publish\",\n                datasette_platform,\n                str(database_path),",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 233,
        "coloffset": 13,
        "linematch": "elif datasette_platform == constants.chasten.Executable_Vercel:",
        "context": "        # of the application as it will be deployed on the platform\n        running_argument = \"\"\n        if datasette_platform == constants.chasten.Executable_Fly:\n            running_argument = \"--app=chasten\"\n        elif datasette_platform == constants.chasten.Executable_Vercel:\n            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        # there was a metadata parameter, so include it\n        if metadata is not None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 233,
        "coloffset": 13,
        "linematch": "elif datasette_platform == constants.chasten.Executable_Vercel:",
        "context": "        # of the application as it will be deployed on the platform\n        running_argument = \"\"\n        if datasette_platform == constants.chasten.Executable_Fly:\n            running_argument = \"--app=chasten\"\n        elif datasette_platform == constants.chasten.Executable_Vercel:\n            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        # there was a metadata parameter, so include it\n        if metadata is not None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 131,
        "coloffset": 0,
        "linematch": "def start_datasette_server(  # noqa: PLR0912, PLR0913",
        "context": "        )\n    output.console.print()\n\n\ndef start_datasette_server(  # noqa: PLR0912, PLR0913\n    database_path: Path,\n    datasette_metadata: Path,\n    datasette_platform: str = enumerations.DatasettePublicationPlatform.FLY.value,\n    datasette_port: int = 8001,\n    publish: bool = False,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 172,
        "coloffset": 4,
        "linematch": "if not found_executable:",
        "context": "        full_executable_name,\n    )\n    # since it was not possible to find the executable for datasette, display and\n    # error message and then exit this function since no further steps are possible\n    if not found_executable:\n        output.console.print(\n            f\":person_shrugging: Was not able to find {constants.datasette.Datasette_Executable}\"\n        )\n        return None\n    # run the localhost server because the",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 179,
        "coloffset": 4,
        "linematch": "if not publish:",
        "context": "        )\n        return None\n    # run the localhost server because the\n    # function was not asked to publish a database\n    if not publish:\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        if metadata is not None:\n            cmd = [\n                str(full_executable_name),",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 231,
        "coloffset": 8,
        "linematch": "if datasette_platform == constants.chasten.Executable_Fly:",
        "context": "        # create the customized running argument for either fly or vercel; note\n        # that these programs take different arguments for specifying the name\n        # of the application as it will be deployed on the platform\n        running_argument = \"\"\n        if datasette_platform == constants.chasten.Executable_Fly:\n            running_argument = \"--app=chasten\"\n        elif datasette_platform == constants.chasten.Executable_Vercel:\n            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 238,
        "coloffset": 8,
        "linematch": "if metadata is not None:",
        "context": "            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        # there was a metadata parameter, so include it\n        if metadata is not None:\n            cmd = [\n                str(full_executable_name),\n                \"publish\",\n                datasette_platform,\n                str(database_path),",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 182,
        "coloffset": 8,
        "linematch": "if metadata is not None:",
        "context": "    # function was not asked to publish a database\n    if not publish:\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        if metadata is not None:\n            cmd = [\n                str(full_executable_name),\n                str(database_path),\n                \"-m\",\n                str(metadata),",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 204,
        "coloffset": 4,
        "linematch": "elif publish:",
        "context": "        # there is debugging output in the console to indicate this option.\n        proc = subprocess.Popen(cmd)\n        proc.wait()\n    # publish the datasette instance to the chosen datasette platform\n    elif publish:\n        # get information about the datasette executable, confirming that\n        # it is available in the virtual environment created by chasten\n        (\n            found_publish_platform_executable,\n            publish_platform_executable,",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 214,
        "coloffset": 8,
        "linematch": "if not found_publish_platform_executable:",
        "context": "        ) = filesystem.can_find_executable(util.executable_name(datasette_platform))\n        # was not able to find the fly or vercel executable (the person using this\n        # program has to install separately, following the instructions for the\n        # datasette-publish-fly plugin) and thus need to exit and not proceed\n        if not found_publish_platform_executable:\n            output.console.print(\n                f\":person_shrugging: Was not able to find '{datasette_platform}'\"\n            )\n            return None\n        # was able to find the fly or vercel executable that will support the",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 231,
        "coloffset": 8,
        "linematch": "if datasette_platform == constants.chasten.Executable_Fly:",
        "context": "        # create the customized running argument for either fly or vercel; note\n        # that these programs take different arguments for specifying the name\n        # of the application as it will be deployed on the platform\n        running_argument = \"\"\n        if datasette_platform == constants.chasten.Executable_Fly:\n            running_argument = \"--app=chasten\"\n        elif datasette_platform == constants.chasten.Executable_Vercel:\n            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 233,
        "coloffset": 8,
        "linematch": "elif datasette_platform == constants.chasten.Executable_Vercel:",
        "context": "        # of the application as it will be deployed on the platform\n        running_argument = \"\"\n        if datasette_platform == constants.chasten.Executable_Fly:\n            running_argument = \"--app=chasten\"\n        elif datasette_platform == constants.chasten.Executable_Vercel:\n            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        # there was a metadata parameter, so include it\n        if metadata is not None:",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 238,
        "coloffset": 8,
        "linematch": "if metadata is not None:",
        "context": "            running_argument = \"--project=chasten\"\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        # there was a metadata parameter, so include it\n        if metadata is not None:\n            cmd = [\n                str(full_executable_name),\n                \"publish\",\n                datasette_platform,\n                str(database_path),",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 139,
        "coloffset": 4,
        "linematch": "\"\"\"Start a local datasette server.\"\"\"",
        "context": "    datasette_port: int = 8001,\n    publish: bool = False,\n    OpSystem: str = \"Linux\",\n) -> None:\n    \"\"\"Start a local datasette server.\"\"\"\n    # define the name of the executable needed to run the server\n    # define the name of the file that contains datasette metadata;\n    # note that by default the metadata could be None and thus it\n    # will not be passed as a -m argument to the datasette program\n    metadata = datasette_metadata",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 144,
        "coloffset": 4,
        "linematch": "metadata = datasette_metadata",
        "context": "    # define the name of the executable needed to run the server\n    # define the name of the file that contains datasette metadata;\n    # note that by default the metadata could be None and thus it\n    # will not be passed as a -m argument to the datasette program\n    metadata = datasette_metadata\n    # identify the location at which the virtual environment exists;\n    # note that this is the location where executable dependencies of\n    # chasten will exist in a bin directory. For instance, the \"datasette\"\n    # executable that is a dependency of chasten can be found by starting\n    # the search from this location for the virtual environment.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 150,
        "coloffset": 4,
        "linematch": "full_executable_name = util.executable_name(",
        "context": "    # note that this is the location where executable dependencies of\n    # chasten will exist in a bin directory. For instance, the \"datasette\"\n    # executable that is a dependency of chasten can be found by starting\n    # the search from this location for the virtual environment.\n    full_executable_name = util.executable_name(\n        constants.datasette.Datasette_Executable, OpSystem\n    )\n    (found_executable, executable_path) = filesystem.can_find_executable(\n        full_executable_name\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 153,
        "coloffset": 4,
        "linematch": "(found_executable, executable_path) = filesystem.can_find_executable(",
        "context": "    # the search from this location for the virtual environment.\n    full_executable_name = util.executable_name(\n        constants.datasette.Datasette_Executable, OpSystem\n    )\n    (found_executable, executable_path) = filesystem.can_find_executable(\n        full_executable_name\n    )\n    # output diagnostic information about the datasette instance; note\n    # that the output must appear here and not from the calling function\n    # because once the datasette instance starts the chasten tool can",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 160,
        "coloffset": 4,
        "linematch": "if publish:",
        "context": "    # output diagnostic information about the datasette instance; note\n    # that the output must appear here and not from the calling function\n    # because once the datasette instance starts the chasten tool can\n    # no longer produce output in the console\n    if publish:\n        label = \":sparkles: Details for datasette publishing:\"\n    else:\n        label = \":sparkles: Details for datasette startup:\"\n    display_datasette_details(\n        label,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 164,
        "coloffset": 4,
        "linematch": "display_datasette_details(",
        "context": "    if publish:\n        label = \":sparkles: Details for datasette publishing:\"\n    else:\n        label = \":sparkles: Details for datasette startup:\"\n    display_datasette_details(\n        label,\n        sys.prefix,\n        str(executable_path),\n        full_executable_name,\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 172,
        "coloffset": 4,
        "linematch": "if not found_executable:",
        "context": "        full_executable_name,\n    )\n    # since it was not possible to find the executable for datasette, display and\n    # error message and then exit this function since no further steps are possible\n    if not found_executable:\n        output.console.print(\n            f\":person_shrugging: Was not able to find {constants.datasette.Datasette_Executable}\"\n        )\n        return None\n    # run the localhost server because the",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 179,
        "coloffset": 4,
        "linematch": "if not publish:",
        "context": "        )\n        return None\n    # run the localhost server because the\n    # function was not asked to publish a database\n    if not publish:\n        # the metadata parameter should not be passed to the datasette\n        # program if it was not specified as an option\n        if metadata is not None:\n            cmd = [\n                str(full_executable_name),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 131,
        "coloffset": 0,
        "linematch": "def start_datasette_server(  # noqa: PLR0912, PLR0913",
        "context": "        )\n    output.console.print()\n\n\ndef start_datasette_server(  # noqa: PLR0912, PLR0913\n    database_path: Path,\n    datasette_metadata: Path,\n    datasette_platform: str = enumerations.DatasettePublicationPlatform.FLY.value,\n    datasette_port: int = 8001,\n    publish: bool = False,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 131,
        "coloffset": 0,
        "linematch": "def start_datasette_server(  # noqa: PLR0912, PLR0913",
        "context": "        )\n    output.console.print()\n\n\ndef start_datasette_server(  # noqa: PLR0912, PLR0913\n    database_path: Path,\n    datasette_metadata: Path,\n    datasette_platform: str = enumerations.DatasettePublicationPlatform.FLY.value,\n    datasette_port: int = 8001,\n    publish: bool = False,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #305",
        "line": 143,
        "description": [
          "    grouped_files = group_files_by_directory(container)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #306",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #307",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #308",
        "line": 176,
        "description": [
          "        current_xpath_pattern = current_check.pattern"
        ],
        "failure": []
      },
      {
        "name": "Mutant #309",
        "line": 182,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #310",
        "line": 187,
        "description": [
          "        min_count = current_check.min"
        ],
        "failure": []
      },
      {
        "name": "Mutant #311",
        "line": 188,
        "description": [
          "        max_count = current_check.max"
        ],
        "failure": []
      },
      {
        "name": "Mutant #312",
        "line": 189,
        "description": [
          "        min_label = checks.create_attribute_label(min_count, constants.checks.Check_Min)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #313",
        "line": 190,
        "description": [
          "        max_label = checks.create_attribute_label(max_count, constants.checks.Check_Max)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #314",
        "line": 193,
        "description": [
          "        check_id = current_check.id"
        ],
        "failure": []
      },
      {
        "name": "Mutant #315",
        "line": 194,
        "description": [
          "        check_id_label = checks.create_attribute_label(check_id, constants.checks.Check_Id)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #316",
        "line": 195,
        "description": [
          "        check_name = current_check.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #317",
        "line": 196,
        "description": [
          "        check_name_label = checks.create_attribute_label(check_name, constants.checks.Check_Name)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #318",
        "line": 200,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #319",
        "line": 223,
        "description": [
          "                    position_end = current_match.position.lineno"
        ],
        "failure": []
      },
      {
        "name": "Mutant #320",
        "line": 225,
        "description": [
          "                    column_offset = current_match.position.col_offset"
        ],
        "failure": []
      },
      {
        "name": "Mutant #321",
        "line": 230,
        "description": [
          "                    all_lines = current_match.file_lines"
        ],
        "failure": []
      },
      {
        "name": "Mutant #322",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #323",
        "line": 240,
        "description": [
          "                    ]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #324",
        "line": 258,
        "description": [
          "                    )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1368",
        "line": 132,
        "description": [
          "    if len(file_name) > max_length:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1369",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1370",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1371",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1372",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1373",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1374",
        "line": 148,
        "description": [
          "        console.print(f\"{small_bullet_unicode} Directory: {directory}\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1375",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1376",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1377",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1378",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1379",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1380",
        "line": 156,
        "description": [
          "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1381",
        "line": 160,
        "description": [
          "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1382",
        "line": 169,
        "description": [
          "    if not verbose:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1383",
        "line": 171,
        "description": [
          "    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1384",
        "line": 175,
        "description": [
          "        current_check: results.Check = current_source.check  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1385",
        "line": 177,
        "description": [
          "        console.print(\"\\n:tada: Check:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1386",
        "line": 205,
        "description": [
          "                expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1387",
        "line": 206,
        "description": [
          "                title=f\"{combined_attribute_label}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1388",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1389",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1390",
        "line": 214,
        "description": [
          "                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1391",
        "line": 221,
        "description": [
          "                    opt_print_log(verbose, label=\":sparkles: Matching source code:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1392",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1393",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1394",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1395",
        "line": 239,
        "description": [
          "                        + constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1396",
        "line": 249,
        "description": [
          "                        \"\\n\".join(str(line) for line in lines),"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1397",
        "line": 253,
        "description": [
          "                        line_numbers=True,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1398",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1399",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1400",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1401",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1402",
        "line": 264,
        "description": [
          "                            expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1403",
        "line": 265,
        "description": [
          "                            title=f\"{current_match.path}:{position_end}:{column_offset}\","
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "display_results_frog_mouth",
    "function_scope": "270-289",
    "patterns": [
      {
        "lineno": 278,
        "coloffset": 4,
        "linematch": "if exec_found:",
        "context": "        result_file,\n    ]\n    executable = util.executable_name(\"frogmouth\", OpSystem)\n    exec_found, executable_path = filesystem.can_find_executable(executable)\n    if exec_found:\n        # run frogmouth with specified path\n        output.console.print(\"\\n\ud83d\udc38 Frogmouth Information\\n\")\n        output.console.print(f\" {small_bullet_unicode} Venv: {sys.prefix}\")\n        output.console.print(f\" {small_bullet_unicode} Program: {executable_path}\")\n        proc = subprocess.Popen(cmd)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 270,
        "coloffset": 0,
        "linematch": "def display_results_frog_mouth(result_file, OpSystem) -> None:",
        "context": "        proc = subprocess.Popen(cmd)\n        proc.wait()\n\n\ndef display_results_frog_mouth(result_file, OpSystem) -> None:\n    \"\"\"Run frogmouth as a subprocess of chasten\"\"\"\n    cmd = [\n        \"frogmouth\",\n        result_file,\n    ]",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 271,
        "coloffset": 4,
        "linematch": "\"\"\"Run frogmouth as a subprocess of chasten\"\"\"",
        "context": "        proc.wait()\n\n\ndef display_results_frog_mouth(result_file, OpSystem) -> None:\n    \"\"\"Run frogmouth as a subprocess of chasten\"\"\"\n    cmd = [\n        \"frogmouth\",\n        result_file,\n    ]\n    executable = util.executable_name(\"frogmouth\", OpSystem)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 272,
        "coloffset": 4,
        "linematch": "cmd = [",
        "context": "\n\ndef display_results_frog_mouth(result_file, OpSystem) -> None:\n    \"\"\"Run frogmouth as a subprocess of chasten\"\"\"\n    cmd = [\n        \"frogmouth\",\n        result_file,\n    ]\n    executable = util.executable_name(\"frogmouth\", OpSystem)\n    exec_found, executable_path = filesystem.can_find_executable(executable)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 276,
        "coloffset": 4,
        "linematch": "executable = util.executable_name(\"frogmouth\", OpSystem)",
        "context": "    cmd = [\n        \"frogmouth\",\n        result_file,\n    ]\n    executable = util.executable_name(\"frogmouth\", OpSystem)\n    exec_found, executable_path = filesystem.can_find_executable(executable)\n    if exec_found:\n        # run frogmouth with specified path\n        output.console.print(\"\\n\ud83d\udc38 Frogmouth Information\\n\")\n        output.console.print(f\" {small_bullet_unicode} Venv: {sys.prefix}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 277,
        "coloffset": 4,
        "linematch": "exec_found, executable_path = filesystem.can_find_executable(executable)",
        "context": "        \"frogmouth\",\n        result_file,\n    ]\n    executable = util.executable_name(\"frogmouth\", OpSystem)\n    exec_found, executable_path = filesystem.can_find_executable(executable)\n    if exec_found:\n        # run frogmouth with specified path\n        output.console.print(\"\\n\ud83d\udc38 Frogmouth Information\\n\")\n        output.console.print(f\" {small_bullet_unicode} Venv: {sys.prefix}\")\n        output.console.print(f\" {small_bullet_unicode} Program: {executable_path}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 278,
        "coloffset": 4,
        "linematch": "if exec_found:",
        "context": "        result_file,\n    ]\n    executable = util.executable_name(\"frogmouth\", OpSystem)\n    exec_found, executable_path = filesystem.can_find_executable(executable)\n    if exec_found:\n        # run frogmouth with specified path\n        output.console.print(\"\\n\ud83d\udc38 Frogmouth Information\\n\")\n        output.console.print(f\" {small_bullet_unicode} Venv: {sys.prefix}\")\n        output.console.print(f\" {small_bullet_unicode} Program: {executable_path}\")\n        proc = subprocess.Popen(cmd)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "detect_configuration",
    "function_scope": "69-86",
    "patterns": [
      {
        "lineno": 73,
        "coloffset": 4,
        "linematch": "if config is not None:",
        "context": "def detect_configuration(config: Optional[Path]) -> str:\n    \"\"\"Detect the configuration.\"\"\"\n    # there is a specified configuration directory path and thus\n    # this overrides the use of the platform-specific configuration\n    if config is not None:\n        chasten_user_config_dir_str = str(config)\n    # there is no configuration directory specified and thus\n    # this function should access the platform-specific\n    # configuration directory detected by platformdirs\n    else:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 69,
        "coloffset": 0,
        "linematch": "def detect_configuration(config: Optional[Path]) -> str:",
        "context": "    \"checks.yml\": CHECKS_FILE_DEFAULT_CONTENTS,\n}\n\n\ndef detect_configuration(config: Optional[Path]) -> str:\n    \"\"\"Detect the configuration.\"\"\"\n    # there is a specified configuration directory path and thus\n    # this overrides the use of the platform-specific configuration\n    if config is not None:\n        chasten_user_config_dir_str = str(config)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "\"\"\"Detect the configuration.\"\"\"",
        "context": "}\n\n\ndef detect_configuration(config: Optional[Path]) -> str:\n    \"\"\"Detect the configuration.\"\"\"\n    # there is a specified configuration directory path and thus\n    # this overrides the use of the platform-specific configuration\n    if config is not None:\n        chasten_user_config_dir_str = str(config)\n    # there is no configuration directory specified and thus",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 73,
        "coloffset": 4,
        "linematch": "if config is not None:",
        "context": "def detect_configuration(config: Optional[Path]) -> str:\n    \"\"\"Detect the configuration.\"\"\"\n    # there is a specified configuration directory path and thus\n    # this overrides the use of the platform-specific configuration\n    if config is not None:\n        chasten_user_config_dir_str = str(config)\n    # there is no configuration directory specified and thus\n    # this function should access the platform-specific\n    # configuration directory detected by platformdirs\n    else:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 86,
        "coloffset": 4,
        "linematch": "return chasten_user_config_dir_str",
        "context": "            application_name=constants.chasten.Application_Name,\n            application_author=constants.chasten.Application_Author,\n        )\n    # return in string form the detected configuration directory\n    return chasten_user_config_dir_str\n\n\ndef create_configuration_directory(\n    config: Optional[Path] = None, force: bool = False\n) -> Union[Path, NoReturn]:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "create_configuration_directory",
    "function_scope": "89-105",
    "patterns": [
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "if force:",
        "context": "    # create a path out of the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    # recursively delete the configuration directory and all of its\n    # contents because the force parameter permits deletion\n    if force:\n        shutil.rmtree(chasten_user_config_dir_path)\n    # create the configuration directory, a step that\n    # may fail if the directory already exists; in this\n    # case the FileExistsError will be passed to caller\n    chasten_user_config_dir_path.mkdir(parents=True)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 89,
        "coloffset": 0,
        "linematch": "def create_configuration_directory(",
        "context": "    # return in string form the detected configuration directory\n    return chasten_user_config_dir_str\n\n\ndef create_configuration_directory(\n    config: Optional[Path] = None, force: bool = False\n) -> Union[Path, NoReturn]:\n    \"\"\"Create the configuration directory.\"\"\"\n    # detect the configuration directory\n    chasten_user_config_dir_str = detect_configuration(config)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 92,
        "coloffset": 4,
        "linematch": "\"\"\"Create the configuration directory.\"\"\"",
        "context": "\ndef create_configuration_directory(\n    config: Optional[Path] = None, force: bool = False\n) -> Union[Path, NoReturn]:\n    \"\"\"Create the configuration directory.\"\"\"\n    # detect the configuration directory\n    chasten_user_config_dir_str = detect_configuration(config)\n    # create a path out of the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    # recursively delete the configuration directory and all of its",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "chasten_user_config_dir_str = detect_configuration(config)",
        "context": "    config: Optional[Path] = None, force: bool = False\n) -> Union[Path, NoReturn]:\n    \"\"\"Create the configuration directory.\"\"\"\n    # detect the configuration directory\n    chasten_user_config_dir_str = detect_configuration(config)\n    # create a path out of the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    # recursively delete the configuration directory and all of its\n    # contents because the force parameter permits deletion\n    if force:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "chasten_user_config_dir_path = Path(chasten_user_config_dir_str)",
        "context": "    \"\"\"Create the configuration directory.\"\"\"\n    # detect the configuration directory\n    chasten_user_config_dir_str = detect_configuration(config)\n    # create a path out of the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    # recursively delete the configuration directory and all of its\n    # contents because the force parameter permits deletion\n    if force:\n        shutil.rmtree(chasten_user_config_dir_path)\n    # create the configuration directory, a step that",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "if force:",
        "context": "    # create a path out of the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    # recursively delete the configuration directory and all of its\n    # contents because the force parameter permits deletion\n    if force:\n        shutil.rmtree(chasten_user_config_dir_path)\n    # create the configuration directory, a step that\n    # may fail if the directory already exists; in this\n    # case the FileExistsError will be passed to caller\n    chasten_user_config_dir_path.mkdir(parents=True)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 104,
        "coloffset": 4,
        "linematch": "chasten_user_config_dir_path.mkdir(parents=True)",
        "context": "        shutil.rmtree(chasten_user_config_dir_path)\n    # create the configuration directory, a step that\n    # may fail if the directory already exists; in this\n    # case the FileExistsError will be passed to caller\n    chasten_user_config_dir_path.mkdir(parents=True)\n    return chasten_user_config_dir_path\n\n\ndef create_configuration_file(\n    config: Path, config_file_name: str = constants.filesystem.Main_Configuration_File",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 105,
        "coloffset": 4,
        "linematch": "return chasten_user_config_dir_path",
        "context": "    # create the configuration directory, a step that\n    # may fail if the directory already exists; in this\n    # case the FileExistsError will be passed to caller\n    chasten_user_config_dir_path.mkdir(parents=True)\n    return chasten_user_config_dir_path\n\n\ndef create_configuration_file(\n    config: Path, config_file_name: str = constants.filesystem.Main_Configuration_File\n) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1365",
        "line": 95,
        "description": [
          "    console.print(\":sparkles: Finished running test suite for the specified program\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "create_directory_tree_visualization",
    "function_scope": "127-145",
    "patterns": [
      {
        "lineno": 131,
        "coloffset": 4,
        "linematch": "if tree is None:",
        "context": "def create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore\n    \"\"\"Create a directory tree visualization using the Rich tree.\"\"\"\n    # create the root of the tree if it\n    # has not already been created\n    if tree is None:\n        tree = Tree(f\":open_file_folder: {path.name}\")\n    # add the new file node to the tree since\n    # the tree has already been created\n    else:\n        tree = tree.add(f\":open_file_folder: {path.name}\")",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 138,
        "coloffset": 4,
        "linematch": "if path.is_dir():",
        "context": "    # the tree has already been created\n    else:\n        tree = tree.add(f\":open_file_folder: {path.name}\")\n    # recursively process the directory\n    if path.is_dir():\n        for item in path.iterdir():\n            if item.is_dir():\n                create_directory_tree_visualization(item, tree)\n            else:\n                tree.add(f\":page_facing_up: {item.name}\")",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 140,
        "coloffset": 12,
        "linematch": "if item.is_dir():",
        "context": "        tree = tree.add(f\":open_file_folder: {path.name}\")\n    # recursively process the directory\n    if path.is_dir():\n        for item in path.iterdir():\n            if item.is_dir():\n                create_directory_tree_visualization(item, tree)\n            else:\n                tree.add(f\":page_facing_up: {item.name}\")\n    # return the tree now containing all nodes\n    return tree",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 140,
        "coloffset": 12,
        "linematch": "if item.is_dir():",
        "context": "        tree = tree.add(f\":open_file_folder: {path.name}\")\n    # recursively process the directory\n    if path.is_dir():\n        for item in path.iterdir():\n            if item.is_dir():\n                create_directory_tree_visualization(item, tree)\n            else:\n                tree.add(f\":page_facing_up: {item.name}\")\n    # return the tree now containing all nodes\n    return tree",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 131,
        "coloffset": 7,
        "linematch": "if tree is None:",
        "context": "def create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore\n    \"\"\"Create a directory tree visualization using the Rich tree.\"\"\"\n    # create the root of the tree if it\n    # has not already been created\n    if tree is None:\n        tree = Tree(f\":open_file_folder: {path.name}\")\n    # add the new file node to the tree since\n    # the tree has already been created\n    else:\n        tree = tree.add(f\":open_file_folder: {path.name}\")",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 127,
        "coloffset": 0,
        "linematch": "def create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore",
        "context": "    file_contents = FILE_CONTENTS_LOOKUP[config_file_name]\n    chasten_user_config_main_file.write_text(file_contents)\n\n\ndef create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore\n    \"\"\"Create a directory tree visualization using the Rich tree.\"\"\"\n    # create the root of the tree if it\n    # has not already been created\n    if tree is None:\n        tree = Tree(f\":open_file_folder: {path.name}\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 138,
        "coloffset": 4,
        "linematch": "if path.is_dir():",
        "context": "    # the tree has already been created\n    else:\n        tree = tree.add(f\":open_file_folder: {path.name}\")\n    # recursively process the directory\n    if path.is_dir():\n        for item in path.iterdir():\n            if item.is_dir():\n                create_directory_tree_visualization(item, tree)\n            else:\n                tree.add(f\":page_facing_up: {item.name}\")",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 140,
        "coloffset": 12,
        "linematch": "if item.is_dir():",
        "context": "        tree = tree.add(f\":open_file_folder: {path.name}\")\n    # recursively process the directory\n    if path.is_dir():\n        for item in path.iterdir():\n            if item.is_dir():\n                create_directory_tree_visualization(item, tree)\n            else:\n                tree.add(f\":page_facing_up: {item.name}\")\n    # return the tree now containing all nodes\n    return tree",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 128,
        "coloffset": 4,
        "linematch": "\"\"\"Create a directory tree visualization using the Rich tree.\"\"\"",
        "context": "    chasten_user_config_main_file.write_text(file_contents)\n\n\ndef create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore\n    \"\"\"Create a directory tree visualization using the Rich tree.\"\"\"\n    # create the root of the tree if it\n    # has not already been created\n    if tree is None:\n        tree = Tree(f\":open_file_folder: {path.name}\")\n    # add the new file node to the tree since",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 131,
        "coloffset": 4,
        "linematch": "if tree is None:",
        "context": "def create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore\n    \"\"\"Create a directory tree visualization using the Rich tree.\"\"\"\n    # create the root of the tree if it\n    # has not already been created\n    if tree is None:\n        tree = Tree(f\":open_file_folder: {path.name}\")\n    # add the new file node to the tree since\n    # the tree has already been created\n    else:\n        tree = tree.add(f\":open_file_folder: {path.name}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 138,
        "coloffset": 4,
        "linematch": "if path.is_dir():",
        "context": "    # the tree has already been created\n    else:\n        tree = tree.add(f\":open_file_folder: {path.name}\")\n    # recursively process the directory\n    if path.is_dir():\n        for item in path.iterdir():\n            if item.is_dir():\n                create_directory_tree_visualization(item, tree)\n            else:\n                tree.add(f\":page_facing_up: {item.name}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 145,
        "coloffset": 4,
        "linematch": "return tree",
        "context": "                create_directory_tree_visualization(item, tree)\n            else:\n                tree.add(f\":page_facing_up: {item.name}\")\n    # return the tree now containing all nodes\n    return tree\n\n\ndef confirm_valid_file(file: Path) -> bool:\n    \"\"\"Confirm that the provided file is a valid path that is a file.\"\"\"\n    # determine if the file is not None and if it is a file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 127,
        "coloffset": 0,
        "linematch": "def create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore",
        "context": "    file_contents = FILE_CONTENTS_LOOKUP[config_file_name]\n    chasten_user_config_main_file.write_text(file_contents)\n\n\ndef create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore\n    \"\"\"Create a directory tree visualization using the Rich tree.\"\"\"\n    # create the root of the tree if it\n    # has not already been created\n    if tree is None:\n        tree = Tree(f\":open_file_folder: {path.name}\")",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 127,
        "coloffset": 0,
        "linematch": "def create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore",
        "context": "    file_contents = FILE_CONTENTS_LOOKUP[config_file_name]\n    chasten_user_config_main_file.write_text(file_contents)\n\n\ndef create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore\n    \"\"\"Create a directory tree visualization using the Rich tree.\"\"\"\n    # create the root of the tree if it\n    # has not already been created\n    if tree is None:\n        tree = Tree(f\":open_file_folder: {path.name}\")",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #305",
        "line": 143,
        "description": [
          "    grouped_files = group_files_by_directory(container)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1368",
        "line": 132,
        "description": [
          "    if len(file_name) > max_length:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1369",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1370",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1371",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1372",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1373",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "confirm_valid_file",
    "function_scope": "148-156",
    "patterns": [
      {
        "lineno": 151,
        "coloffset": 4,
        "linematch": "if file is not None:",
        "context": "\ndef confirm_valid_file(file: Path) -> bool:\n    \"\"\"Confirm that the provided file is a valid path that is a file.\"\"\"\n    # determine if the file is not None and if it is a file\n    if file is not None:\n        # the file is valid\n        if file.is_file() and file.exists():\n            return True\n    # the file was either none or not valid\n    return False",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 153,
        "coloffset": 8,
        "linematch": "if file.is_file() and file.exists():",
        "context": "    \"\"\"Confirm that the provided file is a valid path that is a file.\"\"\"\n    # determine if the file is not None and if it is a file\n    if file is not None:\n        # the file is valid\n        if file.is_file() and file.exists():\n            return True\n    # the file was either none or not valid\n    return False\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 153,
        "coloffset": 8,
        "linematch": "if file.is_file() and file.exists():",
        "context": "    \"\"\"Confirm that the provided file is a valid path that is a file.\"\"\"\n    # determine if the file is not None and if it is a file\n    if file is not None:\n        # the file is valid\n        if file.is_file() and file.exists():\n            return True\n    # the file was either none or not valid\n    return False\n\n",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 148,
        "coloffset": 0,
        "linematch": "def confirm_valid_file(file: Path) -> bool:",
        "context": "    # return the tree now containing all nodes\n    return tree\n\n\ndef confirm_valid_file(file: Path) -> bool:\n    \"\"\"Confirm that the provided file is a valid path that is a file.\"\"\"\n    # determine if the file is not None and if it is a file\n    if file is not None:\n        # the file is valid\n        if file.is_file() and file.exists():",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 153,
        "coloffset": 8,
        "linematch": "if file.is_file() and file.exists():",
        "context": "    \"\"\"Confirm that the provided file is a valid path that is a file.\"\"\"\n    # determine if the file is not None and if it is a file\n    if file is not None:\n        # the file is valid\n        if file.is_file() and file.exists():\n            return True\n    # the file was either none or not valid\n    return False\n\n",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 149,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the provided file is a valid path that is a file.\"\"\"",
        "context": "    return tree\n\n\ndef confirm_valid_file(file: Path) -> bool:\n    \"\"\"Confirm that the provided file is a valid path that is a file.\"\"\"\n    # determine if the file is not None and if it is a file\n    if file is not None:\n        # the file is valid\n        if file.is_file() and file.exists():\n            return True",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 151,
        "coloffset": 4,
        "linematch": "if file is not None:",
        "context": "\ndef confirm_valid_file(file: Path) -> bool:\n    \"\"\"Confirm that the provided file is a valid path that is a file.\"\"\"\n    # determine if the file is not None and if it is a file\n    if file is not None:\n        # the file is valid\n        if file.is_file() and file.exists():\n            return True\n    # the file was either none or not valid\n    return False",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 156,
        "coloffset": 4,
        "linematch": "return False",
        "context": "        # the file is valid\n        if file.is_file() and file.exists():\n            return True\n    # the file was either none or not valid\n    return False\n\n\ndef confirm_valid_directory(directory: Path) -> bool:\n    \"\"\"Confirm that the provided directory is a valid path that is a directory.\"\"\"\n    # determine if the file is not None and if it is a file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #306",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #307",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1374",
        "line": 148,
        "description": [
          "        console.print(f\"{small_bullet_unicode} Directory: {directory}\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1375",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1376",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1377",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1378",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1379",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1380",
        "line": 156,
        "description": [
          "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "confirm_valid_directory",
    "function_scope": "159-167",
    "patterns": [
      {
        "lineno": 162,
        "coloffset": 4,
        "linematch": "if directory is not None:",
        "context": "\ndef confirm_valid_directory(directory: Path) -> bool:\n    \"\"\"Confirm that the provided directory is a valid path that is a directory.\"\"\"\n    # determine if the file is not None and if it is a file\n    if directory is not None:\n        # the file is valid\n        if directory.is_dir() and directory.exists():\n            return True\n    # the directory was either none or not valid\n    return False",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 164,
        "coloffset": 8,
        "linematch": "if directory.is_dir() and directory.exists():",
        "context": "    \"\"\"Confirm that the provided directory is a valid path that is a directory.\"\"\"\n    # determine if the file is not None and if it is a file\n    if directory is not None:\n        # the file is valid\n        if directory.is_dir() and directory.exists():\n            return True\n    # the directory was either none or not valid\n    return False\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 164,
        "coloffset": 8,
        "linematch": "if directory.is_dir() and directory.exists():",
        "context": "    \"\"\"Confirm that the provided directory is a valid path that is a directory.\"\"\"\n    # determine if the file is not None and if it is a file\n    if directory is not None:\n        # the file is valid\n        if directory.is_dir() and directory.exists():\n            return True\n    # the directory was either none or not valid\n    return False\n\n",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 159,
        "coloffset": 0,
        "linematch": "def confirm_valid_directory(directory: Path) -> bool:",
        "context": "    # the file was either none or not valid\n    return False\n\n\ndef confirm_valid_directory(directory: Path) -> bool:\n    \"\"\"Confirm that the provided directory is a valid path that is a directory.\"\"\"\n    # determine if the file is not None and if it is a file\n    if directory is not None:\n        # the file is valid\n        if directory.is_dir() and directory.exists():",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 164,
        "coloffset": 8,
        "linematch": "if directory.is_dir() and directory.exists():",
        "context": "    \"\"\"Confirm that the provided directory is a valid path that is a directory.\"\"\"\n    # determine if the file is not None and if it is a file\n    if directory is not None:\n        # the file is valid\n        if directory.is_dir() and directory.exists():\n            return True\n    # the directory was either none or not valid\n    return False\n\n",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 160,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the provided directory is a valid path that is a directory.\"\"\"",
        "context": "    return False\n\n\ndef confirm_valid_directory(directory: Path) -> bool:\n    \"\"\"Confirm that the provided directory is a valid path that is a directory.\"\"\"\n    # determine if the file is not None and if it is a file\n    if directory is not None:\n        # the file is valid\n        if directory.is_dir() and directory.exists():\n            return True",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 162,
        "coloffset": 4,
        "linematch": "if directory is not None:",
        "context": "\ndef confirm_valid_directory(directory: Path) -> bool:\n    \"\"\"Confirm that the provided directory is a valid path that is a directory.\"\"\"\n    # determine if the file is not None and if it is a file\n    if directory is not None:\n        # the file is valid\n        if directory.is_dir() and directory.exists():\n            return True\n    # the directory was either none or not valid\n    return False",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 167,
        "coloffset": 4,
        "linematch": "return False",
        "context": "        # the file is valid\n        if directory.is_dir() and directory.exists():\n            return True\n    # the directory was either none or not valid\n    return False\n\n\ndef get_default_directory_list() -> List[Path]:\n    \"\"\"Return the default directory list that is the current working directory by itself.\"\"\"\n    default_directory_list = [Path(constants.filesystem.Current_Directory)]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1381",
        "line": 160,
        "description": [
          "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "write_chasten_results",
    "function_scope": "176-209",
    "patterns": [
      {
        "lineno": 183,
        "coloffset": 4,
        "linematch": "if save:",
        "context": "    results_content: results.Chasten,\n    save: bool = False,\n) -> str:\n    \"\"\"Write the results of a Chasten subclass of Pydantic BaseModel to the specified directory.\"\"\"\n    if save:\n        # extract the unique hexadecimal code that will ensure that\n        # this file name is unique when it is being saved\n        results_file_uuid = results_content.configuration.fileuuid\n        # extract the current date and time when results were created\n        formatted_datetime = results_content.configuration._datetime",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 176,
        "coloffset": 0,
        "linematch": "def write_chasten_results(",
        "context": "    default_directory_list = [Path(constants.filesystem.Current_Directory)]\n    return default_directory_list\n\n\ndef write_chasten_results(\n    results_path: Path,\n    projectname: str,\n    results_content: results.Chasten,\n    save: bool = False,\n) -> str:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 182,
        "coloffset": 4,
        "linematch": "\"\"\"Write the results of a Chasten subclass of Pydantic BaseModel to the specified directory.\"\"\"",
        "context": "    projectname: str,\n    results_content: results.Chasten,\n    save: bool = False,\n) -> str:\n    \"\"\"Write the results of a Chasten subclass of Pydantic BaseModel to the specified directory.\"\"\"\n    if save:\n        # extract the unique hexadecimal code that will ensure that\n        # this file name is unique when it is being saved\n        results_file_uuid = results_content.configuration.fileuuid\n        # extract the current date and time when results were created",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 183,
        "coloffset": 4,
        "linematch": "if save:",
        "context": "    results_content: results.Chasten,\n    save: bool = False,\n) -> str:\n    \"\"\"Write the results of a Chasten subclass of Pydantic BaseModel to the specified directory.\"\"\"\n    if save:\n        # extract the unique hexadecimal code that will ensure that\n        # this file name is unique when it is being saved\n        results_file_uuid = results_content.configuration.fileuuid\n        # extract the current date and time when results were created\n        formatted_datetime = results_content.configuration._datetime",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 209,
        "coloffset": 4,
        "linematch": "return constants.markers.Empty_String",
        "context": "        # return the name of the created file for diagnostic purposes\n        return complete_results_file_name\n    # saving was not enabled and thus this function cannot\n    # return the name of the file that was created during saving\n    return constants.markers.Empty_String\n\n\ndef write_dict_results(\n    results_json: str,\n    results_path: Path,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #308",
        "line": 176,
        "description": [
          "        current_xpath_pattern = current_check.pattern"
        ],
        "failure": []
      },
      {
        "name": "Mutant #309",
        "line": 182,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #310",
        "line": 187,
        "description": [
          "        min_count = current_check.min"
        ],
        "failure": []
      },
      {
        "name": "Mutant #311",
        "line": 188,
        "description": [
          "        max_count = current_check.max"
        ],
        "failure": []
      },
      {
        "name": "Mutant #312",
        "line": 189,
        "description": [
          "        min_label = checks.create_attribute_label(min_count, constants.checks.Check_Min)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #313",
        "line": 190,
        "description": [
          "        max_label = checks.create_attribute_label(max_count, constants.checks.Check_Max)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #314",
        "line": 193,
        "description": [
          "        check_id = current_check.id"
        ],
        "failure": []
      },
      {
        "name": "Mutant #315",
        "line": 194,
        "description": [
          "        check_id_label = checks.create_attribute_label(check_id, constants.checks.Check_Id)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #316",
        "line": 195,
        "description": [
          "        check_name = current_check.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #317",
        "line": 196,
        "description": [
          "        check_name_label = checks.create_attribute_label(check_name, constants.checks.Check_Name)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #318",
        "line": 200,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1385",
        "line": 177,
        "description": [
          "        console.print(\"\\n:tada: Check:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1386",
        "line": 205,
        "description": [
          "                expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1387",
        "line": 206,
        "description": [
          "                title=f\"{combined_attribute_label}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1388",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1389",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "can_find_executable",
    "function_scope": "305-315",
    "patterns": [
      {
        "lineno": 311,
        "coloffset": 4,
        "linematch": "if executable_path is not None:",
        "context": "    # use the shutil.which function to find the path of the executable\n    executable_path = shutil.which(executable_name)\n    # the executable is available in the path, so\n    # signal that it is found and return the full path\n    if executable_path is not None:\n        return (True, executable_path)\n    # the executable is not available, so signal its\n    # absence and then return an emptry string instead of a path\n    return (False, constants.markers.Nothing)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 305,
        "coloffset": 0,
        "linematch": "def can_find_executable(executable_name: str) -> Tuple[bool, str]:",
        "context": "    # return the list of JSON dictionaries\n    return json_dicts_list\n\n\ndef can_find_executable(executable_name: str) -> Tuple[bool, str]:\n    \"\"\"Determine whether or not it is possible to find an executable.\"\"\"\n    # use the shutil.which function to find the path of the executable\n    executable_path = shutil.which(executable_name)\n    # the executable is available in the path, so\n    # signal that it is found and return the full path",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 306,
        "coloffset": 4,
        "linematch": "\"\"\"Determine whether or not it is possible to find an executable.\"\"\"",
        "context": "    return json_dicts_list\n\n\ndef can_find_executable(executable_name: str) -> Tuple[bool, str]:\n    \"\"\"Determine whether or not it is possible to find an executable.\"\"\"\n    # use the shutil.which function to find the path of the executable\n    executable_path = shutil.which(executable_name)\n    # the executable is available in the path, so\n    # signal that it is found and return the full path\n    if executable_path is not None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 308,
        "coloffset": 4,
        "linematch": "executable_path = shutil.which(executable_name)",
        "context": "\ndef can_find_executable(executable_name: str) -> Tuple[bool, str]:\n    \"\"\"Determine whether or not it is possible to find an executable.\"\"\"\n    # use the shutil.which function to find the path of the executable\n    executable_path = shutil.which(executable_name)\n    # the executable is available in the path, so\n    # signal that it is found and return the full path\n    if executable_path is not None:\n        return (True, executable_path)\n    # the executable is not available, so signal its",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 311,
        "coloffset": 4,
        "linematch": "if executable_path is not None:",
        "context": "    # use the shutil.which function to find the path of the executable\n    executable_path = shutil.which(executable_name)\n    # the executable is available in the path, so\n    # signal that it is found and return the full path\n    if executable_path is not None:\n        return (True, executable_path)\n    # the executable is not available, so signal its\n    # absence and then return an emptry string instead of a path\n    return (False, constants.markers.Nothing)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 315,
        "coloffset": 4,
        "linematch": "return (False, constants.markers.Nothing)",
        "context": "    if executable_path is not None:\n        return (True, executable_path)\n    # the executable is not available, so signal its\n    # absence and then return an emptry string instead of a path\n    return (False, constants.markers.Nothing)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "load_user_api_key",
    "function_scope": "67-74",
    "patterns": [
      {
        "lineno": 70,
        "coloffset": 8,
        "linematch": "if len(lines) == 2:  # noqa: PLR2004",
        "context": "\ndef load_user_api_key(file):\n    with open(file, \"r\") as f:\n        lines = f.read().strip().split(\"\\n\")\n        if len(lines) == 2:  # noqa: PLR2004\n            key = lines[0].encode()\n            encrypted_key = lines[1]\n        fernet = Fernet(key)\n        return fernet.decrypt(encrypted_key.encode()).decode()\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 70,
        "coloffset": 11,
        "linematch": "if len(lines) == 2:  # noqa: PLR2004",
        "context": "\ndef load_user_api_key(file):\n    with open(file, \"r\") as f:\n        lines = f.read().strip().split(\"\\n\")\n        if len(lines) == 2:  # noqa: PLR2004\n            key = lines[0].encode()\n            encrypted_key = lines[1]\n        fernet = Fernet(key)\n        return fernet.decrypt(encrypted_key.encode()).decode()\n",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 67,
        "coloffset": 0,
        "linematch": "def load_user_api_key(file):",
        "context": "    with open(API_KEY_FILE, \"w\") as f:\n        f.write(key.decode() + \"\\n\" + encrypted_key)\n\n\ndef load_user_api_key(file):\n    with open(file, \"r\") as f:\n        lines = f.read().strip().split(\"\\n\")\n        if len(lines) == 2:  # noqa: PLR2004\n            key = lines[0].encode()\n            encrypted_key = lines[1]",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 68,
        "coloffset": 4,
        "linematch": "with open(file, \"r\") as f:",
        "context": "        f.write(key.decode() + \"\\n\" + encrypted_key)\n\n\ndef load_user_api_key(file):\n    with open(file, \"r\") as f:\n        lines = f.read().strip().split(\"\\n\")\n        if len(lines) == 2:  # noqa: PLR2004\n            key = lines[0].encode()\n            encrypted_key = lines[1]\n        fernet = Fernet(key)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "extract_checks_file_name",
    "function_scope": "102-118",
    "patterns": [
      {
        "lineno": 107,
        "coloffset": 4,
        "linematch": "if constants.checks.Check_Chasten in configuration.keys():",
        "context": "    configuration: Dict[str, Dict[str, Any]]\n) -> Tuple[bool, List[str]]:\n    \"\"\"Validate the checks configuration.\"\"\"\n    # there is a main \"chasten\" key\n    if constants.checks.Check_Chasten in configuration.keys():\n        # there is a \"checks-file\" key\n        if constants.checks.Check_File in configuration[constants.checks.Check_Chasten]:\n            # extract the name of the checks-files\n            # and return them in a list with a boolean\n            # indicate to show that checks files were found",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 109,
        "coloffset": 8,
        "linematch": "if constants.checks.Check_File in configuration[constants.checks.Check_Chasten]:",
        "context": "    \"\"\"Validate the checks configuration.\"\"\"\n    # there is a main \"chasten\" key\n    if constants.checks.Check_Chasten in configuration.keys():\n        # there is a \"checks-file\" key\n        if constants.checks.Check_File in configuration[constants.checks.Check_Chasten]:\n            # extract the name of the checks-files\n            # and return them in a list with a boolean\n            # indicate to show that checks files were found\n            checks_file_name_list = configuration[constants.checks.Check_Chasten][\n                constants.checks.Check_File",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 109,
        "coloffset": 8,
        "linematch": "if constants.checks.Check_File in configuration[constants.checks.Check_Chasten]:",
        "context": "    \"\"\"Validate the checks configuration.\"\"\"\n    # there is a main \"chasten\" key\n    if constants.checks.Check_Chasten in configuration.keys():\n        # there is a \"checks-file\" key\n        if constants.checks.Check_File in configuration[constants.checks.Check_Chasten]:\n            # extract the name of the checks-files\n            # and return them in a list with a boolean\n            # indicate to show that checks files were found\n            checks_file_name_list = configuration[constants.checks.Check_Chasten][\n                constants.checks.Check_File",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 102,
        "coloffset": 0,
        "linematch": "def extract_checks_file_name(",
        "context": "    },\n}\n\n\ndef extract_checks_file_name(\n    configuration: Dict[str, Dict[str, Any]]\n) -> Tuple[bool, List[str]]:\n    \"\"\"Validate the checks configuration.\"\"\"\n    # there is a main \"chasten\" key\n    if constants.checks.Check_Chasten in configuration.keys():",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 107,
        "coloffset": 41,
        "linematch": "if constants.checks.Check_Chasten in configuration.keys():",
        "context": "    configuration: Dict[str, Dict[str, Any]]\n) -> Tuple[bool, List[str]]:\n    \"\"\"Validate the checks configuration.\"\"\"\n    # there is a main \"chasten\" key\n    if constants.checks.Check_Chasten in configuration.keys():\n        # there is a \"checks-file\" key\n        if constants.checks.Check_File in configuration[constants.checks.Check_Chasten]:\n            # extract the name of the checks-files\n            # and return them in a list with a boolean\n            # indicate to show that checks files were found",
        "pattern": ".//FunctionDef//Call/func/Attribute[@attr=\"keys\"]",
        "check_id": "KF001",
        "check_name": "key-function"
      },
      {
        "lineno": 109,
        "coloffset": 8,
        "linematch": "if constants.checks.Check_File in configuration[constants.checks.Check_Chasten]:",
        "context": "    \"\"\"Validate the checks configuration.\"\"\"\n    # there is a main \"chasten\" key\n    if constants.checks.Check_Chasten in configuration.keys():\n        # there is a \"checks-file\" key\n        if constants.checks.Check_File in configuration[constants.checks.Check_Chasten]:\n            # extract the name of the checks-files\n            # and return them in a list with a boolean\n            # indicate to show that checks files were found\n            checks_file_name_list = configuration[constants.checks.Check_Chasten][\n                constants.checks.Check_File",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 105,
        "coloffset": 4,
        "linematch": "\"\"\"Validate the checks configuration.\"\"\"",
        "context": "\ndef extract_checks_file_name(\n    configuration: Dict[str, Dict[str, Any]]\n) -> Tuple[bool, List[str]]:\n    \"\"\"Validate the checks configuration.\"\"\"\n    # there is a main \"chasten\" key\n    if constants.checks.Check_Chasten in configuration.keys():\n        # there is a \"checks-file\" key\n        if constants.checks.Check_File in configuration[constants.checks.Check_Chasten]:\n            # extract the name of the checks-files",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 107,
        "coloffset": 4,
        "linematch": "if constants.checks.Check_Chasten in configuration.keys():",
        "context": "    configuration: Dict[str, Dict[str, Any]]\n) -> Tuple[bool, List[str]]:\n    \"\"\"Validate the checks configuration.\"\"\"\n    # there is a main \"chasten\" key\n    if constants.checks.Check_Chasten in configuration.keys():\n        # there is a \"checks-file\" key\n        if constants.checks.Check_File in configuration[constants.checks.Check_Chasten]:\n            # extract the name of the checks-files\n            # and return them in a list with a boolean\n            # indicate to show that checks files were found",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 118,
        "coloffset": 4,
        "linematch": "return (False, [constants.markers.Empty_String])",
        "context": "                constants.checks.Check_File\n            ]\n            return (True, checks_file_name_list)\n    # contents were not found and thus returen no filenames\n    return (False, [constants.markers.Empty_String])\n\n\ndef validate_configuration(\n    configuration: Dict[str, Dict[str, Any]],\n    schema: Dict[str, Any] = JSON_SCHEMA_CONFIG,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "validate_file",
    "function_scope": "147-168",
    "patterns": [
      {
        "lineno": 161,
        "coloffset": 4,
        "linematch": "if not validated:",
        "context": "    output.console.print(\n        f\":sparkles: Validated {file_name}? {util.get_human_readable_boolean(validated)}\"\n    )\n    # there was a validation error, so display the error report\n    if not validated:\n        output.console.print(f\":person_shrugging: Validation errors:\\n\\n{errors}\")\n    # validation worked correctly, so display the configuration file\n    else:\n        output.opt_print_log(verbose, newline=\"\")\n        output.opt_print_log(verbose, label=f\":sparkles: Contents of {file_name}:\\n\")",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 147,
        "coloffset": 0,
        "linematch": "def validate_file(",
        "context": "    \"\"\"Validate the checks configuration.\"\"\"\n    return validate_configuration(configuration, JSON_SCHEMA_CHECKS)\n\n\ndef validate_file(\n    file_name: str,\n    configuration_file_yaml_str: str,\n    yaml_data_dict: Dict[str, Dict[str, Any]],\n    json_schema: Dict[str, Any] = JSON_SCHEMA_CONFIG,\n    verbose: bool = False,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 154,
        "coloffset": 4,
        "linematch": "\"\"\"Validate the provided file according to the provided JSON schema.\"\"\"",
        "context": "    yaml_data_dict: Dict[str, Dict[str, Any]],\n    json_schema: Dict[str, Any] = JSON_SCHEMA_CONFIG,\n    verbose: bool = False,\n) -> bool:\n    \"\"\"Validate the provided file according to the provided JSON schema.\"\"\"\n    # perform the validation of the configuration file\n    (validated, errors) = validate_configuration(yaml_data_dict, json_schema)\n    output.console.print(\n        f\":sparkles: Validated {file_name}? {util.get_human_readable_boolean(validated)}\"\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 156,
        "coloffset": 4,
        "linematch": "(validated, errors) = validate_configuration(yaml_data_dict, json_schema)",
        "context": "    verbose: bool = False,\n) -> bool:\n    \"\"\"Validate the provided file according to the provided JSON schema.\"\"\"\n    # perform the validation of the configuration file\n    (validated, errors) = validate_configuration(yaml_data_dict, json_schema)\n    output.console.print(\n        f\":sparkles: Validated {file_name}? {util.get_human_readable_boolean(validated)}\"\n    )\n    # there was a validation error, so display the error report\n    if not validated:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 157,
        "coloffset": 4,
        "linematch": "output.console.print(",
        "context": ") -> bool:\n    \"\"\"Validate the provided file according to the provided JSON schema.\"\"\"\n    # perform the validation of the configuration file\n    (validated, errors) = validate_configuration(yaml_data_dict, json_schema)\n    output.console.print(\n        f\":sparkles: Validated {file_name}? {util.get_human_readable_boolean(validated)}\"\n    )\n    # there was a validation error, so display the error report\n    if not validated:\n        output.console.print(f\":person_shrugging: Validation errors:\\n\\n{errors}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 161,
        "coloffset": 4,
        "linematch": "if not validated:",
        "context": "    output.console.print(\n        f\":sparkles: Validated {file_name}? {util.get_human_readable_boolean(validated)}\"\n    )\n    # there was a validation error, so display the error report\n    if not validated:\n        output.console.print(f\":person_shrugging: Validation errors:\\n\\n{errors}\")\n    # validation worked correctly, so display the configuration file\n    else:\n        output.opt_print_log(verbose, newline=\"\")\n        output.opt_print_log(verbose, label=f\":sparkles: Contents of {file_name}:\\n\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 168,
        "coloffset": 4,
        "linematch": "return validated",
        "context": "    else:\n        output.opt_print_log(verbose, newline=\"\")\n        output.opt_print_log(verbose, label=f\":sparkles: Contents of {file_name}:\\n\")\n        output.opt_print_log(verbose, config_file=configuration_file_yaml_str)\n    return validated",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #306",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #307",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1374",
        "line": 148,
        "description": [
          "        console.print(f\"{small_bullet_unicode} Directory: {directory}\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1375",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1376",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1377",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1378",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1379",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1380",
        "line": 156,
        "description": [
          "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1381",
        "line": 160,
        "description": [
          "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "split_file",
    "function_scope": "21-29",
    "patterns": [
      {
        "lineno": 27,
        "coloffset": 12,
        "linematch": "if strip_row:",
        "context": "    check_list = []\n    with open(file_name) as file:\n        for row in file:\n            strip_row = row.strip()  # Remove leading/trailing white spaces\n            if strip_row:\n                check_list.append(strip_row.split(\",\"))\n    return check_list\n\n\ndef write_checks(check_list: List[List[str]]) -> str:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 21,
        "coloffset": 0,
        "linematch": "def split_file(file_name: Path) -> List[List[str]]:",
        "context": "}\nCHECK_DEFAULT = [\"\", \"1\", False]\n\n\ndef split_file(file_name: Path) -> List[List[str]]:\n    \"\"\"Split a csv file into a list of lists.\"\"\"\n    check_list = []\n    with open(file_name) as file:\n        for row in file:\n            strip_row = row.strip()  # Remove leading/trailing white spaces",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "\"\"\"Split a csv file into a list of lists.\"\"\"",
        "context": "CHECK_DEFAULT = [\"\", \"1\", False]\n\n\ndef split_file(file_name: Path) -> List[List[str]]:\n    \"\"\"Split a csv file into a list of lists.\"\"\"\n    check_list = []\n    with open(file_name) as file:\n        for row in file:\n            strip_row = row.strip()  # Remove leading/trailing white spaces\n            if strip_row:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "check_list = []",
        "context": "\n\ndef split_file(file_name: Path) -> List[List[str]]:\n    \"\"\"Split a csv file into a list of lists.\"\"\"\n    check_list = []\n    with open(file_name) as file:\n        for row in file:\n            strip_row = row.strip()  # Remove leading/trailing white spaces\n            if strip_row:\n                check_list.append(strip_row.split(\",\"))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "with open(file_name) as file:",
        "context": "\ndef split_file(file_name: Path) -> List[List[str]]:\n    \"\"\"Split a csv file into a list of lists.\"\"\"\n    check_list = []\n    with open(file_name) as file:\n        for row in file:\n            strip_row = row.strip()  # Remove leading/trailing white spaces\n            if strip_row:\n                check_list.append(strip_row.split(\",\"))\n    return check_list",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "return check_list",
        "context": "        for row in file:\n            strip_row = row.strip()  # Remove leading/trailing white spaces\n            if strip_row:\n                check_list.append(strip_row.split(\",\"))\n    return check_list\n\n\ndef write_checks(check_list: List[List[str]]) -> str:\n    \"\"\"Generate structured output based on the contents of the file.\"\"\"\n    if len(check_list) != 0:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "write_checks",
    "function_scope": "32-40",
    "patterns": [
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "if len(check_list) != 0:",
        "context": "\n\ndef write_checks(check_list: List[List[str]]) -> str:\n    \"\"\"Generate structured output based on the contents of the file.\"\"\"\n    if len(check_list) != 0:\n        result = \"Make a YAML file that checks for:\"\n        for checks in check_list:\n            quantity = \"exactly\" if checks[2] == \"True\" else \"at minimum\"\n            result += f\"\\n - {quantity} {checks[1]} {checks[0]}\"\n        return result",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 32,
        "coloffset": 0,
        "linematch": "def write_checks(check_list: List[List[str]]) -> str:",
        "context": "                check_list.append(strip_row.split(\",\"))\n    return check_list\n\n\ndef write_checks(check_list: List[List[str]]) -> str:\n    \"\"\"Generate structured output based on the contents of the file.\"\"\"\n    if len(check_list) != 0:\n        result = \"Make a YAML file that checks for:\"\n        for checks in check_list:\n            quantity = \"exactly\" if checks[2] == \"True\" else \"at minimum\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "\"\"\"Generate structured output based on the contents of the file.\"\"\"",
        "context": "    return check_list\n\n\ndef write_checks(check_list: List[List[str]]) -> str:\n    \"\"\"Generate structured output based on the contents of the file.\"\"\"\n    if len(check_list) != 0:\n        result = \"Make a YAML file that checks for:\"\n        for checks in check_list:\n            quantity = \"exactly\" if checks[2] == \"True\" else \"at minimum\"\n            result += f\"\\n - {quantity} {checks[1]} {checks[0]}\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "if len(check_list) != 0:",
        "context": "\n\ndef write_checks(check_list: List[List[str]]) -> str:\n    \"\"\"Generate structured output based on the contents of the file.\"\"\"\n    if len(check_list) != 0:\n        result = \"Make a YAML file that checks for:\"\n        for checks in check_list:\n            quantity = \"exactly\" if checks[2] == \"True\" else \"at minimum\"\n            result += f\"\\n - {quantity} {checks[1]} {checks[0]}\"\n        return result",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "return \"[red][ERROR][/red] No checks were supplied\"",
        "context": "        for checks in check_list:\n            quantity = \"exactly\" if checks[2] == \"True\" else \"at minimum\"\n            result += f\"\\n - {quantity} {checks[1]} {checks[0]}\"\n        return result\n    return \"[red][ERROR][/red] No checks were supplied\"\n\n\ndef store_in_file(File: Path, Pattern, Matches, Exact):\n    \"\"\"Store inputed values into a text file\"\"\"\n    File.touch()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "on_input_changed",
    "function_scope": "117-125",
    "patterns": [
      {
        "lineno": 120,
        "coloffset": 8,
        "linematch": "if event.input.id == \"Check\":",
        "context": "\n    def on_input_changed(self, event: Input.Changed) -> None:\n        \"\"\"When inputs change this updates the values of Check\"\"\"\n        self.Valid = False\n        if event.input.id == \"Check\":\n            self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n        elif event.validation_result is not None:\n            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 122,
        "coloffset": 8,
        "linematch": "elif event.validation_result is not None:",
        "context": "        \"\"\"When inputs change this updates the values of Check\"\"\"\n        self.Valid = False\n        if event.input.id == \"Check\":\n            self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n        elif event.validation_result is not None:\n            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 123,
        "coloffset": 12,
        "linematch": "if event.validation_result.is_valid:",
        "context": "        self.Valid = False\n        if event.input.id == \"Check\":\n            self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n        elif event.validation_result is not None:\n            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"Exact\":",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 123,
        "coloffset": 12,
        "linematch": "if event.validation_result.is_valid:",
        "context": "        self.Valid = False\n        if event.input.id == \"Check\":\n            self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n        elif event.validation_result is not None:\n            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"Exact\":",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 117,
        "coloffset": 4,
        "linematch": "def on_input_changed(self, event: Input.Changed) -> None:",
        "context": "    \"\"\"\n    Check: ClassVar[list] = [\"\", \"1\", False]\n    Valid: bool = False\n\n    def on_input_changed(self, event: Input.Changed) -> None:\n        \"\"\"When inputs change this updates the values of Check\"\"\"\n        self.Valid = False\n        if event.input.id == \"Check\":\n            self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n        elif event.validation_result is not None:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 122,
        "coloffset": 8,
        "linematch": "elif event.validation_result is not None:",
        "context": "        \"\"\"When inputs change this updates the values of Check\"\"\"\n        self.Valid = False\n        if event.input.id == \"Check\":\n            self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n        elif event.validation_result is not None:\n            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 123,
        "coloffset": 12,
        "linematch": "if event.validation_result.is_valid:",
        "context": "        self.Valid = False\n        if event.input.id == \"Check\":\n            self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n        elif event.validation_result is not None:\n            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"Exact\":",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 118,
        "coloffset": 8,
        "linematch": "\"\"\"When inputs change this updates the values of Check\"\"\"",
        "context": "    Check: ClassVar[list] = [\"\", \"1\", False]\n    Valid: bool = False\n\n    def on_input_changed(self, event: Input.Changed) -> None:\n        \"\"\"When inputs change this updates the values of Check\"\"\"\n        self.Valid = False\n        if event.input.id == \"Check\":\n            self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n        elif event.validation_result is not None:\n            if event.validation_result.is_valid:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 119,
        "coloffset": 8,
        "linematch": "self.Valid = False",
        "context": "    Valid: bool = False\n\n    def on_input_changed(self, event: Input.Changed) -> None:\n        \"\"\"When inputs change this updates the values of Check\"\"\"\n        self.Valid = False\n        if event.input.id == \"Check\":\n            self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n        elif event.validation_result is not None:\n            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 120,
        "coloffset": 8,
        "linematch": "if event.input.id == \"Check\":",
        "context": "\n    def on_input_changed(self, event: Input.Changed) -> None:\n        \"\"\"When inputs change this updates the values of Check\"\"\"\n        self.Valid = False\n        if event.input.id == \"Check\":\n            self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n        elif event.validation_result is not None:\n            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #304",
        "line": 123,
        "description": [
          "            grouped_files[directory] = []"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1367",
        "line": 122,
        "description": [
          "        if directory not in grouped_files:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "on_button_pressed",
    "function_scope": "127-156",
    "patterns": [
      {
        "lineno": 128,
        "coloffset": 8,
        "linematch": "if event.button.id == \"Exact\":",
        "context": "                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"Exact\":\n            self.Check[2] = True  # Mark the \"Exact\" button as clicked\n            event.button.disabled = True  # Disable the \"Exact\" button after clicking\n        elif event.button.id == \"done\":\n            config_App.exit(\n                self",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 131,
        "coloffset": 8,
        "linematch": "elif event.button.id == \"done\":",
        "context": "    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"Exact\":\n            self.Check[2] = True  # Mark the \"Exact\" button as clicked\n            event.button.disabled = True  # Disable the \"Exact\" button after clicking\n        elif event.button.id == \"done\":\n            config_App.exit(\n                self\n            )  # Exit the application if the \"Done\" button is clicked\n        elif event.button.id == \"clear\":\n            with open(CHECK_STORAGE, \"w\") as file:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 135,
        "coloffset": 8,
        "linematch": "elif event.button.id == \"clear\":",
        "context": "        elif event.button.id == \"done\":\n            config_App.exit(\n                self\n            )  # Exit the application if the \"Done\" button is clicked\n        elif event.button.id == \"clear\":\n            with open(CHECK_STORAGE, \"w\") as file:\n                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 140,
        "coloffset": 8,
        "linematch": "elif self.Valid:",
        "context": "            with open(CHECK_STORAGE, \"w\") as file:\n                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 141,
        "coloffset": 12,
        "linematch": "if event.button.id == \"next\":",
        "context": "                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )\n                self.Check[0] = \"\"",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 141,
        "coloffset": 12,
        "linematch": "if event.button.id == \"next\":",
        "context": "                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )\n                self.Check[0] = \"\"",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 141,
        "coloffset": 15,
        "linematch": "if event.button.id == \"next\":",
        "context": "                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )\n                self.Check[0] = \"\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 141,
        "coloffset": 15,
        "linematch": "if event.button.id == \"next\":",
        "context": "                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )\n                self.Check[0] = \"\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 141,
        "coloffset": 15,
        "linematch": "if event.button.id == \"next\":",
        "context": "                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )\n                self.Check[0] = \"\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 141,
        "coloffset": 15,
        "linematch": "if event.button.id == \"next\":",
        "context": "                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )\n                self.Check[0] = \"\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 141,
        "coloffset": 15,
        "linematch": "if event.button.id == \"next\":",
        "context": "                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )\n                self.Check[0] = \"\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 141,
        "coloffset": 15,
        "linematch": "if event.button.id == \"next\":",
        "context": "                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )\n                self.Check[0] = \"\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 127,
        "coloffset": 4,
        "linematch": "def on_button_pressed(self, event: Button.Pressed) -> None:",
        "context": "            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"Exact\":\n            self.Check[2] = True  # Mark the \"Exact\" button as clicked\n            event.button.disabled = True  # Disable the \"Exact\" button after clicking\n        elif event.button.id == \"done\":\n            config_App.exit(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 131,
        "coloffset": 8,
        "linematch": "elif event.button.id == \"done\":",
        "context": "    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"Exact\":\n            self.Check[2] = True  # Mark the \"Exact\" button as clicked\n            event.button.disabled = True  # Disable the \"Exact\" button after clicking\n        elif event.button.id == \"done\":\n            config_App.exit(\n                self\n            )  # Exit the application if the \"Done\" button is clicked\n        elif event.button.id == \"clear\":\n            with open(CHECK_STORAGE, \"w\") as file:",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 135,
        "coloffset": 8,
        "linematch": "elif event.button.id == \"clear\":",
        "context": "        elif event.button.id == \"done\":\n            config_App.exit(\n                self\n            )  # Exit the application if the \"Done\" button is clicked\n        elif event.button.id == \"clear\":\n            with open(CHECK_STORAGE, \"w\") as file:\n                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 140,
        "coloffset": 8,
        "linematch": "elif self.Valid:",
        "context": "            with open(CHECK_STORAGE, \"w\") as file:\n                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 141,
        "coloffset": 12,
        "linematch": "if event.button.id == \"next\":",
        "context": "                file.write(\n                    \"\"\n                )  # Clears Checks.txt file when \"Clear Check\" button is clicked\n        elif self.Valid:\n            if event.button.id == \"next\":\n                # If \"Next Check!\" is clicked and input is valid, record the input data to a file\n                store_in_file(\n                    CHECK_STORAGE, self.Check[0], self.Check[1], self.Check[2]\n                )\n                self.Check[0] = \"\"",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 128,
        "coloffset": 8,
        "linematch": "if event.button.id == \"Exact\":",
        "context": "                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"Exact\":\n            self.Check[2] = True  # Mark the \"Exact\" button as clicked\n            event.button.disabled = True  # Disable the \"Exact\" button after clicking\n        elif event.button.id == \"done\":\n            config_App.exit(\n                self",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 127,
        "coloffset": 4,
        "linematch": "def on_button_pressed(self, event: Button.Pressed) -> None:",
        "context": "            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"Exact\":\n            self.Check[2] = True  # Mark the \"Exact\" button as clicked\n            event.button.disabled = True  # Disable the \"Exact\" button after clicking\n        elif event.button.id == \"done\":\n            config_App.exit(",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 127,
        "coloffset": 4,
        "linematch": "def on_button_pressed(self, event: Button.Pressed) -> None:",
        "context": "            if event.validation_result.is_valid:\n                self.Check[CHECK_VALUE[str(event.input.name)]] = event.input.value\n                self.Valid = True\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"Exact\":\n            self.Check[2] = True  # Mark the \"Exact\" button as clicked\n            event.button.disabled = True  # Disable the \"Exact\" button after clicking\n        elif event.button.id == \"done\":\n            config_App.exit(",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #305",
        "line": 143,
        "description": [
          "    grouped_files = group_files_by_directory(container)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #306",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #307",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1368",
        "line": 132,
        "description": [
          "    if len(file_name) > max_length:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1369",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1370",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1371",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1372",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1373",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1374",
        "line": 148,
        "description": [
          "        console.print(f\"{small_bullet_unicode} Directory: {directory}\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1375",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1376",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1377",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1378",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1379",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1380",
        "line": 156,
        "description": [
          "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "include_or_exclude_checks",
    "function_scope": "12-43",
    "patterns": [
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "if check_attribute is None or check_match is None:",
        "context": "    filtered_checks = []\n    # at least one aspect of the inputs was not specified (likely due to\n    # the fact that the command-line argument(s) were not used) and thus\n    # there is no filtering that should take place; return the input\n    if check_attribute is None or check_match is None:\n        return checks\n    # the function's inputs are valid and so perform the filtering\n    for check in checks:\n        # extract the contents of the requested attribute for inclusion\n        check_requested_include_attribute = check[check_attribute]",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 36,
        "coloffset": 8,
        "linematch": "if (fuzzy_value >= check_confidence) and include:",
        "context": "        # --> specified match string\n        fuzzy_value = fuzz.ratio(check_match, check_requested_include_attribute)\n        # include the check if the fuzzy inclusion value is above (or equal to) threshold\n        # and the purpose of the function call is to include values\n        if (fuzzy_value >= check_confidence) and include:\n            filtered_checks.append(check)\n        # include the check if the fuzzy inclusion value is below threshold\n        # and the purpose of the function call is to exclude values;\n        # note that not including a value means that it excludes\n        elif (fuzzy_value < check_confidence) and not include:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 41,
        "coloffset": 8,
        "linematch": "elif (fuzzy_value < check_confidence) and not include:",
        "context": "            filtered_checks.append(check)\n        # include the check if the fuzzy inclusion value is below threshold\n        # and the purpose of the function call is to exclude values;\n        # note that not including a value means that it excludes\n        elif (fuzzy_value < check_confidence) and not include:\n            filtered_checks.append(check)\n    return filtered_checks\n\n\ndef filter_matches(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 24,
        "coloffset": 34,
        "linematch": "if check_attribute is None or check_match is None:",
        "context": "    filtered_checks = []\n    # at least one aspect of the inputs was not specified (likely due to\n    # the fact that the command-line argument(s) were not used) and thus\n    # there is no filtering that should take place; return the input\n    if check_attribute is None or check_match is None:\n        return checks\n    # the function's inputs are valid and so perform the filtering\n    for check in checks:\n        # extract the contents of the requested attribute for inclusion\n        check_requested_include_attribute = check[check_attribute]",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 24,
        "coloffset": 34,
        "linematch": "if check_attribute is None or check_match is None:",
        "context": "    filtered_checks = []\n    # at least one aspect of the inputs was not specified (likely due to\n    # the fact that the command-line argument(s) were not used) and thus\n    # there is no filtering that should take place; return the input\n    if check_attribute is None or check_match is None:\n        return checks\n    # the function's inputs are valid and so perform the filtering\n    for check in checks:\n        # extract the contents of the requested attribute for inclusion\n        check_requested_include_attribute = check[check_attribute]",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 12,
        "coloffset": 0,
        "linematch": "def include_or_exclude_checks(",
        "context": "\nfrom chasten import constants, enumerations\n\n\ndef include_or_exclude_checks(\n    checks: List[Dict[str, Union[str, Dict[str, int]]]],\n    check_attribute: enumerations.FilterableAttribute,\n    check_match: str,\n    check_confidence: int = constants.checks.Check_Confidence,\n    include: bool = True,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 41,
        "coloffset": 8,
        "linematch": "elif (fuzzy_value < check_confidence) and not include:",
        "context": "            filtered_checks.append(check)\n        # include the check if the fuzzy inclusion value is below threshold\n        # and the purpose of the function call is to exclude values;\n        # note that not including a value means that it excludes\n        elif (fuzzy_value < check_confidence) and not include:\n            filtered_checks.append(check)\n    return filtered_checks\n\n\ndef filter_matches(",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 12,
        "coloffset": 0,
        "linematch": "def include_or_exclude_checks(",
        "context": "\nfrom chasten import constants, enumerations\n\n\ndef include_or_exclude_checks(\n    checks: List[Dict[str, Union[str, Dict[str, int]]]],\n    check_attribute: enumerations.FilterableAttribute,\n    check_match: str,\n    check_confidence: int = constants.checks.Check_Confidence,\n    include: bool = True,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "\"\"\"Perform all of the includes and excludes for the list of checks.\"\"\"",
        "context": "    check_match: str,\n    check_confidence: int = constants.checks.Check_Confidence,\n    include: bool = True,\n) -> List[Dict[str, Union[str, Dict[str, int]]]]:\n    \"\"\"Perform all of the includes and excludes for the list of checks.\"\"\"\n    filtered_checks = []\n    # at least one aspect of the inputs was not specified (likely due to\n    # the fact that the command-line argument(s) were not used) and thus\n    # there is no filtering that should take place; return the input\n    if check_attribute is None or check_match is None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "filtered_checks = []",
        "context": "    check_confidence: int = constants.checks.Check_Confidence,\n    include: bool = True,\n) -> List[Dict[str, Union[str, Dict[str, int]]]]:\n    \"\"\"Perform all of the includes and excludes for the list of checks.\"\"\"\n    filtered_checks = []\n    # at least one aspect of the inputs was not specified (likely due to\n    # the fact that the command-line argument(s) were not used) and thus\n    # there is no filtering that should take place; return the input\n    if check_attribute is None or check_match is None:\n        return checks",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "if check_attribute is None or check_match is None:",
        "context": "    filtered_checks = []\n    # at least one aspect of the inputs was not specified (likely due to\n    # the fact that the command-line argument(s) were not used) and thus\n    # there is no filtering that should take place; return the input\n    if check_attribute is None or check_match is None:\n        return checks\n    # the function's inputs are valid and so perform the filtering\n    for check in checks:\n        # extract the contents of the requested attribute for inclusion\n        check_requested_include_attribute = check[check_attribute]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "for check in checks:",
        "context": "    # there is no filtering that should take place; return the input\n    if check_attribute is None or check_match is None:\n        return checks\n    # the function's inputs are valid and so perform the filtering\n    for check in checks:\n        # extract the contents of the requested attribute for inclusion\n        check_requested_include_attribute = check[check_attribute]\n        # compute the fuzzy match value for the specific:\n        # --> requested include attribute\n        # --> specified match string",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "return filtered_checks",
        "context": "        # and the purpose of the function call is to exclude values;\n        # note that not including a value means that it excludes\n        elif (fuzzy_value < check_confidence) and not include:\n            filtered_checks.append(check)\n    return filtered_checks\n\n\ndef filter_matches(\n    match_list: List[Union[pyastgrepsearch.Match, Any]],\n    data_type,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 12,
        "coloffset": 0,
        "linematch": "def include_or_exclude_checks(",
        "context": "\nfrom chasten import constants, enumerations\n\n\ndef include_or_exclude_checks(\n    checks: List[Dict[str, Union[str, Dict[str, int]]]],\n    check_attribute: enumerations.FilterableAttribute,\n    check_match: str,\n    check_confidence: int = constants.checks.Check_Confidence,\n    include: bool = True,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 12,
        "coloffset": 0,
        "linematch": "def include_or_exclude_checks(",
        "context": "\nfrom chasten import constants, enumerations\n\n\ndef include_or_exclude_checks(\n    checks: List[Dict[str, Union[str, Dict[str, int]]]],\n    check_attribute: enumerations.FilterableAttribute,\n    check_match: str,\n    check_confidence: int = constants.checks.Check_Confidence,\n    include: bool = True,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #299",
        "line": 19,
        "description": [
          "console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      },
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1360",
        "line": 16,
        "description": [
          "logger: logging.Logger = logging.getLogger()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "filter_matches",
    "function_scope": "46-66",
    "patterns": [
      {
        "lineno": 58,
        "coloffset": 8,
        "linematch": "if isinstance(match, data_type):",
        "context": "    for match in match_list:\n        # if the current match is of the\n        # specified type, then keep it in\n        # the list of the matching matches\n        if isinstance(match, data_type):\n            subset_match_list.append(match)\n        # if the current match is not of the\n        # specified type, then keep it in\n        # the list of non-matching matches\n        else:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 46,
        "coloffset": 0,
        "linematch": "def filter_matches(",
        "context": "            filtered_checks.append(check)\n    return filtered_checks\n\n\ndef filter_matches(\n    match_list: List[Union[pyastgrepsearch.Match, Any]],\n    data_type,\n) -> Tuple[List[pyastgrepsearch.Match], List[Any]]:\n    \"\"\"Filter the list of matches based on the provided data type.\"\"\"\n    subset_match_list = []",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 46,
        "coloffset": 0,
        "linematch": "def filter_matches(",
        "context": "            filtered_checks.append(check)\n    return filtered_checks\n\n\ndef filter_matches(\n    match_list: List[Union[pyastgrepsearch.Match, Any]],\n    data_type,\n) -> Tuple[List[pyastgrepsearch.Match], List[Any]]:\n    \"\"\"Filter the list of matches based on the provided data type.\"\"\"\n    subset_match_list = []",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "\"\"\"Filter the list of matches based on the provided data type.\"\"\"",
        "context": "def filter_matches(\n    match_list: List[Union[pyastgrepsearch.Match, Any]],\n    data_type,\n) -> Tuple[List[pyastgrepsearch.Match], List[Any]]:\n    \"\"\"Filter the list of matches based on the provided data type.\"\"\"\n    subset_match_list = []\n    did_not_match_list = []\n    # iterate through all of the matches\n    for match in match_list:\n        # if the current match is of the",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "subset_match_list = []",
        "context": "    match_list: List[Union[pyastgrepsearch.Match, Any]],\n    data_type,\n) -> Tuple[List[pyastgrepsearch.Match], List[Any]]:\n    \"\"\"Filter the list of matches based on the provided data type.\"\"\"\n    subset_match_list = []\n    did_not_match_list = []\n    # iterate through all of the matches\n    for match in match_list:\n        # if the current match is of the\n        # specified type, then keep it in",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "did_not_match_list = []",
        "context": "    data_type,\n) -> Tuple[List[pyastgrepsearch.Match], List[Any]]:\n    \"\"\"Filter the list of matches based on the provided data type.\"\"\"\n    subset_match_list = []\n    did_not_match_list = []\n    # iterate through all of the matches\n    for match in match_list:\n        # if the current match is of the\n        # specified type, then keep it in\n        # the list of the matching matches",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 54,
        "coloffset": 4,
        "linematch": "for match in match_list:",
        "context": "    \"\"\"Filter the list of matches based on the provided data type.\"\"\"\n    subset_match_list = []\n    did_not_match_list = []\n    # iterate through all of the matches\n    for match in match_list:\n        # if the current match is of the\n        # specified type, then keep it in\n        # the list of the matching matches\n        if isinstance(match, data_type):\n            subset_match_list.append(match)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 66,
        "coloffset": 4,
        "linematch": "return (subset_match_list, did_not_match_list)",
        "context": "        # the list of non-matching matches\n        else:\n            did_not_match_list.append(match)\n    # return both of the created lists\n    return (subset_match_list, did_not_match_list)\n\n\ndef organize_matches(\n    match_list: List[pyastgrepsearch.Match],\n) -> Dict[str, List[pyastgrepsearch.Match]]:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "organize_matches",
    "function_scope": "69-94",
    "patterns": [
      {
        "lineno": 82,
        "coloffset": 8,
        "linematch": "if current_match_file_name in match_dict:",
        "context": "    for current_match in match_list:\n        # extract the name of the file for the current match\n        current_match_file_name = str(current_match.path)\n        # already storing matches for this file\n        if current_match_file_name in match_dict:\n            # extract the existing list of matches for this file\n            current_match_file_list = match_dict[current_match_file_name]\n            current_match_file_list.append(current_match)\n        # not already storing matches for this file\n        else:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 69,
        "coloffset": 0,
        "linematch": "def organize_matches(",
        "context": "    # return both of the created lists\n    return (subset_match_list, did_not_match_list)\n\n\ndef organize_matches(\n    match_list: List[pyastgrepsearch.Match],\n) -> Dict[str, List[pyastgrepsearch.Match]]:\n    \"\"\"Organize the matches on a per-file basis to support simplified processing.\"\"\"\n    match_dict: Dict[str, List[pyastgrepsearch.Match]] = {}\n    # iterate through each of the matches in the list, with",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 69,
        "coloffset": 0,
        "linematch": "def organize_matches(",
        "context": "    # return both of the created lists\n    return (subset_match_list, did_not_match_list)\n\n\ndef organize_matches(\n    match_list: List[pyastgrepsearch.Match],\n) -> Dict[str, List[pyastgrepsearch.Match]]:\n    \"\"\"Organize the matches on a per-file basis to support simplified processing.\"\"\"\n    match_dict: Dict[str, List[pyastgrepsearch.Match]] = {}\n    # iterate through each of the matches in the list, with",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 72,
        "coloffset": 4,
        "linematch": "\"\"\"Organize the matches on a per-file basis to support simplified processing.\"\"\"",
        "context": "\ndef organize_matches(\n    match_list: List[pyastgrepsearch.Match],\n) -> Dict[str, List[pyastgrepsearch.Match]]:\n    \"\"\"Organize the matches on a per-file basis to support simplified processing.\"\"\"\n    match_dict: Dict[str, List[pyastgrepsearch.Match]] = {}\n    # iterate through each of the matches in the list, with\n    # the goal of creating a dictionary organized so that\n    # --> the key is the name of a file under analysis\n    # --> the value is a list of all of the matches for that file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 73,
        "coloffset": 4,
        "linematch": "match_dict: Dict[str, List[pyastgrepsearch.Match]] = {}",
        "context": "def organize_matches(\n    match_list: List[pyastgrepsearch.Match],\n) -> Dict[str, List[pyastgrepsearch.Match]]:\n    \"\"\"Organize the matches on a per-file basis to support simplified processing.\"\"\"\n    match_dict: Dict[str, List[pyastgrepsearch.Match]] = {}\n    # iterate through each of the matches in the list, with\n    # the goal of creating a dictionary organized so that\n    # --> the key is the name of a file under analysis\n    # --> the value is a list of all of the matches for that file\n    for current_match in match_list:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "for current_match in match_list:",
        "context": "    # iterate through each of the matches in the list, with\n    # the goal of creating a dictionary organized so that\n    # --> the key is the name of a file under analysis\n    # --> the value is a list of all of the matches for that file\n    for current_match in match_list:\n        # extract the name of the file for the current match\n        current_match_file_name = str(current_match.path)\n        # already storing matches for this file\n        if current_match_file_name in match_dict:\n            # extract the existing list of matches for this file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "return match_dict",
        "context": "            # add the current match to the list\n            current_match_list.append(current_match)\n            # associate this new list with the current file name\n            match_dict[current_match_file_name] = current_match_list\n    return match_dict\n\n\ndef combine_dicts(dict_list: List[Dict[Any, Any]]) -> str:\n    \"\"\"Combine all dictionaries in the list into a single list of dictionaries as a string.\"\"\"\n    # combine all of the dictionaries in the list into",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "display_serve_or_publish_details",
    "function_scope": "72-94",
    "patterns": [
      {
        "lineno": 91,
        "coloffset": 4,
        "linematch": "if not publish:",
        "context": "        f\"{constants.markers.Indent}{small_bullet_unicode} Metadata: '{output.shorten_file_name(str(metadata), 120)}'\"\n    )\n    # do not display a port if the task is publishing to fly.io\n    # because that step does not support port specification\n    if not publish:\n        output.console.print(\n            f\"{constants.markers.Indent}{small_bullet_unicode} Port: {port}\"\n        )\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 72,
        "coloffset": 0,
        "linematch": "def display_serve_or_publish_details(",
        "context": "        **kwargs,\n    )\n\n\ndef display_serve_or_publish_details(\n    label: str,\n    database_path: Path,\n    metadata: Path,\n    port: int = 8001,\n    publish: bool = False,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 72,
        "coloffset": 0,
        "linematch": "def display_serve_or_publish_details(",
        "context": "        **kwargs,\n    )\n\n\ndef display_serve_or_publish_details(\n    label: str,\n    database_path: Path,\n    metadata: Path,\n    port: int = 8001,\n    publish: bool = False,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 79,
        "coloffset": 4,
        "linematch": "\"\"\"Display diagnostic details at startup of serve or publish commands.\"\"\"",
        "context": "    metadata: Path,\n    port: int = 8001,\n    publish: bool = False,\n) -> None:\n    \"\"\"Display diagnostic details at startup of serve or publish commands.\"\"\"\n    # output diagnostic information about the datasette instance\n    output.console.print()\n    output.console.print(label)\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Database: '{output.shorten_file_name(str(database_path), 120)}'\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 81,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "    publish: bool = False,\n) -> None:\n    \"\"\"Display diagnostic details at startup of serve or publish commands.\"\"\"\n    # output diagnostic information about the datasette instance\n    output.console.print()\n    output.console.print(label)\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Database: '{output.shorten_file_name(str(database_path), 120)}'\"\n    )\n    output.console.print(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 82,
        "coloffset": 4,
        "linematch": "output.console.print(label)",
        "context": ") -> None:\n    \"\"\"Display diagnostic details at startup of serve or publish commands.\"\"\"\n    # output diagnostic information about the datasette instance\n    output.console.print()\n    output.console.print(label)\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Database: '{output.shorten_file_name(str(database_path), 120)}'\"\n    )\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Metadata: '{output.shorten_file_name(str(metadata), 120)}'\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "output.console.print(",
        "context": "    \"\"\"Display diagnostic details at startup of serve or publish commands.\"\"\"\n    # output diagnostic information about the datasette instance\n    output.console.print()\n    output.console.print(label)\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Database: '{output.shorten_file_name(str(database_path), 120)}'\"\n    )\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Metadata: '{output.shorten_file_name(str(metadata), 120)}'\"\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 86,
        "coloffset": 4,
        "linematch": "output.console.print(",
        "context": "    output.console.print(label)\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Database: '{output.shorten_file_name(str(database_path), 120)}'\"\n    )\n    output.console.print(\n        f\"{constants.markers.Indent}{small_bullet_unicode} Metadata: '{output.shorten_file_name(str(metadata), 120)}'\"\n    )\n    # do not display a port if the task is publishing to fly.io\n    # because that step does not support port specification\n    if not publish:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 91,
        "coloffset": 4,
        "linematch": "if not publish:",
        "context": "        f\"{constants.markers.Indent}{small_bullet_unicode} Metadata: '{output.shorten_file_name(str(metadata), 120)}'\"\n    )\n    # do not display a port if the task is publishing to fly.io\n    # because that step does not support port specification\n    if not publish:\n        output.console.print(\n            f\"{constants.markers.Indent}{small_bullet_unicode} Port: {port}\"\n        )\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "create_checks",
    "function_scope": "107-150",
    "patterns": [
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "if filesystem.confirm_valid_file(CHECK_STORAGE):",
        "context": "    \"\"\"\ud83d\udd27 Interactively specify for checks and have a checks.yml file created(Requires API key)\"\"\"\n    # creates a textual object for better user interface\n    app.run()\n    # Checks if the file storing the wanted checks exists and is valid\n    if filesystem.confirm_valid_file(CHECK_STORAGE):\n        # stores the human readable version of the checks\n        result = configApp.write_checks(configApp.split_file(CHECK_STORAGE))\n        # Checks if API key storage file exists\n        if filesystem.confirm_valid_file(API_KEY_STORAGE):\n            # prints the human readable checks to the terminal",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 118,
        "coloffset": 8,
        "linematch": "if filesystem.confirm_valid_file(API_KEY_STORAGE):",
        "context": "    if filesystem.confirm_valid_file(CHECK_STORAGE):\n        # stores the human readable version of the checks\n        result = configApp.write_checks(configApp.split_file(CHECK_STORAGE))\n        # Checks if API key storage file exists\n        if filesystem.confirm_valid_file(API_KEY_STORAGE):\n            # prints the human readable checks to the terminal\n            output.console.print(result)\n            # loads the decrypted API Key\n            api_key = createchecks.load_user_api_key(API_KEY_STORAGE)\n            # calls the function to generate the yaml file",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 118,
        "coloffset": 8,
        "linematch": "if filesystem.confirm_valid_file(API_KEY_STORAGE):",
        "context": "    if filesystem.confirm_valid_file(CHECK_STORAGE):\n        # stores the human readable version of the checks\n        result = configApp.write_checks(configApp.split_file(CHECK_STORAGE))\n        # Checks if API key storage file exists\n        if filesystem.confirm_valid_file(API_KEY_STORAGE):\n            # prints the human readable checks to the terminal\n            output.console.print(result)\n            # loads the decrypted API Key\n            api_key = createchecks.load_user_api_key(API_KEY_STORAGE)\n            # calls the function to generate the yaml file",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 107,
        "coloffset": 0,
        "linematch": "def create_checks(",
        "context": "# ---\n\n\n@cli.command()\ndef create_checks(\n    filename: Path = typer.Option(\"checks.yml\", help=\"YAML file name\")\n) -> None:\n    \"\"\"\ud83d\udd27 Interactively specify for checks and have a checks.yml file created(Requires API key)\"\"\"\n    # creates a textual object for better user interface\n    app.run()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 118,
        "coloffset": 8,
        "linematch": "if filesystem.confirm_valid_file(API_KEY_STORAGE):",
        "context": "    if filesystem.confirm_valid_file(CHECK_STORAGE):\n        # stores the human readable version of the checks\n        result = configApp.write_checks(configApp.split_file(CHECK_STORAGE))\n        # Checks if API key storage file exists\n        if filesystem.confirm_valid_file(API_KEY_STORAGE):\n            # prints the human readable checks to the terminal\n            output.console.print(result)\n            # loads the decrypted API Key\n            api_key = createchecks.load_user_api_key(API_KEY_STORAGE)\n            # calls the function to generate the yaml file",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 107,
        "coloffset": 0,
        "linematch": "def create_checks(",
        "context": "# ---\n\n\n@cli.command()\ndef create_checks(\n    filename: Path = typer.Option(\"checks.yml\", help=\"YAML file name\")\n) -> None:\n    \"\"\"\ud83d\udd27 Interactively specify for checks and have a checks.yml file created(Requires API key)\"\"\"\n    # creates a textual object for better user interface\n    app.run()",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 110,
        "coloffset": 4,
        "linematch": "\"\"\"\ud83d\udd27 Interactively specify for checks and have a checks.yml file created(Requires API key)\"\"\"",
        "context": "@cli.command()\ndef create_checks(\n    filename: Path = typer.Option(\"checks.yml\", help=\"YAML file name\")\n) -> None:\n    \"\"\"\ud83d\udd27 Interactively specify for checks and have a checks.yml file created(Requires API key)\"\"\"\n    # creates a textual object for better user interface\n    app.run()\n    # Checks if the file storing the wanted checks exists and is valid\n    if filesystem.confirm_valid_file(CHECK_STORAGE):\n        # stores the human readable version of the checks",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "app.run()",
        "context": "    filename: Path = typer.Option(\"checks.yml\", help=\"YAML file name\")\n) -> None:\n    \"\"\"\ud83d\udd27 Interactively specify for checks and have a checks.yml file created(Requires API key)\"\"\"\n    # creates a textual object for better user interface\n    app.run()\n    # Checks if the file storing the wanted checks exists and is valid\n    if filesystem.confirm_valid_file(CHECK_STORAGE):\n        # stores the human readable version of the checks\n        result = configApp.write_checks(configApp.split_file(CHECK_STORAGE))\n        # Checks if API key storage file exists",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "if filesystem.confirm_valid_file(CHECK_STORAGE):",
        "context": "    \"\"\"\ud83d\udd27 Interactively specify for checks and have a checks.yml file created(Requires API key)\"\"\"\n    # creates a textual object for better user interface\n    app.run()\n    # Checks if the file storing the wanted checks exists and is valid\n    if filesystem.confirm_valid_file(CHECK_STORAGE):\n        # stores the human readable version of the checks\n        result = configApp.write_checks(configApp.split_file(CHECK_STORAGE))\n        # Checks if API key storage file exists\n        if filesystem.confirm_valid_file(API_KEY_STORAGE):\n            # prints the human readable checks to the terminal",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #304",
        "line": 123,
        "description": [
          "            grouped_files[directory] = []"
        ],
        "failure": []
      },
      {
        "name": "Mutant #305",
        "line": 143,
        "description": [
          "    grouped_files = group_files_by_directory(container)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #306",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1367",
        "line": 122,
        "description": [
          "        if directory not in grouped_files:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1368",
        "line": 132,
        "description": [
          "    if len(file_name) > max_length:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1369",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1370",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1371",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1372",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1373",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1374",
        "line": 148,
        "description": [
          "        console.print(f\"{small_bullet_unicode} Directory: {directory}\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1375",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "configure",
    "function_scope": "154-248",
    "patterns": [
      {
        "lineno": 198,
        "coloffset": 4,
        "linematch": "if task == enumerations.ConfigureTask.VALIDATE:",
        "context": "    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the configuration directory and its contents\n    if task == enumerations.ConfigureTask.VALIDATE:\n        # validate the configuration files:\n        # --> config.yml (or url pointing to one)\n        # --> checks.yml (or whatever file/url is reference in config.yml)\n        (validated, _) = configuration.validate_configuration_files(config, verbose)\n        # some aspect of the configuration was not",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 211,
        "coloffset": 4,
        "linematch": "if task == enumerations.ConfigureTask.CREATE:",
        "context": "                \"\\n:person_shrugging: Cannot perform analysis due to configuration error(s).\\n\"\n            )\n            sys.exit(constants.markers.Non_Zero_Exit)\n    # create the configuration directory and a starting version of the configuration file\n    if task == enumerations.ConfigureTask.CREATE:\n        # attempt to create the configuration directory\n        try:\n            # create the configuration directory, which will either be the one\n            # specified by the config parameter (if it exists) or it will be\n            # the one in the platform-specific directory given by platformdirs",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 205,
        "coloffset": 8,
        "linematch": "if not validated:",
        "context": "        # --> checks.yml (or whatever file/url is reference in config.yml)\n        (validated, _) = configuration.validate_configuration_files(config, verbose)\n        # some aspect of the configuration was not\n        # valid, so exit early and signal an error\n        if not validated:\n            output.console.print(\n                \"\\n:person_shrugging: Cannot perform analysis due to configuration error(s).\\n\"\n            )\n            sys.exit(constants.markers.Non_Zero_Exit)\n    # create the configuration directory and a starting version of the configuration file",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 217,
        "coloffset": 12,
        "linematch": "if config is None:",
        "context": "        try:\n            # create the configuration directory, which will either be the one\n            # specified by the config parameter (if it exists) or it will be\n            # the one in the platform-specific directory given by platformdirs\n            if config is None:\n                configuration_directory = None\n            else:\n                configuration_directory = Path(config)\n            created_directory_path = filesystem.create_configuration_directory(\n                configuration_directory, force",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 241,
        "coloffset": 12,
        "linematch": "if not force:",
        "context": "        # cannot re-create the configuration directory, so display\n        # a message and suggest the use of --force the next time;\n        # exit early and signal an error with a non-zero exist code\n        except FileExistsError:\n            if not force:\n                output.console.print(\n                    \"\\n:person_shrugging: Configuration directory already exists.\"\n                )\n                output.console.print(\n                    \"Use --force to recreate configuration directory and its containing files.\"",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 205,
        "coloffset": 8,
        "linematch": "if not validated:",
        "context": "        # --> checks.yml (or whatever file/url is reference in config.yml)\n        (validated, _) = configuration.validate_configuration_files(config, verbose)\n        # some aspect of the configuration was not\n        # valid, so exit early and signal an error\n        if not validated:\n            output.console.print(\n                \"\\n:person_shrugging: Cannot perform analysis due to configuration error(s).\\n\"\n            )\n            sys.exit(constants.markers.Non_Zero_Exit)\n    # create the configuration directory and a starting version of the configuration file",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 217,
        "coloffset": 12,
        "linematch": "if config is None:",
        "context": "        try:\n            # create the configuration directory, which will either be the one\n            # specified by the config parameter (if it exists) or it will be\n            # the one in the platform-specific directory given by platformdirs\n            if config is None:\n                configuration_directory = None\n            else:\n                configuration_directory = Path(config)\n            created_directory_path = filesystem.create_configuration_directory(\n                configuration_directory, force",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 241,
        "coloffset": 12,
        "linematch": "if not force:",
        "context": "        # cannot re-create the configuration directory, so display\n        # a message and suggest the use of --force the next time;\n        # exit early and signal an error with a non-zero exist code\n        except FileExistsError:\n            if not force:\n                output.console.print(\n                    \"\\n:person_shrugging: Configuration directory already exists.\"\n                )\n                output.console.print(\n                    \"Use --force to recreate configuration directory and its containing files.\"",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 217,
        "coloffset": 15,
        "linematch": "if config is None:",
        "context": "        try:\n            # create the configuration directory, which will either be the one\n            # specified by the config parameter (if it exists) or it will be\n            # the one in the platform-specific directory given by platformdirs\n            if config is None:\n                configuration_directory = None\n            else:\n                configuration_directory = Path(config)\n            created_directory_path = filesystem.create_configuration_directory(\n                configuration_directory, force",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 19,
        "coloffset": 0,
        "linematch": "def configure(context):",
        "context": "    else:\n        # Skip all other mutations\n        context.skip = True\n\ndef configure(context):\n    context.pre_mutation = pre_mutation",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 154,
        "coloffset": 0,
        "linematch": "def configure(  # noqa: PLR0913",
        "context": "        )\n\n\n@cli.command()\ndef configure(  # noqa: PLR0913\n    task: enumerations.ConfigureTask = typer.Argument(\n        enumerations.ConfigureTask.VALIDATE.value\n    ),\n    config: str = typer.Option(\n        None,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 211,
        "coloffset": 4,
        "linematch": "if task == enumerations.ConfigureTask.CREATE:",
        "context": "                \"\\n:person_shrugging: Cannot perform analysis due to configuration error(s).\\n\"\n            )\n            sys.exit(constants.markers.Non_Zero_Exit)\n    # create the configuration directory and a starting version of the configuration file\n    if task == enumerations.ConfigureTask.CREATE:\n        # attempt to create the configuration directory\n        try:\n            # create the configuration directory, which will either be the one\n            # specified by the config parameter (if it exists) or it will be\n            # the one in the platform-specific directory given by platformdirs",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 205,
        "coloffset": 8,
        "linematch": "if not validated:",
        "context": "        # --> checks.yml (or whatever file/url is reference in config.yml)\n        (validated, _) = configuration.validate_configuration_files(config, verbose)\n        # some aspect of the configuration was not\n        # valid, so exit early and signal an error\n        if not validated:\n            output.console.print(\n                \"\\n:person_shrugging: Cannot perform analysis due to configuration error(s).\\n\"\n            )\n            sys.exit(constants.markers.Non_Zero_Exit)\n    # create the configuration directory and a starting version of the configuration file",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 217,
        "coloffset": 12,
        "linematch": "if config is None:",
        "context": "        try:\n            # create the configuration directory, which will either be the one\n            # specified by the config parameter (if it exists) or it will be\n            # the one in the platform-specific directory given by platformdirs\n            if config is None:\n                configuration_directory = None\n            else:\n                configuration_directory = Path(config)\n            created_directory_path = filesystem.create_configuration_directory(\n                configuration_directory, force",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 241,
        "coloffset": 12,
        "linematch": "if not force:",
        "context": "        # cannot re-create the configuration directory, so display\n        # a message and suggest the use of --force the next time;\n        # exit early and signal an error with a non-zero exist code\n        except FileExistsError:\n            if not force:\n                output.console.print(\n                    \"\\n:person_shrugging: Configuration directory already exists.\"\n                )\n                output.console.print(\n                    \"Use --force to recreate configuration directory and its containing files.\"",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 154,
        "coloffset": 0,
        "linematch": "def configure(  # noqa: PLR0913",
        "context": "        )\n\n\n@cli.command()\ndef configure(  # noqa: PLR0913\n    task: enumerations.ConfigureTask = typer.Argument(\n        enumerations.ConfigureTask.VALIDATE.value\n    ),\n    config: str = typer.Option(\n        None,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "context.pre_mutation = pre_mutation",
        "context": "        # Skip all other mutations\n        context.skip = True\n\ndef configure(context):\n    context.pre_mutation = pre_mutation",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 182,
        "coloffset": 4,
        "linematch": "\"\"\"\ud83e\ude82 Manage chasten's configuration.\"\"\"",
        "context": "        help=\"Create configuration directory and files even if they exist\",\n    ),\n    verbose: bool = typer.Option(False, help=\"Display verbose debugging output\"),\n) -> None:\n    \"\"\"\ud83e\ude82 Manage chasten's configuration.\"\"\"\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,\n        debug_destination,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 184,
        "coloffset": 4,
        "linematch": "output_preamble(",
        "context": "    verbose: bool = typer.Option(False, help=\"Display verbose debugging output\"),\n) -> None:\n    \"\"\"\ud83e\ude82 Manage chasten's configuration.\"\"\"\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,\n        debug_destination,\n        task=task.value,\n        config=config,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 193,
        "coloffset": 4,
        "linematch": "output.setup(debug_level, debug_destination)",
        "context": "        config=config,\n        force=force,\n    )\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the configuration directory and its contents\n    if task == enumerations.ConfigureTask.VALIDATE:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 194,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Display verbose output? {verbose}\")",
        "context": "        force=force,\n    )\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the configuration directory and its contents\n    if task == enumerations.ConfigureTask.VALIDATE:\n        # validate the configuration files:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 195,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Debug level? {debug_level.value}\")",
        "context": "    )\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the configuration directory and its contents\n    if task == enumerations.ConfigureTask.VALIDATE:\n        # validate the configuration files:\n        # --> config.yml (or url pointing to one)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 196,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Debug destination? {debug_destination.value}\")",
        "context": "    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the configuration directory and its contents\n    if task == enumerations.ConfigureTask.VALIDATE:\n        # validate the configuration files:\n        # --> config.yml (or url pointing to one)\n        # --> checks.yml (or whatever file/url is reference in config.yml)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 198,
        "coloffset": 4,
        "linematch": "if task == enumerations.ConfigureTask.VALIDATE:",
        "context": "    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the configuration directory and its contents\n    if task == enumerations.ConfigureTask.VALIDATE:\n        # validate the configuration files:\n        # --> config.yml (or url pointing to one)\n        # --> checks.yml (or whatever file/url is reference in config.yml)\n        (validated, _) = configuration.validate_configuration_files(config, verbose)\n        # some aspect of the configuration was not",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 211,
        "coloffset": 4,
        "linematch": "if task == enumerations.ConfigureTask.CREATE:",
        "context": "                \"\\n:person_shrugging: Cannot perform analysis due to configuration error(s).\\n\"\n            )\n            sys.exit(constants.markers.Non_Zero_Exit)\n    # create the configuration directory and a starting version of the configuration file\n    if task == enumerations.ConfigureTask.CREATE:\n        # attempt to create the configuration directory\n        try:\n            # create the configuration directory, which will either be the one\n            # specified by the config parameter (if it exists) or it will be\n            # the one in the platform-specific directory given by platformdirs",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 154,
        "coloffset": 0,
        "linematch": "def configure(  # noqa: PLR0913",
        "context": "        )\n\n\n@cli.command()\ndef configure(  # noqa: PLR0913\n    task: enumerations.ConfigureTask = typer.Argument(\n        enumerations.ConfigureTask.VALIDATE.value\n    ),\n    config: str = typer.Option(\n        None,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 154,
        "coloffset": 0,
        "linematch": "def configure(  # noqa: PLR0913",
        "context": "        )\n\n\n@cli.command()\ndef configure(  # noqa: PLR0913\n    task: enumerations.ConfigureTask = typer.Argument(\n        enumerations.ConfigureTask.VALIDATE.value\n    ),\n    config: str = typer.Option(\n        None,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #308",
        "line": 176,
        "description": [
          "        current_xpath_pattern = current_check.pattern"
        ],
        "failure": []
      },
      {
        "name": "Mutant #309",
        "line": 182,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #310",
        "line": 187,
        "description": [
          "        min_count = current_check.min"
        ],
        "failure": []
      },
      {
        "name": "Mutant #311",
        "line": 188,
        "description": [
          "        max_count = current_check.max"
        ],
        "failure": []
      },
      {
        "name": "Mutant #312",
        "line": 189,
        "description": [
          "        min_label = checks.create_attribute_label(min_count, constants.checks.Check_Min)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #313",
        "line": 190,
        "description": [
          "        max_label = checks.create_attribute_label(max_count, constants.checks.Check_Max)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #314",
        "line": 193,
        "description": [
          "        check_id = current_check.id"
        ],
        "failure": []
      },
      {
        "name": "Mutant #315",
        "line": 194,
        "description": [
          "        check_id_label = checks.create_attribute_label(check_id, constants.checks.Check_Id)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #316",
        "line": 195,
        "description": [
          "        check_name = current_check.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #317",
        "line": 196,
        "description": [
          "        check_name_label = checks.create_attribute_label(check_name, constants.checks.Check_Name)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #318",
        "line": 200,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #319",
        "line": 223,
        "description": [
          "                    position_end = current_match.position.lineno"
        ],
        "failure": []
      },
      {
        "name": "Mutant #320",
        "line": 225,
        "description": [
          "                    column_offset = current_match.position.col_offset"
        ],
        "failure": []
      },
      {
        "name": "Mutant #321",
        "line": 230,
        "description": [
          "                    all_lines = current_match.file_lines"
        ],
        "failure": []
      },
      {
        "name": "Mutant #322",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #323",
        "line": 240,
        "description": [
          "                    ]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1380",
        "line": 156,
        "description": [
          "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1381",
        "line": 160,
        "description": [
          "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1382",
        "line": 169,
        "description": [
          "    if not verbose:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1383",
        "line": 171,
        "description": [
          "    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1384",
        "line": 175,
        "description": [
          "        current_check: results.Check = current_source.check  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1385",
        "line": 177,
        "description": [
          "        console.print(\"\\n:tada: Check:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1386",
        "line": 205,
        "description": [
          "                expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1387",
        "line": 206,
        "description": [
          "                title=f\"{combined_attribute_label}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1388",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1389",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1390",
        "line": 214,
        "description": [
          "                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1391",
        "line": 221,
        "description": [
          "                    opt_print_log(verbose, label=\":sparkles: Matching source code:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1392",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1393",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1394",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1395",
        "line": 239,
        "description": [
          "                        + constants.markers.Code_Context"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "analyze",
    "function_scope": "252-728",
    "patterns": [
      {
        "lineno": 395,
        "coloffset": 4,
        "linematch": "if not validated:",
        "context": "        config, verbose\n    )\n    # some aspect of the configuration was not\n    # valid, so exit early and signal an error\n    if not validated:\n        output.console.print(\n            \"\\n:person_shrugging: Cannot perform analysis due to configuration error(s).\\n\"\n        )\n        output.logger.debug(\"Cannot perform analysis due to configuration error(s)\")\n        sys.exit(constants.markers.Non_Zero_Exit)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 421,
        "coloffset": 4,
        "linematch": "if not filesystem.confirm_valid_directory(",
        "context": "    # not possible to analyze the Python source files in this directory\n    # OR\n    # the specified search path is not valid and thus it is\n    # not possible to analyze the specific Python source code file\n    if not filesystem.confirm_valid_directory(\n        input_path\n    ) and not filesystem.confirm_valid_file(input_path):\n        output.console.print(\n            \"\\n:person_shrugging: Cannot perform analysis due to invalid search directory.\\n\"\n        )",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 428,
        "coloffset": 4,
        "linematch": "if store_result:",
        "context": "        output.console.print(\n            \"\\n:person_shrugging: Cannot perform analysis due to invalid search directory.\\n\"\n        )\n        sys.exit(constants.markers.Non_Zero_Exit)\n    if store_result:\n        # creates an empty string for storing results temporarily\n        analysis_result = \"\"\n        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 461,
        "coloffset": 4,
        "linematch": "if xpath == \"1.0\":",
        "context": "    output.console.print()\n    # create a check_status list for all of the checks\n    check_status_list: List[bool] = []\n    # check XPATH version\n    if xpath == \"1.0\":\n        output.logger.debug(\"Using XPath version 1.0\")\n    else:\n        output.logger.debug(\"Using XPath version 2.0\")\n    # iterate through and perform each of the checks\n    for current_check in check_list:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 643,
        "coloffset": 4,
        "linematch": "if saved_file_name:",
        "context": "    saved_file_name = filesystem.write_chasten_results(\n        output_directory, project, chasten_results_save, save\n    )\n    # output the name of the saved file if saving successfully took place\n    if saved_file_name:\n        output.console.print(f\"\\n:sparkles: Saved the file '{saved_file_name}'\")\n    # --save-xml and --view-xml\n    if save_XML is not None or view_XML is not None:\n        output.console.print(\":memo: Saving XML...\")\n        try:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 646,
        "coloffset": 4,
        "linematch": "if save_XML is not None or view_XML is not None:",
        "context": "    # output the name of the saved file if saving successfully took place\n    if saved_file_name:\n        output.console.print(f\"\\n:sparkles: Saved the file '{saved_file_name}'\")\n    # --save-xml and --view-xml\n    if save_XML is not None or view_XML is not None:\n        output.console.print(\":memo: Saving XML...\")\n        try:\n            if os.path.isdir(input_path):\n                for each_file in os.listdir(input_path):\n                    each_file = Path(input_path) / Path(each_file)  # type: ignore # noqa: PLW2901",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 709,
        "coloffset": 4,
        "linematch": "if not all_checks_passed:",
        "context": "    all_checks_passed = all(check_status_list)\n    end_time = time.time()\n    elapsed_time = end_time - start_time\n\n    if not all_checks_passed:\n        output.console.print(\":sweat: At least one check did not pass.\")\n        if store_result:\n            # writes results of analyze into a markdown file\n            analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n            output.console.print(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 722,
        "coloffset": 4,
        "linematch": "if store_result:",
        "context": "    output.console.print(\n        f\"\\n:joy: All checks passed. Elapsed Time: {elapsed_time} seconds\"\n    )\n    output.logger.debug(\"Analysis complete.\")\n    if store_result:\n        # writes results of analyze into a markdown file\n        result_path = os.path.abspath(analysis_file_dir)\n        analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n        output.console.print(f\"\\n:sparkles: Results saved in: {result_path}\\n\")\n        if display:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 433,
        "coloffset": 8,
        "linematch": "if filesystem.confirm_valid_file(analysis_file_dir):",
        "context": "        # creates an empty string for storing results temporarily\n        analysis_result = \"\"\n        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):\n            if not force:\n                if display:\n                    database.display_results_frog_mouth(\n                        analysis_file_dir, util.get_OS()\n                    )",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 434,
        "coloffset": 12,
        "linematch": "if not force:",
        "context": "        analysis_result = \"\"\n        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):\n            if not force:\n                if display:\n                    database.display_results_frog_mouth(\n                        analysis_file_dir, util.get_OS()\n                    )\n                    sys.exit(0)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 435,
        "coloffset": 16,
        "linematch": "if display:",
        "context": "        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):\n            if not force:\n                if display:\n                    database.display_results_frog_mouth(\n                        analysis_file_dir, util.get_OS()\n                    )\n                    sys.exit(0)\n                else:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 488,
        "coloffset": 8,
        "linematch": "if xpath == \"1.0\":",
        "context": "        # this looks for matches across all path(s) in the specified source path\n        # match_generator = pyastgrepsearch.search_python_files(\n        #         paths=valid_directories, expression=current_xpath_pattern, xpath2=True\n        # )\n        if xpath == \"1.0\":\n            match_generator = pyastgrepsearch.search_python_files(\n                paths=valid_directories, expression=current_xpath_pattern, xpath2=False\n            )\n        else:\n            match_generator = pyastgrepsearch.search_python_files(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 510,
        "coloffset": 8,
        "linematch": "if checks.is_checkable(min_count, max_count):",
        "context": "        # correspond so that processing of matches takes place per-file\n        match_dict = process.organize_matches(match_generator_list)\n        # perform an enforceable check if it is warranted for this check\n        current_check_save = None\n        if checks.is_checkable(min_count, max_count):\n            # determine whether or not the number of found matches is within mix and max\n            check_status = checks.check_match_count(\n                len(match_generator_list), min_count, max_count\n            )\n            # keep track of the outcome for this check",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 531,
        "coloffset": 8,
        "linematch": "if store_result:",
        "context": "        output.console.print(\n            f\"  {check_status_symbol} id: '{check_id}', name: '{check_name}'\"\n            + f\", pattern: '{current_xpath_pattern_escape}', min={min_count}, max={max_count}\"\n        )\n        if store_result:\n            # makes the check marks or x's appear as words instead for markdown\n            check_pass = (\n                \"PASSED:\"\n                if check_status_symbol == \"[green]\\u2713[/green]\"\n                else \"FAILED:\"",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 551,
        "coloffset": 8,
        "linematch": "if len(match_generator_list) == 0:",
        "context": "            filename=str(str(vd) for vd in valid_directories)\n        )\n        # there were no matches and thus the current_check_save of None\n        # should be recorded inside of the source of the results\n        if len(match_generator_list) == 0:\n            current_result_source.check = current_check_save\n        # iteratively analyze:\n        # a) A specific file name\n        # b) All of the matches for that file name\n        # Note: the goal is to only process matches for a",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 580,
        "coloffset": 12,
        "linematch": "if store_result:",
        "context": "            # display minimal diagnostic output\n            output.console.print(\n                f\"    {small_bullet_unicode} {file_name} - {len(matches_list)} matches\"\n            )\n            if store_result:\n                # stores details of checks in string to be stored later\n                analysis_result += f\"    - {file_name} - {len(matches_list)} matches\\n\"\n            # extract the lines of source code for this file; note that all of\n            # these matches are organized for the same file and thus it is\n            # acceptable to extract the lines of the file from the first match",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 587,
        "coloffset": 12,
        "linematch": "if len(matches_list) > 0:",
        "context": "            # extract the lines of source code for this file; note that all of\n            # these matches are organized for the same file and thus it is\n            # acceptable to extract the lines of the file from the first match\n            # a long as there are matches available for analysis\n            if len(matches_list) > 0:\n                current_result_source._filelines = matches_list[0].file_lines\n            # iterate through all of the matches that are specifically\n            # connected to this source that is connected to a specific file name\n            for current_match in matches_list:\n                if isinstance(current_match, pyastgrepsearch.Match):",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 592,
        "coloffset": 16,
        "linematch": "if isinstance(current_match, pyastgrepsearch.Match):",
        "context": "                current_result_source._filelines = matches_list[0].file_lines\n            # iterate through all of the matches that are specifically\n            # connected to this source that is connected to a specific file name\n            for current_match in matches_list:\n                if isinstance(current_match, pyastgrepsearch.Match):\n                    current_result_source._filelines = current_match.file_lines\n                    # extract the direct line number for this match\n                    position_end = current_match.position.lineno\n                    # extract the column offset for this match\n                    column_offset = current_match.position.col_offset",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 649,
        "coloffset": 12,
        "linematch": "if os.path.isdir(input_path):",
        "context": "    # --save-xml and --view-xml\n    if save_XML is not None or view_XML is not None:\n        output.console.print(\":memo: Saving XML...\")\n        try:\n            if os.path.isdir(input_path):\n                for each_file in os.listdir(input_path):\n                    each_file = Path(input_path) / Path(each_file)  # type: ignore # noqa: PLW2901\n                    if (\n                        not os.path.isdir(each_file)\n                        and os.path.isfile(each_file)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 652,
        "coloffset": 20,
        "linematch": "if (",
        "context": "        try:\n            if os.path.isdir(input_path):\n                for each_file in os.listdir(input_path):\n                    each_file = Path(input_path) / Path(each_file)  # type: ignore # noqa: PLW2901\n                    if (\n                        not os.path.isdir(each_file)\n                        and os.path.isfile(each_file)\n                        and str(each_file).endswith(\".py\")\n                    ):\n                        # Read the bytes of the input path and store them in the 'contents' variable",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 666,
        "coloffset": 24,
        "linematch": "if view_XML is not None:",
        "context": "                        )\n                        # Convert the Abstract Syntax Tree (AST) into an XML representation\n                        xml_root = pyastgrep.asts.ast_to_xml(ast, {})\n                        # Check if view_xml is chosen\n                        if view_XML is not None:\n                            output.console.print(\n                                pyastgrep.xml.tostring(\n                                    xml_root, pretty_print=True\n                                ).decode(\"utf-8\")\n                            )",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 672,
        "coloffset": 20,
        "linematch": "elif os.path.isdir(each_file):",
        "context": "                                pyastgrep.xml.tostring(\n                                    xml_root, pretty_print=True\n                                ).decode(\"utf-8\")\n                            )\n                    elif os.path.isdir(each_file):\n                        for sub_file in os.listdir(each_file):\n                            sub_file = Path(each_file) / Path(sub_file)  # type: ignore # noqa: PLW2901\n                            if str(sub_file).endswith(\".py\"):\n                                contents = Path(sub_file).read_bytes()\n                                _, ast = pyastgrep.files.parse_python_file(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 675,
        "coloffset": 28,
        "linematch": "if str(sub_file).endswith(\".py\"):",
        "context": "                            )\n                    elif os.path.isdir(each_file):\n                        for sub_file in os.listdir(each_file):\n                            sub_file = Path(each_file) / Path(sub_file)  # type: ignore # noqa: PLW2901\n                            if str(sub_file).endswith(\".py\"):\n                                contents = Path(sub_file).read_bytes()\n                                _, ast = pyastgrep.files.parse_python_file(\n                                    contents, sub_file, auto_dedent=False\n                                )\n                                xml_root = pyastgrep.asts.ast_to_xml(ast, {})",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 682,
        "coloffset": 32,
        "linematch": "if view_XML is not None:",
        "context": "                                    contents, sub_file, auto_dedent=False\n                                )\n                                xml_root = pyastgrep.asts.ast_to_xml(ast, {})\n                                # Check if view_xml is chosen\n                                if view_XML is not None:\n                                    output.console.print(\n                                        pyastgrep.xml.tostring(\n                                            xml_root, pretty_print=True\n                                        ).decode(\"utf-8\")\n                                    )",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 688,
        "coloffset": 12,
        "linematch": "elif os.path.isfile(input_path) and str(input_path).endswith(\".py\"):",
        "context": "                                        pyastgrep.xml.tostring(\n                                            xml_root, pretty_print=True\n                                        ).decode(\"utf-8\")\n                                    )\n            elif os.path.isfile(input_path) and str(input_path).endswith(\".py\"):\n                contents = Path(input_path).read_bytes()\n                _, ast = pyastgrep.files.parse_python_file(\n                    contents, input_path, auto_dedent=False\n                )\n                xml_root = pyastgrep.asts.ast_to_xml(ast, {})",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 695,
        "coloffset": 16,
        "linematch": "if view_XML is not None:",
        "context": "                    contents, input_path, auto_dedent=False\n                )\n                xml_root = pyastgrep.asts.ast_to_xml(ast, {})\n                # Check if view_xml is chosen\n                if view_XML is not None:\n                    output.console.print(\n                        pyastgrep.xml.tostring(xml_root, pretty_print=True).decode(\n                            \"utf-8\"\n                        )\n                    )",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 711,
        "coloffset": 8,
        "linematch": "if store_result:",
        "context": "    elapsed_time = end_time - start_time\n\n    if not all_checks_passed:\n        output.console.print(\":sweat: At least one check did not pass.\")\n        if store_result:\n            # writes results of analyze into a markdown file\n            analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n            output.console.print(\n                f\"\\n:sparkles: Results saved in: {os.path.abspath(analysis_file_dir)}\\n\"\n            )",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 727,
        "coloffset": 8,
        "linematch": "if display:",
        "context": "        # writes results of analyze into a markdown file\n        result_path = os.path.abspath(analysis_file_dir)\n        analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n        output.console.print(f\"\\n:sparkles: Results saved in: {result_path}\\n\")\n        if display:\n            database.display_results_frog_mouth(result_path, util.get_OS())\n\n\n@cli.command()\ndef integrate(  # noqa: PLR0913",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 433,
        "coloffset": 8,
        "linematch": "if filesystem.confirm_valid_file(analysis_file_dir):",
        "context": "        # creates an empty string for storing results temporarily\n        analysis_result = \"\"\n        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):\n            if not force:\n                if display:\n                    database.display_results_frog_mouth(\n                        analysis_file_dir, util.get_OS()\n                    )",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 434,
        "coloffset": 12,
        "linematch": "if not force:",
        "context": "        analysis_result = \"\"\n        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):\n            if not force:\n                if display:\n                    database.display_results_frog_mouth(\n                        analysis_file_dir, util.get_OS()\n                    )\n                    sys.exit(0)",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 435,
        "coloffset": 16,
        "linematch": "if display:",
        "context": "        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):\n            if not force:\n                if display:\n                    database.display_results_frog_mouth(\n                        analysis_file_dir, util.get_OS()\n                    )\n                    sys.exit(0)\n                else:",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 649,
        "coloffset": 12,
        "linematch": "if os.path.isdir(input_path):",
        "context": "    # --save-xml and --view-xml\n    if save_XML is not None or view_XML is not None:\n        output.console.print(\":memo: Saving XML...\")\n        try:\n            if os.path.isdir(input_path):\n                for each_file in os.listdir(input_path):\n                    each_file = Path(input_path) / Path(each_file)  # type: ignore # noqa: PLW2901\n                    if (\n                        not os.path.isdir(each_file)\n                        and os.path.isfile(each_file)",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 652,
        "coloffset": 20,
        "linematch": "if (",
        "context": "        try:\n            if os.path.isdir(input_path):\n                for each_file in os.listdir(input_path):\n                    each_file = Path(input_path) / Path(each_file)  # type: ignore # noqa: PLW2901\n                    if (\n                        not os.path.isdir(each_file)\n                        and os.path.isfile(each_file)\n                        and str(each_file).endswith(\".py\")\n                    ):\n                        # Read the bytes of the input path and store them in the 'contents' variable",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 666,
        "coloffset": 24,
        "linematch": "if view_XML is not None:",
        "context": "                        )\n                        # Convert the Abstract Syntax Tree (AST) into an XML representation\n                        xml_root = pyastgrep.asts.ast_to_xml(ast, {})\n                        # Check if view_xml is chosen\n                        if view_XML is not None:\n                            output.console.print(\n                                pyastgrep.xml.tostring(\n                                    xml_root, pretty_print=True\n                                ).decode(\"utf-8\")\n                            )",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 675,
        "coloffset": 28,
        "linematch": "if str(sub_file).endswith(\".py\"):",
        "context": "                            )\n                    elif os.path.isdir(each_file):\n                        for sub_file in os.listdir(each_file):\n                            sub_file = Path(each_file) / Path(sub_file)  # type: ignore # noqa: PLW2901\n                            if str(sub_file).endswith(\".py\"):\n                                contents = Path(sub_file).read_bytes()\n                                _, ast = pyastgrep.files.parse_python_file(\n                                    contents, sub_file, auto_dedent=False\n                                )\n                                xml_root = pyastgrep.asts.ast_to_xml(ast, {})",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 682,
        "coloffset": 32,
        "linematch": "if view_XML is not None:",
        "context": "                                    contents, sub_file, auto_dedent=False\n                                )\n                                xml_root = pyastgrep.asts.ast_to_xml(ast, {})\n                                # Check if view_xml is chosen\n                                if view_XML is not None:\n                                    output.console.print(\n                                        pyastgrep.xml.tostring(\n                                            xml_root, pretty_print=True\n                                        ).decode(\"utf-8\")\n                                    )",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 695,
        "coloffset": 16,
        "linematch": "if view_XML is not None:",
        "context": "                    contents, input_path, auto_dedent=False\n                )\n                xml_root = pyastgrep.asts.ast_to_xml(ast, {})\n                # Check if view_xml is chosen\n                if view_XML is not None:\n                    output.console.print(\n                        pyastgrep.xml.tostring(xml_root, pretty_print=True).decode(\n                            \"utf-8\"\n                        )\n                    )",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 711,
        "coloffset": 8,
        "linematch": "if store_result:",
        "context": "    elapsed_time = end_time - start_time\n\n    if not all_checks_passed:\n        output.console.print(\":sweat: At least one check did not pass.\")\n        if store_result:\n            # writes results of analyze into a markdown file\n            analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n            output.console.print(\n                f\"\\n:sparkles: Results saved in: {os.path.abspath(analysis_file_dir)}\\n\"\n            )",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 727,
        "coloffset": 8,
        "linematch": "if display:",
        "context": "        # writes results of analyze into a markdown file\n        result_path = os.path.abspath(analysis_file_dir)\n        analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n        output.console.print(f\"\\n:sparkles: Results saved in: {result_path}\\n\")\n        if display:\n            database.display_results_frog_mouth(result_path, util.get_OS())\n\n\n@cli.command()\ndef integrate(  # noqa: PLR0913",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 535,
        "coloffset": 19,
        "linematch": "if check_status_symbol == \"[green]\\u2713[/green]\"",
        "context": "        if store_result:\n            # makes the check marks or x's appear as words instead for markdown\n            check_pass = (\n                \"PASSED:\"\n                if check_status_symbol == \"[green]\\u2713[/green]\"\n                else \"FAILED:\"\n            )\n            # stores check type in a string to stored in file later\n            analysis_result += (\n                f\"\\n# {check_pass} **ID:** '{check_id}', **Name:** '{check_name}'\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 535,
        "coloffset": 19,
        "linematch": "if check_status_symbol == \"[green]\\u2713[/green]\"",
        "context": "        if store_result:\n            # makes the check marks or x's appear as words instead for markdown\n            check_pass = (\n                \"PASSED:\"\n                if check_status_symbol == \"[green]\\u2713[/green]\"\n                else \"FAILED:\"\n            )\n            # stores check type in a string to stored in file later\n            analysis_result += (\n                f\"\\n# {check_pass} **ID:** '{check_id}', **Name:** '{check_name}'\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 535,
        "coloffset": 19,
        "linematch": "if check_status_symbol == \"[green]\\u2713[/green]\"",
        "context": "        if store_result:\n            # makes the check marks or x's appear as words instead for markdown\n            check_pass = (\n                \"PASSED:\"\n                if check_status_symbol == \"[green]\\u2713[/green]\"\n                else \"FAILED:\"\n            )\n            # stores check type in a string to stored in file later\n            analysis_result += (\n                f\"\\n# {check_pass} **ID:** '{check_id}', **Name:** '{check_name}'\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 535,
        "coloffset": 19,
        "linematch": "if check_status_symbol == \"[green]\\u2713[/green]\"",
        "context": "        if store_result:\n            # makes the check marks or x's appear as words instead for markdown\n            check_pass = (\n                \"PASSED:\"\n                if check_status_symbol == \"[green]\\u2713[/green]\"\n                else \"FAILED:\"\n            )\n            # stores check type in a string to stored in file later\n            analysis_result += (\n                f\"\\n# {check_pass} **ID:** '{check_id}', **Name:** '{check_name}'\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 535,
        "coloffset": 19,
        "linematch": "if check_status_symbol == \"[green]\\u2713[/green]\"",
        "context": "        if store_result:\n            # makes the check marks or x's appear as words instead for markdown\n            check_pass = (\n                \"PASSED:\"\n                if check_status_symbol == \"[green]\\u2713[/green]\"\n                else \"FAILED:\"\n            )\n            # stores check type in a string to stored in file later\n            analysis_result += (\n                f\"\\n# {check_pass} **ID:** '{check_id}', **Name:** '{check_name}'\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 535,
        "coloffset": 19,
        "linematch": "if check_status_symbol == \"[green]\\u2713[/green]\"",
        "context": "        if store_result:\n            # makes the check marks or x's appear as words instead for markdown\n            check_pass = (\n                \"PASSED:\"\n                if check_status_symbol == \"[green]\\u2713[/green]\"\n                else \"FAILED:\"\n            )\n            # stores check type in a string to stored in file later\n            analysis_result += (\n                f\"\\n# {check_pass} **ID:** '{check_id}', **Name:** '{check_name}'\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 252,
        "coloffset": 0,
        "linematch": "def analyze(  # noqa: PLR0912, PLR0913, PLR0915",
        "context": "            sys.exit(constants.markers.Non_Zero_Exit)\n\n\n@cli.command()\ndef analyze(  # noqa: PLR0912, PLR0913, PLR0915\n    project: str = typer.Argument(help=\"Name of the project.\"),\n    xpath: Path = typer.Option(\n        str,\n        \"--xpath-version\",\n        \"-xp\",",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 252,
        "coloffset": 0,
        "linematch": "def analyze(  # noqa: PLR0912, PLR0913, PLR0915",
        "context": "            sys.exit(constants.markers.Non_Zero_Exit)\n\n\n@cli.command()\ndef analyze(  # noqa: PLR0912, PLR0913, PLR0915\n    project: str = typer.Argument(help=\"Name of the project.\"),\n    xpath: Path = typer.Option(\n        str,\n        \"--xpath-version\",\n        \"-xp\",",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 421,
        "coloffset": 4,
        "linematch": "if not filesystem.confirm_valid_directory(",
        "context": "    # not possible to analyze the Python source files in this directory\n    # OR\n    # the specified search path is not valid and thus it is\n    # not possible to analyze the specific Python source code file\n    if not filesystem.confirm_valid_directory(\n        input_path\n    ) and not filesystem.confirm_valid_file(input_path):\n        output.console.print(\n            \"\\n:person_shrugging: Cannot perform analysis due to invalid search directory.\\n\"\n        )",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 428,
        "coloffset": 4,
        "linematch": "if store_result:",
        "context": "        output.console.print(\n            \"\\n:person_shrugging: Cannot perform analysis due to invalid search directory.\\n\"\n        )\n        sys.exit(constants.markers.Non_Zero_Exit)\n    if store_result:\n        # creates an empty string for storing results temporarily\n        analysis_result = \"\"\n        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 461,
        "coloffset": 4,
        "linematch": "if xpath == \"1.0\":",
        "context": "    output.console.print()\n    # create a check_status list for all of the checks\n    check_status_list: List[bool] = []\n    # check XPATH version\n    if xpath == \"1.0\":\n        output.logger.debug(\"Using XPath version 1.0\")\n    else:\n        output.logger.debug(\"Using XPath version 2.0\")\n    # iterate through and perform each of the checks\n    for current_check in check_list:",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 510,
        "coloffset": 8,
        "linematch": "if checks.is_checkable(min_count, max_count):",
        "context": "        # correspond so that processing of matches takes place per-file\n        match_dict = process.organize_matches(match_generator_list)\n        # perform an enforceable check if it is warranted for this check\n        current_check_save = None\n        if checks.is_checkable(min_count, max_count):\n            # determine whether or not the number of found matches is within mix and max\n            check_status = checks.check_match_count(\n                len(match_generator_list), min_count, max_count\n            )\n            # keep track of the outcome for this check",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 531,
        "coloffset": 8,
        "linematch": "if store_result:",
        "context": "        output.console.print(\n            f\"  {check_status_symbol} id: '{check_id}', name: '{check_name}'\"\n            + f\", pattern: '{current_xpath_pattern_escape}', min={min_count}, max={max_count}\"\n        )\n        if store_result:\n            # makes the check marks or x's appear as words instead for markdown\n            check_pass = (\n                \"PASSED:\"\n                if check_status_symbol == \"[green]\\u2713[/green]\"\n                else \"FAILED:\"",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 551,
        "coloffset": 8,
        "linematch": "if len(match_generator_list) == 0:",
        "context": "            filename=str(str(vd) for vd in valid_directories)\n        )\n        # there were no matches and thus the current_check_save of None\n        # should be recorded inside of the source of the results\n        if len(match_generator_list) == 0:\n            current_result_source.check = current_check_save\n        # iteratively analyze:\n        # a) A specific file name\n        # b) All of the matches for that file name\n        # Note: the goal is to only process matches for a",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 587,
        "coloffset": 12,
        "linematch": "if len(matches_list) > 0:",
        "context": "            # extract the lines of source code for this file; note that all of\n            # these matches are organized for the same file and thus it is\n            # acceptable to extract the lines of the file from the first match\n            # a long as there are matches available for analysis\n            if len(matches_list) > 0:\n                current_result_source._filelines = matches_list[0].file_lines\n            # iterate through all of the matches that are specifically\n            # connected to this source that is connected to a specific file name\n            for current_match in matches_list:\n                if isinstance(current_match, pyastgrepsearch.Match):",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 643,
        "coloffset": 4,
        "linematch": "if saved_file_name:",
        "context": "    saved_file_name = filesystem.write_chasten_results(\n        output_directory, project, chasten_results_save, save\n    )\n    # output the name of the saved file if saving successfully took place\n    if saved_file_name:\n        output.console.print(f\"\\n:sparkles: Saved the file '{saved_file_name}'\")\n    # --save-xml and --view-xml\n    if save_XML is not None or view_XML is not None:\n        output.console.print(\":memo: Saving XML...\")\n        try:",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 646,
        "coloffset": 4,
        "linematch": "if save_XML is not None or view_XML is not None:",
        "context": "    # output the name of the saved file if saving successfully took place\n    if saved_file_name:\n        output.console.print(f\"\\n:sparkles: Saved the file '{saved_file_name}'\")\n    # --save-xml and --view-xml\n    if save_XML is not None or view_XML is not None:\n        output.console.print(\":memo: Saving XML...\")\n        try:\n            if os.path.isdir(input_path):\n                for each_file in os.listdir(input_path):\n                    each_file = Path(input_path) / Path(each_file)  # type: ignore # noqa: PLW2901",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 709,
        "coloffset": 4,
        "linematch": "if not all_checks_passed:",
        "context": "    all_checks_passed = all(check_status_list)\n    end_time = time.time()\n    elapsed_time = end_time - start_time\n\n    if not all_checks_passed:\n        output.console.print(\":sweat: At least one check did not pass.\")\n        if store_result:\n            # writes results of analyze into a markdown file\n            analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n            output.console.print(",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 722,
        "coloffset": 4,
        "linematch": "if store_result:",
        "context": "    output.console.print(\n        f\"\\n:joy: All checks passed. Elapsed Time: {elapsed_time} seconds\"\n    )\n    output.logger.debug(\"Analysis complete.\")\n    if store_result:\n        # writes results of analyze into a markdown file\n        result_path = os.path.abspath(analysis_file_dir)\n        analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n        output.console.print(f\"\\n:sparkles: Results saved in: {result_path}\\n\")\n        if display:",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 433,
        "coloffset": 8,
        "linematch": "if filesystem.confirm_valid_file(analysis_file_dir):",
        "context": "        # creates an empty string for storing results temporarily\n        analysis_result = \"\"\n        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):\n            if not force:\n                if display:\n                    database.display_results_frog_mouth(\n                        analysis_file_dir, util.get_OS()\n                    )",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 434,
        "coloffset": 12,
        "linematch": "if not force:",
        "context": "        analysis_result = \"\"\n        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):\n            if not force:\n                if display:\n                    database.display_results_frog_mouth(\n                        analysis_file_dir, util.get_OS()\n                    )\n                    sys.exit(0)",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 435,
        "coloffset": 16,
        "linematch": "if display:",
        "context": "        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):\n            if not force:\n                if display:\n                    database.display_results_frog_mouth(\n                        analysis_file_dir, util.get_OS()\n                    )\n                    sys.exit(0)\n                else:",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 649,
        "coloffset": 12,
        "linematch": "if os.path.isdir(input_path):",
        "context": "    # --save-xml and --view-xml\n    if save_XML is not None or view_XML is not None:\n        output.console.print(\":memo: Saving XML...\")\n        try:\n            if os.path.isdir(input_path):\n                for each_file in os.listdir(input_path):\n                    each_file = Path(input_path) / Path(each_file)  # type: ignore # noqa: PLW2901\n                    if (\n                        not os.path.isdir(each_file)\n                        and os.path.isfile(each_file)",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 652,
        "coloffset": 20,
        "linematch": "if (",
        "context": "        try:\n            if os.path.isdir(input_path):\n                for each_file in os.listdir(input_path):\n                    each_file = Path(input_path) / Path(each_file)  # type: ignore # noqa: PLW2901\n                    if (\n                        not os.path.isdir(each_file)\n                        and os.path.isfile(each_file)\n                        and str(each_file).endswith(\".py\")\n                    ):\n                        # Read the bytes of the input path and store them in the 'contents' variable",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 666,
        "coloffset": 24,
        "linematch": "if view_XML is not None:",
        "context": "                        )\n                        # Convert the Abstract Syntax Tree (AST) into an XML representation\n                        xml_root = pyastgrep.asts.ast_to_xml(ast, {})\n                        # Check if view_xml is chosen\n                        if view_XML is not None:\n                            output.console.print(\n                                pyastgrep.xml.tostring(\n                                    xml_root, pretty_print=True\n                                ).decode(\"utf-8\")\n                            )",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 672,
        "coloffset": 20,
        "linematch": "elif os.path.isdir(each_file):",
        "context": "                                pyastgrep.xml.tostring(\n                                    xml_root, pretty_print=True\n                                ).decode(\"utf-8\")\n                            )\n                    elif os.path.isdir(each_file):\n                        for sub_file in os.listdir(each_file):\n                            sub_file = Path(each_file) / Path(sub_file)  # type: ignore # noqa: PLW2901\n                            if str(sub_file).endswith(\".py\"):\n                                contents = Path(sub_file).read_bytes()\n                                _, ast = pyastgrep.files.parse_python_file(",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 675,
        "coloffset": 28,
        "linematch": "if str(sub_file).endswith(\".py\"):",
        "context": "                            )\n                    elif os.path.isdir(each_file):\n                        for sub_file in os.listdir(each_file):\n                            sub_file = Path(each_file) / Path(sub_file)  # type: ignore # noqa: PLW2901\n                            if str(sub_file).endswith(\".py\"):\n                                contents = Path(sub_file).read_bytes()\n                                _, ast = pyastgrep.files.parse_python_file(\n                                    contents, sub_file, auto_dedent=False\n                                )\n                                xml_root = pyastgrep.asts.ast_to_xml(ast, {})",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 682,
        "coloffset": 32,
        "linematch": "if view_XML is not None:",
        "context": "                                    contents, sub_file, auto_dedent=False\n                                )\n                                xml_root = pyastgrep.asts.ast_to_xml(ast, {})\n                                # Check if view_xml is chosen\n                                if view_XML is not None:\n                                    output.console.print(\n                                        pyastgrep.xml.tostring(\n                                            xml_root, pretty_print=True\n                                        ).decode(\"utf-8\")\n                                    )",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 688,
        "coloffset": 12,
        "linematch": "elif os.path.isfile(input_path) and str(input_path).endswith(\".py\"):",
        "context": "                                        pyastgrep.xml.tostring(\n                                            xml_root, pretty_print=True\n                                        ).decode(\"utf-8\")\n                                    )\n            elif os.path.isfile(input_path) and str(input_path).endswith(\".py\"):\n                contents = Path(input_path).read_bytes()\n                _, ast = pyastgrep.files.parse_python_file(\n                    contents, input_path, auto_dedent=False\n                )\n                xml_root = pyastgrep.asts.ast_to_xml(ast, {})",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 695,
        "coloffset": 16,
        "linematch": "if view_XML is not None:",
        "context": "                    contents, input_path, auto_dedent=False\n                )\n                xml_root = pyastgrep.asts.ast_to_xml(ast, {})\n                # Check if view_xml is chosen\n                if view_XML is not None:\n                    output.console.print(\n                        pyastgrep.xml.tostring(xml_root, pretty_print=True).decode(\n                            \"utf-8\"\n                        )\n                    )",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 711,
        "coloffset": 8,
        "linematch": "if store_result:",
        "context": "    elapsed_time = end_time - start_time\n\n    if not all_checks_passed:\n        output.console.print(\":sweat: At least one check did not pass.\")\n        if store_result:\n            # writes results of analyze into a markdown file\n            analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n            output.console.print(\n                f\"\\n:sparkles: Results saved in: {os.path.abspath(analysis_file_dir)}\\n\"\n            )",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 727,
        "coloffset": 8,
        "linematch": "if display:",
        "context": "        # writes results of analyze into a markdown file\n        result_path = os.path.abspath(analysis_file_dir)\n        analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n        output.console.print(f\"\\n:sparkles: Results saved in: {result_path}\\n\")\n        if display:\n            database.display_results_frog_mouth(result_path, util.get_OS())\n\n\n@cli.command()\ndef integrate(  # noqa: PLR0913",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 252,
        "coloffset": 0,
        "linematch": "def analyze(  # noqa: PLR0912, PLR0913, PLR0915",
        "context": "            sys.exit(constants.markers.Non_Zero_Exit)\n\n\n@cli.command()\ndef analyze(  # noqa: PLR0912, PLR0913, PLR0915\n    project: str = typer.Argument(help=\"Name of the project.\"),\n    xpath: Path = typer.Option(\n        str,\n        \"--xpath-version\",\n        \"-xp\",",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 466,
        "coloffset": 4,
        "linematch": "for current_check in check_list:",
        "context": "        output.logger.debug(\"Using XPath version 1.0\")\n    else:\n        output.logger.debug(\"Using XPath version 2.0\")\n    # iterate through and perform each of the checks\n    for current_check in check_list:\n        # extract the pattern for the current check\n        current_xpath_pattern = str(\n            current_check[constants.checks.Check_Pattern]\n        )  # type: ignore\n        # extract the minimum and maximum values for the checks, if they exist",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 561,
        "coloffset": 8,
        "linematch": "for file_name, matches_list in match_dict.items():",
        "context": "        # specific file, ensuring that matches for different files\n        # are not mixed together, which would contaminate the results\n        # Note: this is needed because using pyastgrepsearch will\n        # return results for all of the files that matched the check\n        for file_name, matches_list in match_dict.items():\n            # create the current check\n            current_check_save = results.Check(\n                id=check_id,  # type: ignore\n                name=check_name,  # type: ignore\n                description=check_description,  # type: ignore",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 650,
        "coloffset": 16,
        "linematch": "for each_file in os.listdir(input_path):",
        "context": "    if save_XML is not None or view_XML is not None:\n        output.console.print(\":memo: Saving XML...\")\n        try:\n            if os.path.isdir(input_path):\n                for each_file in os.listdir(input_path):\n                    each_file = Path(input_path) / Path(each_file)  # type: ignore # noqa: PLW2901\n                    if (\n                        not os.path.isdir(each_file)\n                        and os.path.isfile(each_file)\n                        and str(each_file).endswith(\".py\")",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 342,
        "coloffset": 4,
        "linematch": "\"\"\"\ud83d\udcab Analyze the AST of Python source code.\"\"\"",
        "context": "    verbose: bool = typer.Option(False, help=\"Enable verbose mode output.\"),\n    save: bool = typer.Option(False, help=\"Enable saving of output file(s).\"),\n    force: bool = typer.Option(False, help=\"Force creation of new markdown file\"),\n) -> None:\n    \"\"\"\ud83d\udcab Analyze the AST of Python source code.\"\"\"\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 344,
        "coloffset": 4,
        "linematch": "output.setup(debug_level, debug_destination)",
        "context": "    force: bool = typer.Option(False, help=\"Force creation of new markdown file\"),\n) -> None:\n    \"\"\"\ud83d\udcab Analyze the AST of Python source code.\"\"\"\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    start_time = time.time()\n    output.logger.debug(\"Analysis Started.\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 345,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Display verbose output? {verbose}\")",
        "context": ") -> None:\n    \"\"\"\ud83d\udcab Analyze the AST of Python source code.\"\"\"\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    start_time = time.time()\n    output.logger.debug(\"Analysis Started.\")\n    # output the preamble, including extra parameters specific to this function",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 346,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Debug level? {debug_level.value}\")",
        "context": "    \"\"\"\ud83d\udcab Analyze the AST of Python source code.\"\"\"\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    start_time = time.time()\n    output.logger.debug(\"Analysis Started.\")\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 347,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Debug destination? {debug_destination.value}\")",
        "context": "    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    start_time = time.time()\n    output.logger.debug(\"Analysis Started.\")\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 348,
        "coloffset": 4,
        "linematch": "start_time = time.time()",
        "context": "    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    start_time = time.time()\n    output.logger.debug(\"Analysis Started.\")\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 349,
        "coloffset": 4,
        "linematch": "output.logger.debug(\"Analysis Started.\")",
        "context": "    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    start_time = time.time()\n    output.logger.debug(\"Analysis Started.\")\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,\n        debug_destination,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 351,
        "coloffset": 4,
        "linematch": "output_preamble(",
        "context": "    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    start_time = time.time()\n    output.logger.debug(\"Analysis Started.\")\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,\n        debug_destination,\n        project=project,\n        directory=input_path,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 359,
        "coloffset": 4,
        "linematch": "chasten_version = util.get_chasten_version()",
        "context": "        project=project,\n        directory=input_path,\n    )\n    # extract the current version of the program\n    chasten_version = util.get_chasten_version()\n    # display current chasten version\n    output.logger.debug(f\"Current version of chasten: {chasten_version}\")\n    # create the include and exclude criteria\n    include = results.CheckCriterion(\n        attribute=str(checks.fix_check_criterion(check_include[0])),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 361,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Current version of chasten: {chasten_version}\")",
        "context": "    )\n    # extract the current version of the program\n    chasten_version = util.get_chasten_version()\n    # display current chasten version\n    output.logger.debug(f\"Current version of chasten: {chasten_version}\")\n    # create the include and exclude criteria\n    include = results.CheckCriterion(\n        attribute=str(checks.fix_check_criterion(check_include[0])),\n        value=str(checks.fix_check_criterion(check_include[1])),\n        confidence=int(checks.fix_check_criterion(check_include[2])),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 363,
        "coloffset": 4,
        "linematch": "include = results.CheckCriterion(",
        "context": "    chasten_version = util.get_chasten_version()\n    # display current chasten version\n    output.logger.debug(f\"Current version of chasten: {chasten_version}\")\n    # create the include and exclude criteria\n    include = results.CheckCriterion(\n        attribute=str(checks.fix_check_criterion(check_include[0])),\n        value=str(checks.fix_check_criterion(check_include[1])),\n        confidence=int(checks.fix_check_criterion(check_include[2])),\n    )\n    exclude = results.CheckCriterion(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 368,
        "coloffset": 4,
        "linematch": "exclude = results.CheckCriterion(",
        "context": "        attribute=str(checks.fix_check_criterion(check_include[0])),\n        value=str(checks.fix_check_criterion(check_include[1])),\n        confidence=int(checks.fix_check_criterion(check_include[2])),\n    )\n    exclude = results.CheckCriterion(\n        attribute=str(checks.fix_check_criterion(check_exclude[0])),\n        value=str(checks.fix_check_criterion(check_exclude[1])),\n        confidence=int(checks.fix_check_criterion(check_exclude[2])),\n    )\n    # create a configuration that is the same for all results",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 374,
        "coloffset": 4,
        "linematch": "chasten_configuration = results.Configuration(",
        "context": "        value=str(checks.fix_check_criterion(check_exclude[1])),\n        confidence=int(checks.fix_check_criterion(check_exclude[2])),\n    )\n    # create a configuration that is the same for all results\n    chasten_configuration = results.Configuration(\n        chastenversion=chasten_version,\n        projectname=project,\n        configdirectory=Path(config),\n        searchpath=input_path,\n        debuglevel=debug_level,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 386,
        "coloffset": 4,
        "linematch": "chasten_results_save = results.Chasten(configuration=chasten_configuration)",
        "context": "        checkexclude=exclude,\n    )\n    # connect the configuration to the top-level chasten object for results saving\n    # note: this is the final object that contains all of the data\n    chasten_results_save = results.Chasten(configuration=chasten_configuration)\n    # add extra space after the command to run the program\n    output.console.print()\n    # validate the configuration\n    (validated, checks_dict) = configuration.validate_configuration_files(\n        config, verbose",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 388,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "    # connect the configuration to the top-level chasten object for results saving\n    # note: this is the final object that contains all of the data\n    chasten_results_save = results.Chasten(configuration=chasten_configuration)\n    # add extra space after the command to run the program\n    output.console.print()\n    # validate the configuration\n    (validated, checks_dict) = configuration.validate_configuration_files(\n        config, verbose\n    )\n    # some aspect of the configuration was not",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 390,
        "coloffset": 4,
        "linematch": "(validated, checks_dict) = configuration.validate_configuration_files(",
        "context": "    chasten_results_save = results.Chasten(configuration=chasten_configuration)\n    # add extra space after the command to run the program\n    output.console.print()\n    # validate the configuration\n    (validated, checks_dict) = configuration.validate_configuration_files(\n        config, verbose\n    )\n    # some aspect of the configuration was not\n    # valid, so exit early and signal an error\n    if not validated:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 395,
        "coloffset": 4,
        "linematch": "if not validated:",
        "context": "        config, verbose\n    )\n    # some aspect of the configuration was not\n    # valid, so exit early and signal an error\n    if not validated:\n        output.console.print(\n            \"\\n:person_shrugging: Cannot perform analysis due to configuration error(s).\\n\"\n        )\n        output.logger.debug(\"Cannot perform analysis due to configuration error(s)\")\n        sys.exit(constants.markers.Non_Zero_Exit)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 404,
        "coloffset": 4,
        "linematch": "check_list: List[Dict[str, Union[str, Dict[str, int]]]] = checks_dict[",
        "context": "        sys.exit(constants.markers.Non_Zero_Exit)\n    # extract the list of the specific patterns (i.e., the XPATH expressions)\n    # that will be used to analyze all of the XML-based representations of\n    # the Python source code found in the valid directories\n    check_list: List[Dict[str, Union[str, Dict[str, int]]]] = checks_dict[\n        constants.checks.Checks_Label\n    ]\n    # filter the list of checks based on the include and exclude parameters\n    # --> only run those checks that were included\n    check_list = process.include_or_exclude_checks(  # type: ignore",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 409,
        "coloffset": 4,
        "linematch": "check_list = process.include_or_exclude_checks(  # type: ignore",
        "context": "        constants.checks.Checks_Label\n    ]\n    # filter the list of checks based on the include and exclude parameters\n    # --> only run those checks that were included\n    check_list = process.include_or_exclude_checks(  # type: ignore\n        check_list, include=True, *check_include\n    )\n    # --> remove those checks that were excluded\n    check_list = process.include_or_exclude_checks(  # type: ignore\n        check_list, include=False, *check_exclude",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 413,
        "coloffset": 4,
        "linematch": "check_list = process.include_or_exclude_checks(  # type: ignore",
        "context": "    check_list = process.include_or_exclude_checks(  # type: ignore\n        check_list, include=True, *check_include\n    )\n    # --> remove those checks that were excluded\n    check_list = process.include_or_exclude_checks(  # type: ignore\n        check_list, include=False, *check_exclude\n    )\n    # the specified search path is not valid and thus it is\n    # not possible to analyze the Python source files in this directory\n    # OR",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 421,
        "coloffset": 4,
        "linematch": "if not filesystem.confirm_valid_directory(",
        "context": "    # not possible to analyze the Python source files in this directory\n    # OR\n    # the specified search path is not valid and thus it is\n    # not possible to analyze the specific Python source code file\n    if not filesystem.confirm_valid_directory(\n        input_path\n    ) and not filesystem.confirm_valid_file(input_path):\n        output.console.print(\n            \"\\n:person_shrugging: Cannot perform analysis due to invalid search directory.\\n\"\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 428,
        "coloffset": 4,
        "linematch": "if store_result:",
        "context": "        output.console.print(\n            \"\\n:person_shrugging: Cannot perform analysis due to invalid search directory.\\n\"\n        )\n        sys.exit(constants.markers.Non_Zero_Exit)\n    if store_result:\n        # creates an empty string for storing results temporarily\n        analysis_result = \"\"\n        analysis_file_dir = store_result / ANALYSIS_FILE\n        # clears markdown file of results if it exists and new results are to be store\n        if filesystem.confirm_valid_file(analysis_file_dir):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 450,
        "coloffset": 4,
        "linematch": "valid_directories = [input_path]",
        "context": "                analysis_file_dir.write_text(\"\")\n        # creates file if doesn't exist already\n        analysis_file_dir.touch()\n    # create the list of directories\n    valid_directories = [input_path]\n    # output the list of directories subject to checking\n    output.console.print()\n    output.console.print(f\":sparkles: Analyzing Python source code in: {input_path}\")\n    # output the number of checks that will be performed\n    output.console.print()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 452,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "        analysis_file_dir.touch()\n    # create the list of directories\n    valid_directories = [input_path]\n    # output the list of directories subject to checking\n    output.console.print()\n    output.console.print(f\":sparkles: Analyzing Python source code in: {input_path}\")\n    # output the number of checks that will be performed\n    output.console.print()\n    output.console.print(f\":tada: Performing {len(check_list)} check(s):\")\n    output.console.print()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 453,
        "coloffset": 4,
        "linematch": "output.console.print(f\":sparkles: Analyzing Python source code in: {input_path}\")",
        "context": "    # create the list of directories\n    valid_directories = [input_path]\n    # output the list of directories subject to checking\n    output.console.print()\n    output.console.print(f\":sparkles: Analyzing Python source code in: {input_path}\")\n    # output the number of checks that will be performed\n    output.console.print()\n    output.console.print(f\":tada: Performing {len(check_list)} check(s):\")\n    output.console.print()\n    # create a check_status list for all of the checks",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 455,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "    # output the list of directories subject to checking\n    output.console.print()\n    output.console.print(f\":sparkles: Analyzing Python source code in: {input_path}\")\n    # output the number of checks that will be performed\n    output.console.print()\n    output.console.print(f\":tada: Performing {len(check_list)} check(s):\")\n    output.console.print()\n    # create a check_status list for all of the checks\n    check_status_list: List[bool] = []\n    # check XPATH version",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 456,
        "coloffset": 4,
        "linematch": "output.console.print(f\":tada: Performing {len(check_list)} check(s):\")",
        "context": "    output.console.print()\n    output.console.print(f\":sparkles: Analyzing Python source code in: {input_path}\")\n    # output the number of checks that will be performed\n    output.console.print()\n    output.console.print(f\":tada: Performing {len(check_list)} check(s):\")\n    output.console.print()\n    # create a check_status list for all of the checks\n    check_status_list: List[bool] = []\n    # check XPATH version\n    if xpath == \"1.0\":",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 457,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "    output.console.print(f\":sparkles: Analyzing Python source code in: {input_path}\")\n    # output the number of checks that will be performed\n    output.console.print()\n    output.console.print(f\":tada: Performing {len(check_list)} check(s):\")\n    output.console.print()\n    # create a check_status list for all of the checks\n    check_status_list: List[bool] = []\n    # check XPATH version\n    if xpath == \"1.0\":\n        output.logger.debug(\"Using XPath version 1.0\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 459,
        "coloffset": 4,
        "linematch": "check_status_list: List[bool] = []",
        "context": "    output.console.print()\n    output.console.print(f\":tada: Performing {len(check_list)} check(s):\")\n    output.console.print()\n    # create a check_status list for all of the checks\n    check_status_list: List[bool] = []\n    # check XPATH version\n    if xpath == \"1.0\":\n        output.logger.debug(\"Using XPath version 1.0\")\n    else:\n        output.logger.debug(\"Using XPath version 2.0\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 461,
        "coloffset": 4,
        "linematch": "if xpath == \"1.0\":",
        "context": "    output.console.print()\n    # create a check_status list for all of the checks\n    check_status_list: List[bool] = []\n    # check XPATH version\n    if xpath == \"1.0\":\n        output.logger.debug(\"Using XPath version 1.0\")\n    else:\n        output.logger.debug(\"Using XPath version 2.0\")\n    # iterate through and perform each of the checks\n    for current_check in check_list:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 466,
        "coloffset": 4,
        "linematch": "for current_check in check_list:",
        "context": "        output.logger.debug(\"Using XPath version 1.0\")\n    else:\n        output.logger.debug(\"Using XPath version 2.0\")\n    # iterate through and perform each of the checks\n    for current_check in check_list:\n        # extract the pattern for the current check\n        current_xpath_pattern = str(\n            current_check[constants.checks.Check_Pattern]\n        )  # type: ignore\n        # extract the minimum and maximum values for the checks, if they exist",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 631,
        "coloffset": 4,
        "linematch": "total_result = util.total_amount_passed(check_status_list)",
        "context": "            chasten_results_save.sources.append(current_result_source)\n        # add the amount of total matches in each check to the end of each checks output\n        output.console.print(f\"   = {len(match_generator_list)} total matches\\n\")\n    # calculate the final count of matches found\n    total_result = util.total_amount_passed(check_status_list)\n    # display checks passed, total amount of checks, and percentage of checks passed\n    output.console.print(\n        f\":computer: {total_result[0]} / {total_result[1]} checks passed ({total_result[2]}%)\\n\"\n    )\n    # display all of the analysis results if verbose output is requested",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 633,
        "coloffset": 4,
        "linematch": "output.console.print(",
        "context": "        output.console.print(f\"   = {len(match_generator_list)} total matches\\n\")\n    # calculate the final count of matches found\n    total_result = util.total_amount_passed(check_status_list)\n    # display checks passed, total amount of checks, and percentage of checks passed\n    output.console.print(\n        f\":computer: {total_result[0]} / {total_result[1]} checks passed ({total_result[2]}%)\\n\"\n    )\n    # display all of the analysis results if verbose output is requested\n    output.print_analysis_details(chasten_results_save, verbose=verbose)\n    # save all of the results from this analysis",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 637,
        "coloffset": 4,
        "linematch": "output.print_analysis_details(chasten_results_save, verbose=verbose)",
        "context": "    output.console.print(\n        f\":computer: {total_result[0]} / {total_result[1]} checks passed ({total_result[2]}%)\\n\"\n    )\n    # display all of the analysis results if verbose output is requested\n    output.print_analysis_details(chasten_results_save, verbose=verbose)\n    # save all of the results from this analysis\n    saved_file_name = filesystem.write_chasten_results(\n        output_directory, project, chasten_results_save, save\n    )\n    # output the name of the saved file if saving successfully took place",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 639,
        "coloffset": 4,
        "linematch": "saved_file_name = filesystem.write_chasten_results(",
        "context": "    )\n    # display all of the analysis results if verbose output is requested\n    output.print_analysis_details(chasten_results_save, verbose=verbose)\n    # save all of the results from this analysis\n    saved_file_name = filesystem.write_chasten_results(\n        output_directory, project, chasten_results_save, save\n    )\n    # output the name of the saved file if saving successfully took place\n    if saved_file_name:\n        output.console.print(f\"\\n:sparkles: Saved the file '{saved_file_name}'\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 643,
        "coloffset": 4,
        "linematch": "if saved_file_name:",
        "context": "    saved_file_name = filesystem.write_chasten_results(\n        output_directory, project, chasten_results_save, save\n    )\n    # output the name of the saved file if saving successfully took place\n    if saved_file_name:\n        output.console.print(f\"\\n:sparkles: Saved the file '{saved_file_name}'\")\n    # --save-xml and --view-xml\n    if save_XML is not None or view_XML is not None:\n        output.console.print(\":memo: Saving XML...\")\n        try:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 646,
        "coloffset": 4,
        "linematch": "if save_XML is not None or view_XML is not None:",
        "context": "    # output the name of the saved file if saving successfully took place\n    if saved_file_name:\n        output.console.print(f\"\\n:sparkles: Saved the file '{saved_file_name}'\")\n    # --save-xml and --view-xml\n    if save_XML is not None or view_XML is not None:\n        output.console.print(\":memo: Saving XML...\")\n        try:\n            if os.path.isdir(input_path):\n                for each_file in os.listdir(input_path):\n                    each_file = Path(input_path) / Path(each_file)  # type: ignore # noqa: PLW2901",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 705,
        "coloffset": 4,
        "linematch": "all_checks_passed = all(check_status_list)",
        "context": "        except FileNotFoundError:\n            output.console.print(\":sweat: Sorry, could not convert to xml.\")\n    # confirm whether or not all of the checks passed\n    # and then display the appropriate diagnostic message\n    all_checks_passed = all(check_status_list)\n    end_time = time.time()\n    elapsed_time = end_time - start_time\n\n    if not all_checks_passed:\n        output.console.print(\":sweat: At least one check did not pass.\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 706,
        "coloffset": 4,
        "linematch": "end_time = time.time()",
        "context": "            output.console.print(\":sweat: Sorry, could not convert to xml.\")\n    # confirm whether or not all of the checks passed\n    # and then display the appropriate diagnostic message\n    all_checks_passed = all(check_status_list)\n    end_time = time.time()\n    elapsed_time = end_time - start_time\n\n    if not all_checks_passed:\n        output.console.print(\":sweat: At least one check did not pass.\")\n        if store_result:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 707,
        "coloffset": 4,
        "linematch": "elapsed_time = end_time - start_time",
        "context": "    # confirm whether or not all of the checks passed\n    # and then display the appropriate diagnostic message\n    all_checks_passed = all(check_status_list)\n    end_time = time.time()\n    elapsed_time = end_time - start_time\n\n    if not all_checks_passed:\n        output.console.print(\":sweat: At least one check did not pass.\")\n        if store_result:\n            # writes results of analyze into a markdown file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 709,
        "coloffset": 4,
        "linematch": "if not all_checks_passed:",
        "context": "    all_checks_passed = all(check_status_list)\n    end_time = time.time()\n    elapsed_time = end_time - start_time\n\n    if not all_checks_passed:\n        output.console.print(\":sweat: At least one check did not pass.\")\n        if store_result:\n            # writes results of analyze into a markdown file\n            analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n            output.console.print(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 718,
        "coloffset": 4,
        "linematch": "output.console.print(",
        "context": "            output.console.print(\n                f\"\\n:sparkles: Results saved in: {os.path.abspath(analysis_file_dir)}\\n\"\n            )\n        sys.exit(constants.markers.Non_Zero_Exit)\n    output.console.print(\n        f\"\\n:joy: All checks passed. Elapsed Time: {elapsed_time} seconds\"\n    )\n    output.logger.debug(\"Analysis complete.\")\n    if store_result:\n        # writes results of analyze into a markdown file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 721,
        "coloffset": 4,
        "linematch": "output.logger.debug(\"Analysis complete.\")",
        "context": "        sys.exit(constants.markers.Non_Zero_Exit)\n    output.console.print(\n        f\"\\n:joy: All checks passed. Elapsed Time: {elapsed_time} seconds\"\n    )\n    output.logger.debug(\"Analysis complete.\")\n    if store_result:\n        # writes results of analyze into a markdown file\n        result_path = os.path.abspath(analysis_file_dir)\n        analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n        output.console.print(f\"\\n:sparkles: Results saved in: {result_path}\\n\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 722,
        "coloffset": 4,
        "linematch": "if store_result:",
        "context": "    output.console.print(\n        f\"\\n:joy: All checks passed. Elapsed Time: {elapsed_time} seconds\"\n    )\n    output.logger.debug(\"Analysis complete.\")\n    if store_result:\n        # writes results of analyze into a markdown file\n        result_path = os.path.abspath(analysis_file_dir)\n        analysis_file_dir.write_text(analysis_result, encoding=\"utf-8\")\n        output.console.print(f\"\\n:sparkles: Results saved in: {result_path}\\n\")\n        if display:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 252,
        "coloffset": 0,
        "linematch": "def analyze(  # noqa: PLR0912, PLR0913, PLR0915",
        "context": "            sys.exit(constants.markers.Non_Zero_Exit)\n\n\n@cli.command()\ndef analyze(  # noqa: PLR0912, PLR0913, PLR0915\n    project: str = typer.Argument(help=\"Name of the project.\"),\n    xpath: Path = typer.Option(\n        str,\n        \"--xpath-version\",\n        \"-xp\",",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]",
        "check_id": "F027",
        "check_name": "high-cyclomatic-complexity"
      },
      {
        "lineno": 252,
        "coloffset": 0,
        "linematch": "def analyze(  # noqa: PLR0912, PLR0913, PLR0915",
        "context": "            sys.exit(constants.markers.Non_Zero_Exit)\n\n\n@cli.command()\ndef analyze(  # noqa: PLR0912, PLR0913, PLR0915\n    project: str = typer.Argument(help=\"Name of the project.\"),\n    xpath: Path = typer.Option(\n        str,\n        \"--xpath-version\",\n        \"-xp\",",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 252,
        "coloffset": 0,
        "linematch": "def analyze(  # noqa: PLR0912, PLR0913, PLR0915",
        "context": "            sys.exit(constants.markers.Non_Zero_Exit)\n\n\n@cli.command()\ndef analyze(  # noqa: PLR0912, PLR0913, PLR0915\n    project: str = typer.Argument(help=\"Name of the project.\"),\n    xpath: Path = typer.Option(\n        str,\n        \"--xpath-version\",\n        \"-xp\",",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #324",
        "line": 258,
        "description": [
          "                    )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1397",
        "line": 253,
        "description": [
          "                        line_numbers=True,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1398",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1399",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1400",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1401",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1402",
        "line": 264,
        "description": [
          "                            expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1403",
        "line": 265,
        "description": [
          "                            title=f\"{current_match.path}:{position_end}:{column_offset}\","
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "integrate",
    "function_scope": "732-817",
    "patterns": [
      {
        "lineno": 796,
        "coloffset": 4,
        "linematch": "if combined_json_file_name:",
        "context": "    combined_json_file_name = filesystem.write_dict_results(\n        combined_json_dict, output_directory, project\n    )\n    # output the name of the saved file if saving successfully took place\n    if combined_json_file_name:\n        output.console.print(f\"\\n:sparkles: Saved the file '{combined_json_file_name}'\")\n        output.logger.debug(f\"Saved the file '{combined_json_file_name}'.\")\n    # \"flatten\" (i.e., \"un-nest\") the now-saved combined JSON file using flatterer\n    # create the SQLite3 database and then configure the database for use in datasette\n    combined_flattened_directory = filesystem.write_flattened_csv_and_database(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 808,
        "coloffset": 4,
        "linematch": "if combined_flattened_directory:",
        "context": "        project,\n    )\n    output.logger.debug(\"Flattened JSON and created SQLite database.\")\n    # output the name of the saved file if saving successfully took place\n    if combined_flattened_directory:\n        output.console.print(\n            f\"\\n:sparkles: Created this directory structure in {Path(combined_flattened_directory).parent}:\"\n        )\n        combined_directory_tree = filesystem.create_directory_tree_visualization(\n            Path(combined_flattened_directory)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 732,
        "coloffset": 0,
        "linematch": "def integrate(  # noqa: PLR0913",
        "context": "            database.display_results_frog_mouth(result_path, util.get_OS())\n\n\n@cli.command()\ndef integrate(  # noqa: PLR0913\n    project: str = typer.Argument(help=\"Name of the project.\"),\n    json_path: List[Path] = typer.Argument(\n        help=\"Directories, files, or globs for chasten's JSON result file(s).\",\n    ),\n    output_directory: Path = typer.Option(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 808,
        "coloffset": 4,
        "linematch": "if combined_flattened_directory:",
        "context": "        project,\n    )\n    output.logger.debug(\"Flattened JSON and created SQLite database.\")\n    # output the name of the saved file if saving successfully took place\n    if combined_flattened_directory:\n        output.console.print(\n            f\"\\n:sparkles: Created this directory structure in {Path(combined_flattened_directory).parent}:\"\n        )\n        combined_directory_tree = filesystem.create_directory_tree_visualization(\n            Path(combined_flattened_directory)",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 732,
        "coloffset": 0,
        "linematch": "def integrate(  # noqa: PLR0913",
        "context": "            database.display_results_frog_mouth(result_path, util.get_OS())\n\n\n@cli.command()\ndef integrate(  # noqa: PLR0913\n    project: str = typer.Argument(help=\"Name of the project.\"),\n    json_path: List[Path] = typer.Argument(\n        help=\"Directories, files, or globs for chasten's JSON result file(s).\",\n    ),\n    output_directory: Path = typer.Option(",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 767,
        "coloffset": 4,
        "linematch": "\"\"\"\ud83d\udea7 Integrate files and make a database.\"\"\"",
        "context": "        help=\"Create converted results files even if they exist\",\n    ),\n    verbose: bool = typer.Option(False, help=\"Display verbose debugging output\"),\n) -> None:\n    \"\"\"\ud83d\udea7 Integrate files and make a database.\"\"\"\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,\n        debug_destination,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 769,
        "coloffset": 4,
        "linematch": "output_preamble(",
        "context": "    verbose: bool = typer.Option(False, help=\"Display verbose debugging output\"),\n) -> None:\n    \"\"\"\ud83d\udea7 Integrate files and make a database.\"\"\"\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,\n        debug_destination,\n        project=project,\n        output_directory=output_directory,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 778,
        "coloffset": 4,
        "linematch": "output.logger.debug(\"Integrate function started.\")",
        "context": "        output_directory=output_directory,\n        json_path=json_path,\n        force=force,\n    )\n    output.logger.debug(\"Integrate function started.\")\n    # output the list of directories subject to checking\n    output.console.print()\n    output.console.print(\":sparkles: Combining data file(s) in:\")\n    output.logger.debug(\":sparkles: Combining data file(s) in:\")\n    output.console.print()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 780,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "        force=force,\n    )\n    output.logger.debug(\"Integrate function started.\")\n    # output the list of directories subject to checking\n    output.console.print()\n    output.console.print(\":sparkles: Combining data file(s) in:\")\n    output.logger.debug(\":sparkles: Combining data file(s) in:\")\n    output.console.print()\n    output.print_list_contents(json_path)\n    # extract all of the JSON dictionaries from the specified files",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 781,
        "coloffset": 4,
        "linematch": "output.console.print(\":sparkles: Combining data file(s) in:\")",
        "context": "    )\n    output.logger.debug(\"Integrate function started.\")\n    # output the list of directories subject to checking\n    output.console.print()\n    output.console.print(\":sparkles: Combining data file(s) in:\")\n    output.logger.debug(\":sparkles: Combining data file(s) in:\")\n    output.console.print()\n    output.print_list_contents(json_path)\n    # extract all of the JSON dictionaries from the specified files\n    json_dicts = filesystem.get_json_results(json_path)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 782,
        "coloffset": 4,
        "linematch": "output.logger.debug(\":sparkles: Combining data file(s) in:\")",
        "context": "    output.logger.debug(\"Integrate function started.\")\n    # output the list of directories subject to checking\n    output.console.print()\n    output.console.print(\":sparkles: Combining data file(s) in:\")\n    output.logger.debug(\":sparkles: Combining data file(s) in:\")\n    output.console.print()\n    output.print_list_contents(json_path)\n    # extract all of the JSON dictionaries from the specified files\n    json_dicts = filesystem.get_json_results(json_path)\n    count = len(json_path)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 783,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "    # output the list of directories subject to checking\n    output.console.print()\n    output.console.print(\":sparkles: Combining data file(s) in:\")\n    output.logger.debug(\":sparkles: Combining data file(s) in:\")\n    output.console.print()\n    output.print_list_contents(json_path)\n    # extract all of the JSON dictionaries from the specified files\n    json_dicts = filesystem.get_json_results(json_path)\n    count = len(json_path)\n    output.console.print(f\"\\n:sparkles: Total of {count} files in all directories.\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 784,
        "coloffset": 4,
        "linematch": "output.print_list_contents(json_path)",
        "context": "    output.console.print()\n    output.console.print(\":sparkles: Combining data file(s) in:\")\n    output.logger.debug(\":sparkles: Combining data file(s) in:\")\n    output.console.print()\n    output.print_list_contents(json_path)\n    # extract all of the JSON dictionaries from the specified files\n    json_dicts = filesystem.get_json_results(json_path)\n    count = len(json_path)\n    output.console.print(f\"\\n:sparkles: Total of {count} files in all directories.\")\n    # combine all of the dictionaries into a single string",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 786,
        "coloffset": 4,
        "linematch": "json_dicts = filesystem.get_json_results(json_path)",
        "context": "    output.logger.debug(\":sparkles: Combining data file(s) in:\")\n    output.console.print()\n    output.print_list_contents(json_path)\n    # extract all of the JSON dictionaries from the specified files\n    json_dicts = filesystem.get_json_results(json_path)\n    count = len(json_path)\n    output.console.print(f\"\\n:sparkles: Total of {count} files in all directories.\")\n    # combine all of the dictionaries into a single string\n    combined_json_dict = process.combine_dicts(json_dicts)\n    # write the combined JSON file string to the filesystem",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 787,
        "coloffset": 4,
        "linematch": "count = len(json_path)",
        "context": "    output.console.print()\n    output.print_list_contents(json_path)\n    # extract all of the JSON dictionaries from the specified files\n    json_dicts = filesystem.get_json_results(json_path)\n    count = len(json_path)\n    output.console.print(f\"\\n:sparkles: Total of {count} files in all directories.\")\n    # combine all of the dictionaries into a single string\n    combined_json_dict = process.combine_dicts(json_dicts)\n    # write the combined JSON file string to the filesystem\n    combined_json_file_name = filesystem.write_dict_results(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 788,
        "coloffset": 4,
        "linematch": "output.console.print(f\"\\n:sparkles: Total of {count} files in all directories.\")",
        "context": "    output.print_list_contents(json_path)\n    # extract all of the JSON dictionaries from the specified files\n    json_dicts = filesystem.get_json_results(json_path)\n    count = len(json_path)\n    output.console.print(f\"\\n:sparkles: Total of {count} files in all directories.\")\n    # combine all of the dictionaries into a single string\n    combined_json_dict = process.combine_dicts(json_dicts)\n    # write the combined JSON file string to the filesystem\n    combined_json_file_name = filesystem.write_dict_results(\n        combined_json_dict, output_directory, project",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 790,
        "coloffset": 4,
        "linematch": "combined_json_dict = process.combine_dicts(json_dicts)",
        "context": "    json_dicts = filesystem.get_json_results(json_path)\n    count = len(json_path)\n    output.console.print(f\"\\n:sparkles: Total of {count} files in all directories.\")\n    # combine all of the dictionaries into a single string\n    combined_json_dict = process.combine_dicts(json_dicts)\n    # write the combined JSON file string to the filesystem\n    combined_json_file_name = filesystem.write_dict_results(\n        combined_json_dict, output_directory, project\n    )\n    # output the name of the saved file if saving successfully took place",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 792,
        "coloffset": 4,
        "linematch": "combined_json_file_name = filesystem.write_dict_results(",
        "context": "    output.console.print(f\"\\n:sparkles: Total of {count} files in all directories.\")\n    # combine all of the dictionaries into a single string\n    combined_json_dict = process.combine_dicts(json_dicts)\n    # write the combined JSON file string to the filesystem\n    combined_json_file_name = filesystem.write_dict_results(\n        combined_json_dict, output_directory, project\n    )\n    # output the name of the saved file if saving successfully took place\n    if combined_json_file_name:\n        output.console.print(f\"\\n:sparkles: Saved the file '{combined_json_file_name}'\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 796,
        "coloffset": 4,
        "linematch": "if combined_json_file_name:",
        "context": "    combined_json_file_name = filesystem.write_dict_results(\n        combined_json_dict, output_directory, project\n    )\n    # output the name of the saved file if saving successfully took place\n    if combined_json_file_name:\n        output.console.print(f\"\\n:sparkles: Saved the file '{combined_json_file_name}'\")\n        output.logger.debug(f\"Saved the file '{combined_json_file_name}'.\")\n    # \"flatten\" (i.e., \"un-nest\") the now-saved combined JSON file using flatterer\n    # create the SQLite3 database and then configure the database for use in datasette\n    combined_flattened_directory = filesystem.write_flattened_csv_and_database(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 801,
        "coloffset": 4,
        "linematch": "combined_flattened_directory = filesystem.write_flattened_csv_and_database(",
        "context": "        output.console.print(f\"\\n:sparkles: Saved the file '{combined_json_file_name}'\")\n        output.logger.debug(f\"Saved the file '{combined_json_file_name}'.\")\n    # \"flatten\" (i.e., \"un-nest\") the now-saved combined JSON file using flatterer\n    # create the SQLite3 database and then configure the database for use in datasette\n    combined_flattened_directory = filesystem.write_flattened_csv_and_database(\n        combined_json_file_name,\n        output_directory,\n        project,\n    )\n    output.logger.debug(\"Flattened JSON and created SQLite database.\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 806,
        "coloffset": 4,
        "linematch": "output.logger.debug(\"Flattened JSON and created SQLite database.\")",
        "context": "        combined_json_file_name,\n        output_directory,\n        project,\n    )\n    output.logger.debug(\"Flattened JSON and created SQLite database.\")\n    # output the name of the saved file if saving successfully took place\n    if combined_flattened_directory:\n        output.console.print(\n            f\"\\n:sparkles: Created this directory structure in {Path(combined_flattened_directory).parent}:\"\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 808,
        "coloffset": 4,
        "linematch": "if combined_flattened_directory:",
        "context": "        project,\n    )\n    output.logger.debug(\"Flattened JSON and created SQLite database.\")\n    # output the name of the saved file if saving successfully took place\n    if combined_flattened_directory:\n        output.console.print(\n            f\"\\n:sparkles: Created this directory structure in {Path(combined_flattened_directory).parent}:\"\n        )\n        combined_directory_tree = filesystem.create_directory_tree_visualization(\n            Path(combined_flattened_directory)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "print_diagnostics",
    "function_scope": "40-51",
    "patterns": [
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "if verbose:",
        "context": "def print_diagnostics(verbose: bool, **configurations: Any) -> None:\n    \"\"\"Display all variables input to the function.\"\"\"\n    global console  # noqa: PLW0602\n    # display diagnostic information for each configuration keyword argument\n    if verbose:\n        console.print(\":sparkles: Configured with these parameters:\")\n        # iterate through each of the configuration keyword arguments\n        for configuration_current in configurations:\n            # print the name and the value of the keyword argument\n            console.print(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 40,
        "coloffset": 0,
        "linematch": "def print_diagnostics(verbose: bool, **configurations: Any) -> None:",
        "context": "        debug_level.value, debug_destination.value\n    )\n\n\ndef print_diagnostics(verbose: bool, **configurations: Any) -> None:\n    \"\"\"Display all variables input to the function.\"\"\"\n    global console  # noqa: PLW0602\n    # display diagnostic information for each configuration keyword argument\n    if verbose:\n        console.print(\":sparkles: Configured with these parameters:\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 40,
        "coloffset": 0,
        "linematch": "def print_diagnostics(verbose: bool, **configurations: Any) -> None:",
        "context": "        debug_level.value, debug_destination.value\n    )\n\n\ndef print_diagnostics(verbose: bool, **configurations: Any) -> None:\n    \"\"\"Display all variables input to the function.\"\"\"\n    global console  # noqa: PLW0602\n    # display diagnostic information for each configuration keyword argument\n    if verbose:\n        console.print(\":sparkles: Configured with these parameters:\")",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "\"\"\"Display all variables input to the function.\"\"\"",
        "context": "    )\n\n\ndef print_diagnostics(verbose: bool, **configurations: Any) -> None:\n    \"\"\"Display all variables input to the function.\"\"\"\n    global console  # noqa: PLW0602\n    # display diagnostic information for each configuration keyword argument\n    if verbose:\n        console.print(\":sparkles: Configured with these parameters:\")\n        # iterate through each of the configuration keyword arguments",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_diagnostics(verbose: bool, **configurations: Any) -> None:\n    \"\"\"Display all variables input to the function.\"\"\"\n    global console  # noqa: PLW0602\n    # display diagnostic information for each configuration keyword argument\n    if verbose:\n        console.print(\":sparkles: Configured with these parameters:\")\n        # iterate through each of the configuration keyword arguments\n        for configuration_current in configurations:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "if verbose:",
        "context": "def print_diagnostics(verbose: bool, **configurations: Any) -> None:\n    \"\"\"Display all variables input to the function.\"\"\"\n    global console  # noqa: PLW0602\n    # display diagnostic information for each configuration keyword argument\n    if verbose:\n        console.print(\":sparkles: Configured with these parameters:\")\n        # iterate through each of the configuration keyword arguments\n        for configuration_current in configurations:\n            # print the name and the value of the keyword argument\n            console.print(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_diagnostics(verbose: bool, **configurations: Any) -> None:\n    \"\"\"Display all variables input to the function.\"\"\"\n    global console  # noqa: PLW0602\n    # display diagnostic information for each configuration keyword argument\n    if verbose:\n        console.print(\":sparkles: Configured with these parameters:\")\n        # iterate through each of the configuration keyword arguments\n        for configuration_current in configurations:",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "opt_print_log",
    "function_scope": "54-64",
    "patterns": [
      {
        "lineno": 61,
        "coloffset": 8,
        "linematch": "if verbose:",
        "context": "    # iterate through each of the configuration keyword arguments\n    for current in contents:\n        # print the name and the value of the keyword argument\n        # to the console if verbose mode is enabled\n        if verbose:\n            console.print(contents[current])\n        # always log the information to the configured logger\n        logger.debug(contents[current])\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 54,
        "coloffset": 0,
        "linematch": "def opt_print_log(verbose: bool, **contents: Any) -> None:",
        "context": "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\"\n            )\n\n\ndef opt_print_log(verbose: bool, **contents: Any) -> None:\n    \"\"\"Produce logging information and only print when not verbose.\"\"\"\n    global console  # noqa: PLW0602\n    # iterate through each of the configuration keyword arguments\n    for current in contents:\n        # print the name and the value of the keyword argument",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 54,
        "coloffset": 0,
        "linematch": "def opt_print_log(verbose: bool, **contents: Any) -> None:",
        "context": "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\"\n            )\n\n\ndef opt_print_log(verbose: bool, **contents: Any) -> None:\n    \"\"\"Produce logging information and only print when not verbose.\"\"\"\n    global console  # noqa: PLW0602\n    # iterate through each of the configuration keyword arguments\n    for current in contents:\n        # print the name and the value of the keyword argument",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "\"\"\"Produce logging information and only print when not verbose.\"\"\"",
        "context": "            )\n\n\ndef opt_print_log(verbose: bool, **contents: Any) -> None:\n    \"\"\"Produce logging information and only print when not verbose.\"\"\"\n    global console  # noqa: PLW0602\n    # iterate through each of the configuration keyword arguments\n    for current in contents:\n        # print the name and the value of the keyword argument\n        # to the console if verbose mode is enabled",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef opt_print_log(verbose: bool, **contents: Any) -> None:\n    \"\"\"Produce logging information and only print when not verbose.\"\"\"\n    global console  # noqa: PLW0602\n    # iterate through each of the configuration keyword arguments\n    for current in contents:\n        # print the name and the value of the keyword argument\n        # to the console if verbose mode is enabled\n        if verbose:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "for current in contents:",
        "context": "def opt_print_log(verbose: bool, **contents: Any) -> None:\n    \"\"\"Produce logging information and only print when not verbose.\"\"\"\n    global console  # noqa: PLW0602\n    # iterate through each of the configuration keyword arguments\n    for current in contents:\n        # print the name and the value of the keyword argument\n        # to the console if verbose mode is enabled\n        if verbose:\n            console.print(contents[current])\n        # always log the information to the configured logger",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef opt_print_log(verbose: bool, **contents: Any) -> None:\n    \"\"\"Produce logging information and only print when not verbose.\"\"\"\n    global console  # noqa: PLW0602\n    # iterate through each of the configuration keyword arguments\n    for current in contents:\n        # print the name and the value of the keyword argument\n        # to the console if verbose mode is enabled\n        if verbose:",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "group_files_by_directory",
    "function_scope": "105-126",
    "patterns": [
      {
        "lineno": 122,
        "coloffset": 8,
        "linematch": "if directory not in grouped_files:",
        "context": "        file_name = file_path.name\n        # update the dictionary that uses:\n        # --> a Path key for the containing directory\n        # --> a list of strings for the contained files\n        if directory not in grouped_files:\n            grouped_files[directory] = []\n        grouped_files[directory].append(file_name)\n    # return the dictionary of files organized by directory\n    return grouped_files\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 105,
        "coloffset": 0,
        "linematch": "def group_files_by_directory(file_paths: List[Path]) -> Dict[Path, List[str]]:",
        "context": "    global console  # noqa: PLW0602\n    console.print()\n\n\ndef group_files_by_directory(file_paths: List[Path]) -> Dict[Path, List[str]]:\n    \"\"\"Organize the files in a list according to their base directory.\"\"\"\n    # create an empty dictionary\n    grouped_files: Dict[Path, List[str]] = {}\n    # iterate through each of the full paths\n    # and extract the containing directory",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 105,
        "coloffset": 0,
        "linematch": "def group_files_by_directory(file_paths: List[Path]) -> Dict[Path, List[str]]:",
        "context": "    global console  # noqa: PLW0602\n    console.print()\n\n\ndef group_files_by_directory(file_paths: List[Path]) -> Dict[Path, List[str]]:\n    \"\"\"Organize the files in a list according to their base directory.\"\"\"\n    # create an empty dictionary\n    grouped_files: Dict[Path, List[str]] = {}\n    # iterate through each of the full paths\n    # and extract the containing directory",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 106,
        "coloffset": 4,
        "linematch": "\"\"\"Organize the files in a list according to their base directory.\"\"\"",
        "context": "    console.print()\n\n\ndef group_files_by_directory(file_paths: List[Path]) -> Dict[Path, List[str]]:\n    \"\"\"Organize the files in a list according to their base directory.\"\"\"\n    # create an empty dictionary\n    grouped_files: Dict[Path, List[str]] = {}\n    # iterate through each of the full paths\n    # and extract the containing directory\n    # from the name of the file that is contained",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 108,
        "coloffset": 4,
        "linematch": "grouped_files: Dict[Path, List[str]] = {}",
        "context": "\ndef group_files_by_directory(file_paths: List[Path]) -> Dict[Path, List[str]]:\n    \"\"\"Organize the files in a list according to their base directory.\"\"\"\n    # create an empty dictionary\n    grouped_files: Dict[Path, List[str]] = {}\n    # iterate through each of the full paths\n    # and extract the containing directory\n    # from the name of the file that is contained\n    for file_path in file_paths:\n        # extract the parent (i.e., containing)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "for file_path in file_paths:",
        "context": "    grouped_files: Dict[Path, List[str]] = {}\n    # iterate through each of the full paths\n    # and extract the containing directory\n    # from the name of the file that is contained\n    for file_path in file_paths:\n        # extract the parent (i.e., containing)\n        # directory for the current file path\n        directory = file_path.parent\n        # extract the name of the file, excluding\n        # the containing directory",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 126,
        "coloffset": 4,
        "linematch": "return grouped_files",
        "context": "        if directory not in grouped_files:\n            grouped_files[directory] = []\n        grouped_files[directory].append(file_name)\n    # return the dictionary of files organized by directory\n    return grouped_files\n\n\ndef shorten_file_name(file_name: str, max_length: int) -> str:\n    \"\"\"Elide part of a file name if it is longer than the maximum length.\"\"\"\n    # remove content from the start of the filename if it is too long",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #304",
        "line": 123,
        "description": [
          "            grouped_files[directory] = []"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1367",
        "line": 122,
        "description": [
          "        if directory not in grouped_files:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "shorten_file_name",
    "function_scope": "129-134",
    "patterns": [
      {
        "lineno": 132,
        "coloffset": 4,
        "linematch": "if len(file_name) > max_length:",
        "context": "\ndef shorten_file_name(file_name: str, max_length: int) -> str:\n    \"\"\"Elide part of a file name if it is longer than the maximum length.\"\"\"\n    # remove content from the start of the filename if it is too long\n    if len(file_name) > max_length:\n        return \"... \" + file_name[-(max_length - 3) :]\n    return file_name\n\n\ndef print_list_contents(container: List[Path]) -> None:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 129,
        "coloffset": 0,
        "linematch": "def shorten_file_name(file_name: str, max_length: int) -> str:",
        "context": "    # return the dictionary of files organized by directory\n    return grouped_files\n\n\ndef shorten_file_name(file_name: str, max_length: int) -> str:\n    \"\"\"Elide part of a file name if it is longer than the maximum length.\"\"\"\n    # remove content from the start of the filename if it is too long\n    if len(file_name) > max_length:\n        return \"... \" + file_name[-(max_length - 3) :]\n    return file_name",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 129,
        "coloffset": 0,
        "linematch": "def shorten_file_name(file_name: str, max_length: int) -> str:",
        "context": "    # return the dictionary of files organized by directory\n    return grouped_files\n\n\ndef shorten_file_name(file_name: str, max_length: int) -> str:\n    \"\"\"Elide part of a file name if it is longer than the maximum length.\"\"\"\n    # remove content from the start of the filename if it is too long\n    if len(file_name) > max_length:\n        return \"... \" + file_name[-(max_length - 3) :]\n    return file_name",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 130,
        "coloffset": 4,
        "linematch": "\"\"\"Elide part of a file name if it is longer than the maximum length.\"\"\"",
        "context": "    return grouped_files\n\n\ndef shorten_file_name(file_name: str, max_length: int) -> str:\n    \"\"\"Elide part of a file name if it is longer than the maximum length.\"\"\"\n    # remove content from the start of the filename if it is too long\n    if len(file_name) > max_length:\n        return \"... \" + file_name[-(max_length - 3) :]\n    return file_name\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 132,
        "coloffset": 4,
        "linematch": "if len(file_name) > max_length:",
        "context": "\ndef shorten_file_name(file_name: str, max_length: int) -> str:\n    \"\"\"Elide part of a file name if it is longer than the maximum length.\"\"\"\n    # remove content from the start of the filename if it is too long\n    if len(file_name) > max_length:\n        return \"... \" + file_name[-(max_length - 3) :]\n    return file_name\n\n\ndef print_list_contents(container: List[Path]) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 134,
        "coloffset": 4,
        "linematch": "return file_name",
        "context": "    \"\"\"Elide part of a file name if it is longer than the maximum length.\"\"\"\n    # remove content from the start of the filename if it is too long\n    if len(file_name) > max_length:\n        return \"... \" + file_name[-(max_length - 3) :]\n    return file_name\n\n\ndef print_list_contents(container: List[Path]) -> None:\n    \"\"\"Display the contents of the list in an easy-to-read fashion.\"\"\"\n    global console  # noqa: PLW0602",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1368",
        "line": 132,
        "description": [
          "    if len(file_name) > max_length:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1369",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1370",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1371",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1372",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1373",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "print_analysis_details",
    "function_scope": "160-267",
    "patterns": [
      {
        "lineno": 169,
        "coloffset": 4,
        "linematch": "if not verbose:",
        "context": "    # 2) Note: the _match object that is inside of a Match BaseModel subclass\n    # is an instance of pyastgrepsearch.Match and contains the entire details\n    # about the specific match, including the entire source code. This object\n    # is not saved to the JSON file by default, as evidenced by the underscore\n    if not verbose:\n        return None\n    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")\n    # iterate through the the list of sources inside of the resulting analysis\n    for current_source in chasten.sources:\n        # extract the current check from this source",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 209,
        "coloffset": 8,
        "linematch": "if len(current_check._matches) > 0:  # type: ignore",
        "context": "                expand=False,\n                title=f\"{combined_attribute_label}\",\n            )\n        )\n        if len(current_check._matches) > 0:  # type: ignore\n            # display the details about the number of matches and the name of the source's file\n            opt_print_log(verbose, blank=constants.markers.Empty_String)\n            opt_print_log(\n                verbose,\n                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\",",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 218,
        "coloffset": 16,
        "linematch": "if isinstance(current_match, pyastgrepsearch.Match):  # type: ignore",
        "context": "                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\",\n            )\n            # iterate through each of the matches and display all of their details\n            for current_match in current_check._matches:  # type: ignore\n                if isinstance(current_match, pyastgrepsearch.Match):  # type: ignore\n                    # display a label for matching output information\n                    opt_print_log(verbose, blank=constants.markers.Empty_String)\n                    opt_print_log(verbose, label=\":sparkles: Matching source code:\")\n                    # extract the direct line number for this match\n                    position_end = current_match.position.lineno",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 218,
        "coloffset": 16,
        "linematch": "if isinstance(current_match, pyastgrepsearch.Match):  # type: ignore",
        "context": "                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\",\n            )\n            # iterate through each of the matches and display all of their details\n            for current_match in current_check._matches:  # type: ignore\n                if isinstance(current_match, pyastgrepsearch.Match):  # type: ignore\n                    # display a label for matching output information\n                    opt_print_log(verbose, blank=constants.markers.Empty_String)\n                    opt_print_log(verbose, label=\":sparkles: Matching source code:\")\n                    # extract the direct line number for this match\n                    position_end = current_match.position.lineno",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 160,
        "coloffset": 0,
        "linematch": "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:",
        "context": "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\"\n            )\n\n\ndef print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:\n    \"\"\"Print all of the verbose debugging details for the results of an analysis.\"\"\"\n    global console  # noqa: PLW0602\n    # 1) Note: see the BaseModel definitions in results.py for more details\n    # about the objects and their relationships\n    # 2) Note: the _match object that is inside of a Match BaseModel subclass",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 160,
        "coloffset": 0,
        "linematch": "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:",
        "context": "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\"\n            )\n\n\ndef print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:\n    \"\"\"Print all of the verbose debugging details for the results of an analysis.\"\"\"\n    global console  # noqa: PLW0602\n    # 1) Note: see the BaseModel definitions in results.py for more details\n    # about the objects and their relationships\n    # 2) Note: the _match object that is inside of a Match BaseModel subclass",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 218,
        "coloffset": 16,
        "linematch": "if isinstance(current_match, pyastgrepsearch.Match):  # type: ignore",
        "context": "                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\",\n            )\n            # iterate through each of the matches and display all of their details\n            for current_match in current_check._matches:  # type: ignore\n                if isinstance(current_match, pyastgrepsearch.Match):  # type: ignore\n                    # display a label for matching output information\n                    opt_print_log(verbose, blank=constants.markers.Empty_String)\n                    opt_print_log(verbose, label=\":sparkles: Matching source code:\")\n                    # extract the direct line number for this match\n                    position_end = current_match.position.lineno",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 160,
        "coloffset": 0,
        "linematch": "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:",
        "context": "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\"\n            )\n\n\ndef print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:\n    \"\"\"Print all of the verbose debugging details for the results of an analysis.\"\"\"\n    global console  # noqa: PLW0602\n    # 1) Note: see the BaseModel definitions in results.py for more details\n    # about the objects and their relationships\n    # 2) Note: the _match object that is inside of a Match BaseModel subclass",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 173,
        "coloffset": 4,
        "linematch": "for current_source in chasten.sources:",
        "context": "    if not verbose:\n        return None\n    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")\n    # iterate through the the list of sources inside of the resulting analysis\n    for current_source in chasten.sources:\n        # extract the current check from this source\n        current_check: results.Check = current_source.check  # type: ignore\n        current_xpath_pattern = current_check.pattern\n        console.print(\"\\n:tada: Check:\")\n        xpath_syntax = Syntax(",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 161,
        "coloffset": 4,
        "linematch": "\"\"\"Print all of the verbose debugging details for the results of an analysis.\"\"\"",
        "context": "            )\n\n\ndef print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:\n    \"\"\"Print all of the verbose debugging details for the results of an analysis.\"\"\"\n    global console  # noqa: PLW0602\n    # 1) Note: see the BaseModel definitions in results.py for more details\n    # about the objects and their relationships\n    # 2) Note: the _match object that is inside of a Match BaseModel subclass\n    # is an instance of pyastgrepsearch.Match and contains the entire details",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 162,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:\n    \"\"\"Print all of the verbose debugging details for the results of an analysis.\"\"\"\n    global console  # noqa: PLW0602\n    # 1) Note: see the BaseModel definitions in results.py for more details\n    # about the objects and their relationships\n    # 2) Note: the _match object that is inside of a Match BaseModel subclass\n    # is an instance of pyastgrepsearch.Match and contains the entire details\n    # about the specific match, including the entire source code. This object",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 169,
        "coloffset": 4,
        "linematch": "if not verbose:",
        "context": "    # 2) Note: the _match object that is inside of a Match BaseModel subclass\n    # is an instance of pyastgrepsearch.Match and contains the entire details\n    # about the specific match, including the entire source code. This object\n    # is not saved to the JSON file by default, as evidenced by the underscore\n    if not verbose:\n        return None\n    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")\n    # iterate through the the list of sources inside of the resulting analysis\n    for current_source in chasten.sources:\n        # extract the current check from this source",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 171,
        "coloffset": 4,
        "linematch": "opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")",
        "context": "    # about the specific match, including the entire source code. This object\n    # is not saved to the JSON file by default, as evidenced by the underscore\n    if not verbose:\n        return None\n    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")\n    # iterate through the the list of sources inside of the resulting analysis\n    for current_source in chasten.sources:\n        # extract the current check from this source\n        current_check: results.Check = current_source.check  # type: ignore\n        current_xpath_pattern = current_check.pattern",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 173,
        "coloffset": 4,
        "linematch": "for current_source in chasten.sources:",
        "context": "    if not verbose:\n        return None\n    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")\n    # iterate through the the list of sources inside of the resulting analysis\n    for current_source in chasten.sources:\n        # extract the current check from this source\n        current_check: results.Check = current_source.check  # type: ignore\n        current_xpath_pattern = current_check.pattern\n        console.print(\"\\n:tada: Check:\")\n        xpath_syntax = Syntax(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 160,
        "coloffset": 0,
        "linematch": "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:",
        "context": "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\"\n            )\n\n\ndef print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:\n    \"\"\"Print all of the verbose debugging details for the results of an analysis.\"\"\"\n    global console  # noqa: PLW0602\n    # 1) Note: see the BaseModel definitions in results.py for more details\n    # about the objects and their relationships\n    # 2) Note: the _match object that is inside of a Match BaseModel subclass",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 162,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:\n    \"\"\"Print all of the verbose debugging details for the results of an analysis.\"\"\"\n    global console  # noqa: PLW0602\n    # 1) Note: see the BaseModel definitions in results.py for more details\n    # about the objects and their relationships\n    # 2) Note: the _match object that is inside of a Match BaseModel subclass\n    # is an instance of pyastgrepsearch.Match and contains the entire details\n    # about the specific match, including the entire source code. This object",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      },
      {
        "lineno": 160,
        "coloffset": 0,
        "linematch": "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:",
        "context": "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\"\n            )\n\n\ndef print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:\n    \"\"\"Print all of the verbose debugging details for the results of an analysis.\"\"\"\n    global console  # noqa: PLW0602\n    # 1) Note: see the BaseModel definitions in results.py for more details\n    # about the objects and their relationships\n    # 2) Note: the _match object that is inside of a Match BaseModel subclass",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #308",
        "line": 176,
        "description": [
          "        current_xpath_pattern = current_check.pattern"
        ],
        "failure": []
      },
      {
        "name": "Mutant #309",
        "line": 182,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #310",
        "line": 187,
        "description": [
          "        min_count = current_check.min"
        ],
        "failure": []
      },
      {
        "name": "Mutant #311",
        "line": 188,
        "description": [
          "        max_count = current_check.max"
        ],
        "failure": []
      },
      {
        "name": "Mutant #312",
        "line": 189,
        "description": [
          "        min_label = checks.create_attribute_label(min_count, constants.checks.Check_Min)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #313",
        "line": 190,
        "description": [
          "        max_label = checks.create_attribute_label(max_count, constants.checks.Check_Max)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #314",
        "line": 193,
        "description": [
          "        check_id = current_check.id"
        ],
        "failure": []
      },
      {
        "name": "Mutant #315",
        "line": 194,
        "description": [
          "        check_id_label = checks.create_attribute_label(check_id, constants.checks.Check_Id)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #316",
        "line": 195,
        "description": [
          "        check_name = current_check.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #317",
        "line": 196,
        "description": [
          "        check_name_label = checks.create_attribute_label(check_name, constants.checks.Check_Name)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #318",
        "line": 200,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #319",
        "line": 223,
        "description": [
          "                    position_end = current_match.position.lineno"
        ],
        "failure": []
      },
      {
        "name": "Mutant #320",
        "line": 225,
        "description": [
          "                    column_offset = current_match.position.col_offset"
        ],
        "failure": []
      },
      {
        "name": "Mutant #321",
        "line": 230,
        "description": [
          "                    all_lines = current_match.file_lines"
        ],
        "failure": []
      },
      {
        "name": "Mutant #322",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #323",
        "line": 240,
        "description": [
          "                    ]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #324",
        "line": 258,
        "description": [
          "                    )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1381",
        "line": 160,
        "description": [
          "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1382",
        "line": 169,
        "description": [
          "    if not verbose:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1383",
        "line": 171,
        "description": [
          "    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1384",
        "line": 175,
        "description": [
          "        current_check: results.Check = current_source.check  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1385",
        "line": 177,
        "description": [
          "        console.print(\"\\n:tada: Check:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1386",
        "line": 205,
        "description": [
          "                expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1387",
        "line": 206,
        "description": [
          "                title=f\"{combined_attribute_label}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1388",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1389",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1390",
        "line": 214,
        "description": [
          "                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1391",
        "line": 221,
        "description": [
          "                    opt_print_log(verbose, label=\":sparkles: Matching source code:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1392",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1393",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1394",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1395",
        "line": 239,
        "description": [
          "                        + constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1396",
        "line": 249,
        "description": [
          "                        \"\\n\".join(str(line) for line in lines),"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1397",
        "line": 253,
        "description": [
          "                        line_numbers=True,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1398",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1399",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1400",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1401",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1402",
        "line": 264,
        "description": [
          "                            expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1403",
        "line": 265,
        "description": [
          "                            title=f\"{current_match.path}:{position_end}:{column_offset}\","
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_split_file",
    "function_scope": "46-52",
    "patterns": [
      {
        "lineno": 52,
        "coloffset": 11,
        "linematch": "assert configApp.split_file(file) == CSV_CHECK_LIST",
        "context": "    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n\n# Property-based test to check if the 'store_in_file' function correctly stores generated data in a file\n@given(\n    Pattern=st.text(alphabet=ALPHABET, min_size=3, max_size=150),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 52,
        "coloffset": 11,
        "linematch": "assert configApp.split_file(file) == CSV_CHECK_LIST",
        "context": "    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n\n# Property-based test to check if the 'store_in_file' function correctly stores generated data in a file\n@given(\n    Pattern=st.text(alphabet=ALPHABET, min_size=3, max_size=150),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 52,
        "coloffset": 11,
        "linematch": "assert configApp.split_file(file) == CSV_CHECK_LIST",
        "context": "    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n\n# Property-based test to check if the 'store_in_file' function correctly stores generated data in a file\n@given(\n    Pattern=st.text(alphabet=ALPHABET, min_size=3, max_size=150),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 46,
        "coloffset": 0,
        "linematch": "def test_split_file(tmpdir):",
        "context": "    assert configApp.write_checks([]) == \"[red][ERROR][/red] No checks were supplied\"\n\n\n# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "assert configApp.split_file(file) == CSV_CHECK_LIST",
        "context": "    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n\n# Property-based test to check if the 'store_in_file' function correctly stores generated data in a file\n@given(\n    Pattern=st.text(alphabet=ALPHABET, min_size=3, max_size=150),",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "\"\"\"Test the split_file function by parsing check data from a file.\"\"\"",
        "context": "\n\n# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "tmp_dir = pathlib.Path(tmpdir)",
        "context": "\n# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "file = tmp_dir / \"check_test.txt\"",
        "context": "# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "file.touch()",
        "context": "def test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n\n# Property-based test to check if the 'store_in_file' function correctly stores generated data in a file",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "file.write_text(CHECK_TEST_DEFAULT)",
        "context": "    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n\n# Property-based test to check if the 'store_in_file' function correctly stores generated data in a file\n@given(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "assert configApp.split_file(file) == CSV_CHECK_LIST",
        "context": "    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n\n# Property-based test to check if the 'store_in_file' function correctly stores generated data in a file\n@given(\n    Pattern=st.text(alphabet=ALPHABET, min_size=3, max_size=150),",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "\"\"\"Test the split_file function by parsing check data from a file.\"\"\"",
        "context": "\n\n# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "tmp_dir = pathlib.Path(tmpdir)",
        "context": "\n# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "file = tmp_dir / \"check_test.txt\"",
        "context": "# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "file.touch()",
        "context": "def test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n\n# Property-based test to check if the 'store_in_file' function correctly stores generated data in a file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "file.write_text(CHECK_TEST_DEFAULT)",
        "context": "    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n\n# Property-based test to check if the 'store_in_file' function correctly stores generated data in a file\n@given(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "assert configApp.split_file(file) == CSV_CHECK_LIST",
        "context": "    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    file.write_text(CHECK_TEST_DEFAULT)\n    assert configApp.split_file(file) == CSV_CHECK_LIST\n\n\n# Property-based test to check if the 'store_in_file' function correctly stores generated data in a file\n@given(\n    Pattern=st.text(alphabet=ALPHABET, min_size=3, max_size=150),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_debug_destination_iteration",
    "function_scope": "43-45",
    "patterns": [
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 43,
        "coloffset": 0,
        "linematch": "def test_debug_destination_iteration():",
        "context": "    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"",
        "context": "    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"",
        "context": "    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "context": "\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_is_url_correct",
    "function_scope": "38-41",
    "patterns": [
      {
        "lineno": 41,
        "coloffset": 11,
        "linematch": "assert result is True",
        "context": "@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:\n    \"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"\n    result = util.is_url(url=url)\n    assert result is True\n\n\n@given(check_status_list=st.lists(st.booleans()))\n@pytest.mark.fuzz\ndef test_total_amount_passed(check_status_list: list[bool]):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 38,
        "coloffset": 0,
        "linematch": "def test_is_url_correct(url: str) -> None:",
        "context": "\n\n@given(url=provisional.urls())\n@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:\n    \"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"\n    result = util.is_url(url=url)\n    assert result is True\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:\n    \"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"\n    result = util.is_url(url=url)\n    assert result is True\n\n\n@given(check_status_list=st.lists(st.booleans()))\n@pytest.mark.fuzz\ndef test_total_amount_passed(check_status_list: list[bool]):",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"",
        "context": "\n@given(url=provisional.urls())\n@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:\n    \"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"\n    result = util.is_url(url=url)\n    assert result is True\n\n\n@given(check_status_list=st.lists(st.booleans()))",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "result = util.is_url(url=url)",
        "context": "@given(url=provisional.urls())\n@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:\n    \"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"\n    result = util.is_url(url=url)\n    assert result is True\n\n\n@given(check_status_list=st.lists(st.booleans()))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:\n    \"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"\n    result = util.is_url(url=url)\n    assert result is True\n\n\n@given(check_status_list=st.lists(st.booleans()))\n@pytest.mark.fuzz\ndef test_total_amount_passed(check_status_list: list[bool]):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"",
        "context": "\n@given(url=provisional.urls())\n@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:\n    \"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"\n    result = util.is_url(url=url)\n    assert result is True\n\n\n@given(check_status_list=st.lists(st.booleans()))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "result = util.is_url(url=url)",
        "context": "@given(url=provisional.urls())\n@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:\n    \"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"\n    result = util.is_url(url=url)\n    assert result is True\n\n\n@given(check_status_list=st.lists(st.booleans()))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "@pytest.mark.fuzz\ndef test_is_url_correct(url: str) -> None:\n    \"\"\"Use Hypothesis to confirm that URLs are correctly recognized/unrecognized.\"\"\"\n    result = util.is_url(url=url)\n    assert result is True\n\n\n@given(check_status_list=st.lists(st.booleans()))\n@pytest.mark.fuzz\ndef test_total_amount_passed(check_status_list: list[bool]):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_invalid_file",
    "function_scope": "39-45",
    "patterns": [
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert filesystem.confirm_valid_file(None) is False",
        "context": "    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert filesystem.confirm_valid_file(None) is False",
        "context": "    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert filesystem.confirm_valid_file(None) is False",
        "context": "    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert filesystem.confirm_valid_file(None) is False",
        "context": "    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert filesystem.confirm_valid_file(None) is False",
        "context": "    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert filesystem.confirm_valid_file(None) is False",
        "context": "    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def test_invalid_file() -> None:",
        "context": "    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n\n\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert confirmation is False",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "assert filesystem.confirm_valid_file(None) is False",
        "context": "    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that a valid directory is found.\"\"\"",
        "context": "    assert confirmation is True\n\n\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))",
        "context": "\n\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "this_file_not = pathlib.Path(file_str)",
        "context": "\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "confirmation = filesystem.confirm_valid_file(this_file_not)",
        "context": "def test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert confirmation is False",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "assert filesystem.confirm_valid_file(None) is False",
        "context": "    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that a valid directory is found.\"\"\"",
        "context": "    assert confirmation is True\n\n\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))",
        "context": "\n\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "this_file_not = pathlib.Path(file_str)",
        "context": "\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "confirmation = filesystem.confirm_valid_file(this_file_not)",
        "context": "def test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert confirmation is False",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "assert filesystem.confirm_valid_file(None) is False",
        "context": "    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))\n    this_file_not = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file_not)\n    assert confirmation is False\n    assert filesystem.confirm_valid_file(None) is False\n\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_create_checks_configuration_file",
    "function_scope": "227-244",
    "patterns": [
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 244,
        "coloffset": 11,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 227,
        "coloffset": 0,
        "linematch": "def test_create_checks_configuration_file(mock_user_config_dir, tmp_path):",
        "context": "    )\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_checks_configuration_file(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm that it is possible to create the checks configuration file if it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 235,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 236,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 242,
        "coloffset": 4,
        "linematch": "assert main_configuation_file.exists()",
        "context": "    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 244,
        "coloffset": 4,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 228,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to create the checks configuration file if it does not exist.\"\"\"",
        "context": "\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_checks_configuration_file(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm that it is possible to create the checks configuration file if it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 232,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm that it is possible to create the checks configuration file if it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 233,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 234,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 235,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 236,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 238,
        "coloffset": 4,
        "linematch": "filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 241,
        "coloffset": 4,
        "linematch": "main_configuation_file = dir_path / \"checks.yml\"",
        "context": "    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 242,
        "coloffset": 4,
        "linematch": "assert main_configuation_file.exists()",
        "context": "    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 244,
        "coloffset": 4,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 228,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to create the checks configuration file if it does not exist.\"\"\"",
        "context": "\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_checks_configuration_file(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm that it is possible to create the checks configuration file if it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 232,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm that it is possible to create the checks configuration file if it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 233,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 234,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 235,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 236,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 238,
        "coloffset": 4,
        "linematch": "filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 241,
        "coloffset": 4,
        "linematch": "main_configuation_file = dir_path / \"checks.yml\"",
        "context": "    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 242,
        "coloffset": 4,
        "linematch": "assert main_configuation_file.exists()",
        "context": "    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Checks_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 244,
        "coloffset": 4,
        "linematch": "assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"checks.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert main_configuation_file.read_text() == filesystem.CHECKS_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #321",
        "line": 230,
        "description": [
          "                    all_lines = current_match.file_lines"
        ],
        "failure": []
      },
      {
        "name": "Mutant #322",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #323",
        "line": 240,
        "description": [
          "                    ]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1392",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1393",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1394",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1395",
        "line": 239,
        "description": [
          "                        + constants.markers.Code_Context"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_check_match_count_expected",
    "function_scope": "133-136",
    "patterns": [
      {
        "lineno": 136,
        "coloffset": 11,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 136,
        "coloffset": 11,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 136,
        "coloffset": 11,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 136,
        "coloffset": 11,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 136,
        "coloffset": 11,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 136,
        "coloffset": 11,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 136,
        "coloffset": 11,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 136,
        "coloffset": 11,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 133,
        "coloffset": 0,
        "linematch": "def test_check_match_count_expected(count, min_value, max_value, expected):",
        "context": "        (1, 2, None, False),\n        (3, None, 2, False),\n    ],\n)\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 136,
        "coloffset": 4,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 134,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the check of the match count works for simple examples.\"\"\"",
        "context": "        (3, None, 2, False),\n    ],\n)\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 135,
        "coloffset": 4,
        "linematch": "result = check_match_count(count, min_value, max_value)",
        "context": "    ],\n)\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 136,
        "coloffset": 4,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 134,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the check of the match count works for simple examples.\"\"\"",
        "context": "        (3, None, 2, False),\n    ],\n)\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 135,
        "coloffset": 4,
        "linematch": "result = check_match_count(count, min_value, max_value)",
        "context": "    ],\n)\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 136,
        "coloffset": 4,
        "linematch": "assert result == expected",
        "context": ")\ndef test_check_match_count_expected(count, min_value, max_value, expected):\n    \"\"\"Confirm that the check of the match count works for simple examples.\"\"\"\n    result = check_match_count(count, min_value, max_value)\n    assert result == expected\n\n\n@given(\n    st.integers(),\n    st.integers(min_value=0, max_value=25),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1369",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1370",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1371",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1372",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1373",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_integers",
    "function_scope": "111-115",
    "patterns": [
      {
        "lineno": 115,
        "coloffset": 41,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 115,
        "coloffset": 41,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 115,
        "coloffset": 41,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 115,
        "coloffset": 41,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 115,
        "coloffset": 41,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 115,
        "coloffset": 41,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 115,
        "coloffset": 41,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 115,
        "coloffset": 41,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 49,
        "coloffset": 0,
        "linematch": "def test_integers(config):",
        "context": "\n@given(from_schema(JSON_SCHEMA_CONFIG))\n@settings(suppress_health_check=[HealthCheck.too_slow])\n@pytest.mark.fuzz\ndef test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 111,
        "coloffset": 0,
        "linematch": "def test_integers(check):",
        "context": "\n@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.too_slow])\ndef test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "assert is_valid",
        "context": "@pytest.mark.fuzz\ndef test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "assert not errors",
        "context": "def test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "assert isinstance(min_count, int) or min_count is None",
        "context": "@settings(suppress_health_check=[HealthCheck.too_slow])\ndef test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"",
        "context": "@given(from_schema(JSON_SCHEMA_CONFIG))\n@settings(suppress_health_check=[HealthCheck.too_slow])\n@pytest.mark.fuzz\ndef test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "is_valid, errors = validate_configuration(config)",
        "context": "@settings(suppress_health_check=[HealthCheck.too_slow])\n@pytest.mark.fuzz\ndef test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "assert is_valid",
        "context": "@pytest.mark.fuzz\ndef test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "assert not errors",
        "context": "def test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"",
        "context": "@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.too_slow])\ndef test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 113,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)",
        "context": "@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.too_slow])\ndef test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "assert isinstance(min_count, int) or min_count is None",
        "context": "@settings(suppress_health_check=[HealthCheck.too_slow])\ndef test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"",
        "context": "@given(from_schema(JSON_SCHEMA_CONFIG))\n@settings(suppress_health_check=[HealthCheck.too_slow])\n@pytest.mark.fuzz\ndef test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "is_valid, errors = validate_configuration(config)",
        "context": "@settings(suppress_health_check=[HealthCheck.too_slow])\n@pytest.mark.fuzz\ndef test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "assert is_valid",
        "context": "@pytest.mark.fuzz\ndef test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "assert not errors",
        "context": "def test_integers(config):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible valid instances.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"",
        "context": "@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.too_slow])\ndef test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 113,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)",
        "context": "@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.too_slow])\ndef test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "assert isinstance(min_count, int) or min_count is None",
        "context": "@settings(suppress_health_check=[HealthCheck.too_slow])\ndef test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "assert isinstance(min_count, int) or min_count is None",
        "context": "@settings(suppress_health_check=[HealthCheck.too_slow])\ndef test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_integers(check):\n    \"\"\"Use Hypothesis and the JSON schema plugin to confirm validation works for all possible check configurations.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@pytest.mark.parametrize(\n    \"count,min_value,max_value,expected\",\n    [",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_analyze_store_results_valid_path",
    "function_scope": "515-534",
    "patterns": [
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 534,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 515,
        "coloffset": 0,
        "linematch": "def test_analyze_store_results_valid_path(directory, cwd):",
        "context": "\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz\ndef test_analyze_store_results_valid_path(directory, cwd):\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 534,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 516,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz\ndef test_analyze_store_results_valid_path(directory, cwd):\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 519,
        "coloffset": 4,
        "linematch": "configuration_directory = str(cwd) + \"/.chasten\"",
        "context": "def test_analyze_store_results_valid_path(directory, cwd):\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 520,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            cwd,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 534,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 516,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz\ndef test_analyze_store_results_valid_path(directory, cwd):\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 519,
        "coloffset": 4,
        "linematch": "configuration_directory = str(cwd) + \"/.chasten\"",
        "context": "def test_analyze_store_results_valid_path(directory, cwd):\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 520,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            cwd,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 534,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            directory,\n            \"--force\",\n        ],\n    )\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "is_in_closed_interval",
    "function_scope": "66-68",
    "patterns": [
      {
        "lineno": 68,
        "coloffset": 46,
        "linematch": "return min(max_value, value) == value and max(min_value, value) == value",
        "context": "\n\ndef is_in_closed_interval(value: int, min_value: int, max_value: int) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    return min(max_value, value) == value and max(min_value, value) == value\n\n\ndef check_match_count(\n    count: int, min_value: Union[int, None] = None, max_value: Union[int, None] = None\n) -> bool:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 68,
        "coloffset": 46,
        "linematch": "return min(max_value, value) == value and max(min_value, value) == value",
        "context": "\n\ndef is_in_closed_interval(value: int, min_value: int, max_value: int) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    return min(max_value, value) == value and max(min_value, value) == value\n\n\ndef check_match_count(\n    count: int, min_value: Union[int, None] = None, max_value: Union[int, None] = None\n) -> bool:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 66,
        "coloffset": 0,
        "linematch": "def is_in_closed_interval(value: int, min_value: int, max_value: int) -> bool:",
        "context": "        return False\n    return True\n\n\ndef is_in_closed_interval(value: int, min_value: int, max_value: int) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    return min(max_value, value) == value and max(min_value, value) == value\n\n\ndef check_match_count(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 67,
        "coloffset": 4,
        "linematch": "\"\"\"Help to see if the value is in the closed interval.\"\"\"",
        "context": "    return True\n\n\ndef is_in_closed_interval(value: int, min_value: int, max_value: int) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    return min(max_value, value) == value and max(min_value, value) == value\n\n\ndef check_match_count(\n    count: int, min_value: Union[int, None] = None, max_value: Union[int, None] = None",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 68,
        "coloffset": 4,
        "linematch": "return min(max_value, value) == value and max(min_value, value) == value",
        "context": "\n\ndef is_in_closed_interval(value: int, min_value: int, max_value: int) -> bool:\n    \"\"\"Help to see if the value is in the closed interval.\"\"\"\n    return min(max_value, value) == value and max(min_value, value) == value\n\n\ndef check_match_count(\n    count: int, min_value: Union[int, None] = None, max_value: Union[int, None] = None\n) -> bool:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_write_checks",
    "function_scope": "33-36",
    "patterns": [
      {
        "lineno": 33,
        "coloffset": 0,
        "linematch": "def test_write_checks():",
        "context": "\"\"\"\n\n\n# Test to check if the 'write_checks' function correctly converts CSV data to a formatted string\ndef test_write_checks():\n    \"\"\"Test the write_checks function by converting CSV data to a formatted string.\"\"\"\n    expected_check = \"Make a YAML file that checks for:\\n - exactly 2 for loop\\n - at minimum 3 while loop\\n - at minimum 1 function\\n - exactly 1 assert statement\"\n    assert configApp.write_checks(CSV_CHECK_LIST) == expected_check\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert configApp.write_checks(CSV_CHECK_LIST) == expected_check",
        "context": "# Test to check if the 'write_checks' function correctly converts CSV data to a formatted string\ndef test_write_checks():\n    \"\"\"Test the write_checks function by converting CSV data to a formatted string.\"\"\"\n    expected_check = \"Make a YAML file that checks for:\\n - exactly 2 for loop\\n - at minimum 3 while loop\\n - at minimum 1 function\\n - exactly 1 assert statement\"\n    assert configApp.write_checks(CSV_CHECK_LIST) == expected_check\n\n\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():\n    \"\"\"Test the write_checks function when list is empty\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "\"\"\"Test the write_checks function by converting CSV data to a formatted string.\"\"\"",
        "context": "\n\n# Test to check if the 'write_checks' function correctly converts CSV data to a formatted string\ndef test_write_checks():\n    \"\"\"Test the write_checks function by converting CSV data to a formatted string.\"\"\"\n    expected_check = \"Make a YAML file that checks for:\\n - exactly 2 for loop\\n - at minimum 3 while loop\\n - at minimum 1 function\\n - exactly 1 assert statement\"\n    assert configApp.write_checks(CSV_CHECK_LIST) == expected_check\n\n\n# Test to check the handling of an empty input list by the 'write_checks' function",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "expected_check = \"Make a YAML file that checks for:\\n - exactly 2 for loop\\n - at minimum 3 while loop\\n - at minimum 1 function\\n - exactly 1 assert statement\"",
        "context": "\n# Test to check if the 'write_checks' function correctly converts CSV data to a formatted string\ndef test_write_checks():\n    \"\"\"Test the write_checks function by converting CSV data to a formatted string.\"\"\"\n    expected_check = \"Make a YAML file that checks for:\\n - exactly 2 for loop\\n - at minimum 3 while loop\\n - at minimum 1 function\\n - exactly 1 assert statement\"\n    assert configApp.write_checks(CSV_CHECK_LIST) == expected_check\n\n\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert configApp.write_checks(CSV_CHECK_LIST) == expected_check",
        "context": "# Test to check if the 'write_checks' function correctly converts CSV data to a formatted string\ndef test_write_checks():\n    \"\"\"Test the write_checks function by converting CSV data to a formatted string.\"\"\"\n    expected_check = \"Make a YAML file that checks for:\\n - exactly 2 for loop\\n - at minimum 3 while loop\\n - at minimum 1 function\\n - exactly 1 assert statement\"\n    assert configApp.write_checks(CSV_CHECK_LIST) == expected_check\n\n\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():\n    \"\"\"Test the write_checks function when list is empty\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "\"\"\"Test the write_checks function by converting CSV data to a formatted string.\"\"\"",
        "context": "\n\n# Test to check if the 'write_checks' function correctly converts CSV data to a formatted string\ndef test_write_checks():\n    \"\"\"Test the write_checks function by converting CSV data to a formatted string.\"\"\"\n    expected_check = \"Make a YAML file that checks for:\\n - exactly 2 for loop\\n - at minimum 3 while loop\\n - at minimum 1 function\\n - exactly 1 assert statement\"\n    assert configApp.write_checks(CSV_CHECK_LIST) == expected_check\n\n\n# Test to check the handling of an empty input list by the 'write_checks' function",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "expected_check = \"Make a YAML file that checks for:\\n - exactly 2 for loop\\n - at minimum 3 while loop\\n - at minimum 1 function\\n - exactly 1 assert statement\"",
        "context": "\n# Test to check if the 'write_checks' function correctly converts CSV data to a formatted string\ndef test_write_checks():\n    \"\"\"Test the write_checks function by converting CSV data to a formatted string.\"\"\"\n    expected_check = \"Make a YAML file that checks for:\\n - exactly 2 for loop\\n - at minimum 3 while loop\\n - at minimum 1 function\\n - exactly 1 assert statement\"\n    assert configApp.write_checks(CSV_CHECK_LIST) == expected_check\n\n\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert configApp.write_checks(CSV_CHECK_LIST) == expected_check",
        "context": "# Test to check if the 'write_checks' function correctly converts CSV data to a formatted string\ndef test_write_checks():\n    \"\"\"Test the write_checks function by converting CSV data to a formatted string.\"\"\"\n    expected_check = \"Make a YAML file that checks for:\\n - exactly 2 for loop\\n - at minimum 3 while loop\\n - at minimum 1 function\\n - exactly 1 assert statement\"\n    assert configApp.write_checks(CSV_CHECK_LIST) == expected_check\n\n\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():\n    \"\"\"Test the write_checks function when list is empty\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_write_checks_empty_file",
    "function_scope": "40-42",
    "patterns": [
      {
        "lineno": 40,
        "coloffset": 0,
        "linematch": "def test_write_checks_empty_file():",
        "context": "    assert configApp.write_checks(CSV_CHECK_LIST) == expected_check\n\n\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():\n    \"\"\"Test the write_checks function when list is empty\"\"\"\n    assert configApp.write_checks([]) == \"[red][ERROR][/red] No checks were supplied\"\n\n\n# Test to check if the 'split_file' function correctly parses a file with check data",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "assert configApp.write_checks([]) == \"[red][ERROR][/red] No checks were supplied\"",
        "context": "\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():\n    \"\"\"Test the write_checks function when list is empty\"\"\"\n    assert configApp.write_checks([]) == \"[red][ERROR][/red] No checks were supplied\"\n\n\n# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "\"\"\"Test the write_checks function when list is empty\"\"\"",
        "context": "\n\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():\n    \"\"\"Test the write_checks function when list is empty\"\"\"\n    assert configApp.write_checks([]) == \"[red][ERROR][/red] No checks were supplied\"\n\n\n# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "assert configApp.write_checks([]) == \"[red][ERROR][/red] No checks were supplied\"",
        "context": "\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():\n    \"\"\"Test the write_checks function when list is empty\"\"\"\n    assert configApp.write_checks([]) == \"[red][ERROR][/red] No checks were supplied\"\n\n\n# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "\"\"\"Test the write_checks function when list is empty\"\"\"",
        "context": "\n\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():\n    \"\"\"Test the write_checks function when list is empty\"\"\"\n    assert configApp.write_checks([]) == \"[red][ERROR][/red] No checks were supplied\"\n\n\n# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "assert configApp.write_checks([]) == \"[red][ERROR][/red] No checks were supplied\"",
        "context": "\n# Test to check the handling of an empty input list by the 'write_checks' function\ndef test_write_checks_empty_file():\n    \"\"\"Test the write_checks function when list is empty\"\"\"\n    assert configApp.write_checks([]) == \"[red][ERROR][/red] No checks were supplied\"\n\n\n# Test to check if the 'split_file' function correctly parses a file with check data\ndef test_split_file(tmpdir):\n    \"\"\"Test the split_file function by parsing check data from a file.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_store_in_file",
    "function_scope": "63-70",
    "patterns": [
      {
        "lineno": 63,
        "coloffset": 0,
        "linematch": "def test_store_in_file(Pattern, Matches, Exact, tmpdir):",
        "context": "    Exact=st.booleans(),\n)\n@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_store_in_file(Pattern, Matches, Exact, tmpdir):\n    \"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "context": "    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 64,
        "coloffset": 4,
        "linematch": "\"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"",
        "context": ")\n@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_store_in_file(Pattern, Matches, Exact, tmpdir):\n    \"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 65,
        "coloffset": 4,
        "linematch": "tmp_dir = pathlib.Path(tmpdir)",
        "context": "@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_store_in_file(Pattern, Matches, Exact, tmpdir):\n    \"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 66,
        "coloffset": 4,
        "linematch": "file = tmp_dir / \"check_test.txt\"",
        "context": "@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_store_in_file(Pattern, Matches, Exact, tmpdir):\n    \"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 67,
        "coloffset": 4,
        "linematch": "file.touch()",
        "context": "def test_store_in_file(Pattern, Matches, Exact, tmpdir):\n    \"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 69,
        "coloffset": 4,
        "linematch": "configApp.store_in_file(file, Pattern, Matches, Exact)",
        "context": "    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "context": "    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 64,
        "coloffset": 4,
        "linematch": "\"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"",
        "context": ")\n@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_store_in_file(Pattern, Matches, Exact, tmpdir):\n    \"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 65,
        "coloffset": 4,
        "linematch": "tmp_dir = pathlib.Path(tmpdir)",
        "context": "@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_store_in_file(Pattern, Matches, Exact, tmpdir):\n    \"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 66,
        "coloffset": 4,
        "linematch": "file = tmp_dir / \"check_test.txt\"",
        "context": "@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_store_in_file(Pattern, Matches, Exact, tmpdir):\n    \"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 67,
        "coloffset": 4,
        "linematch": "file.touch()",
        "context": "def test_store_in_file(Pattern, Matches, Exact, tmpdir):\n    \"\"\"Tests if the store_in_file function correctly stores data in a file.\"\"\"\n    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 69,
        "coloffset": 4,
        "linematch": "configApp.store_in_file(file, Pattern, Matches, Exact)",
        "context": "    tmp_dir = pathlib.Path(tmpdir)\n    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "context": "    file = tmp_dir / \"check_test.txt\"\n    file.touch()\n    # Call the 'store_in_file' function with generated data and check if it's stored in the file\n    configApp.store_in_file(file, Pattern, Matches, Exact)\n    assert f\"\\n{Pattern},{Matches},{Exact}\" in file.read_text(\"utf-8\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_create_chasten_view",
    "function_scope": "8-16",
    "patterns": [
      {
        "lineno": 8,
        "coloffset": 0,
        "linematch": "def test_create_chasten_view():",
        "context": "\nfrom chasten import database\n\n\ndef test_create_chasten_view():\n    \"\"\"Confirm that the function creating and viewing an example database does not crash\"\"\"\n    # define the variable name for the example database\n    chasten_database_name: str = \".example_database\"\n    # create the database with example name\n    # run the view command with a set SQL query",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the function creating and viewing an example database does not crash\"\"\"",
        "context": "from chasten import database\n\n\ndef test_create_chasten_view():\n    \"\"\"Confirm that the function creating and viewing an example database does not crash\"\"\"\n    # define the variable name for the example database\n    chasten_database_name: str = \".example_database\"\n    # create the database with example name\n    # run the view command with a set SQL query\n    database.create_chasten_view(chasten_database_name)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "chasten_database_name: str = \".example_database\"",
        "context": "\ndef test_create_chasten_view():\n    \"\"\"Confirm that the function creating and viewing an example database does not crash\"\"\"\n    # define the variable name for the example database\n    chasten_database_name: str = \".example_database\"\n    # create the database with example name\n    # run the view command with a set SQL query\n    database.create_chasten_view(chasten_database_name)\n    # remove the example variable made\n    os.remove(\".example_database\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "database.create_chasten_view(chasten_database_name)",
        "context": "    # define the variable name for the example database\n    chasten_database_name: str = \".example_database\"\n    # create the database with example name\n    # run the view command with a set SQL query\n    database.create_chasten_view(chasten_database_name)\n    # remove the example variable made\n    os.remove(\".example_database\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "os.remove(\".example_database\")",
        "context": "    # create the database with example name\n    # run the view command with a set SQL query\n    database.create_chasten_view(chasten_database_name)\n    # remove the example variable made\n    os.remove(\".example_database\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the function creating and viewing an example database does not crash\"\"\"",
        "context": "from chasten import database\n\n\ndef test_create_chasten_view():\n    \"\"\"Confirm that the function creating and viewing an example database does not crash\"\"\"\n    # define the variable name for the example database\n    chasten_database_name: str = \".example_database\"\n    # create the database with example name\n    # run the view command with a set SQL query\n    database.create_chasten_view(chasten_database_name)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "chasten_database_name: str = \".example_database\"",
        "context": "\ndef test_create_chasten_view():\n    \"\"\"Confirm that the function creating and viewing an example database does not crash\"\"\"\n    # define the variable name for the example database\n    chasten_database_name: str = \".example_database\"\n    # create the database with example name\n    # run the view command with a set SQL query\n    database.create_chasten_view(chasten_database_name)\n    # remove the example variable made\n    os.remove(\".example_database\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "database.create_chasten_view(chasten_database_name)",
        "context": "    # define the variable name for the example database\n    chasten_database_name: str = \".example_database\"\n    # create the database with example name\n    # run the view command with a set SQL query\n    database.create_chasten_view(chasten_database_name)\n    # remove the example variable made\n    os.remove(\".example_database\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "os.remove(\".example_database\")",
        "context": "    # create the database with example name\n    # run the view command with a set SQL query\n    database.create_chasten_view(chasten_database_name)\n    # remove the example variable made\n    os.remove(\".example_database\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1360",
        "line": 16,
        "description": [
          "logger: logging.Logger = logging.getLogger()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_debug_level_values",
    "function_scope": "8-14",
    "patterns": [
      {
        "lineno": 8,
        "coloffset": 0,
        "linematch": "def test_debug_level_values():",
        "context": "\nfrom chasten.debug import DebugDestination, DebugLevel\n\n\ndef test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "assert DebugLevel.DEBUG == \"DEBUG\"",
        "context": "\n\ndef test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "assert DebugLevel.INFO == \"INFO\"",
        "context": "\ndef test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 12,
        "coloffset": 4,
        "linematch": "assert DebugLevel.WARNING == \"WARNING\"",
        "context": "def test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "assert DebugLevel.ERROR == \"ERROR\"",
        "context": "    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert DebugLevel.CRITICAL == \"CRITICAL\"",
        "context": "    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that all of the enumeration values are correct.\"\"\"",
        "context": "from chasten.debug import DebugDestination, DebugLevel\n\n\ndef test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "assert DebugLevel.DEBUG == \"DEBUG\"",
        "context": "\n\ndef test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "assert DebugLevel.INFO == \"INFO\"",
        "context": "\ndef test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 12,
        "coloffset": 4,
        "linematch": "assert DebugLevel.WARNING == \"WARNING\"",
        "context": "def test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "assert DebugLevel.ERROR == \"ERROR\"",
        "context": "    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert DebugLevel.CRITICAL == \"CRITICAL\"",
        "context": "    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that all of the enumeration values are correct.\"\"\"",
        "context": "from chasten.debug import DebugDestination, DebugLevel\n\n\ndef test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "assert DebugLevel.DEBUG == \"DEBUG\"",
        "context": "\n\ndef test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "assert DebugLevel.INFO == \"INFO\"",
        "context": "\ndef test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 12,
        "coloffset": 4,
        "linematch": "assert DebugLevel.WARNING == \"WARNING\"",
        "context": "def test_debug_level_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "assert DebugLevel.ERROR == \"ERROR\"",
        "context": "    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert DebugLevel.CRITICAL == \"CRITICAL\"",
        "context": "    assert DebugLevel.DEBUG == \"DEBUG\"\n    assert DebugLevel.INFO == \"INFO\"\n    assert DebugLevel.WARNING == \"WARNING\"\n    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_debug_level_isinstance",
    "function_scope": "17-23",
    "patterns": [
      {
        "lineno": 17,
        "coloffset": 0,
        "linematch": "def test_debug_level_isinstance():",
        "context": "    assert DebugLevel.ERROR == \"ERROR\"\n    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.DEBUG, DebugLevel)",
        "context": "\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.INFO, DebugLevel)",
        "context": "\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.WARNING, DebugLevel)",
        "context": "def test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.ERROR, DebugLevel)",
        "context": "    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.CRITICAL, DebugLevel)",
        "context": "    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"",
        "context": "    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.DEBUG, DebugLevel)",
        "context": "\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.INFO, DebugLevel)",
        "context": "\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.WARNING, DebugLevel)",
        "context": "def test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.ERROR, DebugLevel)",
        "context": "    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.CRITICAL, DebugLevel)",
        "context": "    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"",
        "context": "    assert DebugLevel.CRITICAL == \"CRITICAL\"\n\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.DEBUG, DebugLevel)",
        "context": "\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.INFO, DebugLevel)",
        "context": "\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.WARNING, DebugLevel)",
        "context": "def test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.ERROR, DebugLevel)",
        "context": "    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.CRITICAL, DebugLevel)",
        "context": "    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.DEBUG, DebugLevel)",
        "context": "\n\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.INFO, DebugLevel)",
        "context": "\ndef test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.WARNING, DebugLevel)",
        "context": "def test_debug_level_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.ERROR, DebugLevel)",
        "context": "    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugLevel.CRITICAL, DebugLevel)",
        "context": "    assert isinstance(DebugLevel.DEBUG, DebugLevel)\n    assert isinstance(DebugLevel.INFO, DebugLevel)\n    assert isinstance(DebugLevel.WARNING, DebugLevel)\n    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #299",
        "line": 19,
        "description": [
          "console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_debug_level_iteration",
    "function_scope": "26-28",
    "patterns": [
      {
        "lineno": 26,
        "coloffset": 0,
        "linematch": "def test_debug_level_iteration():",
        "context": "    assert isinstance(DebugLevel.ERROR, DebugLevel)\n    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n\n\ndef test_debug_destination_values():",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "context": "\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to list all of the possible values.\"\"\"",
        "context": "    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "context": "\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to list all of the possible values.\"\"\"",
        "context": "    assert isinstance(DebugLevel.CRITICAL, DebugLevel)\n\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "context": "\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "context": "\n\ndef test_debug_level_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_debug_destination_values",
    "function_scope": "31-34",
    "patterns": [
      {
        "lineno": 31,
        "coloffset": 0,
        "linematch": "def test_debug_destination_values():",
        "context": "    \"\"\"Confirm that it is possible to list all of the possible values.\"\"\"\n    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"\n    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "assert DebugDestination.CONSOLE == \"CONSOLE\"",
        "context": "\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"\n    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert DebugDestination.SYSLOG == \"SYSLOG\"",
        "context": "\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"\n    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that all of the enumeration values are correct.\"\"\"",
        "context": "    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"\n    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "assert DebugDestination.CONSOLE == \"CONSOLE\"",
        "context": "\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"\n    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert DebugDestination.SYSLOG == \"SYSLOG\"",
        "context": "\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"\n    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that all of the enumeration values are correct.\"\"\"",
        "context": "    assert list(DebugLevel) == [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"\n    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "assert DebugDestination.CONSOLE == \"CONSOLE\"",
        "context": "\n\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"\n    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert DebugDestination.SYSLOG == \"SYSLOG\"",
        "context": "\ndef test_debug_destination_values():\n    \"\"\"Confirm that all of the enumeration values are correct.\"\"\"\n    assert DebugDestination.CONSOLE == \"CONSOLE\"\n    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_debug_destination_isinstance",
    "function_scope": "37-40",
    "patterns": [
      {
        "lineno": 37,
        "coloffset": 0,
        "linematch": "def test_debug_destination_isinstance():",
        "context": "    assert DebugDestination.CONSOLE == \"CONSOLE\"\n    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugDestination.CONSOLE, DebugDestination)",
        "context": "\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugDestination.SYSLOG, DebugDestination)",
        "context": "\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 38,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"",
        "context": "    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugDestination.CONSOLE, DebugDestination)",
        "context": "\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugDestination.SYSLOG, DebugDestination)",
        "context": "\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 38,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"",
        "context": "    assert DebugDestination.SYSLOG == \"SYSLOG\"\n\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugDestination.CONSOLE, DebugDestination)",
        "context": "\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugDestination.SYSLOG, DebugDestination)",
        "context": "\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugDestination.CONSOLE, DebugDestination)",
        "context": "\n\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "assert isinstance(DebugDestination.SYSLOG, DebugDestination)",
        "context": "\ndef test_debug_destination_isinstance():\n    \"\"\"Confirm that all of the individual levels are of the correct type.\"\"\"\n    assert isinstance(DebugDestination.CONSOLE, DebugDestination)\n    assert isinstance(DebugDestination.SYSLOG, DebugDestination)\n\n\ndef test_debug_destination_iteration():\n    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_level_destination_invalid",
    "function_scope": "48-51",
    "patterns": [
      {
        "lineno": 48,
        "coloffset": 0,
        "linematch": "def test_level_destination_invalid():",
        "context": "    \"\"\"Confirm that it is possible to list all of the possible valuers.\"\"\"\n    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        DebugLevel(\"INVALID\")\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that invalid values raise a ValueError.\"\"\"",
        "context": "    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        DebugLevel(\"INVALID\")\n\n\ndef test_debug_destination_invalid():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "with pytest.raises(ValueError):",
        "context": "\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        DebugLevel(\"INVALID\")\n\n\ndef test_debug_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that invalid values raise a ValueError.\"\"\"",
        "context": "    assert list(DebugDestination) == [\"CONSOLE\", \"SYSLOG\"]\n\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        DebugLevel(\"INVALID\")\n\n\ndef test_debug_destination_invalid():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "with pytest.raises(ValueError):",
        "context": "\n\ndef test_level_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        DebugLevel(\"INVALID\")\n\n\ndef test_debug_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_debug_destination_invalid",
    "function_scope": "54-57",
    "patterns": [
      {
        "lineno": 54,
        "coloffset": 0,
        "linematch": "def test_debug_destination_invalid():",
        "context": "    with pytest.raises(ValueError):\n        DebugLevel(\"INVALID\")\n\n\ndef test_debug_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        DebugDestination(\"INVALID\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that invalid values raise a ValueError.\"\"\"",
        "context": "        DebugLevel(\"INVALID\")\n\n\ndef test_debug_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        DebugDestination(\"INVALID\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "with pytest.raises(ValueError):",
        "context": "\n\ndef test_debug_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        DebugDestination(\"INVALID\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that invalid values raise a ValueError.\"\"\"",
        "context": "        DebugLevel(\"INVALID\")\n\n\ndef test_debug_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        DebugDestination(\"INVALID\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "with pytest.raises(ValueError):",
        "context": "\n\ndef test_debug_destination_invalid():\n    \"\"\"Confirm that invalid values raise a ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        DebugDestination(\"INVALID\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_fuzz_create_use_config_dir",
    "function_scope": "13-21",
    "patterns": [
      {
        "lineno": 13,
        "coloffset": 0,
        "linematch": "def test_fuzz_create_use_config_dir(",
        "context": "\n\n@given(applicationname=strategies.text(), applicationauthor=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_create_use_config_dir(\n    applicationname: str, applicationauthor: str\n) -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash and produces directory with the application name.\"\"\"\n    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "assert user_config_dir_str",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and produces directory with the application name.\"\"\"\n    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor\n    )\n    assert user_config_dir_str\n    assert applicationname in user_config_dir_str\n\n\n@given(\n    debug_level=strategies.sampled_from(",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "assert applicationname in user_config_dir_str",
        "context": "    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor\n    )\n    assert user_config_dir_str\n    assert applicationname in user_config_dir_str\n\n\n@given(\n    debug_level=strategies.sampled_from(\n        [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the function does not crash and produces directory with the application name.\"\"\"",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_create_use_config_dir(\n    applicationname: str, applicationauthor: str\n) -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash and produces directory with the application name.\"\"\"\n    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor\n    )\n    assert user_config_dir_str\n    assert applicationname in user_config_dir_str",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "user_config_dir_str = configuration.user_config_dir(",
        "context": "def test_fuzz_create_use_config_dir(\n    applicationname: str, applicationauthor: str\n) -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash and produces directory with the application name.\"\"\"\n    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor\n    )\n    assert user_config_dir_str\n    assert applicationname in user_config_dir_str\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "assert user_config_dir_str",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and produces directory with the application name.\"\"\"\n    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor\n    )\n    assert user_config_dir_str\n    assert applicationname in user_config_dir_str\n\n\n@given(\n    debug_level=strategies.sampled_from(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "assert applicationname in user_config_dir_str",
        "context": "    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor\n    )\n    assert user_config_dir_str\n    assert applicationname in user_config_dir_str\n\n\n@given(\n    debug_level=strategies.sampled_from(\n        [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the function does not crash and produces directory with the application name.\"\"\"",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_create_use_config_dir(\n    applicationname: str, applicationauthor: str\n) -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash and produces directory with the application name.\"\"\"\n    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor\n    )\n    assert user_config_dir_str\n    assert applicationname in user_config_dir_str",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "user_config_dir_str = configuration.user_config_dir(",
        "context": "def test_fuzz_create_use_config_dir(\n    applicationname: str, applicationauthor: str\n) -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash and produces directory with the application name.\"\"\"\n    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor\n    )\n    assert user_config_dir_str\n    assert applicationname in user_config_dir_str\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "assert user_config_dir_str",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and produces directory with the application name.\"\"\"\n    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor\n    )\n    assert user_config_dir_str\n    assert applicationname in user_config_dir_str\n\n\n@given(\n    debug_level=strategies.sampled_from(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "assert applicationname in user_config_dir_str",
        "context": "    user_config_dir_str = configuration.user_config_dir(\n        applicationname, applicationauthor\n    )\n    assert user_config_dir_str\n    assert applicationname in user_config_dir_str\n\n\n@given(\n    debug_level=strategies.sampled_from(\n        [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #299",
        "line": 19,
        "description": [
          "console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1360",
        "line": 16,
        "description": [
          "logger: logging.Logger = logging.getLogger()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_fuzz_configure_logging",
    "function_scope": "31-36",
    "patterns": [
      {
        "lineno": 31,
        "coloffset": 0,
        "linematch": "def test_fuzz_configure_logging(debug_level, debug_dest):",
        "context": "    ),\n    debug_dest=strategies.sampled_from([\"CONSOLE\", \"SYSLOG\"]),\n)\n@pytest.mark.fuzz\ndef test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert logger",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n\n@given(",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "assert created",
        "context": "def test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n\n@given(\n    debug_level=strategies.sampled_from(",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert isinstance(logger, logging.Logger)",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n\n@given(\n    debug_level=strategies.sampled_from(\n        [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"",
        "context": "    debug_dest=strategies.sampled_from([\"CONSOLE\", \"SYSLOG\"]),\n)\n@pytest.mark.fuzz\ndef test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "logger, created = configuration.configure_logging(debug_level, debug_dest)",
        "context": ")\n@pytest.mark.fuzz\ndef test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert logger",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n\n@given(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "assert created",
        "context": "def test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n\n@given(\n    debug_level=strategies.sampled_from(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert isinstance(logger, logging.Logger)",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n\n@given(\n    debug_level=strategies.sampled_from(\n        [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"",
        "context": "    debug_dest=strategies.sampled_from([\"CONSOLE\", \"SYSLOG\"]),\n)\n@pytest.mark.fuzz\ndef test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "logger, created = configuration.configure_logging(debug_level, debug_dest)",
        "context": ")\n@pytest.mark.fuzz\ndef test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert logger",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n\n@given(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "assert created",
        "context": "def test_fuzz_configure_logging(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n\n@given(\n    debug_level=strategies.sampled_from(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert isinstance(logger, logging.Logger)",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n\n@given(\n    debug_level=strategies.sampled_from(\n        [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert isinstance(logger, logging.Logger)",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert created\n    assert isinstance(logger, logging.Logger)\n\n\n@given(\n    debug_level=strategies.sampled_from(\n        [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_fuzz_configure_logging_incorrect_inputs",
    "function_scope": "46-51",
    "patterns": [
      {
        "lineno": 46,
        "coloffset": 0,
        "linematch": "def test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):",
        "context": "    ),\n    debug_dest=strategies.sampled_from([\"CONSOLE-WRONG\", \"SYSLOG-WRONG\"]),\n)\n@pytest.mark.fuzz\ndef test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "assert logger",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "assert not created",
        "context": "def test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "assert isinstance(logger, logging.Logger)",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"",
        "context": "    debug_dest=strategies.sampled_from([\"CONSOLE-WRONG\", \"SYSLOG-WRONG\"]),\n)\n@pytest.mark.fuzz\ndef test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "logger, created = configuration.configure_logging(debug_level, debug_dest)",
        "context": ")\n@pytest.mark.fuzz\ndef test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "assert logger",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "assert not created",
        "context": "def test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "assert isinstance(logger, logging.Logger)",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"",
        "context": "    debug_dest=strategies.sampled_from([\"CONSOLE-WRONG\", \"SYSLOG-WRONG\"]),\n)\n@pytest.mark.fuzz\ndef test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "logger, created = configuration.configure_logging(debug_level, debug_dest)",
        "context": ")\n@pytest.mark.fuzz\ndef test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "assert logger",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "assert not created",
        "context": "def test_fuzz_configure_logging_incorrect_inputs(debug_level, debug_dest):\n    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "assert isinstance(logger, logging.Logger)",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "assert isinstance(logger, logging.Logger)",
        "context": "    \"\"\"Use Hypothesis to confirm that the function does not crash and always produces logger with valid data.\"\"\"\n    logger, created = configuration.configure_logging(debug_level, debug_dest)\n    assert logger\n    assert not created\n    assert isinstance(logger, logging.Logger)",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_human_readable_boolean",
    "function_scope": "12-15",
    "patterns": [
      {
        "lineno": 12,
        "coloffset": 0,
        "linematch": "def test_human_readable_boolean() -> None:",
        "context": "\nfrom chasten import constants, util\n\n\ndef test_human_readable_boolean() -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    assert util.get_human_readable_boolean(answer=True) == \"Yes\"\n    assert util.get_human_readable_boolean(answer=False) == \"No\"\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert util.get_human_readable_boolean(answer=True) == \"Yes\"",
        "context": "\n\ndef test_human_readable_boolean() -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    assert util.get_human_readable_boolean(answer=True) == \"Yes\"\n    assert util.get_human_readable_boolean(answer=False) == \"No\"\n\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "assert util.get_human_readable_boolean(answer=False) == \"No\"",
        "context": "\ndef test_human_readable_boolean() -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    assert util.get_human_readable_boolean(answer=True) == \"Yes\"\n    assert util.get_human_readable_boolean(answer=False) == \"No\"\n\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean(answer: bool) -> None:",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"",
        "context": "from chasten import constants, util\n\n\ndef test_human_readable_boolean() -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    assert util.get_human_readable_boolean(answer=True) == \"Yes\"\n    assert util.get_human_readable_boolean(answer=False) == \"No\"\n\n\n@given(answer=st.booleans())",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert util.get_human_readable_boolean(answer=True) == \"Yes\"",
        "context": "\n\ndef test_human_readable_boolean() -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    assert util.get_human_readable_boolean(answer=True) == \"Yes\"\n    assert util.get_human_readable_boolean(answer=False) == \"No\"\n\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "assert util.get_human_readable_boolean(answer=False) == \"No\"",
        "context": "\ndef test_human_readable_boolean() -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    assert util.get_human_readable_boolean(answer=True) == \"Yes\"\n    assert util.get_human_readable_boolean(answer=False) == \"No\"\n\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean(answer: bool) -> None:",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"",
        "context": "from chasten import constants, util\n\n\ndef test_human_readable_boolean() -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    assert util.get_human_readable_boolean(answer=True) == \"Yes\"\n    assert util.get_human_readable_boolean(answer=False) == \"No\"\n\n\n@given(answer=st.booleans())",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert util.get_human_readable_boolean(answer=True) == \"Yes\"",
        "context": "\n\ndef test_human_readable_boolean() -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    assert util.get_human_readable_boolean(answer=True) == \"Yes\"\n    assert util.get_human_readable_boolean(answer=False) == \"No\"\n\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "assert util.get_human_readable_boolean(answer=False) == \"No\"",
        "context": "\ndef test_human_readable_boolean() -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    assert util.get_human_readable_boolean(answer=True) == \"Yes\"\n    assert util.get_human_readable_boolean(answer=False) == \"No\"\n\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean(answer: bool) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_fuzz_human_readable_boolean",
    "function_scope": "20-22",
    "patterns": [
      {
        "lineno": 20,
        "coloffset": 0,
        "linematch": "def test_fuzz_human_readable_boolean(answer: bool) -> None:",
        "context": "\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    util.get_human_readable_boolean(answer=answer)\n\n\n@given(answer=st.booleans())",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"",
        "context": "\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    util.get_human_readable_boolean(answer=answer)\n\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "util.get_human_readable_boolean(answer=answer)",
        "context": "@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    util.get_human_readable_boolean(answer=answer)\n\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"",
        "context": "\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    util.get_human_readable_boolean(answer=answer)\n\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "util.get_human_readable_boolean(answer=answer)",
        "context": "@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean(answer: bool) -> None:\n    \"\"\"Use Hypothesis to confirm that the function does not crash.\"\"\"\n    util.get_human_readable_boolean(answer=answer)\n\n\n@given(answer=st.booleans())\n@pytest.mark.fuzz\ndef test_fuzz_human_readable_boolean_correct_string(answer: bool) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_total_amount_passed",
    "function_scope": "46-50",
    "patterns": [
      {
        "lineno": 46,
        "coloffset": 0,
        "linematch": "def test_total_amount_passed(check_status_list: list[bool]):",
        "context": "\n\n@given(check_status_list=st.lists(st.booleans()))\n@pytest.mark.fuzz\ndef test_total_amount_passed(check_status_list: list[bool]):\n    stats = util.total_amount_passed(check_status_list)\n\n    assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier\n    assert stats[0] <= stats[1]\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier",
        "context": "@pytest.mark.fuzz\ndef test_total_amount_passed(check_status_list: list[bool]):\n    stats = util.total_amount_passed(check_status_list)\n\n    assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier\n    assert stats[0] <= stats[1]\n\n\nOpSystem = util.get_OS()\ndatasette_exec = constants.datasette.Datasette_Executable",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "assert stats[0] <= stats[1]",
        "context": "def test_total_amount_passed(check_status_list: list[bool]):\n    stats = util.total_amount_passed(check_status_list)\n\n    assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier\n    assert stats[0] <= stats[1]\n\n\nOpSystem = util.get_OS()\ndatasette_exec = constants.datasette.Datasette_Executable\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "stats = util.total_amount_passed(check_status_list)",
        "context": "\n@given(check_status_list=st.lists(st.booleans()))\n@pytest.mark.fuzz\ndef test_total_amount_passed(check_status_list: list[bool]):\n    stats = util.total_amount_passed(check_status_list)\n\n    assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier\n    assert stats[0] <= stats[1]\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier",
        "context": "@pytest.mark.fuzz\ndef test_total_amount_passed(check_status_list: list[bool]):\n    stats = util.total_amount_passed(check_status_list)\n\n    assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier\n    assert stats[0] <= stats[1]\n\n\nOpSystem = util.get_OS()\ndatasette_exec = constants.datasette.Datasette_Executable",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "assert stats[0] <= stats[1]",
        "context": "def test_total_amount_passed(check_status_list: list[bool]):\n    stats = util.total_amount_passed(check_status_list)\n\n    assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier\n    assert stats[0] <= stats[1]\n\n\nOpSystem = util.get_OS()\ndatasette_exec = constants.datasette.Datasette_Executable\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "stats = util.total_amount_passed(check_status_list)",
        "context": "\n@given(check_status_list=st.lists(st.booleans()))\n@pytest.mark.fuzz\ndef test_total_amount_passed(check_status_list: list[bool]):\n    stats = util.total_amount_passed(check_status_list)\n\n    assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier\n    assert stats[0] <= stats[1]\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier",
        "context": "@pytest.mark.fuzz\ndef test_total_amount_passed(check_status_list: list[bool]):\n    stats = util.total_amount_passed(check_status_list)\n\n    assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier\n    assert stats[0] <= stats[1]\n\n\nOpSystem = util.get_OS()\ndatasette_exec = constants.datasette.Datasette_Executable",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "assert stats[0] <= stats[1]",
        "context": "def test_total_amount_passed(check_status_list: list[bool]):\n    stats = util.total_amount_passed(check_status_list)\n\n    assert constants.markers.Zero <= stats[2] <= constants.markers.Percent_Multiplier\n    assert stats[0] <= stats[1]\n\n\nOpSystem = util.get_OS()\ndatasette_exec = constants.datasette.Datasette_Executable\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "get_valid_api_key",
    "function_scope": "9-11",
    "patterns": [
      {
        "lineno": 9,
        "coloffset": 0,
        "linematch": "def get_valid_api_key():",
        "context": "\nfrom chasten.createchecks import generate_yaml_config, is_valid_api_key\n\n\ndef get_valid_api_key():\n    \"\"\"Retrive and return api key from env variable\"\"\"\n    return os.getenv(\"API_KEY\")\n\n\n@pytest.mark.api",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "\"\"\"Retrive and return api key from env variable\"\"\"",
        "context": "from chasten.createchecks import generate_yaml_config, is_valid_api_key\n\n\ndef get_valid_api_key():\n    \"\"\"Retrive and return api key from env variable\"\"\"\n    return os.getenv(\"API_KEY\")\n\n\n@pytest.mark.api\ndef test_valid_api_key():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "return os.getenv(\"API_KEY\")",
        "context": "\n\ndef get_valid_api_key():\n    \"\"\"Retrive and return api key from env variable\"\"\"\n    return os.getenv(\"API_KEY\")\n\n\n@pytest.mark.api\ndef test_valid_api_key():\n    \"\"\"Test is_valid_api_key function with a valid api key.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_valid_directory",
    "function_scope": "14-19",
    "patterns": [
      {
        "lineno": 14,
        "coloffset": 0,
        "linematch": "def test_valid_directory() -> None:",
        "context": "\nfrom chasten import constants, filesystem\n\n\ndef test_valid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "assert confirmation is True",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n\n\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that a valid directory is found.\"\"\"",
        "context": "from chasten import constants, filesystem\n\n\ndef test_valid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "directory_str = str(Path(\"./tests/\"))",
        "context": "\n\ndef test_valid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "directory = pathlib.Path(directory_str)",
        "context": "\ndef test_valid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n\n\ndef test_invalid_directory() -> None:",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "confirmation = filesystem.confirm_valid_directory(directory)",
        "context": "def test_valid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n\n\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "assert confirmation is True",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n\n\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that a valid directory is found.\"\"\"",
        "context": "from chasten import constants, filesystem\n\n\ndef test_valid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "directory_str = str(Path(\"./tests/\"))",
        "context": "\n\ndef test_valid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "directory = pathlib.Path(directory_str)",
        "context": "\ndef test_valid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n\n\ndef test_invalid_directory() -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "confirmation = filesystem.confirm_valid_directory(directory)",
        "context": "def test_valid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n\n\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "assert confirmation is True",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./tests/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n\n\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #299",
        "line": 19,
        "description": [
          "console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1360",
        "line": 16,
        "description": [
          "logger: logging.Logger = logging.getLogger()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_invalid_directory",
    "function_scope": "22-28",
    "patterns": [
      {
        "lineno": 22,
        "coloffset": 0,
        "linematch": "def test_invalid_directory() -> None:",
        "context": "    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is True\n\n\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert confirmation is False",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert filesystem.confirm_valid_directory(None) is False",
        "context": "    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that a valid directory is found.\"\"\"",
        "context": "    assert confirmation is True\n\n\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "directory_str = str(Path(\"./testsNOT/\"))",
        "context": "\n\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "directory = pathlib.Path(directory_str)",
        "context": "\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "confirmation = filesystem.confirm_valid_directory(directory)",
        "context": "def test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert confirmation is False",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert filesystem.confirm_valid_directory(None) is False",
        "context": "    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that a valid directory is found.\"\"\"",
        "context": "    assert confirmation is True\n\n\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "directory_str = str(Path(\"./testsNOT/\"))",
        "context": "\n\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "directory = pathlib.Path(directory_str)",
        "context": "\ndef test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "confirmation = filesystem.confirm_valid_directory(directory)",
        "context": "def test_invalid_directory() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert confirmation is False",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert filesystem.confirm_valid_directory(None) is False",
        "context": "    directory_str = str(Path(\"./testsNOT/\"))\n    directory = pathlib.Path(directory_str)\n    confirmation = filesystem.confirm_valid_directory(directory)\n    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_valid_file",
    "function_scope": "31-36",
    "patterns": [
      {
        "lineno": 31,
        "coloffset": 0,
        "linematch": "def test_valid_file() -> None:",
        "context": "    assert confirmation is False\n    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert confirmation is True",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n\n\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that a valid directory is found.\"\"\"",
        "context": "    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))",
        "context": "\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "this_file = pathlib.Path(file_str)",
        "context": "\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n\n\ndef test_invalid_file() -> None:",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "confirmation = filesystem.confirm_valid_file(this_file)",
        "context": "def test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n\n\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert confirmation is True",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n\n\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that a valid directory is found.\"\"\"",
        "context": "    assert filesystem.confirm_valid_directory(None) is False\n\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))",
        "context": "\n\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "this_file = pathlib.Path(file_str)",
        "context": "\ndef test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n\n\ndef test_invalid_file() -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "confirmation = filesystem.confirm_valid_file(this_file)",
        "context": "def test_valid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n\n\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert confirmation is True",
        "context": "    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystem.py\"))\n    this_file = pathlib.Path(file_str)\n    confirmation = filesystem.confirm_valid_file(this_file)\n    assert confirmation is True\n\n\ndef test_invalid_file() -> None:\n    \"\"\"Confirm that a valid directory is found.\"\"\"\n    file_str = str(Path(\"./tests\") / Path(\"test_filesystemNOT.py.py\"))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_fuzz_confirm_valid_directory_using_builds",
    "function_scope": "50-52",
    "patterns": [
      {
        "lineno": 50,
        "coloffset": 0,
        "linematch": "def test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:",
        "context": "\n\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:\n    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_directory(directory=directory)\n\n\n@given(file=strategies.builds(pathlib.Path))",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the function does not crash.\"\"\"",
        "context": "\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:\n    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_directory(directory=directory)\n\n\n@given(file=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "filesystem.confirm_valid_directory(directory=directory)",
        "context": "@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:\n    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_directory(directory=directory)\n\n\n@given(file=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_file_using_builds(file: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the function does not crash.\"\"\"",
        "context": "\n@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:\n    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_directory(directory=directory)\n\n\n@given(file=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "filesystem.confirm_valid_directory(directory=directory)",
        "context": "@given(directory=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_directory_using_builds(directory: pathlib.Path) -> None:\n    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_directory(directory=directory)\n\n\n@given(file=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_file_using_builds(file: pathlib.Path) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_fuzz_confirm_valid_file_using_builds",
    "function_scope": "57-59",
    "patterns": [
      {
        "lineno": 57,
        "coloffset": 0,
        "linematch": "def test_fuzz_confirm_valid_file_using_builds(file: pathlib.Path) -> None:",
        "context": "\n\n@given(file=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_file_using_builds(file: pathlib.Path) -> None:\n    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_file(file=file)\n\n\ndef test_create_directory_tree(tmpdir):",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the function does not crash.\"\"\"",
        "context": "\n@given(file=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_file_using_builds(file: pathlib.Path) -> None:\n    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_file(file=file)\n\n\ndef test_create_directory_tree(tmpdir):\n    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 4,
        "linematch": "filesystem.confirm_valid_file(file=file)",
        "context": "@given(file=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_file_using_builds(file: pathlib.Path) -> None:\n    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_file(file=file)\n\n\ndef test_create_directory_tree(tmpdir):\n    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"\n    # create a temporary directory",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the function does not crash.\"\"\"",
        "context": "\n@given(file=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_file_using_builds(file: pathlib.Path) -> None:\n    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_file(file=file)\n\n\ndef test_create_directory_tree(tmpdir):\n    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 4,
        "linematch": "filesystem.confirm_valid_file(file=file)",
        "context": "@given(file=strategies.builds(pathlib.Path))\n@pytest.mark.fuzz\ndef test_fuzz_confirm_valid_file_using_builds(file: pathlib.Path) -> None:\n    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_file(file=file)\n\n\ndef test_create_directory_tree(tmpdir):\n    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"\n    # create a temporary directory",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_create_directory_tree",
    "function_scope": "62-85",
    "patterns": [
      {
        "lineno": 62,
        "coloffset": 0,
        "linematch": "def test_create_directory_tree(tmpdir):",
        "context": "    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_file(file=file)\n\n\ndef test_create_directory_tree(tmpdir):\n    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"\n    # create a temporary directory\n    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 62,
        "coloffset": 0,
        "linematch": "def test_create_directory_tree(tmpdir):",
        "context": "    \"\"\"Confirm that the function does not crash.\"\"\"\n    filesystem.confirm_valid_file(file=file)\n\n\ndef test_create_directory_tree(tmpdir):\n    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"\n    # create a temporary directory\n    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 74,
        "coloffset": 4,
        "linematch": "assert isinstance(tree, Tree)",
        "context": "    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 76,
        "coloffset": 4,
        "linematch": "assert tree.label == f\":open_file_folder: {tmp_dir.name}\"",
        "context": "    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 80,
        "coloffset": 4,
        "linematch": "assert set(dirs) == {",
        "context": "    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {\n        f\":page_facing_up: {p.name}\" for p in tmp_dir.iterdir() if p.is_file()\n    }",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "assert set(files) == {",
        "context": "    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {\n        f\":page_facing_up: {p.name}\" for p in tmp_dir.iterdir() if p.is_file()\n    }\n\n\n@given(directory=strategies.builds(pathlib.Path))",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that creation of the textual directory tree works.\"\"\"",
        "context": "    filesystem.confirm_valid_file(file=file)\n\n\ndef test_create_directory_tree(tmpdir):\n    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"\n    # create a temporary directory\n    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 65,
        "coloffset": 4,
        "linematch": "tmp_dir = pathlib.Path(tmpdir)",
        "context": "\ndef test_create_directory_tree(tmpdir):\n    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"\n    # create a temporary directory\n    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 67,
        "coloffset": 4,
        "linematch": "(tmp_dir / \"file1.txt\").touch()",
        "context": "    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"\n    # create a temporary directory\n    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 68,
        "coloffset": 4,
        "linematch": "(tmp_dir / \"subdir1\").mkdir()",
        "context": "    # create a temporary directory\n    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 69,
        "coloffset": 4,
        "linematch": "(tmp_dir / \"subdir2\").mkdir()",
        "context": "    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "(tmp_dir / \"subdir2\" / \"file2.txt\").touch()",
        "context": "    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 72,
        "coloffset": 4,
        "linematch": "tree = filesystem.create_directory_tree_visualization(tmp_dir)",
        "context": "    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 74,
        "coloffset": 4,
        "linematch": "assert isinstance(tree, Tree)",
        "context": "    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 76,
        "coloffset": 4,
        "linematch": "assert tree.label == f\":open_file_folder: {tmp_dir.name}\"",
        "context": "    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore",
        "context": "    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 79,
        "coloffset": 4,
        "linematch": "files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore",
        "context": "    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {\n        f\":page_facing_up: {p.name}\" for p in tmp_dir.iterdir() if p.is_file()",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 80,
        "coloffset": 4,
        "linematch": "assert set(dirs) == {",
        "context": "    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {\n        f\":page_facing_up: {p.name}\" for p in tmp_dir.iterdir() if p.is_file()\n    }",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "assert set(files) == {",
        "context": "    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {\n        f\":page_facing_up: {p.name}\" for p in tmp_dir.iterdir() if p.is_file()\n    }\n\n\n@given(directory=strategies.builds(pathlib.Path))",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that creation of the textual directory tree works.\"\"\"",
        "context": "    filesystem.confirm_valid_file(file=file)\n\n\ndef test_create_directory_tree(tmpdir):\n    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"\n    # create a temporary directory\n    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 65,
        "coloffset": 4,
        "linematch": "tmp_dir = pathlib.Path(tmpdir)",
        "context": "\ndef test_create_directory_tree(tmpdir):\n    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"\n    # create a temporary directory\n    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 67,
        "coloffset": 4,
        "linematch": "(tmp_dir / \"file1.txt\").touch()",
        "context": "    \"\"\"Confirm that creation of the textual directory tree works.\"\"\"\n    # create a temporary directory\n    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 68,
        "coloffset": 4,
        "linematch": "(tmp_dir / \"subdir1\").mkdir()",
        "context": "    # create a temporary directory\n    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 69,
        "coloffset": 4,
        "linematch": "(tmp_dir / \"subdir2\").mkdir()",
        "context": "    tmp_dir = pathlib.Path(tmpdir)\n    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "(tmp_dir / \"subdir2\" / \"file2.txt\").touch()",
        "context": "    # create some files and directories\n    (tmp_dir / \"file1.txt\").touch()\n    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 72,
        "coloffset": 4,
        "linematch": "tree = filesystem.create_directory_tree_visualization(tmp_dir)",
        "context": "    (tmp_dir / \"subdir1\").mkdir()\n    (tmp_dir / \"subdir2\").mkdir()\n    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 74,
        "coloffset": 4,
        "linematch": "assert isinstance(tree, Tree)",
        "context": "    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 76,
        "coloffset": 4,
        "linematch": "assert tree.label == f\":open_file_folder: {tmp_dir.name}\"",
        "context": "    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore",
        "context": "    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 79,
        "coloffset": 4,
        "linematch": "files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore",
        "context": "    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {\n        f\":page_facing_up: {p.name}\" for p in tmp_dir.iterdir() if p.is_file()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 80,
        "coloffset": 4,
        "linematch": "assert set(dirs) == {",
        "context": "    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {\n        f\":page_facing_up: {p.name}\" for p in tmp_dir.iterdir() if p.is_file()\n    }",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "assert set(files) == {",
        "context": "    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {\n        f\":page_facing_up: {p.name}\" for p in tmp_dir.iterdir() if p.is_file()\n    }\n\n\n@given(directory=strategies.builds(pathlib.Path))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 74,
        "coloffset": 4,
        "linematch": "assert isinstance(tree, Tree)",
        "context": "    (tmp_dir / \"subdir2\" / \"file2.txt\").touch()\n    # call the function under test\n    tree = filesystem.create_directory_tree_visualization(tmp_dir)\n    # confirm that the output is a rich tree object\n    assert isinstance(tree, Tree)\n    # confirm the directory name in root node\n    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 80,
        "coloffset": 4,
        "linematch": "assert set(dirs) == {",
        "context": "    assert tree.label == f\":open_file_folder: {tmp_dir.name}\"\n    # confirm that the child nodes contain the expected dirs and files\n    dirs = [node.label for node in tree.children if \":open_file_folder:\" in node.label]  # type: ignore\n    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {\n        f\":page_facing_up: {p.name}\" for p in tmp_dir.iterdir() if p.is_file()\n    }",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "assert set(files) == {",
        "context": "    files = [node.label for node in tree.children if \":page_facing_up:\" in node.label]  # type: ignore\n    assert set(dirs) == {\n        f\":open_file_folder: {p.name}\" for p in tmp_dir.iterdir() if p.is_dir()\n    }\n    assert set(files) == {\n        f\":page_facing_up: {p.name}\" for p in tmp_dir.iterdir() if p.is_file()\n    }\n\n\n@given(directory=strategies.builds(pathlib.Path))",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_create_config_dir_does_not_exist",
    "function_scope": "111-120",
    "patterns": [
      {
        "lineno": 111,
        "coloffset": 0,
        "linematch": "def test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):",
        "context": "    assert set(files) == set(p.name for p in directory.iterdir() if p.is_file())\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 119,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_throw_exception(",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 120,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_throw_exception(\n    mock_user_config_dir, tmp_path",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"",
        "context": "\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 116,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 117,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 118,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n\n\n@patch(\"chasten.configuration.user_config_dir\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 119,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_throw_exception(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 120,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_throw_exception(\n    mock_user_config_dir, tmp_path",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"",
        "context": "\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_does_not_exist(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 116,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 117,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 118,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n\n\n@patch(\"chasten.configuration.user_config_dir\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 119,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_throw_exception(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 120,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_throw_exception(\n    mock_user_config_dir, tmp_path",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_create_config_dir_already_exist_throw_exception",
    "function_scope": "124-138",
    "patterns": [
      {
        "lineno": 124,
        "coloffset": 0,
        "linematch": "def test_create_config_dir_already_exist_throw_exception(",
        "context": "    assert dir_path.exists()\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_throw_exception(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm not possible to create the user configuration directory when it does exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 134,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 135,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 127,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm not possible to create the user configuration directory when it does exist.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_throw_exception(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm not possible to create the user configuration directory when it does exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 131,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm not possible to create the user configuration directory when it does exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 132,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 133,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 134,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 135,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 137,
        "coloffset": 4,
        "linematch": "with pytest.raises(FileExistsError):",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_no_exception_when_no_force(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 127,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm not possible to create the user configuration directory when it does exist.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_throw_exception(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm not possible to create the user configuration directory when it does exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 131,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm not possible to create the user configuration directory when it does exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 132,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 133,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 134,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 135,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 137,
        "coloffset": 4,
        "linematch": "with pytest.raises(FileExistsError):",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_no_exception_when_no_force(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1368",
        "line": 132,
        "description": [
          "    if len(file_name) > max_length:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1369",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1370",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1371",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1372",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1373",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_create_config_dir_already_exist_no_exception_when_no_force",
    "function_scope": "142-156",
    "patterns": [
      {
        "lineno": 142,
        "coloffset": 0,
        "linematch": "def test_create_config_dir_already_exist_no_exception_when_no_force(",
        "context": "        filesystem.create_configuration_directory(force=False)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_no_exception_when_no_force(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 152,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 153,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 145,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_no_exception_when_no_force(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 149,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 150,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 151,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 152,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 153,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 155,
        "coloffset": 4,
        "linematch": "with pytest.raises(FileExistsError):",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_no_exception_when_force(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 145,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_no_exception_when_no_force(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 149,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 150,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 151,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 152,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 153,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 155,
        "coloffset": 4,
        "linematch": "with pytest.raises(FileExistsError):",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it fails if called again without force\n    with pytest.raises(FileExistsError):\n        filesystem.create_configuration_directory(force=False)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_no_exception_when_force(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #305",
        "line": 143,
        "description": [
          "    grouped_files = group_files_by_directory(container)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #306",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #307",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1374",
        "line": 148,
        "description": [
          "        console.print(f\"{small_bullet_unicode} Directory: {directory}\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1375",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1376",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1377",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1378",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1379",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1380",
        "line": 156,
        "description": [
          "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_create_config_dir_already_exist_no_exception_when_force",
    "function_scope": "160-173",
    "patterns": [
      {
        "lineno": 160,
        "coloffset": 0,
        "linematch": "def test_create_config_dir_already_exist_no_exception_when_force(",
        "context": "        filesystem.create_configuration_directory(force=False)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_no_exception_when_force(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 170,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 171,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n\n\ndef test_detect_configuration_with_input_config_directory(tmp_path):",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 163,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_no_exception_when_force(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 167,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 168,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 169,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 170,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 171,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n\n\ndef test_detect_configuration_with_input_config_directory(tmp_path):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 173,
        "coloffset": 4,
        "linematch": "filesystem.create_configuration_directory(force=True)",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n\n\ndef test_detect_configuration_with_input_config_directory(tmp_path):\n    \"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"\n    # detecting a configuration directory should happen with",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 163,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_config_dir_already_exist_no_exception_when_force(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 167,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm possible to create the user configuration directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 168,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 169,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 170,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 171,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n\n\ndef test_detect_configuration_with_input_config_directory(tmp_path):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 173,
        "coloffset": 4,
        "linematch": "filesystem.create_configuration_directory(force=True)",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n\n\ndef test_detect_configuration_with_input_config_directory(tmp_path):\n    \"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"\n    # detecting a configuration directory should happen with",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1381",
        "line": 160,
        "description": [
          "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1382",
        "line": 169,
        "description": [
          "    if not verbose:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1383",
        "line": 171,
        "description": [
          "    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_detect_configuration_with_input_config_directory",
    "function_scope": "176-182",
    "patterns": [
      {
        "lineno": 176,
        "coloffset": 0,
        "linematch": "def test_detect_configuration_with_input_config_directory(tmp_path):",
        "context": "    # confirm that it does not fail if called again with force\n    filesystem.create_configuration_directory(force=True)\n\n\ndef test_detect_configuration_with_input_config_directory(tmp_path):\n    \"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"\n    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 182,
        "coloffset": 4,
        "linematch": "assert filesystem.detect_configuration(config) == str(config)",
        "context": "    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()\n    assert filesystem.detect_configuration(config) == str(config)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_detect_configuration_with_input_config_directory_use_default(\n    mock_user_config_dir, tmp_path",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 177,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"",
        "context": "    filesystem.create_configuration_directory(force=True)\n\n\ndef test_detect_configuration_with_input_config_directory(tmp_path):\n    \"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"\n    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()\n    assert filesystem.detect_configuration(config) == str(config)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 180,
        "coloffset": 4,
        "linematch": "config = tmp_path / \"config\"",
        "context": "def test_detect_configuration_with_input_config_directory(tmp_path):\n    \"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"\n    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()\n    assert filesystem.detect_configuration(config) == str(config)\n\n\n@patch(\"chasten.configuration.user_config_dir\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 181,
        "coloffset": 4,
        "linematch": "config.mkdir()",
        "context": "    \"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"\n    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()\n    assert filesystem.detect_configuration(config) == str(config)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_detect_configuration_with_input_config_directory_use_default(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 182,
        "coloffset": 4,
        "linematch": "assert filesystem.detect_configuration(config) == str(config)",
        "context": "    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()\n    assert filesystem.detect_configuration(config) == str(config)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_detect_configuration_with_input_config_directory_use_default(\n    mock_user_config_dir, tmp_path",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 177,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"",
        "context": "    filesystem.create_configuration_directory(force=True)\n\n\ndef test_detect_configuration_with_input_config_directory(tmp_path):\n    \"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"\n    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()\n    assert filesystem.detect_configuration(config) == str(config)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 180,
        "coloffset": 4,
        "linematch": "config = tmp_path / \"config\"",
        "context": "def test_detect_configuration_with_input_config_directory(tmp_path):\n    \"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"\n    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()\n    assert filesystem.detect_configuration(config) == str(config)\n\n\n@patch(\"chasten.configuration.user_config_dir\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 181,
        "coloffset": 4,
        "linematch": "config.mkdir()",
        "context": "    \"\"\"Confirm that it is possible to detect the configuration directory when it exists.\"\"\"\n    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()\n    assert filesystem.detect_configuration(config) == str(config)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_detect_configuration_with_input_config_directory_use_default(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 182,
        "coloffset": 4,
        "linematch": "assert filesystem.detect_configuration(config) == str(config)",
        "context": "    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()\n    assert filesystem.detect_configuration(config) == str(config)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_detect_configuration_with_input_config_directory_use_default(\n    mock_user_config_dir, tmp_path",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 182,
        "coloffset": 4,
        "linematch": "assert filesystem.detect_configuration(config) == str(config)",
        "context": "    # detecting a configuration directory should happen with\n    # the provided configuration directory over the platform-specific one\n    config = tmp_path / \"config\"\n    config.mkdir()\n    assert filesystem.detect_configuration(config) == str(config)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_detect_configuration_with_input_config_directory_use_default(\n    mock_user_config_dir, tmp_path",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #308",
        "line": 176,
        "description": [
          "        current_xpath_pattern = current_check.pattern"
        ],
        "failure": []
      },
      {
        "name": "Mutant #309",
        "line": 182,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1385",
        "line": 177,
        "description": [
          "        console.print(\"\\n:tada: Check:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_detect_configuration_with_input_config_directory_use_default",
    "function_scope": "186-199",
    "patterns": [
      {
        "lineno": 186,
        "coloffset": 0,
        "linematch": "def test_detect_configuration_with_input_config_directory_use_default(",
        "context": "    assert filesystem.detect_configuration(config) == str(config)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_detect_configuration_with_input_config_directory_use_default(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm that it is possible to detect the configuration directory when none provided.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 196,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 197,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n\n@patch(\"chasten.configuration.user_config_dir\")",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 199,
        "coloffset": 4,
        "linematch": "assert detected_directory == str(dir_path)",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_main_configuration_file(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 189,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to detect the configuration directory when none provided.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_detect_configuration_with_input_config_directory_use_default(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm that it is possible to detect the configuration directory when none provided.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 193,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm that it is possible to detect the configuration directory when none provided.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 194,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 195,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 196,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 197,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n\n@patch(\"chasten.configuration.user_config_dir\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 198,
        "coloffset": 4,
        "linematch": "detected_directory = filesystem.detect_configuration(None)",
        "context": "    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_main_configuration_file(mock_user_config_dir, tmp_path):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 199,
        "coloffset": 4,
        "linematch": "assert detected_directory == str(dir_path)",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_main_configuration_file(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 189,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to detect the configuration directory when none provided.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_detect_configuration_with_input_config_directory_use_default(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm that it is possible to detect the configuration directory when none provided.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 193,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm that it is possible to detect the configuration directory when none provided.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 194,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 195,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 196,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 197,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n\n@patch(\"chasten.configuration.user_config_dir\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 198,
        "coloffset": 4,
        "linematch": "detected_directory = filesystem.detect_configuration(None)",
        "context": "    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_main_configuration_file(mock_user_config_dir, tmp_path):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 199,
        "coloffset": 4,
        "linematch": "assert detected_directory == str(dir_path)",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_main_configuration_file(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 199,
        "coloffset": 4,
        "linematch": "assert detected_directory == str(dir_path)",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    detected_directory = filesystem.detect_configuration(None)\n    assert detected_directory == str(dir_path)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_main_configuration_file(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #310",
        "line": 187,
        "description": [
          "        min_count = current_check.min"
        ],
        "failure": []
      },
      {
        "name": "Mutant #311",
        "line": 188,
        "description": [
          "        max_count = current_check.max"
        ],
        "failure": []
      },
      {
        "name": "Mutant #312",
        "line": 189,
        "description": [
          "        min_label = checks.create_attribute_label(min_count, constants.checks.Check_Min)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #313",
        "line": 190,
        "description": [
          "        max_label = checks.create_attribute_label(max_count, constants.checks.Check_Max)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #314",
        "line": 193,
        "description": [
          "        check_id = current_check.id"
        ],
        "failure": []
      },
      {
        "name": "Mutant #315",
        "line": 194,
        "description": [
          "        check_id_label = checks.create_attribute_label(check_id, constants.checks.Check_Id)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #316",
        "line": 195,
        "description": [
          "        check_name = current_check.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #317",
        "line": 196,
        "description": [
          "        check_name_label = checks.create_attribute_label(check_name, constants.checks.Check_Name)  # type: ignore"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_create_main_configuration_file",
    "function_scope": "203-223",
    "patterns": [
      {
        "lineno": 203,
        "coloffset": 0,
        "linematch": "def test_create_main_configuration_file(mock_user_config_dir, tmp_path):",
        "context": "    assert detected_directory == str(dir_path)\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_main_configuration_file(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 211,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 212,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 218,
        "coloffset": 4,
        "linematch": "assert main_configuation_file.exists()",
        "context": "    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert (\n        main_configuation_file.read_text()\n        == filesystem.CONFIGURATION_FILE_DEFAULT_CONTENTS\n    )",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 220,
        "coloffset": 4,
        "linematch": "assert (",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert (\n        main_configuation_file.read_text()\n        == filesystem.CONFIGURATION_FILE_DEFAULT_CONTENTS\n    )\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 204,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"",
        "context": "\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_main_configuration_file(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 208,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 209,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 210,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 211,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 212,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 214,
        "coloffset": 4,
        "linematch": "filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 217,
        "coloffset": 4,
        "linematch": "main_configuation_file = dir_path / \"config.yml\"",
        "context": "    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert (\n        main_configuation_file.read_text()\n        == filesystem.CONFIGURATION_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 218,
        "coloffset": 4,
        "linematch": "assert main_configuation_file.exists()",
        "context": "    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert (\n        main_configuation_file.read_text()\n        == filesystem.CONFIGURATION_FILE_DEFAULT_CONTENTS\n    )",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 220,
        "coloffset": 4,
        "linematch": "assert (",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert (\n        main_configuation_file.read_text()\n        == filesystem.CONFIGURATION_FILE_DEFAULT_CONTENTS\n    )\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 204,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"",
        "context": "\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_create_main_configuration_file(mock_user_config_dir, tmp_path):\n    \"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 208,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm that it is possible to create the main configuration file if it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 209,
        "coloffset": 4,
        "linematch": "dir_path = tmp_path / \".chasten\"",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 210,
        "coloffset": 4,
        "linematch": "result = filesystem.create_configuration_directory()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 211,
        "coloffset": 4,
        "linematch": "assert result == dir_path",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 212,
        "coloffset": 4,
        "linematch": "assert dir_path.exists()",
        "context": "    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    dir_path = tmp_path / \".chasten\"\n    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 214,
        "coloffset": 4,
        "linematch": "filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore",
        "context": "    result = filesystem.create_configuration_directory()\n    assert result == dir_path\n    assert dir_path.exists()\n    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 217,
        "coloffset": 4,
        "linematch": "main_configuation_file = dir_path / \"config.yml\"",
        "context": "    # create the main configuration file\n    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert (\n        main_configuation_file.read_text()\n        == filesystem.CONFIGURATION_FILE_DEFAULT_CONTENTS",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 218,
        "coloffset": 4,
        "linematch": "assert main_configuation_file.exists()",
        "context": "    filesystem.create_configuration_file(config=None, config_file_name=constants.filesystem.Main_Configuration_File)  # type: ignore\n    # create the path to the main configuration file\n    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert (\n        main_configuation_file.read_text()\n        == filesystem.CONFIGURATION_FILE_DEFAULT_CONTENTS\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 220,
        "coloffset": 4,
        "linematch": "assert (",
        "context": "    # and then assert that it exists and has correct content\n    main_configuation_file = dir_path / \"config.yml\"\n    assert main_configuation_file.exists()\n    # confirm that the configuration file has correct text\n    assert (\n        main_configuation_file.read_text()\n        == filesystem.CONFIGURATION_FILE_DEFAULT_CONTENTS\n    )\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #319",
        "line": 223,
        "description": [
          "                    position_end = current_match.position.lineno"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1386",
        "line": 205,
        "description": [
          "                expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1387",
        "line": 206,
        "description": [
          "                title=f\"{combined_attribute_label}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1388",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1389",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1390",
        "line": 214,
        "description": [
          "                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1391",
        "line": 221,
        "description": [
          "                    opt_print_log(verbose, label=\":sparkles: Matching source code:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_filter_matches",
    "function_scope": "31-37",
    "patterns": [
      {
        "lineno": 31,
        "coloffset": 0,
        "linematch": "def test_filter_matches(match_list, data_type):",
        "context": "    ),\n    data_type=st.just(pyastgrepsearch.Match),\n)\n@pytest.mark.fuzz\ndef test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 31,
        "coloffset": 0,
        "linematch": "def test_filter_matches(match_list, data_type):",
        "context": "    ),\n    data_type=st.just(pyastgrepsearch.Match),\n)\n@pytest.mark.fuzz\ndef test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)",
        "context": "@pytest.mark.fuzz\ndef test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "assert set(filtered) == set(",
        "context": "def test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )\n\n\n@given(match_list=st.lists(st.integers()))",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"",
        "context": "    data_type=st.just(pyastgrepsearch.Match),\n)\n@pytest.mark.fuzz\ndef test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "filtered, _ = process.filter_matches(match_list, data_type)",
        "context": ")\n@pytest.mark.fuzz\ndef test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)",
        "context": "@pytest.mark.fuzz\ndef test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "assert set(filtered) == set(",
        "context": "def test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )\n\n\n@given(match_list=st.lists(st.integers()))",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"",
        "context": "    data_type=st.just(pyastgrepsearch.Match),\n)\n@pytest.mark.fuzz\ndef test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "filtered, _ = process.filter_matches(match_list, data_type)",
        "context": ")\n@pytest.mark.fuzz\ndef test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)",
        "context": "@pytest.mark.fuzz\ndef test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "assert set(filtered) == set(",
        "context": "def test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )\n\n\n@given(match_list=st.lists(st.integers()))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)",
        "context": "@pytest.mark.fuzz\ndef test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )\n\n",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "assert set(filtered) == set(",
        "context": "def test_filter_matches(match_list, data_type):\n    \"\"\"Use Hypothesis to confirm that filtering always gets the Match objects.\"\"\"\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert all(isinstance(m, pyastgrepsearch.Match) for m in filtered)\n    assert set(filtered) == set(\n        m for m in match_list if isinstance(m, pyastgrepsearch.Match)\n    )\n\n\n@given(match_list=st.lists(st.integers()))",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_filter_matches_no_matches",
    "function_scope": "42-46",
    "patterns": [
      {
        "lineno": 42,
        "coloffset": 0,
        "linematch": "def test_filter_matches_no_matches(match_list):",
        "context": "\n\n@given(match_list=st.lists(st.integers()))\n@pytest.mark.fuzz\ndef test_filter_matches_no_matches(match_list):\n    \"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"\n    data_type = pyastgrepsearch.Match\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert filtered == []\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert filtered == []",
        "context": "def test_filter_matches_no_matches(match_list):\n    \"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"\n    data_type = pyastgrepsearch.Match\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert filtered == []\n\n\n@given(match_list=st.lists(st.integers()), data_type=st.just(int))\n@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"",
        "context": "\n@given(match_list=st.lists(st.integers()))\n@pytest.mark.fuzz\ndef test_filter_matches_no_matches(match_list):\n    \"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"\n    data_type = pyastgrepsearch.Match\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert filtered == []\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "data_type = pyastgrepsearch.Match",
        "context": "@given(match_list=st.lists(st.integers()))\n@pytest.mark.fuzz\ndef test_filter_matches_no_matches(match_list):\n    \"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"\n    data_type = pyastgrepsearch.Match\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert filtered == []\n\n\n@given(match_list=st.lists(st.integers()), data_type=st.just(int))",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "filtered, _ = process.filter_matches(match_list, data_type)",
        "context": "@pytest.mark.fuzz\ndef test_filter_matches_no_matches(match_list):\n    \"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"\n    data_type = pyastgrepsearch.Match\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert filtered == []\n\n\n@given(match_list=st.lists(st.integers()), data_type=st.just(int))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert filtered == []",
        "context": "def test_filter_matches_no_matches(match_list):\n    \"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"\n    data_type = pyastgrepsearch.Match\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert filtered == []\n\n\n@given(match_list=st.lists(st.integers()), data_type=st.just(int))\n@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"",
        "context": "\n@given(match_list=st.lists(st.integers()))\n@pytest.mark.fuzz\ndef test_filter_matches_no_matches(match_list):\n    \"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"\n    data_type = pyastgrepsearch.Match\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert filtered == []\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "data_type = pyastgrepsearch.Match",
        "context": "@given(match_list=st.lists(st.integers()))\n@pytest.mark.fuzz\ndef test_filter_matches_no_matches(match_list):\n    \"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"\n    data_type = pyastgrepsearch.Match\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert filtered == []\n\n\n@given(match_list=st.lists(st.integers()), data_type=st.just(int))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "filtered, _ = process.filter_matches(match_list, data_type)",
        "context": "@pytest.mark.fuzz\ndef test_filter_matches_no_matches(match_list):\n    \"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"\n    data_type = pyastgrepsearch.Match\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert filtered == []\n\n\n@given(match_list=st.lists(st.integers()), data_type=st.just(int))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert filtered == []",
        "context": "def test_filter_matches_no_matches(match_list):\n    \"\"\"Use Hypothesis to confirm that filtering does not select a Match when there are none.\"\"\"\n    data_type = pyastgrepsearch.Match\n    filtered, _ = process.filter_matches(match_list, data_type)\n    assert filtered == []\n\n\n@given(match_list=st.lists(st.integers()), data_type=st.just(int))\n@pytest.mark.fuzz\ndef test_filter_matches_only_int_matches(match_list, data_type):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_validate_config_valid_realistic",
    "function_scope": "10-19",
    "patterns": [
      {
        "lineno": 10,
        "coloffset": 0,
        "linematch": "def test_validate_config_valid_realistic():",
        "context": "\nfrom chasten.validate import JSON_SCHEMA_CONFIG, validate_configuration\n\n\ndef test_validate_config_valid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {\n        \"chasten\": {\n            \"checks-file\": [\"checks.yml\"],\n        }",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "assert is_valid",
        "context": "            \"checks-file\": [\"checks.yml\"],\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert is_valid\n    assert not errors\n\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "assert not errors",
        "context": "        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert is_valid\n    assert not errors\n\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"",
        "context": "from chasten.validate import JSON_SCHEMA_CONFIG, validate_configuration\n\n\ndef test_validate_config_valid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {\n        \"chasten\": {\n            \"checks-file\": [\"checks.yml\"],\n        }\n    }",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 12,
        "coloffset": 4,
        "linematch": "valid_config_correct_schema = {",
        "context": "\n\ndef test_validate_config_valid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {\n        \"chasten\": {\n            \"checks-file\": [\"checks.yml\"],\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "is_valid, errors = validate_configuration(valid_config_correct_schema)",
        "context": "        \"chasten\": {\n            \"checks-file\": [\"checks.yml\"],\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert is_valid\n    assert not errors\n\n\ndef test_validate_config_invalid_realistic():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "assert is_valid",
        "context": "            \"checks-file\": [\"checks.yml\"],\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert is_valid\n    assert not errors\n\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "assert not errors",
        "context": "        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert is_valid\n    assert not errors\n\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"",
        "context": "from chasten.validate import JSON_SCHEMA_CONFIG, validate_configuration\n\n\ndef test_validate_config_valid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {\n        \"chasten\": {\n            \"checks-file\": [\"checks.yml\"],\n        }\n    }",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 12,
        "coloffset": 4,
        "linematch": "valid_config_correct_schema = {",
        "context": "\n\ndef test_validate_config_valid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {\n        \"chasten\": {\n            \"checks-file\": [\"checks.yml\"],\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "is_valid, errors = validate_configuration(valid_config_correct_schema)",
        "context": "        \"chasten\": {\n            \"checks-file\": [\"checks.yml\"],\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert is_valid\n    assert not errors\n\n\ndef test_validate_config_invalid_realistic():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "assert is_valid",
        "context": "            \"checks-file\": [\"checks.yml\"],\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert is_valid\n    assert not errors\n\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "assert not errors",
        "context": "        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert is_valid\n    assert not errors\n\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #299",
        "line": 19,
        "description": [
          "console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1360",
        "line": 16,
        "description": [
          "logger: logging.Logger = logging.getLogger()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_validate_config_invalid_realistic",
    "function_scope": "22-32",
    "patterns": [
      {
        "lineno": 22,
        "coloffset": 0,
        "linematch": "def test_validate_config_invalid_realistic():",
        "context": "    assert is_valid\n    assert not errors\n\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {\n        \"chasten\": {\n            \"checks-file\": \"checks.yml\",\n        }",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "assert not is_valid",
        "context": "            \"checks-file\": \"checks.yml\",\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n\n@given(",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "assert errors",
        "context": "        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n\n@given(\n    config=strategies.fixed_dictionaries({\"chasten\": strategies.fixed_dictionaries({})})",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert \"is not of type\" in errors",
        "context": "    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n\n@given(\n    config=strategies.fixed_dictionaries({\"chasten\": strategies.fixed_dictionaries({})})\n)",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"",
        "context": "    assert not errors\n\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {\n        \"chasten\": {\n            \"checks-file\": \"checks.yml\",\n        }\n    }",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "valid_config_correct_schema = {",
        "context": "\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {\n        \"chasten\": {\n            \"checks-file\": \"checks.yml\",\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "is_valid, errors = validate_configuration(valid_config_correct_schema)",
        "context": "        \"chasten\": {\n            \"checks-file\": \"checks.yml\",\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "assert not is_valid",
        "context": "            \"checks-file\": \"checks.yml\",\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n\n@given(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "assert errors",
        "context": "        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n\n@given(\n    config=strategies.fixed_dictionaries({\"chasten\": strategies.fixed_dictionaries({})})",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert \"is not of type\" in errors",
        "context": "    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n\n@given(\n    config=strategies.fixed_dictionaries({\"chasten\": strategies.fixed_dictionaries({})})\n)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"",
        "context": "    assert not errors\n\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {\n        \"chasten\": {\n            \"checks-file\": \"checks.yml\",\n        }\n    }",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "valid_config_correct_schema = {",
        "context": "\n\ndef test_validate_config_invalid_realistic():\n    \"\"\"Confirm that validation with built-in schema works for a realistic valid example.\"\"\"\n    valid_config_correct_schema = {\n        \"chasten\": {\n            \"checks-file\": \"checks.yml\",\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "is_valid, errors = validate_configuration(valid_config_correct_schema)",
        "context": "        \"chasten\": {\n            \"checks-file\": \"checks.yml\",\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "assert not is_valid",
        "context": "            \"checks-file\": \"checks.yml\",\n        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n\n@given(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "assert errors",
        "context": "        }\n    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n\n@given(\n    config=strategies.fixed_dictionaries({\"chasten\": strategies.fixed_dictionaries({})})",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert \"is not of type\" in errors",
        "context": "    }\n    is_valid, errors = validate_configuration(valid_config_correct_schema)\n    assert not is_valid\n    assert errors\n    assert \"is not of type\" in errors\n\n\n@given(\n    config=strategies.fixed_dictionaries({\"chasten\": strategies.fixed_dictionaries({})})\n)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_validate_empty_config",
    "function_scope": "39-43",
    "patterns": [
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def test_validate_empty_config(config):",
        "context": "@given(\n    config=strategies.fixed_dictionaries({\"chasten\": strategies.fixed_dictionaries({})})\n)\n@pytest.mark.fuzz\ndef test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "assert is_valid",
        "context": "@pytest.mark.fuzz\ndef test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n\n\n@given(from_schema(JSON_SCHEMA_CONFIG))\n@settings(suppress_health_check=[HealthCheck.too_slow])",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "assert not errors",
        "context": "def test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n\n\n@given(from_schema(JSON_SCHEMA_CONFIG))\n@settings(suppress_health_check=[HealthCheck.too_slow])\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"",
        "context": "    config=strategies.fixed_dictionaries({\"chasten\": strategies.fixed_dictionaries({})})\n)\n@pytest.mark.fuzz\ndef test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "is_valid, errors = validate_configuration(config)",
        "context": ")\n@pytest.mark.fuzz\ndef test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n\n\n@given(from_schema(JSON_SCHEMA_CONFIG))",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "assert is_valid",
        "context": "@pytest.mark.fuzz\ndef test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n\n\n@given(from_schema(JSON_SCHEMA_CONFIG))\n@settings(suppress_health_check=[HealthCheck.too_slow])",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "assert not errors",
        "context": "def test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n\n\n@given(from_schema(JSON_SCHEMA_CONFIG))\n@settings(suppress_health_check=[HealthCheck.too_slow])\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"",
        "context": "    config=strategies.fixed_dictionaries({\"chasten\": strategies.fixed_dictionaries({})})\n)\n@pytest.mark.fuzz\ndef test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "is_valid, errors = validate_configuration(config)",
        "context": ")\n@pytest.mark.fuzz\ndef test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n\n\n@given(from_schema(JSON_SCHEMA_CONFIG))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "assert is_valid",
        "context": "@pytest.mark.fuzz\ndef test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n\n\n@given(from_schema(JSON_SCHEMA_CONFIG))\n@settings(suppress_health_check=[HealthCheck.too_slow])",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "assert not errors",
        "context": "def test_validate_empty_config(config):\n    \"\"\"Use Hypothesis to confirm that an empty configuration will validate.\"\"\"\n    is_valid, errors = validate_configuration(config)\n    assert is_valid\n    assert not errors\n\n\n@given(from_schema(JSON_SCHEMA_CONFIG))\n@settings(suppress_health_check=[HealthCheck.too_slow])\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_extract_min_max",
    "function_scope": "27-32",
    "patterns": [
      {
        "lineno": 27,
        "coloffset": 0,
        "linematch": "def test_extract_min_max():",
        "context": "    },\n}\n\n\ndef test_extract_min_max():\n    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "assert min_count == 1",
        "context": "def test_extract_min_max():\n    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert max_count == 10  # noqa",
        "context": "    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"",
        "context": "}\n\n\ndef test_extract_min_max():\n    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}",
        "context": "\n\ndef test_extract_min_max():\n    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)",
        "context": "\ndef test_extract_min_max():\n    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n\n\ndef test_extract_max():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "assert min_count == 1",
        "context": "def test_extract_min_max():\n    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert max_count == 10  # noqa",
        "context": "    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"",
        "context": "}\n\n\ndef test_extract_min_max():\n    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}",
        "context": "\n\ndef test_extract_min_max():\n    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)",
        "context": "\ndef test_extract_min_max():\n    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n\n\ndef test_extract_max():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "assert min_count == 1",
        "context": "def test_extract_min_max():\n    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert max_count == 10  # noqa",
        "context": "    \"\"\"Confirm that it is possible to extract both values from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"min\": 1, \"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count == 10  # noqa\n\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_extract_max",
    "function_scope": "35-40",
    "patterns": [
      {
        "lineno": 35,
        "coloffset": 0,
        "linematch": "def test_extract_max():",
        "context": "    assert min_count == 1\n    assert max_count == 10  # noqa\n\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "assert min_count is None",
        "context": "def test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "assert max_count == 10  # noqa",
        "context": "    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"",
        "context": "    assert max_count == 10  # noqa\n\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "check = {\"name\": \"test\", \"count\": {\"max\": 10}}",
        "context": "\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 38,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)",
        "context": "\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n\n\ndef test_extract_min():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "assert min_count is None",
        "context": "def test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "assert max_count == 10  # noqa",
        "context": "    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"",
        "context": "    assert max_count == 10  # noqa\n\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "check = {\"name\": \"test\", \"count\": {\"max\": 10}}",
        "context": "\n\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 38,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)",
        "context": "\ndef test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n\n\ndef test_extract_min():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "assert min_count is None",
        "context": "def test_extract_max():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "assert max_count == 10  # noqa",
        "context": "    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\"name\": \"test\", \"count\": {\"max\": 10}}\n    min_count, max_count = extract_min_max(check)\n    assert min_count is None\n    assert max_count == 10  # noqa\n\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_extract_min",
    "function_scope": "43-53",
    "patterns": [
      {
        "lineno": 43,
        "coloffset": 0,
        "linematch": "def test_extract_min():",
        "context": "    assert min_count is None\n    assert max_count == 10  # noqa\n\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"count\": {\n            \"min\": 1,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "assert min_count == 1",
        "context": "            \"min\": 1,\n        },\n    }\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count is None\n\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "assert max_count is None",
        "context": "        },\n    }\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count is None\n\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"",
        "context": "    assert max_count == 10  # noqa\n\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"count\": {\n            \"min\": 1,\n        },",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "check = {",
        "context": "\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"count\": {\n            \"min\": 1,\n        },\n    }",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)",
        "context": "        \"count\": {\n            \"min\": 1,\n        },\n    }\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count is None\n\n\ndef test_extract_min_max_missing():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "assert min_count == 1",
        "context": "            \"min\": 1,\n        },\n    }\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count is None\n\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "assert max_count is None",
        "context": "        },\n    }\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count is None\n\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"",
        "context": "    assert max_count == 10  # noqa\n\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"count\": {\n            \"min\": 1,\n        },",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "check = {",
        "context": "\n\ndef test_extract_min():\n    \"\"\"Confirm that it is possible to extract one value from the count parmeter when it exists.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"count\": {\n            \"min\": 1,\n        },\n    }",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)",
        "context": "        \"count\": {\n            \"min\": 1,\n        },\n    }\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count is None\n\n\ndef test_extract_min_max_missing():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "assert min_count == 1",
        "context": "            \"min\": 1,\n        },\n    }\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count is None\n\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "assert max_count is None",
        "context": "        },\n    }\n    min_count, max_count = extract_min_max(check)\n    assert min_count == 1\n    assert max_count is None\n\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_extract_min_max_missing",
    "function_scope": "56-61",
    "patterns": [
      {
        "lineno": 56,
        "coloffset": 0,
        "linematch": "def test_extract_min_max_missing():",
        "context": "    assert min_count == 1\n    assert max_count is None\n\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 60,
        "coloffset": 4,
        "linematch": "assert min_count is None",
        "context": "def test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "assert max_count is None",
        "context": "    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"\n    check = {",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 57,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"",
        "context": "    assert max_count is None\n\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "check = {\"name\": \"test\"}",
        "context": "\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)  # type: ignore",
        "context": "\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n\n\ndef test_extract_description():",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 60,
        "coloffset": 4,
        "linematch": "assert min_count is None",
        "context": "def test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "assert max_count is None",
        "context": "    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"\n    check = {",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 57,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"",
        "context": "    assert max_count is None\n\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "check = {\"name\": \"test\"}",
        "context": "\n\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)  # type: ignore",
        "context": "\ndef test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n\n\ndef test_extract_description():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 60,
        "coloffset": 4,
        "linematch": "assert min_count is None",
        "context": "def test_extract_min_max_missing():\n    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "assert max_count is None",
        "context": "    \"\"\"Confirm that it is not possible to extract both values when they do not exist.\"\"\"\n    check = {\"name\": \"test\"}\n    min_count, max_count = extract_min_max(check)  # type: ignore\n    assert min_count is None\n    assert max_count is None\n\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"\n    check = {",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_extract_description",
    "function_scope": "64-73",
    "patterns": [
      {
        "lineno": 64,
        "coloffset": 0,
        "linematch": "def test_extract_description():",
        "context": "    assert min_count is None\n    assert max_count is None\n\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"description\": \"described test\",\n        \"count\": {",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 73,
        "coloffset": 4,
        "linematch": "assert \"described test\" == extract_description(check)",
        "context": "        \"count\": {\n            \"min\": 1,\n        },\n    }\n    assert \"described test\" == extract_description(check)\n\n\ndef test_extract_desription_none():\n    \"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"\n    check = {",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 65,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"",
        "context": "    assert max_count is None\n\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"description\": \"described test\",\n        \"count\": {\n            \"min\": 1,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 66,
        "coloffset": 4,
        "linematch": "check = {",
        "context": "\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"description\": \"described test\",\n        \"count\": {\n            \"min\": 1,\n        },",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 73,
        "coloffset": 4,
        "linematch": "assert \"described test\" == extract_description(check)",
        "context": "        \"count\": {\n            \"min\": 1,\n        },\n    }\n    assert \"described test\" == extract_description(check)\n\n\ndef test_extract_desription_none():\n    \"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"\n    check = {",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 65,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"",
        "context": "    assert max_count is None\n\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"description\": \"described test\",\n        \"count\": {\n            \"min\": 1,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 66,
        "coloffset": 4,
        "linematch": "check = {",
        "context": "\n\ndef test_extract_description():\n    \"\"\"Confirm that if a description exists, it is properly retrieved.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"description\": \"described test\",\n        \"count\": {\n            \"min\": 1,\n        },",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 73,
        "coloffset": 4,
        "linematch": "assert \"described test\" == extract_description(check)",
        "context": "        \"count\": {\n            \"min\": 1,\n        },\n    }\n    assert \"described test\" == extract_description(check)\n\n\ndef test_extract_desription_none():\n    \"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"\n    check = {",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 73,
        "coloffset": 4,
        "linematch": "assert \"described test\" == extract_description(check)",
        "context": "        \"count\": {\n            \"min\": 1,\n        },\n    }\n    assert \"described test\" == extract_description(check)\n\n\ndef test_extract_desription_none():\n    \"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"\n    check = {",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_extract_desription_none",
    "function_scope": "76-84",
    "patterns": [
      {
        "lineno": 76,
        "coloffset": 0,
        "linematch": "def test_extract_desription_none():",
        "context": "    }\n    assert \"described test\" == extract_description(check)\n\n\ndef test_extract_desription_none():\n    \"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"count\": {\n            \"min\": 1,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "assert \"\" == extract_description(check)",
        "context": "        \"count\": {\n            \"min\": 1,\n        },\n    }\n    assert \"\" == extract_description(check)\n\n\n@pytest.mark.parametrize(\n    \"bool_status,expected\",\n    [",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 77,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"",
        "context": "    assert \"described test\" == extract_description(check)\n\n\ndef test_extract_desription_none():\n    \"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"count\": {\n            \"min\": 1,\n        },",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "check = {",
        "context": "\n\ndef test_extract_desription_none():\n    \"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"count\": {\n            \"min\": 1,\n        },\n    }",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "assert \"\" == extract_description(check)",
        "context": "        \"count\": {\n            \"min\": 1,\n        },\n    }\n    assert \"\" == extract_description(check)\n\n\n@pytest.mark.parametrize(\n    \"bool_status,expected\",\n    [",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 77,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"",
        "context": "    assert \"described test\" == extract_description(check)\n\n\ndef test_extract_desription_none():\n    \"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"count\": {\n            \"min\": 1,\n        },",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "check = {",
        "context": "\n\ndef test_extract_desription_none():\n    \"\"\"Confirm that if a description does not exist, an empty string is returned.\"\"\"\n    check = {\n        \"name\": \"test\",\n        \"count\": {\n            \"min\": 1,\n        },\n    }",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "assert \"\" == extract_description(check)",
        "context": "        \"count\": {\n            \"min\": 1,\n        },\n    }\n    assert \"\" == extract_description(check)\n\n\n@pytest.mark.parametrize(\n    \"bool_status,expected\",\n    [",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "assert \"\" == extract_description(check)",
        "context": "        \"count\": {\n            \"min\": 1,\n        },\n    }\n    assert \"\" == extract_description(check)\n\n\n@pytest.mark.parametrize(\n    \"bool_status,expected\",\n    [",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_make_checks_status_message",
    "function_scope": "94-96",
    "patterns": [
      {
        "lineno": 94,
        "coloffset": 0,
        "linematch": "def test_make_checks_status_message(bool_status: bool, expected: str):",
        "context": "        (True, \":smiley: Did the check pass? Yes\"),\n        (False, \":worried: Did the check pass? No\"),\n    ],\n)\ndef test_make_checks_status_message(bool_status: bool, expected: str):\n    \"\"\"Confirms the output matches the expected message.\"\"\"\n    assert make_checks_status_message(bool_status) == expected\n\n\n@given(st.dictionaries(st.text(), st.integers()))",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "assert make_checks_status_message(bool_status) == expected",
        "context": "    ],\n)\ndef test_make_checks_status_message(bool_status: bool, expected: str):\n    \"\"\"Confirms the output matches the expected message.\"\"\"\n    assert make_checks_status_message(bool_status) == expected\n\n\n@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 95,
        "coloffset": 4,
        "linematch": "\"\"\"Confirms the output matches the expected message.\"\"\"",
        "context": "        (False, \":worried: Did the check pass? No\"),\n    ],\n)\ndef test_make_checks_status_message(bool_status: bool, expected: str):\n    \"\"\"Confirms the output matches the expected message.\"\"\"\n    assert make_checks_status_message(bool_status) == expected\n\n\n@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "assert make_checks_status_message(bool_status) == expected",
        "context": "    ],\n)\ndef test_make_checks_status_message(bool_status: bool, expected: str):\n    \"\"\"Confirms the output matches the expected message.\"\"\"\n    assert make_checks_status_message(bool_status) == expected\n\n\n@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 95,
        "coloffset": 4,
        "linematch": "\"\"\"Confirms the output matches the expected message.\"\"\"",
        "context": "        (False, \":worried: Did the check pass? No\"),\n    ],\n)\ndef test_make_checks_status_message(bool_status: bool, expected: str):\n    \"\"\"Confirms the output matches the expected message.\"\"\"\n    assert make_checks_status_message(bool_status) == expected\n\n\n@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "assert make_checks_status_message(bool_status) == expected",
        "context": "    ],\n)\ndef test_make_checks_status_message(bool_status: bool, expected: str):\n    \"\"\"Confirms the output matches the expected message.\"\"\"\n    assert make_checks_status_message(bool_status) == expected\n\n\n@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "assert make_checks_status_message(bool_status) == expected",
        "context": "    ],\n)\ndef test_make_checks_status_message(bool_status: bool, expected: str):\n    \"\"\"Confirms the output matches the expected message.\"\"\"\n    assert make_checks_status_message(bool_status) == expected\n\n\n@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1365",
        "line": 95,
        "description": [
          "    console.print(\":sparkles: Finished running test suite for the specified program\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_extract_min_max_hypothesis",
    "function_scope": "101-105",
    "patterns": [
      {
        "lineno": 101,
        "coloffset": 0,
        "linematch": "def test_extract_min_max_hypothesis(check):",
        "context": "\n\n@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 104,
        "coloffset": 4,
        "linematch": "assert isinstance(min_count, int) or min_count is None",
        "context": "@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 105,
        "coloffset": 4,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.too_slow])",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 102,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"",
        "context": "\n@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 103,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)",
        "context": "@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@given(from_schema(JSON_SCHEMA_COUNT))",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 104,
        "coloffset": 4,
        "linematch": "assert isinstance(min_count, int) or min_count is None",
        "context": "@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 105,
        "coloffset": 4,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.too_slow])",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 102,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"",
        "context": "\n@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 103,
        "coloffset": 4,
        "linematch": "min_count, max_count = extract_min_max(check)",
        "context": "@given(st.dictionaries(st.text(), st.integers()))\n@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@given(from_schema(JSON_SCHEMA_COUNT))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 104,
        "coloffset": 4,
        "linematch": "assert isinstance(min_count, int) or min_count is None",
        "context": "@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 105,
        "coloffset": 4,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.too_slow])",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 104,
        "coloffset": 4,
        "linematch": "assert isinstance(min_count, int) or min_count is None",
        "context": "@pytest.mark.fuzz\ndef test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      },
      {
        "lineno": 105,
        "coloffset": 4,
        "linematch": "assert isinstance(max_count, int) or max_count is None",
        "context": "def test_extract_min_max_hypothesis(check):\n    \"\"\"Use Hypothesis to confirm that extract works correctly.\"\"\"\n    min_count, max_count = extract_min_max(check)\n    assert isinstance(min_count, int) or min_count is None\n    assert isinstance(max_count, int) or max_count is None\n\n\n@given(from_schema(JSON_SCHEMA_COUNT))\n@pytest.mark.fuzz\n@settings(suppress_health_check=[HealthCheck.too_slow])",
        "pattern": "//FunctionDef[starts-with(@name, \"test_\")]//Assert[count(.//Call[func/Name]) > 0]",
        "check_id": "UNUSED001",
        "check_name": "unused-variables"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "cwd",
    "function_scope": "78-80",
    "patterns": [
      {
        "lineno": 78,
        "coloffset": 0,
        "linematch": "def cwd():",
        "context": "\"\"\"\n\n\n@pytest.fixture\ndef cwd():\n    \"\"\"Define a test fixture for the current working directory.\"\"\"\n    return os.getcwd()\n\n\ndef test_cli_analyze_correct_arguments_nothing_to_analyze_not_looking(tmpdir):",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 79,
        "coloffset": 4,
        "linematch": "\"\"\"Define a test fixture for the current working directory.\"\"\"",
        "context": "\n\n@pytest.fixture\ndef cwd():\n    \"\"\"Define a test fixture for the current working directory.\"\"\"\n    return os.getcwd()\n\n\ndef test_cli_analyze_correct_arguments_nothing_to_analyze_not_looking(tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 80,
        "coloffset": 4,
        "linematch": "return os.getcwd()",
        "context": "\n@pytest.fixture\ndef cwd():\n    \"\"\"Define a test fixture for the current working directory.\"\"\"\n    return os.getcwd()\n\n\ndef test_cli_analyze_correct_arguments_nothing_to_analyze_not_looking(tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # create some temporary directories;",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_cli_analyze_correct_arguments_nothing_to_analyze_not_looking",
    "function_scope": "83-116",
    "patterns": [
      {
        "lineno": 83,
        "coloffset": 0,
        "linematch": "def test_cli_analyze_correct_arguments_nothing_to_analyze_not_looking(tmpdir):",
        "context": "    \"\"\"Define a test fixture for the current working directory.\"\"\"\n    return os.getcwd()\n\n\ndef test_cli_analyze_correct_arguments_nothing_to_analyze_not_looking(tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # create some temporary directories;\n    # note that there is no code inside of this directory\n    # and thus chasten does not actually have any\n    # Python source code that it can analyze",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 116,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            configuration_directory,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 0\n\n\ndef test_cli_analyze_correct_arguments_analyze_chasten_codebase(cwd):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # call the analyze command",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"",
        "context": "    return os.getcwd()\n\n\ndef test_cli_analyze_correct_arguments_nothing_to_analyze_not_looking(tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # create some temporary directories;\n    # note that there is no code inside of this directory\n    # and thus chasten does not actually have any\n    # Python source code that it can analyze\n    test_one = tmpdir.mkdir(\"test_one\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 89,
        "coloffset": 4,
        "linematch": "test_one = tmpdir.mkdir(\"test_one\")",
        "context": "    # create some temporary directories;\n    # note that there is no code inside of this directory\n    # and thus chasten does not actually have any\n    # Python source code that it can analyze\n    test_one = tmpdir.mkdir(\"test_one\")\n    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 91,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "    # and thus chasten does not actually have any\n    # Python source code that it can analyze\n    test_one = tmpdir.mkdir(\"test_one\")\n    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "configuration_directory = test_one / Path(\".chasten\")",
        "context": "    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 95,
        "coloffset": 4,
        "linematch": "configuration_directory_path = Path(configuration_directory)",
        "context": "    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "configuration_directory_path.mkdir()",
        "context": "    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 97,
        "coloffset": 4,
        "linematch": "configuration_file = configuration_directory_path / \"config.yml\"",
        "context": "    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 98,
        "coloffset": 4,
        "linematch": "configuration_file.touch()",
        "context": "    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)",
        "context": "    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 100,
        "coloffset": 4,
        "linematch": "checks_file = configuration_directory_path / \"checks.yml\"",
        "context": "    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 101,
        "coloffset": 4,
        "linematch": "checks_file.touch()",
        "context": "    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)\n    result = runner.invoke(\n        main.cli,\n        [",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 102,
        "coloffset": 4,
        "linematch": "checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)",
        "context": "    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 104,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,\n            \"--search-path\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 116,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            configuration_directory,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 0\n\n\ndef test_cli_analyze_correct_arguments_analyze_chasten_codebase(cwd):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # call the analyze command",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"",
        "context": "    return os.getcwd()\n\n\ndef test_cli_analyze_correct_arguments_nothing_to_analyze_not_looking(tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # create some temporary directories;\n    # note that there is no code inside of this directory\n    # and thus chasten does not actually have any\n    # Python source code that it can analyze\n    test_one = tmpdir.mkdir(\"test_one\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 89,
        "coloffset": 4,
        "linematch": "test_one = tmpdir.mkdir(\"test_one\")",
        "context": "    # create some temporary directories;\n    # note that there is no code inside of this directory\n    # and thus chasten does not actually have any\n    # Python source code that it can analyze\n    test_one = tmpdir.mkdir(\"test_one\")\n    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 91,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "    # and thus chasten does not actually have any\n    # Python source code that it can analyze\n    test_one = tmpdir.mkdir(\"test_one\")\n    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "configuration_directory = test_one / Path(\".chasten\")",
        "context": "    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 95,
        "coloffset": 4,
        "linematch": "configuration_directory_path = Path(configuration_directory)",
        "context": "    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "configuration_directory_path.mkdir()",
        "context": "    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 97,
        "coloffset": 4,
        "linematch": "configuration_file = configuration_directory_path / \"config.yml\"",
        "context": "    # .chasten directory that supports testing\n    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 98,
        "coloffset": 4,
        "linematch": "configuration_file.touch()",
        "context": "    configuration_directory = test_one / Path(\".chasten\")\n    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)",
        "context": "    configuration_directory_path = Path(configuration_directory)\n    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)\n    result = runner.invoke(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 100,
        "coloffset": 4,
        "linematch": "checks_file = configuration_directory_path / \"checks.yml\"",
        "context": "    configuration_directory_path.mkdir()\n    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 101,
        "coloffset": 4,
        "linematch": "checks_file.touch()",
        "context": "    configuration_file = configuration_directory_path / \"config.yml\"\n    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)\n    result = runner.invoke(\n        main.cli,\n        [",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 102,
        "coloffset": 4,
        "linematch": "checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)",
        "context": "    configuration_file.touch()\n    configuration_file.write_text(CONFIGURATION_FILE_DEFAULT_CONTENTS)\n    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 104,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    checks_file = configuration_directory_path / \"checks.yml\"\n    checks_file.touch()\n    checks_file.write_text(CHECKS_FILE_DEFAULT_CONTENTS)\n    # filesystem.create_configuration_directory(configuration_directory_path, force=True)\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,\n            \"--search-path\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 116,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            configuration_directory,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 0\n\n\ndef test_cli_analyze_correct_arguments_analyze_chasten_codebase(cwd):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # call the analyze command",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1365",
        "line": 95,
        "description": [
          "    console.print(\":sparkles: Finished running test suite for the specified program\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_cli_analyze_correct_arguments_analyze_chasten_codebase",
    "function_scope": "119-138",
    "patterns": [
      {
        "lineno": 119,
        "coloffset": 0,
        "linematch": "def test_cli_analyze_correct_arguments_analyze_chasten_codebase(cwd):",
        "context": "    )\n    assert result.exit_code == 0\n\n\ndef test_cli_analyze_correct_arguments_analyze_chasten_codebase(cwd):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 138,
        "coloffset": 4,
        "linematch": "assert result.exit_code in [0, 1]",
        "context": "            configuration_directory,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code in [0, 1]\n\n\ndef test_cli_analyze_incorrect_arguments_no_project(cwd, tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 120,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"",
        "context": "    assert result.exit_code == 0\n\n\ndef test_cli_analyze_correct_arguments_analyze_chasten_codebase(cwd):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 122,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "\ndef test_cli_analyze_correct_arguments_analyze_chasten_codebase(cwd):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 125,
        "coloffset": 4,
        "linematch": "configuration_directory = cwd / Path(\".chasten\")",
        "context": "    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 126,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            cwd,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 138,
        "coloffset": 4,
        "linematch": "assert result.exit_code in [0, 1]",
        "context": "            configuration_directory,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code in [0, 1]\n\n\ndef test_cli_analyze_incorrect_arguments_no_project(cwd, tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 120,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"",
        "context": "    assert result.exit_code == 0\n\n\ndef test_cli_analyze_correct_arguments_analyze_chasten_codebase(cwd):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 122,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "\ndef test_cli_analyze_correct_arguments_analyze_chasten_codebase(cwd):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command with correct arguments.\"\"\"\n    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 125,
        "coloffset": 4,
        "linematch": "configuration_directory = cwd / Path(\".chasten\")",
        "context": "    # call the analyze command\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 126,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            cwd,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 138,
        "coloffset": 4,
        "linematch": "assert result.exit_code in [0, 1]",
        "context": "            configuration_directory,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code in [0, 1]\n\n\ndef test_cli_analyze_incorrect_arguments_no_project(cwd, tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #304",
        "line": 123,
        "description": [
          "            grouped_files[directory] = []"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1367",
        "line": 122,
        "description": [
          "        if directory not in grouped_files:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1368",
        "line": 132,
        "description": [
          "    if len(file_name) > max_length:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1369",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1370",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1371",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1372",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1373",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_cli_analyze_incorrect_arguments_no_project",
    "function_scope": "141-162",
    "patterns": [
      {
        "lineno": 141,
        "coloffset": 0,
        "linematch": "def test_cli_analyze_incorrect_arguments_no_project(cwd, tmpdir):",
        "context": "    )\n    assert result.exit_code in [0, 1]\n\n\ndef test_cli_analyze_incorrect_arguments_no_project(cwd, tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    # create a reference to the internal\n    # .chasten directory that supports testing",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 161,
        "coloffset": 4,
        "linematch": "assert result.exit_code != 0",
        "context": "            \"--verbose\",\n        ],\n    )\n    # crashes because the command-line arguments are wrong\n    assert result.exit_code != 0\n    assert \"Missing argument\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 162,
        "coloffset": 4,
        "linematch": "assert \"Missing argument\" in result.output",
        "context": "        ],\n    )\n    # crashes because the command-line arguments are wrong\n    assert result.exit_code != 0\n    assert \"Missing argument\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 142,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does not crash: analyze command incorrect arguments.\"\"\"",
        "context": "    assert result.exit_code in [0, 1]\n\n\ndef test_cli_analyze_incorrect_arguments_no_project(cwd, tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 144,
        "coloffset": 4,
        "linematch": "test_one = tmpdir.mkdir(\"test_one\")",
        "context": "\ndef test_cli_analyze_incorrect_arguments_no_project(cwd, tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    # call the analyze command\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 147,
        "coloffset": 4,
        "linematch": "configuration_directory = cwd / Path(\".chasten\")",
        "context": "    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 149,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            test_one,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 161,
        "coloffset": 4,
        "linematch": "assert result.exit_code != 0",
        "context": "            \"--verbose\",\n        ],\n    )\n    # crashes because the command-line arguments are wrong\n    assert result.exit_code != 0\n    assert \"Missing argument\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 162,
        "coloffset": 4,
        "linematch": "assert \"Missing argument\" in result.output",
        "context": "        ],\n    )\n    # crashes because the command-line arguments are wrong\n    assert result.exit_code != 0\n    assert \"Missing argument\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 142,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does not crash: analyze command incorrect arguments.\"\"\"",
        "context": "    assert result.exit_code in [0, 1]\n\n\ndef test_cli_analyze_incorrect_arguments_no_project(cwd, tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 144,
        "coloffset": 4,
        "linematch": "test_one = tmpdir.mkdir(\"test_one\")",
        "context": "\ndef test_cli_analyze_incorrect_arguments_no_project(cwd, tmpdir):\n    \"\"\"Confirm that using the command-line interface does not crash: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    # call the analyze command\n    result = runner.invoke(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 147,
        "coloffset": 4,
        "linematch": "configuration_directory = cwd / Path(\".chasten\")",
        "context": "    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 149,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            test_one,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 161,
        "coloffset": 4,
        "linematch": "assert result.exit_code != 0",
        "context": "            \"--verbose\",\n        ],\n    )\n    # crashes because the command-line arguments are wrong\n    assert result.exit_code != 0\n    assert \"Missing argument\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 162,
        "coloffset": 4,
        "linematch": "assert \"Missing argument\" in result.output",
        "context": "        ],\n    )\n    # crashes because the command-line arguments are wrong\n    assert result.exit_code != 0\n    assert \"Missing argument\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #305",
        "line": 143,
        "description": [
          "    grouped_files = group_files_by_directory(container)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #306",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #307",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1374",
        "line": 148,
        "description": [
          "        console.print(f\"{small_bullet_unicode} Directory: {directory}\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1375",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1376",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1377",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1378",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1379",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1380",
        "line": 156,
        "description": [
          "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1381",
        "line": 160,
        "description": [
          "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_cli_analyze_incorrect_arguments_wrong_config",
    "function_scope": "165-187",
    "patterns": [
      {
        "lineno": 165,
        "coloffset": 0,
        "linematch": "def test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):",
        "context": "    assert result.exit_code != 0\n    assert \"Missing argument\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 186,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            wrong_config_dir,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 187,
        "coloffset": 4,
        "linematch": "assert \"Cannot perform analysis due to configuration\" in result.output",
        "context": "            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 166,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"",
        "context": "    assert \"Missing argument\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 168,
        "coloffset": 4,
        "linematch": "test_one = tmpdir.mkdir(\"test_one\")",
        "context": "\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 169,
        "coloffset": 4,
        "linematch": "project_name = \"test\"",
        "context": "def test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 172,
        "coloffset": 4,
        "linematch": "wrong_config_dir = \"config\"",
        "context": "    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 174,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,\n            \"--search-path\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 186,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            wrong_config_dir,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 187,
        "coloffset": 4,
        "linematch": "assert \"Cannot perform analysis due to configuration\" in result.output",
        "context": "            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 166,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"",
        "context": "    assert \"Missing argument\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 168,
        "coloffset": 4,
        "linematch": "test_one = tmpdir.mkdir(\"test_one\")",
        "context": "\ndef test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 169,
        "coloffset": 4,
        "linematch": "project_name = \"test\"",
        "context": "def test_cli_analyze_incorrect_arguments_wrong_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 172,
        "coloffset": 4,
        "linematch": "wrong_config_dir = \"config\"",
        "context": "    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 174,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,\n            \"--search-path\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 186,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            wrong_config_dir,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 187,
        "coloffset": 4,
        "linematch": "assert \"Cannot perform analysis due to configuration\" in result.output",
        "context": "            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #308",
        "line": 176,
        "description": [
          "        current_xpath_pattern = current_check.pattern"
        ],
        "failure": []
      },
      {
        "name": "Mutant #309",
        "line": 182,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #310",
        "line": 187,
        "description": [
          "        min_count = current_check.min"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1382",
        "line": 169,
        "description": [
          "    if not verbose:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1383",
        "line": 171,
        "description": [
          "    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1384",
        "line": 175,
        "description": [
          "        current_check: results.Check = current_source.check  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1385",
        "line": 177,
        "description": [
          "        console.print(\"\\n:tada: Check:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_cli_analyze_incorrect_arguments_wrong_source_directory",
    "function_scope": "190-219",
    "patterns": [
      {
        "lineno": 190,
        "coloffset": 0,
        "linematch": "def test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):",
        "context": "    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    _ = tmpdir.mkdir(\"test_one\")\n    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 214,
        "coloffset": 4,
        "linematch": "assert result.exit_code != 0",
        "context": "        ],\n    )\n    # running the program with an invalid --search-path\n    # should not work and thus a zero exit code is wrong\n    assert result.exit_code != 0\n    # note the error code of 2 indicates that it was\n    # an error arising from the fact that typer could\n    # not validate that test_oneFF is a existing directory\n    assert result.exit_code == 2  # noqa\n    assert \"Usage:\" in result.output",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 218,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 2  # noqa",
        "context": "    assert result.exit_code != 0\n    # note the error code of 2 indicates that it was\n    # an error arising from the fact that typer could\n    # not validate that test_oneFF is a existing directory\n    assert result.exit_code == 2  # noqa\n    assert \"Usage:\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 219,
        "coloffset": 4,
        "linematch": "assert \"Usage:\" in result.output",
        "context": "    # note the error code of 2 indicates that it was\n    # an error arising from the fact that typer could\n    # not validate that test_oneFF is a existing directory\n    assert result.exit_code == 2  # noqa\n    assert \"Usage:\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 191,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"",
        "context": "    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    _ = tmpdir.mkdir(\"test_one\")\n    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"\n    # create a configuration directory",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 193,
        "coloffset": 4,
        "linematch": "_ = tmpdir.mkdir(\"test_one\")",
        "context": "\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    _ = tmpdir.mkdir(\"test_one\")\n    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 194,
        "coloffset": 4,
        "linematch": "test_one_incorrect_name = \"test_oneFF\"",
        "context": "def test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    _ = tmpdir.mkdir(\"test_one\")\n    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 195,
        "coloffset": 4,
        "linematch": "project_name = \"test\"",
        "context": "    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    _ = tmpdir.mkdir(\"test_one\")\n    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 198,
        "coloffset": 4,
        "linematch": "wrong_config_dir = \"config\"",
        "context": "    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 200,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,\n            \"--search-path\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 214,
        "coloffset": 4,
        "linematch": "assert result.exit_code != 0",
        "context": "        ],\n    )\n    # running the program with an invalid --search-path\n    # should not work and thus a zero exit code is wrong\n    assert result.exit_code != 0\n    # note the error code of 2 indicates that it was\n    # an error arising from the fact that typer could\n    # not validate that test_oneFF is a existing directory\n    assert result.exit_code == 2  # noqa\n    assert \"Usage:\" in result.output",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 218,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 2  # noqa",
        "context": "    assert result.exit_code != 0\n    # note the error code of 2 indicates that it was\n    # an error arising from the fact that typer could\n    # not validate that test_oneFF is a existing directory\n    assert result.exit_code == 2  # noqa\n    assert \"Usage:\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 219,
        "coloffset": 4,
        "linematch": "assert \"Usage:\" in result.output",
        "context": "    # note the error code of 2 indicates that it was\n    # an error arising from the fact that typer could\n    # not validate that test_oneFF is a existing directory\n    assert result.exit_code == 2  # noqa\n    assert \"Usage:\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 191,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"",
        "context": "    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    _ = tmpdir.mkdir(\"test_one\")\n    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"\n    # create a configuration directory",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 193,
        "coloffset": 4,
        "linematch": "_ = tmpdir.mkdir(\"test_one\")",
        "context": "\ndef test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    _ = tmpdir.mkdir(\"test_one\")\n    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 194,
        "coloffset": 4,
        "linematch": "test_one_incorrect_name = \"test_oneFF\"",
        "context": "def test_cli_analyze_incorrect_arguments_wrong_source_directory(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    _ = tmpdir.mkdir(\"test_one\")\n    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 195,
        "coloffset": 4,
        "linematch": "project_name = \"test\"",
        "context": "    \"\"\"Confirm that using the command-line interface does return non-zero: analyze command incorrect arguments.\"\"\"\n    # create some temporary directories\n    _ = tmpdir.mkdir(\"test_one\")\n    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 198,
        "coloffset": 4,
        "linematch": "wrong_config_dir = \"config\"",
        "context": "    test_one_incorrect_name = \"test_oneFF\"\n    project_name = \"test\"\n    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 200,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a configuration directory\n    # that does not currently exist\n    wrong_config_dir = \"config\"\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,\n            \"--search-path\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 214,
        "coloffset": 4,
        "linematch": "assert result.exit_code != 0",
        "context": "        ],\n    )\n    # running the program with an invalid --search-path\n    # should not work and thus a zero exit code is wrong\n    assert result.exit_code != 0\n    # note the error code of 2 indicates that it was\n    # an error arising from the fact that typer could\n    # not validate that test_oneFF is a existing directory\n    assert result.exit_code == 2  # noqa\n    assert \"Usage:\" in result.output",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 218,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 2  # noqa",
        "context": "    assert result.exit_code != 0\n    # note the error code of 2 indicates that it was\n    # an error arising from the fact that typer could\n    # not validate that test_oneFF is a existing directory\n    assert result.exit_code == 2  # noqa\n    assert \"Usage:\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 219,
        "coloffset": 4,
        "linematch": "assert \"Usage:\" in result.output",
        "context": "    # note the error code of 2 indicates that it was\n    # an error arising from the fact that typer could\n    # not validate that test_oneFF is a existing directory\n    assert result.exit_code == 2  # noqa\n    assert \"Usage:\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"\n    # create some temporary directories",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #313",
        "line": 190,
        "description": [
          "        max_label = checks.create_attribute_label(max_count, constants.checks.Check_Max)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #314",
        "line": 193,
        "description": [
          "        check_id = current_check.id"
        ],
        "failure": []
      },
      {
        "name": "Mutant #315",
        "line": 194,
        "description": [
          "        check_id_label = checks.create_attribute_label(check_id, constants.checks.Check_Id)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #316",
        "line": 195,
        "description": [
          "        check_name = current_check.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #317",
        "line": 196,
        "description": [
          "        check_name_label = checks.create_attribute_label(check_name, constants.checks.Check_Name)  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #318",
        "line": 200,
        "description": [
          "        )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1386",
        "line": 205,
        "description": [
          "                expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1387",
        "line": 206,
        "description": [
          "                title=f\"{combined_attribute_label}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1388",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1389",
        "line": 209,
        "description": [
          "        if len(current_check._matches) > 0:  # type: ignore"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1390",
        "line": 214,
        "description": [
          "                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\","
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_cli_analyze_incorrect_arguments_correct_config",
    "function_scope": "222-244",
    "patterns": [
      {
        "lineno": 222,
        "coloffset": 0,
        "linematch": "def test_cli_analyze_incorrect_arguments_correct_config(tmpdir):",
        "context": "    assert result.exit_code == 2  # noqa\n    assert \"Usage:\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 243,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            correct_config_dir,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\n# def test_cli_analyze_url_config(cwd):\n#     \"\"\"Confirm that using the command-line interface correctly handles a valid URL configuration.\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 244,
        "coloffset": 4,
        "linematch": "assert \"Cannot perform analysis due to configuration\" in result.output",
        "context": "            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\n# def test_cli_analyze_url_config(cwd):\n#     \"\"\"Confirm that using the command-line interface correctly handles a valid URL configuration.\"\"\"\n#     # use config files found in chasten-configuration remotely",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 223,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"",
        "context": "    assert \"Usage:\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does currently exist",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 225,
        "coloffset": 4,
        "linematch": "test_one = tmpdir.mkdir(\"test_one\")",
        "context": "\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does currently exist\n    correct_config_dir = tmpdir.mkdir(\"config\")\n    # call the analyze command",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 226,
        "coloffset": 4,
        "linematch": "project_name = \"test\"",
        "context": "def test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does currently exist\n    correct_config_dir = tmpdir.mkdir(\"config\")\n    # call the analyze command\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 229,
        "coloffset": 4,
        "linematch": "correct_config_dir = tmpdir.mkdir(\"config\")",
        "context": "    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does currently exist\n    correct_config_dir = tmpdir.mkdir(\"config\")\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 231,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a configuration directory\n    # that does currently exist\n    correct_config_dir = tmpdir.mkdir(\"config\")\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,\n            \"--search-path\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 243,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            correct_config_dir,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\n# def test_cli_analyze_url_config(cwd):\n#     \"\"\"Confirm that using the command-line interface correctly handles a valid URL configuration.\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 244,
        "coloffset": 4,
        "linematch": "assert \"Cannot perform analysis due to configuration\" in result.output",
        "context": "            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\n# def test_cli_analyze_url_config(cwd):\n#     \"\"\"Confirm that using the command-line interface correctly handles a valid URL configuration.\"\"\"\n#     # use config files found in chasten-configuration remotely",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 223,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"",
        "context": "    assert \"Usage:\" in result.output\n\n\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does currently exist",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 225,
        "coloffset": 4,
        "linematch": "test_one = tmpdir.mkdir(\"test_one\")",
        "context": "\ndef test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does currently exist\n    correct_config_dir = tmpdir.mkdir(\"config\")\n    # call the analyze command",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 226,
        "coloffset": 4,
        "linematch": "project_name = \"test\"",
        "context": "def test_cli_analyze_incorrect_arguments_correct_config(tmpdir):\n    \"\"\"Confirm that using the command-line interface does return non-zero due to no config files: analyze command correct arguments.\"\"\"\n    # create some temporary directories\n    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does currently exist\n    correct_config_dir = tmpdir.mkdir(\"config\")\n    # call the analyze command\n    result = runner.invoke(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 229,
        "coloffset": 4,
        "linematch": "correct_config_dir = tmpdir.mkdir(\"config\")",
        "context": "    test_one = tmpdir.mkdir(\"test_one\")\n    project_name = \"test\"\n    # create a configuration directory\n    # that does currently exist\n    correct_config_dir = tmpdir.mkdir(\"config\")\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 231,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a configuration directory\n    # that does currently exist\n    correct_config_dir = tmpdir.mkdir(\"config\")\n    # call the analyze command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,\n            \"--search-path\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 243,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            correct_config_dir,\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\n# def test_cli_analyze_url_config(cwd):\n#     \"\"\"Confirm that using the command-line interface correctly handles a valid URL configuration.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 244,
        "coloffset": 4,
        "linematch": "assert \"Cannot perform analysis due to configuration\" in result.output",
        "context": "            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n    assert \"Cannot perform analysis due to configuration\" in result.output\n\n\n# def test_cli_analyze_url_config(cwd):\n#     \"\"\"Confirm that using the command-line interface correctly handles a valid URL configuration.\"\"\"\n#     # use config files found in chasten-configuration remotely",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #319",
        "line": 223,
        "description": [
          "                    position_end = current_match.position.lineno"
        ],
        "failure": []
      },
      {
        "name": "Mutant #320",
        "line": 225,
        "description": [
          "                    column_offset = current_match.position.col_offset"
        ],
        "failure": []
      },
      {
        "name": "Mutant #321",
        "line": 230,
        "description": [
          "                    all_lines = current_match.file_lines"
        ],
        "failure": []
      },
      {
        "name": "Mutant #322",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #323",
        "line": 240,
        "description": [
          "                    ]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1392",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1393",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1394",
        "line": 237,
        "description": [
          "                            0, position_end - constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1395",
        "line": 239,
        "description": [
          "                        + constants.markers.Code_Context"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_cli_configure_create_config_when_does_not_exist",
    "function_scope": "354-371",
    "patterns": [
      {
        "lineno": 354,
        "coloffset": 0,
        "linematch": "def test_cli_configure_create_config_when_does_not_exist(",
        "context": "#     assert result.exit_code == 1\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_cli_configure_create_config_when_does_not_exist(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm that using the command-line interface does create .config directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 371,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"create\",\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 0\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_cli_configure_cannot_create_config_when_does_exist(\n    mock_user_config_dir, tmp_path",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 357,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does create .config directory when it does not exist.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_cli_configure_create_config_when_does_not_exist(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm that using the command-line interface does create .config directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    # call the configure command",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 361,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm that using the command-line interface does create .config directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"configure\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 363,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"configure\",\n            \"create\",\n            \"--verbose\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 371,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"create\",\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 0\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_cli_configure_cannot_create_config_when_does_exist(\n    mock_user_config_dir, tmp_path",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 357,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does create .config directory when it does not exist.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_cli_configure_create_config_when_does_not_exist(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm that using the command-line interface does create .config directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    # call the configure command",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 361,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm that using the command-line interface does create .config directory when it does not exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"configure\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 363,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"configure\",\n            \"create\",\n            \"--verbose\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 371,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"create\",\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 0\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_cli_configure_cannot_create_config_when_does_exist(\n    mock_user_config_dir, tmp_path",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_cli_configure_cannot_create_config_when_does_exist",
    "function_scope": "375-395",
    "patterns": [
      {
        "lineno": 375,
        "coloffset": 0,
        "linematch": "def test_cli_configure_cannot_create_config_when_does_exist(",
        "context": "    assert result.exit_code == 0\n\n\n@patch(\"chasten.configuration.user_config_dir\")\ndef test_cli_configure_cannot_create_config_when_does_exist(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm that using the command-line interface does create .config directory when it does exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 385,
        "coloffset": 4,
        "linematch": "assert config_directory.exists()",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"configure\",",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 395,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            \"create\",\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n\n\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 378,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does create .config directory when it does exist.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_cli_configure_cannot_create_config_when_does_exist(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm that using the command-line interface does create .config directory when it does exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 382,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm that using the command-line interface does create .config directory when it does exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 383,
        "coloffset": 4,
        "linematch": "config_directory = Path(tmp_path / \".chasten\")",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 384,
        "coloffset": 4,
        "linematch": "config_directory.mkdir()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 385,
        "coloffset": 4,
        "linematch": "assert config_directory.exists()",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"configure\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 387,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"configure\",\n            \"create\",\n            \"--verbose\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 395,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            \"create\",\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n\n\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 378,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that using the command-line interface does create .config directory when it does exist.\"\"\"",
        "context": "@patch(\"chasten.configuration.user_config_dir\")\ndef test_cli_configure_cannot_create_config_when_does_exist(\n    mock_user_config_dir, tmp_path\n):\n    \"\"\"Confirm that using the command-line interface does create .config directory when it does exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 382,
        "coloffset": 4,
        "linematch": "mock_user_config_dir.return_value = str(tmp_path / \".chasten\")",
        "context": "    \"\"\"Confirm that using the command-line interface does create .config directory when it does exist.\"\"\"\n    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 383,
        "coloffset": 4,
        "linematch": "config_directory = Path(tmp_path / \".chasten\")",
        "context": "    # monkeypatch the platformdirs user_config_dir to always return\n    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 384,
        "coloffset": 4,
        "linematch": "config_directory.mkdir()",
        "context": "    # the tmpdir test fixture that is controlled by Pytest; the\n    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 385,
        "coloffset": 4,
        "linematch": "assert config_directory.exists()",
        "context": "    # directory inside of that will be \".chasten\" by default\n    mock_user_config_dir.return_value = str(tmp_path / \".chasten\")\n    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"configure\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 387,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    config_directory = Path(tmp_path / \".chasten\")\n    config_directory.mkdir()\n    assert config_directory.exists()\n    # call the configure command\n    result = runner.invoke(\n        main.cli,\n        [\n            \"configure\",\n            \"create\",\n            \"--verbose\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 395,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            \"create\",\n            \"--verbose\",\n        ],\n    )\n    assert result.exit_code == 1\n\n\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_fuzz_cli_analyze_single_directory",
    "function_scope": "401-418",
    "patterns": [
      {
        "lineno": 401,
        "coloffset": 0,
        "linematch": "def test_fuzz_cli_analyze_single_directory(cwd, directory):",
        "context": "\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz\ndef test_fuzz_cli_analyze_single_directory(cwd, directory):\n    \"\"\"Confirm that the function does not crash when called through the command-line interface.\"\"\"\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 418,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"--search-path\",\n            str(directory),\n        ],\n    )\n    assert result.exit_code == 0\n\n\ndef test_analyze_store_results_file_does_not_exist(cwd, tmpdir):\n    \"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"\n    tmp_dir = Path(tmpdir)",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 402,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the function does not crash when called through the command-line interface.\"\"\"",
        "context": "@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz\ndef test_fuzz_cli_analyze_single_directory(cwd, directory):\n    \"\"\"Confirm that the function does not crash when called through the command-line interface.\"\"\"\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 403,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz\ndef test_fuzz_cli_analyze_single_directory(cwd, directory):\n    \"\"\"Confirm that the function does not crash when called through the command-line interface.\"\"\"\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 406,
        "coloffset": 4,
        "linematch": "configuration_directory = cwd / Path(\".chasten\")",
        "context": "    \"\"\"Confirm that the function does not crash when called through the command-line interface.\"\"\"\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 407,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,\n            \"--config\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 418,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"--search-path\",\n            str(directory),\n        ],\n    )\n    assert result.exit_code == 0\n\n\ndef test_analyze_store_results_file_does_not_exist(cwd, tmpdir):\n    \"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"\n    tmp_dir = Path(tmpdir)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 402,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the function does not crash when called through the command-line interface.\"\"\"",
        "context": "@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz\ndef test_fuzz_cli_analyze_single_directory(cwd, directory):\n    \"\"\"Confirm that the function does not crash when called through the command-line interface.\"\"\"\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 403,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz\ndef test_fuzz_cli_analyze_single_directory(cwd, directory):\n    \"\"\"Confirm that the function does not crash when called through the command-line interface.\"\"\"\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 406,
        "coloffset": 4,
        "linematch": "configuration_directory = cwd / Path(\".chasten\")",
        "context": "    \"\"\"Confirm that the function does not crash when called through the command-line interface.\"\"\"\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 407,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = cwd / Path(\".chasten\")\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            project_name,\n            \"--config\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 418,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"--search-path\",\n            str(directory),\n        ],\n    )\n    assert result.exit_code == 0\n\n\ndef test_analyze_store_results_file_does_not_exist(cwd, tmpdir):\n    \"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"\n    tmp_dir = Path(tmpdir)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_analyze_store_results_file_does_not_exist",
    "function_scope": "421-442",
    "patterns": [
      {
        "lineno": 421,
        "coloffset": 0,
        "linematch": "def test_analyze_store_results_file_does_not_exist(cwd, tmpdir):",
        "context": "    )\n    assert result.exit_code == 0\n\n\ndef test_analyze_store_results_file_does_not_exist(cwd, tmpdir):\n    \"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"\n    tmp_dir = Path(tmpdir)\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 441,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"--markdown-storage\",\n            tmp_dir,\n        ],\n    )\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 442,
        "coloffset": 4,
        "linematch": "assert \"\u2728 Results saved in:\" in result.output",
        "context": "            tmp_dir,\n        ],\n    )\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"\n    tmp_dir = Path(tmpdir)",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 422,
        "coloffset": 4,
        "linematch": "\"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"",
        "context": "    assert result.exit_code == 0\n\n\ndef test_analyze_store_results_file_does_not_exist(cwd, tmpdir):\n    \"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"\n    tmp_dir = Path(tmpdir)\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 423,
        "coloffset": 4,
        "linematch": "tmp_dir = Path(tmpdir)",
        "context": "\n\ndef test_analyze_store_results_file_does_not_exist(cwd, tmpdir):\n    \"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"\n    tmp_dir = Path(tmpdir)\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 424,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "\ndef test_analyze_store_results_file_does_not_exist(cwd, tmpdir):\n    \"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"\n    tmp_dir = Path(tmpdir)\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 427,
        "coloffset": 4,
        "linematch": "configuration_directory = str(cwd) + \"/.chasten\"",
        "context": "    tmp_dir = Path(tmpdir)\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 428,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            cwd,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 441,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"--markdown-storage\",\n            tmp_dir,\n        ],\n    )\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 442,
        "coloffset": 4,
        "linematch": "assert \"\u2728 Results saved in:\" in result.output",
        "context": "            tmp_dir,\n        ],\n    )\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"\n    tmp_dir = Path(tmpdir)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 422,
        "coloffset": 4,
        "linematch": "\"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"",
        "context": "    assert result.exit_code == 0\n\n\ndef test_analyze_store_results_file_does_not_exist(cwd, tmpdir):\n    \"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"\n    tmp_dir = Path(tmpdir)\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 423,
        "coloffset": 4,
        "linematch": "tmp_dir = Path(tmpdir)",
        "context": "\n\ndef test_analyze_store_results_file_does_not_exist(cwd, tmpdir):\n    \"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"\n    tmp_dir = Path(tmpdir)\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 424,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "\ndef test_analyze_store_results_file_does_not_exist(cwd, tmpdir):\n    \"\"\"Makes sure analyze doesn't crash when using markdown storage.\"\"\"\n    tmp_dir = Path(tmpdir)\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 427,
        "coloffset": 4,
        "linematch": "configuration_directory = str(cwd) + \"/.chasten\"",
        "context": "    tmp_dir = Path(tmpdir)\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 428,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            cwd,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 441,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"--markdown-storage\",\n            tmp_dir,\n        ],\n    )\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 442,
        "coloffset": 4,
        "linematch": "assert \"\u2728 Results saved in:\" in result.output",
        "context": "            tmp_dir,\n        ],\n    )\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"\n    tmp_dir = Path(tmpdir)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_analyze_store_results_file_exists_no_force",
    "function_scope": "445-477",
    "patterns": [
      {
        "lineno": 445,
        "coloffset": 0,
        "linematch": "def test_analyze_store_results_file_exists_no_force(cwd, tmpdir):",
        "context": "    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 453,
        "coloffset": 4,
        "linematch": "assert file.exists()",
        "context": "    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 473,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            tmp_dir,\n        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 1\n    assert (\n        \"File already exists: use --force to recreate markdown directory.\"\n        in result.output\n    )\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 474,
        "coloffset": 4,
        "linematch": "assert (",
        "context": "        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 1\n    assert (\n        \"File already exists: use --force to recreate markdown directory.\"\n        in result.output\n    )\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 446,
        "coloffset": 4,
        "linematch": "\"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"",
        "context": "    assert \"\u2728 Results saved in:\" in result.output\n\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 447,
        "coloffset": 4,
        "linematch": "tmp_dir = Path(tmpdir)",
        "context": "\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 449,
        "coloffset": 4,
        "linematch": "file = tmp_dir / \"analysis.md\"",
        "context": "def test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 451,
        "coloffset": 4,
        "linematch": "file.touch()",
        "context": "    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 453,
        "coloffset": 4,
        "linematch": "assert file.exists()",
        "context": "    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 454,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 457,
        "coloffset": 4,
        "linematch": "configuration_directory = str(cwd) + \"/.chasten\"",
        "context": "    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 459,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            cwd,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 473,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            tmp_dir,\n        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 1\n    assert (\n        \"File already exists: use --force to recreate markdown directory.\"\n        in result.output\n    )\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 474,
        "coloffset": 4,
        "linematch": "assert (",
        "context": "        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 1\n    assert (\n        \"File already exists: use --force to recreate markdown directory.\"\n        in result.output\n    )\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 446,
        "coloffset": 4,
        "linematch": "\"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"",
        "context": "    assert \"\u2728 Results saved in:\" in result.output\n\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 447,
        "coloffset": 4,
        "linematch": "tmp_dir = Path(tmpdir)",
        "context": "\n\ndef test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 449,
        "coloffset": 4,
        "linematch": "file = tmp_dir / \"analysis.md\"",
        "context": "def test_analyze_store_results_file_exists_no_force(cwd, tmpdir):\n    \"\"\"Make sure Analyze acts accordingly when file exists and their is no force\"\"\"\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 451,
        "coloffset": 4,
        "linematch": "file.touch()",
        "context": "    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 453,
        "coloffset": 4,
        "linematch": "assert file.exists()",
        "context": "    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 454,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 457,
        "coloffset": 4,
        "linematch": "configuration_directory = str(cwd) + \"/.chasten\"",
        "context": "    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 459,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            cwd,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 473,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 1",
        "context": "            tmp_dir,\n        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 1\n    assert (\n        \"File already exists: use --force to recreate markdown directory.\"\n        in result.output\n    )\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 474,
        "coloffset": 4,
        "linematch": "assert (",
        "context": "        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 1\n    assert (\n        \"File already exists: use --force to recreate markdown directory.\"\n        in result.output\n    )\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_analyze_store_results_file_exists_force",
    "function_scope": "480-509",
    "patterns": [
      {
        "lineno": 480,
        "coloffset": 0,
        "linematch": "def test_analyze_store_results_file_exists_force(cwd, tmpdir):",
        "context": "        in result.output\n    )\n\n\ndef test_analyze_store_results_file_exists_force(cwd, tmpdir):\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 487,
        "coloffset": 4,
        "linematch": "assert file.exists()",
        "context": "    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 508,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"--force\",\n        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 509,
        "coloffset": 4,
        "linematch": "assert \"\u2728 Results saved in:\" in result.output",
        "context": "        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 481,
        "coloffset": 4,
        "linematch": "tmp_dir = Path(tmpdir)",
        "context": "    )\n\n\ndef test_analyze_store_results_file_exists_force(cwd, tmpdir):\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 483,
        "coloffset": 4,
        "linematch": "file = tmp_dir / \"analysis.md\"",
        "context": "\ndef test_analyze_store_results_file_exists_force(cwd, tmpdir):\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 485,
        "coloffset": 4,
        "linematch": "file.touch()",
        "context": "    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 487,
        "coloffset": 4,
        "linematch": "assert file.exists()",
        "context": "    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 488,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 491,
        "coloffset": 4,
        "linematch": "configuration_directory = str(cwd) + \"/.chasten\"",
        "context": "    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 493,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            cwd,",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 508,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"--force\",\n        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 509,
        "coloffset": 4,
        "linematch": "assert \"\u2728 Results saved in:\" in result.output",
        "context": "        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 481,
        "coloffset": 4,
        "linematch": "tmp_dir = Path(tmpdir)",
        "context": "    )\n\n\ndef test_analyze_store_results_file_exists_force(cwd, tmpdir):\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 483,
        "coloffset": 4,
        "linematch": "file = tmp_dir / \"analysis.md\"",
        "context": "\ndef test_analyze_store_results_file_exists_force(cwd, tmpdir):\n    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 485,
        "coloffset": 4,
        "linematch": "file.touch()",
        "context": "    tmp_dir = Path(tmpdir)\n    # creates a temporary directory to store markdown file\n    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 487,
        "coloffset": 4,
        "linematch": "assert file.exists()",
        "context": "    file = tmp_dir / \"analysis.md\"\n    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 488,
        "coloffset": 4,
        "linematch": "project_name = \"testing\"",
        "context": "    # creates file if does not exist\n    file.touch()\n    # makes sure the file exists\n    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 491,
        "coloffset": 4,
        "linematch": "configuration_directory = str(cwd) + \"/.chasten\"",
        "context": "    assert file.exists()\n    project_name = \"testing\"\n    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 493,
        "coloffset": 4,
        "linematch": "result = runner.invoke(",
        "context": "    # create a reference to the internal\n    # .chasten directory that supports testing\n    configuration_directory = str(cwd) + \"/.chasten\"\n    # runs the CLI with the specified commands\n    result = runner.invoke(\n        main.cli,\n        [\n            \"analyze\",\n            \"--search-path\",\n            cwd,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 508,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "            \"--force\",\n        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 509,
        "coloffset": 4,
        "linematch": "assert \"\u2728 Results saved in:\" in result.output",
        "context": "        ],\n    )\n    # assert that the code crashes and that the proper message is displayed\n    assert result.exit_code == 0\n    assert \"\u2728 Results saved in:\" in result.output\n\n\n@given(directory=strategies.builds(Path))\n@settings(deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])\n@pytest.mark.fuzz",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_filesystem_constants",
    "function_scope": "12-17",
    "patterns": [
      {
        "lineno": 12,
        "coloffset": 0,
        "linematch": "def test_filesystem_constants():",
        "context": "\nfrom chasten import constants\n\n\ndef test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert constants.filesystem.Current_Directory == \".\"",
        "context": "\n\ndef test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "assert constants.filesystem.Main_Configuration_File == \"config.yml\"",
        "context": "\ndef test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n\n@given(",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "assert constants.humanreadable.Yes == \"Yes\"",
        "context": "def test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n\n@given(\n    directory=strategies.text(),",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "assert constants.humanreadable.No == \"No\"",
        "context": "    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n\n@given(\n    directory=strategies.text(),\n    configfile=strategies.text(),",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm default values of constants.\"\"\"",
        "context": "from chasten import constants\n\n\ndef test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert constants.filesystem.Current_Directory == \".\"",
        "context": "\n\ndef test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "assert constants.filesystem.Main_Configuration_File == \"config.yml\"",
        "context": "\ndef test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n\n@given(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "assert constants.humanreadable.Yes == \"Yes\"",
        "context": "def test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n\n@given(\n    directory=strategies.text(),",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "assert constants.humanreadable.No == \"No\"",
        "context": "    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n\n@given(\n    directory=strategies.text(),\n    configfile=strategies.text(),",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm default values of constants.\"\"\"",
        "context": "from chasten import constants\n\n\ndef test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert constants.filesystem.Current_Directory == \".\"",
        "context": "\n\ndef test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "assert constants.filesystem.Main_Configuration_File == \"config.yml\"",
        "context": "\ndef test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n\n@given(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "assert constants.humanreadable.Yes == \"Yes\"",
        "context": "def test_filesystem_constants():\n    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n\n@given(\n    directory=strategies.text(),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "assert constants.humanreadable.No == \"No\"",
        "context": "    \"\"\"Confirm default values of constants.\"\"\"\n    assert constants.filesystem.Current_Directory == \".\"\n    assert constants.filesystem.Main_Configuration_File == \"config.yml\"\n    assert constants.humanreadable.Yes == \"Yes\"\n    assert constants.humanreadable.No == \"No\"\n\n\n@given(\n    directory=strategies.text(),\n    configfile=strategies.text(),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1360",
        "line": 16,
        "description": [
          "logger: logging.Logger = logging.getLogger()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_fuzz_init",
    "function_scope": "29-37",
    "patterns": [
      {
        "lineno": 29,
        "coloffset": 0,
        "linematch": "def test_fuzz_init(directory, configfile, checksfile, extra, yes, no):  # noqa: PLR0913",
        "context": "    yes=strategies.text(),\n    no=strategies.text(),\n)\n@pytest.mark.fuzz\ndef test_fuzz_init(directory, configfile, checksfile, extra, yes, no):  # noqa: PLR0913\n    \"\"\"Use Hypothesis to confirm that initial value is set correctly.\"\"\"\n    fs = constants.Filesystem(\n        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert fs.Current_Directory == directory",
        "context": "    \"\"\"Use Hypothesis to confirm that initial value is set correctly.\"\"\"\n    fs = constants.Filesystem(\n        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert hr.Yes == yes",
        "context": "        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n\n@given(\n    fs=strategies.builds(constants.Filesystem),",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "assert hr.No == no",
        "context": "    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n\n@given(\n    fs=strategies.builds(constants.Filesystem),\n    hr=strategies.builds(constants.Humanreadable),",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that initial value is set correctly.\"\"\"",
        "context": "    no=strategies.text(),\n)\n@pytest.mark.fuzz\ndef test_fuzz_init(directory, configfile, checksfile, extra, yes, no):  # noqa: PLR0913\n    \"\"\"Use Hypothesis to confirm that initial value is set correctly.\"\"\"\n    fs = constants.Filesystem(\n        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "fs = constants.Filesystem(",
        "context": ")\n@pytest.mark.fuzz\ndef test_fuzz_init(directory, configfile, checksfile, extra, yes, no):  # noqa: PLR0913\n    \"\"\"Use Hypothesis to confirm that initial value is set correctly.\"\"\"\n    fs = constants.Filesystem(\n        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert fs.Current_Directory == directory",
        "context": "    \"\"\"Use Hypothesis to confirm that initial value is set correctly.\"\"\"\n    fs = constants.Filesystem(\n        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "hr = constants.Humanreadable(yes, no)",
        "context": "    fs = constants.Filesystem(\n        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n\n@given(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert hr.Yes == yes",
        "context": "        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n\n@given(\n    fs=strategies.builds(constants.Filesystem),",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "assert hr.No == no",
        "context": "    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n\n@given(\n    fs=strategies.builds(constants.Filesystem),\n    hr=strategies.builds(constants.Humanreadable),",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that initial value is set correctly.\"\"\"",
        "context": "    no=strategies.text(),\n)\n@pytest.mark.fuzz\ndef test_fuzz_init(directory, configfile, checksfile, extra, yes, no):  # noqa: PLR0913\n    \"\"\"Use Hypothesis to confirm that initial value is set correctly.\"\"\"\n    fs = constants.Filesystem(\n        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "fs = constants.Filesystem(",
        "context": ")\n@pytest.mark.fuzz\ndef test_fuzz_init(directory, configfile, checksfile, extra, yes, no):  # noqa: PLR0913\n    \"\"\"Use Hypothesis to confirm that initial value is set correctly.\"\"\"\n    fs = constants.Filesystem(\n        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert fs.Current_Directory == directory",
        "context": "    \"\"\"Use Hypothesis to confirm that initial value is set correctly.\"\"\"\n    fs = constants.Filesystem(\n        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "hr = constants.Humanreadable(yes, no)",
        "context": "    fs = constants.Filesystem(\n        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n\n@given(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert hr.Yes == yes",
        "context": "        directory, configfile, checksfile, extra, extra, extra, extra, extra, extra\n    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n\n@given(\n    fs=strategies.builds(constants.Filesystem),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "assert hr.No == no",
        "context": "    )\n    assert fs.Current_Directory == directory\n    hr = constants.Humanreadable(yes, no)\n    assert hr.Yes == yes\n    assert hr.No == no\n\n\n@given(\n    fs=strategies.builds(constants.Filesystem),\n    hr=strategies.builds(constants.Humanreadable),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_fuzz_immutable",
    "function_scope": "45-52",
    "patterns": [
      {
        "lineno": 45,
        "coloffset": 0,
        "linematch": "def test_fuzz_immutable(fs, hr):",
        "context": "    fs=strategies.builds(constants.Filesystem),\n    hr=strategies.builds(constants.Humanreadable),\n)\n@pytest.mark.fuzz\ndef test_fuzz_immutable(fs, hr):\n    \"\"\"Use Hypothesis to confirm that attribute's value cannot be re-assigned.\"\"\"\n    with pytest.raises(FrozenInstanceError):\n        fs.Current_Directory = str(Path(\"/new\") / Path(\"path\"))\n    with pytest.raises(FrozenInstanceError):\n        hr.Yes = \"YES\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that attribute's value cannot be re-assigned.\"\"\"",
        "context": "    hr=strategies.builds(constants.Humanreadable),\n)\n@pytest.mark.fuzz\ndef test_fuzz_immutable(fs, hr):\n    \"\"\"Use Hypothesis to confirm that attribute's value cannot be re-assigned.\"\"\"\n    with pytest.raises(FrozenInstanceError):\n        fs.Current_Directory = str(Path(\"/new\") / Path(\"path\"))\n    with pytest.raises(FrozenInstanceError):\n        hr.Yes = \"YES\"\n    with pytest.raises(FrozenInstanceError):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "with pytest.raises(FrozenInstanceError):",
        "context": ")\n@pytest.mark.fuzz\ndef test_fuzz_immutable(fs, hr):\n    \"\"\"Use Hypothesis to confirm that attribute's value cannot be re-assigned.\"\"\"\n    with pytest.raises(FrozenInstanceError):\n        fs.Current_Directory = str(Path(\"/new\") / Path(\"path\"))\n    with pytest.raises(FrozenInstanceError):\n        hr.Yes = \"YES\"\n    with pytest.raises(FrozenInstanceError):\n        hr.No = \"NO\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "with pytest.raises(FrozenInstanceError):",
        "context": "def test_fuzz_immutable(fs, hr):\n    \"\"\"Use Hypothesis to confirm that attribute's value cannot be re-assigned.\"\"\"\n    with pytest.raises(FrozenInstanceError):\n        fs.Current_Directory = str(Path(\"/new\") / Path(\"path\"))\n    with pytest.raises(FrozenInstanceError):\n        hr.Yes = \"YES\"\n    with pytest.raises(FrozenInstanceError):\n        hr.No = \"NO\"\n\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "with pytest.raises(FrozenInstanceError):",
        "context": "    with pytest.raises(FrozenInstanceError):\n        fs.Current_Directory = str(Path(\"/new\") / Path(\"path\"))\n    with pytest.raises(FrozenInstanceError):\n        hr.Yes = \"YES\"\n    with pytest.raises(FrozenInstanceError):\n        hr.No = \"NO\"\n\n\n@given(\n    dir1=strategies.text(),",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that attribute's value cannot be re-assigned.\"\"\"",
        "context": "    hr=strategies.builds(constants.Humanreadable),\n)\n@pytest.mark.fuzz\ndef test_fuzz_immutable(fs, hr):\n    \"\"\"Use Hypothesis to confirm that attribute's value cannot be re-assigned.\"\"\"\n    with pytest.raises(FrozenInstanceError):\n        fs.Current_Directory = str(Path(\"/new\") / Path(\"path\"))\n    with pytest.raises(FrozenInstanceError):\n        hr.Yes = \"YES\"\n    with pytest.raises(FrozenInstanceError):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "with pytest.raises(FrozenInstanceError):",
        "context": ")\n@pytest.mark.fuzz\ndef test_fuzz_immutable(fs, hr):\n    \"\"\"Use Hypothesis to confirm that attribute's value cannot be re-assigned.\"\"\"\n    with pytest.raises(FrozenInstanceError):\n        fs.Current_Directory = str(Path(\"/new\") / Path(\"path\"))\n    with pytest.raises(FrozenInstanceError):\n        hr.Yes = \"YES\"\n    with pytest.raises(FrozenInstanceError):\n        hr.No = \"NO\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "with pytest.raises(FrozenInstanceError):",
        "context": "def test_fuzz_immutable(fs, hr):\n    \"\"\"Use Hypothesis to confirm that attribute's value cannot be re-assigned.\"\"\"\n    with pytest.raises(FrozenInstanceError):\n        fs.Current_Directory = str(Path(\"/new\") / Path(\"path\"))\n    with pytest.raises(FrozenInstanceError):\n        hr.Yes = \"YES\"\n    with pytest.raises(FrozenInstanceError):\n        hr.No = \"NO\"\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "with pytest.raises(FrozenInstanceError):",
        "context": "    with pytest.raises(FrozenInstanceError):\n        fs.Current_Directory = str(Path(\"/new\") / Path(\"path\"))\n    with pytest.raises(FrozenInstanceError):\n        hr.Yes = \"YES\"\n    with pytest.raises(FrozenInstanceError):\n        hr.No = \"NO\"\n\n\n@given(\n    dir1=strategies.text(),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_fuzz_dataclass_equality",
    "function_scope": "78-89",
    "patterns": [
      {
        "lineno": 78,
        "coloffset": 0,
        "linematch": "def test_fuzz_dataclass_equality(directory, filename, extra):",
        "context": "\n\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):\n    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 82,
        "coloffset": 4,
        "linematch": "assert dir1 == dir2",
        "context": "def test_fuzz_dataclass_equality(directory, filename, extra):\n    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 89,
        "coloffset": 4,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    assert fs1 == fs2",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 79,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"",
        "context": "\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):\n    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 80,
        "coloffset": 4,
        "linematch": "dir1 = directory",
        "context": "@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):\n    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 81,
        "coloffset": 4,
        "linematch": "dir2 = directory",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):\n    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 82,
        "coloffset": 4,
        "linematch": "assert dir1 == dir2",
        "context": "def test_fuzz_dataclass_equality(directory, filename, extra):\n    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "fs1 = constants.Filesystem(",
        "context": "    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 86,
        "coloffset": 4,
        "linematch": "fs2 = constants.Filesystem(",
        "context": "    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    assert fs1 == fs2",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 89,
        "coloffset": 4,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    assert fs1 == fs2",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 79,
        "coloffset": 4,
        "linematch": "\"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"",
        "context": "\n@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):\n    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 80,
        "coloffset": 4,
        "linematch": "dir1 = directory",
        "context": "@given(directory=strategies.text(), filename=strategies.text(), extra=strategies.text())\n@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):\n    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 81,
        "coloffset": 4,
        "linematch": "dir2 = directory",
        "context": "@pytest.mark.fuzz\ndef test_fuzz_dataclass_equality(directory, filename, extra):\n    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 82,
        "coloffset": 4,
        "linematch": "assert dir1 == dir2",
        "context": "def test_fuzz_dataclass_equality(directory, filename, extra):\n    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "fs1 = constants.Filesystem(",
        "context": "    \"\"\"Use Hypothesis to confirm that the same directory makes the same constant.\"\"\"\n    dir1 = directory\n    dir2 = directory\n    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 86,
        "coloffset": 4,
        "linematch": "fs2 = constants.Filesystem(",
        "context": "    assert dir1 == dir2\n    fs1 = constants.Filesystem(\n        dir1, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    assert fs1 == fs2",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 89,
        "coloffset": 4,
        "linematch": "assert fs1 == fs2",
        "context": "    )\n    fs2 = constants.Filesystem(\n        dir2, filename, filename, extra, extra, extra, extra, extra, extra\n    )\n    assert fs1 == fs2",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "configure_tracebacks",
    "function_scope": "20-22",
    "patterns": [
      {
        "lineno": 20,
        "coloffset": 0,
        "linematch": "def configure_tracebacks() -> None:",
        "context": "\nfrom chasten import constants, filesystem, output, util, validate\n\n\ndef configure_tracebacks() -> None:\n    \"\"\"Configure stack tracebacks arising from a crash to use rich.\"\"\"\n    install()\n\n\ndef user_config_dir(application_name: str, application_author: str) -> str:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 20,
        "coloffset": 0,
        "linematch": "def configure_tracebacks() -> None:",
        "context": "\nfrom chasten import constants, filesystem, output, util, validate\n\n\ndef configure_tracebacks() -> None:\n    \"\"\"Configure stack tracebacks arising from a crash to use rich.\"\"\"\n    install()\n\n\ndef user_config_dir(application_name: str, application_author: str) -> str:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "\"\"\"Configure stack tracebacks arising from a crash to use rich.\"\"\"",
        "context": "from chasten import constants, filesystem, output, util, validate\n\n\ndef configure_tracebacks() -> None:\n    \"\"\"Configure stack tracebacks arising from a crash to use rich.\"\"\"\n    install()\n\n\ndef user_config_dir(application_name: str, application_author: str) -> str:\n    \"\"\"Return the user's configuration directory using platformdirs.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "install()",
        "context": "\n\ndef configure_tracebacks() -> None:\n    \"\"\"Configure stack tracebacks arising from a crash to use rich.\"\"\"\n    install()\n\n\ndef user_config_dir(application_name: str, application_author: str) -> str:\n    \"\"\"Return the user's configuration directory using platformdirs.\"\"\"\n    # access the directory and then return it based on the",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "user_config_dir",
    "function_scope": "25-30",
    "patterns": [
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def user_config_dir(application_name: str, application_author: str) -> str:",
        "context": "    \"\"\"Configure stack tracebacks arising from a crash to use rich.\"\"\"\n    install()\n\n\ndef user_config_dir(application_name: str, application_author: str) -> str:\n    \"\"\"Return the user's configuration directory using platformdirs.\"\"\"\n    # access the directory and then return it based on the\n    # provided name of the application and the application's author\n    chasten_user_config_dir_str = None\n    return chasten_user_config_dir_str",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def user_config_dir(application_name: str, application_author: str) -> str:",
        "context": "    \"\"\"Configure stack tracebacks arising from a crash to use rich.\"\"\"\n    install()\n\n\ndef user_config_dir(application_name: str, application_author: str) -> str:\n    \"\"\"Return the user's configuration directory using platformdirs.\"\"\"\n    # access the directory and then return it based on the\n    # provided name of the application and the application's author\n    chasten_user_config_dir_str = None\n    return chasten_user_config_dir_str",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "\"\"\"Return the user's configuration directory using platformdirs.\"\"\"",
        "context": "    install()\n\n\ndef user_config_dir(application_name: str, application_author: str) -> str:\n    \"\"\"Return the user's configuration directory using platformdirs.\"\"\"\n    # access the directory and then return it based on the\n    # provided name of the application and the application's author\n    chasten_user_config_dir_str = None\n    return chasten_user_config_dir_str\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "chasten_user_config_dir_str = None",
        "context": "def user_config_dir(application_name: str, application_author: str) -> str:\n    \"\"\"Return the user's configuration directory using platformdirs.\"\"\"\n    # access the directory and then return it based on the\n    # provided name of the application and the application's author\n    chasten_user_config_dir_str = None\n    return chasten_user_config_dir_str\n\n\ndef configure_logging(\n    debug_level: str = constants.logging.Default_Logging_Level,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "return chasten_user_config_dir_str",
        "context": "    \"\"\"Return the user's configuration directory using platformdirs.\"\"\"\n    # access the directory and then return it based on the\n    # provided name of the application and the application's author\n    chasten_user_config_dir_str = None\n    return chasten_user_config_dir_str\n\n\ndef configure_logging(\n    debug_level: str = constants.logging.Default_Logging_Level,\n    debug_dest: str = constants.logging.Default_Logging_Destination,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "configure_logging",
    "function_scope": "33-50",
    "patterns": [
      {
        "lineno": 33,
        "coloffset": 0,
        "linematch": "def configure_logging(",
        "context": "    chasten_user_config_dir_str = None\n    return chasten_user_config_dir_str\n\n\ndef configure_logging(\n    debug_level: str = constants.logging.Default_Logging_Level,\n    debug_dest: str = constants.logging.Default_Logging_Destination,\n) -> Tuple[logging.Logger, bool]:\n    \"\"\"Configure standard Python logging package.\"\"\"\n    # use the specified logger with the specified destination",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 33,
        "coloffset": 0,
        "linematch": "def configure_logging(",
        "context": "    chasten_user_config_dir_str = None\n    return chasten_user_config_dir_str\n\n\ndef configure_logging(\n    debug_level: str = constants.logging.Default_Logging_Level,\n    debug_dest: str = constants.logging.Default_Logging_Destination,\n) -> Tuple[logging.Logger, bool]:\n    \"\"\"Configure standard Python logging package.\"\"\"\n    # use the specified logger with the specified destination",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "\"\"\"Configure standard Python logging package.\"\"\"",
        "context": "def configure_logging(\n    debug_level: str = constants.logging.Default_Logging_Level,\n    debug_dest: str = constants.logging.Default_Logging_Destination,\n) -> Tuple[logging.Logger, bool]:\n    \"\"\"Configure standard Python logging package.\"\"\"\n    # use the specified logger with the specified destination\n    # by dynamically constructing the function to call and then\n    # invoking it with the provided debug_dest parameter\n    debug_dest = debug_dest.lower()\n    function_name = constants.logger.Function_Prefix + debug_dest",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "debug_dest = debug_dest.lower()",
        "context": "    \"\"\"Configure standard Python logging package.\"\"\"\n    # use the specified logger with the specified destination\n    # by dynamically constructing the function to call and then\n    # invoking it with the provided debug_dest parameter\n    debug_dest = debug_dest.lower()\n    function_name = constants.logger.Function_Prefix + debug_dest\n    configure_module = sys.modules[__name__]\n    # it was possible to create the requested logger, so return it\n    try:\n        return (getattr(configure_module, function_name)(debug_level), True)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "function_name = constants.logger.Function_Prefix + debug_dest",
        "context": "    # use the specified logger with the specified destination\n    # by dynamically constructing the function to call and then\n    # invoking it with the provided debug_dest parameter\n    debug_dest = debug_dest.lower()\n    function_name = constants.logger.Function_Prefix + debug_dest\n    configure_module = sys.modules[__name__]\n    # it was possible to create the requested logger, so return it\n    try:\n        return (getattr(configure_module, function_name)(debug_level), True)\n    # it was not possible to create the requested logger, so",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "configure_module = sys.modules[__name__]",
        "context": "    # by dynamically constructing the function to call and then\n    # invoking it with the provided debug_dest parameter\n    debug_dest = debug_dest.lower()\n    function_name = constants.logger.Function_Prefix + debug_dest\n    configure_module = sys.modules[__name__]\n    # it was possible to create the requested logger, so return it\n    try:\n        return (getattr(configure_module, function_name)(debug_level), True)\n    # it was not possible to create the requested logger, so\n    # return the default console logger as a safe alternative",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "try:",
        "context": "    debug_dest = debug_dest.lower()\n    function_name = constants.logger.Function_Prefix + debug_dest\n    configure_module = sys.modules[__name__]\n    # it was possible to create the requested logger, so return it\n    try:\n        return (getattr(configure_module, function_name)(debug_level), True)\n    # it was not possible to create the requested logger, so\n    # return the default console logger as a safe alternative\n    except AttributeError:\n        return (configure_logging_console(debug_level), False)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "configure_logging_console",
    "function_scope": "53-67",
    "patterns": [
      {
        "lineno": 53,
        "coloffset": 0,
        "linematch": "def configure_logging_console(",
        "context": "    except AttributeError:\n        return (configure_logging_console(debug_level), False)\n\n\ndef configure_logging_console(\n    debug_level: str = constants.logging.Default_Logging_Level,\n) -> logging.Logger:\n    \"\"\"Configure standard Python logging package to use rich.\"\"\"\n    # use the RichHandler to provide formatted\n    # debugging output in the console",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 53,
        "coloffset": 0,
        "linematch": "def configure_logging_console(",
        "context": "    except AttributeError:\n        return (configure_logging_console(debug_level), False)\n\n\ndef configure_logging_console(\n    debug_level: str = constants.logging.Default_Logging_Level,\n) -> logging.Logger:\n    \"\"\"Configure standard Python logging package to use rich.\"\"\"\n    # use the RichHandler to provide formatted\n    # debugging output in the console",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "\"\"\"Configure standard Python logging package to use rich.\"\"\"",
        "context": "\ndef configure_logging_console(\n    debug_level: str = constants.logging.Default_Logging_Level,\n) -> logging.Logger:\n    \"\"\"Configure standard Python logging package to use rich.\"\"\"\n    # use the RichHandler to provide formatted\n    # debugging output in the console\n    logging.basicConfig(\n        level=debug_level,\n        format=constants.logging.Format,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 4,
        "linematch": "logging.basicConfig(",
        "context": ") -> logging.Logger:\n    \"\"\"Configure standard Python logging package to use rich.\"\"\"\n    # use the RichHandler to provide formatted\n    # debugging output in the console\n    logging.basicConfig(\n        level=debug_level,\n        format=constants.logging.Format,\n        datefmt=\"[%X]\",\n        handlers=[RichHandler()],\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 66,
        "coloffset": 4,
        "linematch": "logger = logging.getLogger()",
        "context": "        datefmt=\"[%X]\",\n        handlers=[RichHandler()],\n    )\n    # create a logger and then return it\n    logger = logging.getLogger()\n    return logger\n\n\ndef configure_logging_syslog(\n    debug_level: str = constants.logging.Default_Logging_Level,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 67,
        "coloffset": 4,
        "linematch": "return logger",
        "context": "        handlers=[RichHandler()],\n    )\n    # create a logger and then return it\n    logger = logging.getLogger()\n    return logger\n\n\ndef configure_logging_syslog(\n    debug_level: str = constants.logging.Default_Logging_Level,\n) -> logging.Logger:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "configure_logging_syslog",
    "function_scope": "70-86",
    "patterns": [
      {
        "lineno": 70,
        "coloffset": 0,
        "linematch": "def configure_logging_syslog(",
        "context": "    logger = logging.getLogger()\n    return logger\n\n\ndef configure_logging_syslog(\n    debug_level: str = constants.logging.Default_Logging_Level,\n) -> logging.Logger:\n    \"\"\"Configure standard Python logging package to use syslog.\"\"\"\n    # use the SysLogHandler to send output to a localhost on a port\n    syslog_handler = logging.handlers.SysLogHandler(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 70,
        "coloffset": 0,
        "linematch": "def configure_logging_syslog(",
        "context": "    logger = logging.getLogger()\n    return logger\n\n\ndef configure_logging_syslog(\n    debug_level: str = constants.logging.Default_Logging_Level,\n) -> logging.Logger:\n    \"\"\"Configure standard Python logging package to use syslog.\"\"\"\n    # use the SysLogHandler to send output to a localhost on a port\n    syslog_handler = logging.handlers.SysLogHandler(",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 73,
        "coloffset": 4,
        "linematch": "\"\"\"Configure standard Python logging package to use syslog.\"\"\"",
        "context": "\ndef configure_logging_syslog(\n    debug_level: str = constants.logging.Default_Logging_Level,\n) -> logging.Logger:\n    \"\"\"Configure standard Python logging package to use syslog.\"\"\"\n    # use the SysLogHandler to send output to a localhost on a port\n    syslog_handler = logging.handlers.SysLogHandler(\n        address=(constants.server.Localhost, constants.server.Port)\n    )\n    logging.basicConfig(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 75,
        "coloffset": 4,
        "linematch": "syslog_handler = logging.handlers.SysLogHandler(",
        "context": "    debug_level: str = constants.logging.Default_Logging_Level,\n) -> logging.Logger:\n    \"\"\"Configure standard Python logging package to use syslog.\"\"\"\n    # use the SysLogHandler to send output to a localhost on a port\n    syslog_handler = logging.handlers.SysLogHandler(\n        address=(constants.server.Localhost, constants.server.Port)\n    )\n    logging.basicConfig(\n        level=debug_level,\n        format=constants.logging.Format,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "logging.basicConfig(",
        "context": "    # use the SysLogHandler to send output to a localhost on a port\n    syslog_handler = logging.handlers.SysLogHandler(\n        address=(constants.server.Localhost, constants.server.Port)\n    )\n    logging.basicConfig(\n        level=debug_level,\n        format=constants.logging.Format,\n        datefmt=\"[%X]\",\n        handlers=[syslog_handler],\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 85,
        "coloffset": 4,
        "linematch": "logger = logging.getLogger()",
        "context": "        datefmt=\"[%X]\",\n        handlers=[syslog_handler],\n    )\n    # create a logger and then return it\n    logger = logging.getLogger()\n    return logger\n\n\ndef display_configuration_directory(\n    chasten_user_config_dir_str: str, verbose: bool = False",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 86,
        "coloffset": 4,
        "linematch": "return logger",
        "context": "        handlers=[syslog_handler],\n    )\n    # create a logger and then return it\n    logger = logging.getLogger()\n    return logger\n\n\ndef display_configuration_directory(\n    chasten_user_config_dir_str: str, verbose: bool = False\n) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "display_configuration_directory",
    "function_scope": "89-100",
    "patterns": [
      {
        "lineno": 89,
        "coloffset": 0,
        "linematch": "def display_configuration_directory(",
        "context": "    logger = logging.getLogger()\n    return logger\n\n\ndef display_configuration_directory(\n    chasten_user_config_dir_str: str, verbose: bool = False\n) -> None:\n    \"\"\"Display information about the configuration in the console.\"\"\"\n    # create a visualization of the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 89,
        "coloffset": 0,
        "linematch": "def display_configuration_directory(",
        "context": "    logger = logging.getLogger()\n    return logger\n\n\ndef display_configuration_directory(\n    chasten_user_config_dir_str: str, verbose: bool = False\n) -> None:\n    \"\"\"Display information about the configuration in the console.\"\"\"\n    # create a visualization of the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 92,
        "coloffset": 4,
        "linematch": "\"\"\"Display information about the configuration in the console.\"\"\"",
        "context": "\ndef display_configuration_directory(\n    chasten_user_config_dir_str: str, verbose: bool = False\n) -> None:\n    \"\"\"Display information about the configuration in the console.\"\"\"\n    # create a visualization of the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    rich_path_tree = filesystem.create_directory_tree_visualization(\n        chasten_user_config_dir_path\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "chasten_user_config_dir_path = Path(chasten_user_config_dir_str)",
        "context": "    chasten_user_config_dir_str: str, verbose: bool = False\n) -> None:\n    \"\"\"Display information about the configuration in the console.\"\"\"\n    # create a visualization of the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    rich_path_tree = filesystem.create_directory_tree_visualization(\n        chasten_user_config_dir_path\n    )\n    # display the visualization of the configuration directory\n    output.opt_print_log(verbose, tree=rich_path_tree)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 95,
        "coloffset": 4,
        "linematch": "rich_path_tree = filesystem.create_directory_tree_visualization(",
        "context": ") -> None:\n    \"\"\"Display information about the configuration in the console.\"\"\"\n    # create a visualization of the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    rich_path_tree = filesystem.create_directory_tree_visualization(\n        chasten_user_config_dir_path\n    )\n    # display the visualization of the configuration directory\n    output.opt_print_log(verbose, tree=rich_path_tree)\n    output.opt_print_log(verbose, empty=\"\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "output.opt_print_log(verbose, tree=rich_path_tree)",
        "context": "    rich_path_tree = filesystem.create_directory_tree_visualization(\n        chasten_user_config_dir_path\n    )\n    # display the visualization of the configuration directory\n    output.opt_print_log(verbose, tree=rich_path_tree)\n    output.opt_print_log(verbose, empty=\"\")\n\n\ndef validate_checks_file(\n    verbose: bool,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 100,
        "coloffset": 4,
        "linematch": "output.opt_print_log(verbose, empty=\"\")",
        "context": "        chasten_user_config_dir_path\n    )\n    # display the visualization of the configuration directory\n    output.opt_print_log(verbose, tree=rich_path_tree)\n    output.opt_print_log(verbose, empty=\"\")\n\n\ndef validate_checks_file(\n    verbose: bool,\n    checks_file_name: str,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1365",
        "line": 95,
        "description": [
          "    console.print(\":sparkles: Finished running test suite for the specified program\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "convert_configuration_text_to_yaml",
    "function_scope": "415-427",
    "patterns": [
      {
        "lineno": 415,
        "coloffset": 0,
        "linematch": "def convert_configuration_text_to_yaml(",
        "context": "        )\n        return (False, None, None)  # type: ignore\n\n\ndef convert_configuration_text_to_yaml(\n    configuration_file_contents_str: str,\n) -> Tuple[bool, Dict[str, Dict[str, Any]]]:\n    \"\"\"Return details about the configuration.\"\"\"\n    yaml_data = None\n    try:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 415,
        "coloffset": 0,
        "linematch": "def convert_configuration_text_to_yaml(",
        "context": "        )\n        return (False, None, None)  # type: ignore\n\n\ndef convert_configuration_text_to_yaml(\n    configuration_file_contents_str: str,\n) -> Tuple[bool, Dict[str, Dict[str, Any]]]:\n    \"\"\"Return details about the configuration.\"\"\"\n    yaml_data = None\n    try:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 418,
        "coloffset": 4,
        "linematch": "\"\"\"Return details about the configuration.\"\"\"",
        "context": "\ndef convert_configuration_text_to_yaml(\n    configuration_file_contents_str: str,\n) -> Tuple[bool, Dict[str, Dict[str, Any]]]:\n    \"\"\"Return details about the configuration.\"\"\"\n    yaml_data = None\n    try:\n        yaml_data = yaml.safe_load(configuration_file_contents_str)\n    except Exception:\n        # yaml parsing has failed and we will indicate the input is invalid",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 419,
        "coloffset": 4,
        "linematch": "yaml_data = None",
        "context": "def convert_configuration_text_to_yaml(\n    configuration_file_contents_str: str,\n) -> Tuple[bool, Dict[str, Dict[str, Any]]]:\n    \"\"\"Return details about the configuration.\"\"\"\n    yaml_data = None\n    try:\n        yaml_data = yaml.safe_load(configuration_file_contents_str)\n    except Exception:\n        # yaml parsing has failed and we will indicate the input is invalid\n        return (False, None)  # type: ignore",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 420,
        "coloffset": 4,
        "linematch": "try:",
        "context": "    configuration_file_contents_str: str,\n) -> Tuple[bool, Dict[str, Dict[str, Any]]]:\n    \"\"\"Return details about the configuration.\"\"\"\n    yaml_data = None\n    try:\n        yaml_data = yaml.safe_load(configuration_file_contents_str)\n    except Exception:\n        # yaml parsing has failed and we will indicate the input is invalid\n        return (False, None)  # type: ignore\n    # return the file name, the textual contents of the configuration file, and",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 427,
        "coloffset": 4,
        "linematch": "return (True, yaml_data)",
        "context": "        # yaml parsing has failed and we will indicate the input is invalid\n        return (False, None)  # type: ignore\n    # return the file name, the textual contents of the configuration file, and\n    # a dict-based representation of the configuration file\n    return (True, yaml_data)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "start_syslog_server",
    "function_scope": "39-67",
    "patterns": [
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def start_syslog_server():",
        "context": "        # write the logging message to a file using a rotating file handler\n        logger.debug(enhanced_message)\n\n\ndef start_syslog_server():\n    \"\"\"Start a syslog server.\"\"\"\n    global logger  # noqa: PLW0602\n    # always log all of the messages to a file\n    logger.setLevel(logging.DEBUG)\n    # create a RotatingFileHandler such that:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "\"\"\"Start a syslog server.\"\"\"",
        "context": "        logger.debug(enhanced_message)\n\n\ndef start_syslog_server():\n    \"\"\"Start a syslog server.\"\"\"\n    global logger  # noqa: PLW0602\n    # always log all of the messages to a file\n    logger.setLevel(logging.DEBUG)\n    # create a RotatingFileHandler such that:\n    # -- it is stored in a file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "global logger  # noqa: PLW0602",
        "context": "\n\ndef start_syslog_server():\n    \"\"\"Start a syslog server.\"\"\"\n    global logger  # noqa: PLW0602\n    # always log all of the messages to a file\n    logger.setLevel(logging.DEBUG)\n    # create a RotatingFileHandler such that:\n    # -- it is stored in a file\n    # -- it can never be bigger than 1 MB",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "logger.setLevel(logging.DEBUG)",
        "context": "def start_syslog_server():\n    \"\"\"Start a syslog server.\"\"\"\n    global logger  # noqa: PLW0602\n    # always log all of the messages to a file\n    logger.setLevel(logging.DEBUG)\n    # create a RotatingFileHandler such that:\n    # -- it is stored in a file\n    # -- it can never be bigger than 1 MB\n    # -- one backup is created when log file gets too big\n    rotating_file_handler = logging.handlers.RotatingFileHandler(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "rotating_file_handler = logging.handlers.RotatingFileHandler(",
        "context": "    # create a RotatingFileHandler such that:\n    # -- it is stored in a file\n    # -- it can never be bigger than 1 MB\n    # -- one backup is created when log file gets too big\n    rotating_file_handler = logging.handlers.RotatingFileHandler(\n        LOG_FILE,\n        maxBytes=constants.server.Max_Log_Size,\n        backupCount=constants.server.Backup_Count,\n    )\n    # add the rotating file handler to the logger",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 54,
        "coloffset": 4,
        "linematch": "logger.addHandler(rotating_file_handler)",
        "context": "        maxBytes=constants.server.Max_Log_Size,\n        backupCount=constants.server.Backup_Count,\n    )\n    # add the rotating file handler to the logger\n    logger.addHandler(rotating_file_handler)\n    # startup the server and then let it run forever\n    try:\n        server = socketserver.UDPServer((HOST, PORT), SyslogUDPHandler)\n        server.serve_forever(poll_interval=constants.server.Poll_Interval)\n    # let the server crash and raise an error on SystemExit and IOError",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "try:",
        "context": "    )\n    # add the rotating file handler to the logger\n    logger.addHandler(rotating_file_handler)\n    # startup the server and then let it run forever\n    try:\n        server = socketserver.UDPServer((HOST, PORT), SyslogUDPHandler)\n        server.serve_forever(poll_interval=constants.server.Poll_Interval)\n    # let the server crash and raise an error on SystemExit and IOError\n    except SystemExit:\n        raise",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "global logger  # noqa: PLW0602",
        "context": "\n\ndef start_syslog_server():\n    \"\"\"Start a syslog server.\"\"\"\n    global logger  # noqa: PLW0602\n    # always log all of the messages to a file\n    logger.setLevel(logging.DEBUG)\n    # create a RotatingFileHandler such that:\n    # -- it is stored in a file\n    # -- it can never be bigger than 1 MB",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "handle",
    "function_scope": "19-36",
    "patterns": [
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "def handle(self):",
        "context": "\nclass SyslogUDPHandler(socketserver.BaseRequestHandler):\n    \"\"\"Syslog UDP handler for receiving debugging messages.\"\"\"\n\n    def handle(self):\n        \"\"\"Receive a message and then display it in output and log it to a file.\"\"\"\n        global logger  # noqa: PLW0602\n        # receive the message from the syslog logging client\n        message = bytes.decode(\n            self.request[0].strip(), encoding=constants.server.Utf8_Encoding",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 20,
        "coloffset": 8,
        "linematch": "\"\"\"Receive a message and then display it in output and log it to a file.\"\"\"",
        "context": "class SyslogUDPHandler(socketserver.BaseRequestHandler):\n    \"\"\"Syslog UDP handler for receiving debugging messages.\"\"\"\n\n    def handle(self):\n        \"\"\"Receive a message and then display it in output and log it to a file.\"\"\"\n        global logger  # noqa: PLW0602\n        # receive the message from the syslog logging client\n        message = bytes.decode(\n            self.request[0].strip(), encoding=constants.server.Utf8_Encoding\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 8,
        "linematch": "global logger  # noqa: PLW0602",
        "context": "    \"\"\"Syslog UDP handler for receiving debugging messages.\"\"\"\n\n    def handle(self):\n        \"\"\"Receive a message and then display it in output and log it to a file.\"\"\"\n        global logger  # noqa: PLW0602\n        # receive the message from the syslog logging client\n        message = bytes.decode(\n            self.request[0].strip(), encoding=constants.server.Utf8_Encoding\n        )\n        # remove not-printable characters that can appear in message",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 8,
        "linematch": "message = bytes.decode(",
        "context": "    def handle(self):\n        \"\"\"Receive a message and then display it in output and log it to a file.\"\"\"\n        global logger  # noqa: PLW0602\n        # receive the message from the syslog logging client\n        message = bytes.decode(\n            self.request[0].strip(), encoding=constants.server.Utf8_Encoding\n        )\n        # remove not-printable characters that can appear in message\n        enhanced_message = str(message).replace(\n            constants.markers.Bad_Fifteen, constants.markers.Empty_String",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 8,
        "linematch": "enhanced_message = str(message).replace(",
        "context": "        message = bytes.decode(\n            self.request[0].strip(), encoding=constants.server.Utf8_Encoding\n        )\n        # remove not-printable characters that can appear in message\n        enhanced_message = str(message).replace(\n            constants.markers.Bad_Fifteen, constants.markers.Empty_String\n        )\n        enhanced_message = enhanced_message.replace(\n            constants.markers.Bad_Zero_Zero, constants.markers.Empty_String\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 8,
        "linematch": "enhanced_message = enhanced_message.replace(",
        "context": "        # remove not-printable characters that can appear in message\n        enhanced_message = str(message).replace(\n            constants.markers.Bad_Fifteen, constants.markers.Empty_String\n        )\n        enhanced_message = enhanced_message.replace(\n            constants.markers.Bad_Zero_Zero, constants.markers.Empty_String\n        )\n        # display the message inside of the syslog's console\n        output.console.print(enhanced_message)\n        # write the logging message to a file using a rotating file handler",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 8,
        "linematch": "output.console.print(enhanced_message)",
        "context": "        enhanced_message = enhanced_message.replace(\n            constants.markers.Bad_Zero_Zero, constants.markers.Empty_String\n        )\n        # display the message inside of the syslog's console\n        output.console.print(enhanced_message)\n        # write the logging message to a file using a rotating file handler\n        logger.debug(enhanced_message)\n\n\ndef start_syslog_server():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 8,
        "linematch": "logger.debug(enhanced_message)",
        "context": "        )\n        # display the message inside of the syslog's console\n        output.console.print(enhanced_message)\n        # write the logging message to a file using a rotating file handler\n        logger.debug(enhanced_message)\n\n\ndef start_syslog_server():\n    \"\"\"Start a syslog server.\"\"\"\n    global logger  # noqa: PLW0602",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 8,
        "linematch": "global logger  # noqa: PLW0602",
        "context": "    \"\"\"Syslog UDP handler for receiving debugging messages.\"\"\"\n\n    def handle(self):\n        \"\"\"Receive a message and then display it in output and log it to a file.\"\"\"\n        global logger  # noqa: PLW0602\n        # receive the message from the syslog logging client\n        message = bytes.decode(\n            self.request[0].strip(), encoding=constants.server.Utf8_Encoding\n        )\n        # remove not-printable characters that can appear in message",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #299",
        "line": 19,
        "description": [
          "console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #300",
        "line": 22,
        "description": [
          "small_bullet_unicode = constants.markers.Small_Bullet_Unicode"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "get_OS",
    "function_scope": "25-28",
    "patterns": [
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def get_OS() -> str:",
        "context": "    # the provided answer is false\n    return constants.humanreadable.No\n\n\ndef get_OS() -> str:\n    \"\"\"Gets the Operating system of the user.\"\"\"\n    OpSystem = platform.system()\n    return OpSystem\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def get_OS() -> str:",
        "context": "    # the provided answer is false\n    return constants.humanreadable.No\n\n\ndef get_OS() -> str:\n    \"\"\"Gets the Operating system of the user.\"\"\"\n    OpSystem = platform.system()\n    return OpSystem\n\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "\"\"\"Gets the Operating system of the user.\"\"\"",
        "context": "    return constants.humanreadable.No\n\n\ndef get_OS() -> str:\n    \"\"\"Gets the Operating system of the user.\"\"\"\n    OpSystem = platform.system()\n    return OpSystem\n\n\ndef executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "OpSystem = platform.system()",
        "context": "\n\ndef get_OS() -> str:\n    \"\"\"Gets the Operating system of the user.\"\"\"\n    OpSystem = platform.system()\n    return OpSystem\n\n\ndef executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:\n    \"\"\"Get the executable directory depending on OS\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "return OpSystem",
        "context": "\ndef get_OS() -> str:\n    \"\"\"Gets the Operating system of the user.\"\"\"\n    OpSystem = platform.system()\n    return OpSystem\n\n\ndef executable_name(executable_name: str, OpSystem: str = \"Linux\") -> str:\n    \"\"\"Get the executable directory depending on OS\"\"\"\n    exe_directory = \"/bin/\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "get_chasten_version",
    "function_scope": "49-65",
    "patterns": [
      {
        "lineno": 49,
        "coloffset": 0,
        "linematch": "def get_chasten_version() -> str:",
        "context": "        return f\"[green]{checkmark_unicode}[/green]\"\n    return f\"[red]{xmark_unicode}[/red]\"\n\n\ndef get_chasten_version() -> str:\n    \"\"\"Use importlib to extract the version of the package.\"\"\"\n    # attempt to determine the current version of the entire package,\n    # bearing in mind that this program appears on PyPI with the name \"chasten\";\n    # this will then return the version string specified with the version attribute\n    # in the [tool.poetry] section of the pyproject.toml file",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 49,
        "coloffset": 0,
        "linematch": "def get_chasten_version() -> str:",
        "context": "        return f\"[green]{checkmark_unicode}[/green]\"\n    return f\"[red]{xmark_unicode}[/red]\"\n\n\ndef get_chasten_version() -> str:\n    \"\"\"Use importlib to extract the version of the package.\"\"\"\n    # attempt to determine the current version of the entire package,\n    # bearing in mind that this program appears on PyPI with the name \"chasten\";\n    # this will then return the version string specified with the version attribute\n    # in the [tool.poetry] section of the pyproject.toml file",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "\"\"\"Use importlib to extract the version of the package.\"\"\"",
        "context": "    return f\"[red]{xmark_unicode}[/red]\"\n\n\ndef get_chasten_version() -> str:\n    \"\"\"Use importlib to extract the version of the package.\"\"\"\n    # attempt to determine the current version of the entire package,\n    # bearing in mind that this program appears on PyPI with the name \"chasten\";\n    # this will then return the version string specified with the version attribute\n    # in the [tool.poetry] section of the pyproject.toml file\n    try:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "try:",
        "context": "    # attempt to determine the current version of the entire package,\n    # bearing in mind that this program appears on PyPI with the name \"chasten\";\n    # this will then return the version string specified with the version attribute\n    # in the [tool.poetry] section of the pyproject.toml file\n    try:\n        version_string_of_foo = importlib.metadata.version(\n            constants.chasten.Application_Name\n        )\n    # note that using the version function does not work when chasten is run\n    # through a 'poetry shell' and/or a 'poetry run' command because at that stage",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 65,
        "coloffset": 4,
        "linematch": "return version_string_of_foo",
        "context": "    # there is not a working package that importlib.metadata can access with a version;\n    # in this situation the function should return the default value of 0.0.0\n    except importlib.metadata.PackageNotFoundError:\n        version_string_of_foo = default_chasten_semver\n    return version_string_of_foo\n\n\ndef join_and_preserve(data, start, end):\n    \"\"\"Join and preserve lines inside of a list.\"\"\"\n    return constants.markers.Newline.join(data[start:end])",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "join_and_preserve",
    "function_scope": "68-70",
    "patterns": [
      {
        "lineno": 68,
        "coloffset": 0,
        "linematch": "def join_and_preserve(data, start, end):",
        "context": "        version_string_of_foo = default_chasten_semver\n    return version_string_of_foo\n\n\ndef join_and_preserve(data, start, end):\n    \"\"\"Join and preserve lines inside of a list.\"\"\"\n    return constants.markers.Newline.join(data[start:end])\n\n\ndef is_url(url: str) -> bool:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 68,
        "coloffset": 0,
        "linematch": "def join_and_preserve(data, start, end):",
        "context": "        version_string_of_foo = default_chasten_semver\n    return version_string_of_foo\n\n\ndef join_and_preserve(data, start, end):\n    \"\"\"Join and preserve lines inside of a list.\"\"\"\n    return constants.markers.Newline.join(data[start:end])\n\n\ndef is_url(url: str) -> bool:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 69,
        "coloffset": 4,
        "linematch": "\"\"\"Join and preserve lines inside of a list.\"\"\"",
        "context": "    return version_string_of_foo\n\n\ndef join_and_preserve(data, start, end):\n    \"\"\"Join and preserve lines inside of a list.\"\"\"\n    return constants.markers.Newline.join(data[start:end])\n\n\ndef is_url(url: str) -> bool:\n    \"\"\"Determine if string is valid URL.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "return constants.markers.Newline.join(data[start:end])",
        "context": "\n\ndef join_and_preserve(data, start, end):\n    \"\"\"Join and preserve lines inside of a list.\"\"\"\n    return constants.markers.Newline.join(data[start:end])\n\n\ndef is_url(url: str) -> bool:\n    \"\"\"Determine if string is valid URL.\"\"\"\n    # parse input url",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "total_amount_passed",
    "function_scope": "106-122",
    "patterns": [
      {
        "lineno": 106,
        "coloffset": 0,
        "linematch": "def total_amount_passed(check_status_list: list[bool]) -> tuple[int, int, float]:",
        "context": "    # determine if parsed and reconstructed url matches original\n    return str(parse_url(url)).lower() == url_reassembled.lower()\n\n\ndef total_amount_passed(check_status_list: list[bool]) -> tuple[int, int, float]:\n    \"\"\"Calculate amount of checks passed in analyze\"\"\"\n    # attempt calculations for percentage of checks passed\n    try:\n        # calculate total amount of checks in list\n        count_total = len(check_status_list)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 106,
        "coloffset": 0,
        "linematch": "def total_amount_passed(check_status_list: list[bool]) -> tuple[int, int, float]:",
        "context": "    # determine if parsed and reconstructed url matches original\n    return str(parse_url(url)).lower() == url_reassembled.lower()\n\n\ndef total_amount_passed(check_status_list: list[bool]) -> tuple[int, int, float]:\n    \"\"\"Calculate amount of checks passed in analyze\"\"\"\n    # attempt calculations for percentage of checks passed\n    try:\n        # calculate total amount of checks in list\n        count_total = len(check_status_list)",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 107,
        "coloffset": 4,
        "linematch": "\"\"\"Calculate amount of checks passed in analyze\"\"\"",
        "context": "    return str(parse_url(url)).lower() == url_reassembled.lower()\n\n\ndef total_amount_passed(check_status_list: list[bool]) -> tuple[int, int, float]:\n    \"\"\"Calculate amount of checks passed in analyze\"\"\"\n    # attempt calculations for percentage of checks passed\n    try:\n        # calculate total amount of checks in list\n        count_total = len(check_status_list)\n        # count total amount of checks counted as true",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 109,
        "coloffset": 4,
        "linematch": "try:",
        "context": "\ndef total_amount_passed(check_status_list: list[bool]) -> tuple[int, int, float]:\n    \"\"\"Calculate amount of checks passed in analyze\"\"\"\n    # attempt calculations for percentage of checks passed\n    try:\n        # calculate total amount of checks in list\n        count_total = len(check_status_list)\n        # count total amount of checks counted as true\n        count_passed = check_status_list.count(True)\n        # return tuple of checks passed, total checks, percentage of checks passed",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1367",
        "line": 122,
        "description": [
          "        if directory not in grouped_files:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "extract_min_max",
    "function_scope": "8-16",
    "patterns": [
      {
        "lineno": 8,
        "coloffset": 0,
        "linematch": "def extract_min_max(",
        "context": "\nfrom chasten import constants, enumerations, util\n\n\ndef extract_min_max(\n    check: Dict[str, Union[str, Dict[str, int]]]\n) -> Tuple[Union[int, None], Union[int, None]]:\n    \"\"\"Extract the minimum and maximum values from the checks dictionary.\"\"\"\n    # extract information about the count attribute\n    # and the min and max values if they exist",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "\"\"\"Extract the minimum and maximum values from the checks dictionary.\"\"\"",
        "context": "\ndef extract_min_max(\n    check: Dict[str, Union[str, Dict[str, int]]]\n) -> Tuple[Union[int, None], Union[int, None]]:\n    \"\"\"Extract the minimum and maximum values from the checks dictionary.\"\"\"\n    # extract information about the count attribute\n    # and the min and max values if they exist\n    min_count = check.get(constants.checks.Check_Count, {}).get(constants.checks.Check_Min)  # type: ignore\n    max_count = check.get(\"count\", {}).get(\"max\")  # type: ignore\n    return (min_count, max_count)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "min_count = check.get(constants.checks.Check_Count, {}).get(constants.checks.Check_Min)  # type: ignore",
        "context": ") -> Tuple[Union[int, None], Union[int, None]]:\n    \"\"\"Extract the minimum and maximum values from the checks dictionary.\"\"\"\n    # extract information about the count attribute\n    # and the min and max values if they exist\n    min_count = check.get(constants.checks.Check_Count, {}).get(constants.checks.Check_Min)  # type: ignore\n    max_count = check.get(\"count\", {}).get(\"max\")  # type: ignore\n    return (min_count, max_count)\n\n\ndef extract_description(check: Dict[str, Union[str, Dict[str, int]]]) -> str:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "max_count = check.get(\"count\", {}).get(\"max\")  # type: ignore",
        "context": "    \"\"\"Extract the minimum and maximum values from the checks dictionary.\"\"\"\n    # extract information about the count attribute\n    # and the min and max values if they exist\n    min_count = check.get(constants.checks.Check_Count, {}).get(constants.checks.Check_Min)  # type: ignore\n    max_count = check.get(\"count\", {}).get(\"max\")  # type: ignore\n    return (min_count, max_count)\n\n\ndef extract_description(check: Dict[str, Union[str, Dict[str, int]]]) -> str:\n    \"\"\"Extract the description that may optionally be stored in a check.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "return (min_count, max_count)",
        "context": "    # extract information about the count attribute\n    # and the min and max values if they exist\n    min_count = check.get(constants.checks.Check_Count, {}).get(constants.checks.Check_Min)  # type: ignore\n    max_count = check.get(\"count\", {}).get(\"max\")  # type: ignore\n    return (min_count, max_count)\n\n\ndef extract_description(check: Dict[str, Union[str, Dict[str, int]]]) -> str:\n    \"\"\"Extract the description that may optionally be stored in a check.\"\"\"\n    # the attribute is not None and thus the function",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1360",
        "line": 16,
        "description": [
          "logger: logging.Logger = logging.getLogger()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "create_chasten_view",
    "function_scope": "40-51",
    "patterns": [
      {
        "lineno": 40,
        "coloffset": 0,
        "linematch": "def create_chasten_view(chasten_database_name: str) -> None:",
        "context": "# create a small bullet for display in the output\nsmall_bullet_unicode = constants.markers.Small_Bullet_Unicode\n\n\ndef create_chasten_view(chasten_database_name: str) -> None:\n    \"\"\"Create a view that combines results in the database tables.\"\"\"\n    database = Database(chasten_database_name)\n    # create a \"virtual table\" (i.e., a view) that is the result\n    # of running the pre-defined query; note that this query\n    # organizes all of chasten's results into a single table.",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "\"\"\"Create a view that combines results in the database tables.\"\"\"",
        "context": "small_bullet_unicode = constants.markers.Small_Bullet_Unicode\n\n\ndef create_chasten_view(chasten_database_name: str) -> None:\n    \"\"\"Create a view that combines results in the database tables.\"\"\"\n    database = Database(chasten_database_name)\n    # create a \"virtual table\" (i.e., a view) that is the result\n    # of running the pre-defined query; note that this query\n    # organizes all of chasten's results into a single table.\n    # When using datasette each of the columns in this view",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "database = Database(chasten_database_name)",
        "context": "\n\ndef create_chasten_view(chasten_database_name: str) -> None:\n    \"\"\"Create a view that combines results in the database tables.\"\"\"\n    database = Database(chasten_database_name)\n    # create a \"virtual table\" (i.e., a view) that is the result\n    # of running the pre-defined query; note that this query\n    # organizes all of chasten's results into a single table.\n    # When using datasette each of the columns in this view\n    # are \"facetable\" which means that they can be enabled or disabled",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "database.create_view(",
        "context": "    # organizes all of chasten's results into a single table.\n    # When using datasette each of the columns in this view\n    # are \"facetable\" which means that they can be enabled or disabled\n    # inside of the web-based user interface\n    database.create_view(\n        constants.chasten.Chasten_Database_View, CHASTEN_SQL_SELECT_QUERY\n    )\n\n\ndef enable_full_text_search(chasten_database_name: str) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "enable_full_text_search",
    "function_scope": "54-82",
    "patterns": [
      {
        "lineno": 54,
        "coloffset": 0,
        "linematch": "def enable_full_text_search(chasten_database_name: str) -> None:",
        "context": "        constants.chasten.Chasten_Database_View, CHASTEN_SQL_SELECT_QUERY\n    )\n\n\ndef enable_full_text_search(chasten_database_name: str) -> None:\n    \"\"\"Enable full-text search in the specific SQLite3 database.\"\"\"\n    database = Database(chasten_database_name)\n    # enable full-text search on the main database table\n    database[\"main\"].enable_fts(\n        [",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "\"\"\"Enable full-text search in the specific SQLite3 database.\"\"\"",
        "context": "    )\n\n\ndef enable_full_text_search(chasten_database_name: str) -> None:\n    \"\"\"Enable full-text search in the specific SQLite3 database.\"\"\"\n    database = Database(chasten_database_name)\n    # enable full-text search on the main database table\n    database[\"main\"].enable_fts(\n        [\n            \"configuration_chastenversion\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "database = Database(chasten_database_name)",
        "context": "\n\ndef enable_full_text_search(chasten_database_name: str) -> None:\n    \"\"\"Enable full-text search in the specific SQLite3 database.\"\"\"\n    database = Database(chasten_database_name)\n    # enable full-text search on the main database table\n    database[\"main\"].enable_fts(\n        [\n            \"configuration_chastenversion\",\n            \"configuration_projectname\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "database[\"main\"].enable_fts(",
        "context": "def enable_full_text_search(chasten_database_name: str) -> None:\n    \"\"\"Enable full-text search in the specific SQLite3 database.\"\"\"\n    database = Database(chasten_database_name)\n    # enable full-text search on the main database table\n    database[\"main\"].enable_fts(\n        [\n            \"configuration_chastenversion\",\n            \"configuration_projectname\",\n            \"configuration_datetime\",\n        ]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 66,
        "coloffset": 4,
        "linematch": "database[\"sources\"].enable_fts(",
        "context": "            \"configuration_datetime\",\n        ]\n    )\n    # enable full-text search on the sources database table\n    database[\"sources\"].enable_fts(\n        [\n            \"filename\",\n            \"check_id\",\n            \"check_name\",\n            \"check_description\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 76,
        "coloffset": 4,
        "linematch": "database[\"sources_check_matches\"].enable_fts(",
        "context": "            \"check_pattern\",\n        ]\n    )\n    # enable full-text search on the sources database table\n    database[\"sources_check_matches\"].enable_fts(\n        [\n            \"lineno\",\n            \"coloffset\",\n            \"linematch\",\n        ]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "create_configuration_file",
    "function_scope": "108-124",
    "patterns": [
      {
        "lineno": 108,
        "coloffset": 0,
        "linematch": "def create_configuration_file(",
        "context": "    chasten_user_config_dir_path.mkdir(parents=True)\n    return chasten_user_config_dir_path\n\n\ndef create_configuration_file(\n    config: Path, config_file_name: str = constants.filesystem.Main_Configuration_File\n) -> None:\n    \"\"\"Create the main configuration file in the configuration directory.\"\"\"\n    # detect the configuration directory\n    chasten_user_config_dir_str = detect_configuration(config)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 111,
        "coloffset": 4,
        "linematch": "\"\"\"Create the main configuration file in the configuration directory.\"\"\"",
        "context": "\ndef create_configuration_file(\n    config: Path, config_file_name: str = constants.filesystem.Main_Configuration_File\n) -> None:\n    \"\"\"Create the main configuration file in the configuration directory.\"\"\"\n    # detect the configuration directory\n    chasten_user_config_dir_str = detect_configuration(config)\n    # create the final path to the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    # create a path to the configuration file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 113,
        "coloffset": 4,
        "linematch": "chasten_user_config_dir_str = detect_configuration(config)",
        "context": "    config: Path, config_file_name: str = constants.filesystem.Main_Configuration_File\n) -> None:\n    \"\"\"Create the main configuration file in the configuration directory.\"\"\"\n    # detect the configuration directory\n    chasten_user_config_dir_str = detect_configuration(config)\n    # create the final path to the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    # create a path to the configuration file\n    chasten_user_config_main_file = chasten_user_config_dir_path / Path(\n        config_file_name",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "chasten_user_config_dir_path = Path(chasten_user_config_dir_str)",
        "context": "    \"\"\"Create the main configuration file in the configuration directory.\"\"\"\n    # detect the configuration directory\n    chasten_user_config_dir_str = detect_configuration(config)\n    # create the final path to the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    # create a path to the configuration file\n    chasten_user_config_main_file = chasten_user_config_dir_path / Path(\n        config_file_name\n    )\n    # create the file (if it does not exist)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 117,
        "coloffset": 4,
        "linematch": "chasten_user_config_main_file = chasten_user_config_dir_path / Path(",
        "context": "    chasten_user_config_dir_str = detect_configuration(config)\n    # create the final path to the configuration directory\n    chasten_user_config_dir_path = Path(chasten_user_config_dir_str)\n    # create a path to the configuration file\n    chasten_user_config_main_file = chasten_user_config_dir_path / Path(\n        config_file_name\n    )\n    # create the file (if it does not exist)\n    chasten_user_config_main_file.touch()\n    # write the default contents of the file",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 121,
        "coloffset": 4,
        "linematch": "chasten_user_config_main_file.touch()",
        "context": "    chasten_user_config_main_file = chasten_user_config_dir_path / Path(\n        config_file_name\n    )\n    # create the file (if it does not exist)\n    chasten_user_config_main_file.touch()\n    # write the default contents of the file\n    file_contents = FILE_CONTENTS_LOOKUP[config_file_name]\n    chasten_user_config_main_file.write_text(file_contents)\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 123,
        "coloffset": 4,
        "linematch": "file_contents = FILE_CONTENTS_LOOKUP[config_file_name]",
        "context": "    )\n    # create the file (if it does not exist)\n    chasten_user_config_main_file.touch()\n    # write the default contents of the file\n    file_contents = FILE_CONTENTS_LOOKUP[config_file_name]\n    chasten_user_config_main_file.write_text(file_contents)\n\n\ndef create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore\n    \"\"\"Create a directory tree visualization using the Rich tree.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 124,
        "coloffset": 4,
        "linematch": "chasten_user_config_main_file.write_text(file_contents)",
        "context": "    # create the file (if it does not exist)\n    chasten_user_config_main_file.touch()\n    # write the default contents of the file\n    file_contents = FILE_CONTENTS_LOOKUP[config_file_name]\n    chasten_user_config_main_file.write_text(file_contents)\n\n\ndef create_directory_tree_visualization(path: Path, tree: Tree = None) -> Tree:  # type: ignore\n    \"\"\"Create a directory tree visualization using the Rich tree.\"\"\"\n    # create the root of the tree if it",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #304",
        "line": 123,
        "description": [
          "            grouped_files[directory] = []"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1367",
        "line": 122,
        "description": [
          "        if directory not in grouped_files:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "get_default_directory_list",
    "function_scope": "170-173",
    "patterns": [
      {
        "lineno": 170,
        "coloffset": 0,
        "linematch": "def get_default_directory_list() -> List[Path]:",
        "context": "    # the directory was either none or not valid\n    return False\n\n\ndef get_default_directory_list() -> List[Path]:\n    \"\"\"Return the default directory list that is the current working directory by itself.\"\"\"\n    default_directory_list = [Path(constants.filesystem.Current_Directory)]\n    return default_directory_list\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 171,
        "coloffset": 4,
        "linematch": "\"\"\"Return the default directory list that is the current working directory by itself.\"\"\"",
        "context": "    return False\n\n\ndef get_default_directory_list() -> List[Path]:\n    \"\"\"Return the default directory list that is the current working directory by itself.\"\"\"\n    default_directory_list = [Path(constants.filesystem.Current_Directory)]\n    return default_directory_list\n\n\ndef write_chasten_results(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 172,
        "coloffset": 4,
        "linematch": "default_directory_list = [Path(constants.filesystem.Current_Directory)]",
        "context": "\n\ndef get_default_directory_list() -> List[Path]:\n    \"\"\"Return the default directory list that is the current working directory by itself.\"\"\"\n    default_directory_list = [Path(constants.filesystem.Current_Directory)]\n    return default_directory_list\n\n\ndef write_chasten_results(\n    results_path: Path,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 173,
        "coloffset": 4,
        "linematch": "return default_directory_list",
        "context": "\ndef get_default_directory_list() -> List[Path]:\n    \"\"\"Return the default directory list that is the current working directory by itself.\"\"\"\n    default_directory_list = [Path(constants.filesystem.Current_Directory)]\n    return default_directory_list\n\n\ndef write_chasten_results(\n    results_path: Path,\n    projectname: str,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1383",
        "line": 171,
        "description": [
          "    opt_print_log(verbose, label=\"\\n:tada: Results from the analysis:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "write_dict_results",
    "function_scope": "212-236",
    "patterns": [
      {
        "lineno": 212,
        "coloffset": 0,
        "linematch": "def write_dict_results(",
        "context": "    # return the name of the file that was created during saving\n    return constants.markers.Empty_String\n\n\ndef write_dict_results(\n    results_json: str,\n    results_path: Path,\n    projectname: str,\n) -> str:\n    \"\"\"Write a JSON file with results to the specified directory.\"\"\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 217,
        "coloffset": 4,
        "linematch": "\"\"\"Write a JSON file with results to the specified directory.\"\"\"",
        "context": "    results_json: str,\n    results_path: Path,\n    projectname: str,\n) -> str:\n    \"\"\"Write a JSON file with results to the specified directory.\"\"\"\n    # generate a unique hexadecimal code that will ensure that\n    # this file name is unique when it is being saved\n    results_file_uuid = uuid.uuid4().hex\n    # create a formatted datetime\n    formatted_datetime = str(datetime.now().strftime(\"%Y%m%d%H%M%S\"))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 220,
        "coloffset": 4,
        "linematch": "results_file_uuid = uuid.uuid4().hex",
        "context": ") -> str:\n    \"\"\"Write a JSON file with results to the specified directory.\"\"\"\n    # generate a unique hexadecimal code that will ensure that\n    # this file name is unique when it is being saved\n    results_file_uuid = uuid.uuid4().hex\n    # create a formatted datetime\n    formatted_datetime = str(datetime.now().strftime(\"%Y%m%d%H%M%S\"))\n    # create a file name so that it includes:\n    # a) the name of the project\n    # b) the date on which analysis was completed",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 222,
        "coloffset": 4,
        "linematch": "formatted_datetime = str(datetime.now().strftime(\"%Y%m%d%H%M%S\"))",
        "context": "    # generate a unique hexadecimal code that will ensure that\n    # this file name is unique when it is being saved\n    results_file_uuid = uuid.uuid4().hex\n    # create a formatted datetime\n    formatted_datetime = str(datetime.now().strftime(\"%Y%m%d%H%M%S\"))\n    # create a file name so that it includes:\n    # a) the name of the project\n    # b) the date on which analysis was completed\n    # c) a unique identifier to handle cased when\n    #    two result files are created at \"same time\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 229,
        "coloffset": 4,
        "linematch": "complete_results_file_name = f\"{constants.filesystem.Main_Results_Combined_File_Name}-{projectname}-{formatted_datetime}-{results_file_uuid}.{constants.filesystem.Results_Extension}\"",
        "context": "    # b) the date on which analysis was completed\n    # c) a unique identifier to handle cased when\n    #    two result files are created at \"same time\"\n    # d) Clear indiciator in the name that this is a combined result\n    complete_results_file_name = f\"{constants.filesystem.Main_Results_Combined_File_Name}-{projectname}-{formatted_datetime}-{results_file_uuid}.{constants.filesystem.Results_Extension}\"\n    # create the file and then write the text,\n    # using indentation to ensure that JSON file is readable\n    results_path_with_file = results_path / complete_results_file_name\n    # use the built-in method from pathlib Path to write the JSON contents\n    results_path_with_file.write_text(results_json, \"utf-8\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 232,
        "coloffset": 4,
        "linematch": "results_path_with_file = results_path / complete_results_file_name",
        "context": "    # d) Clear indiciator in the name that this is a combined result\n    complete_results_file_name = f\"{constants.filesystem.Main_Results_Combined_File_Name}-{projectname}-{formatted_datetime}-{results_file_uuid}.{constants.filesystem.Results_Extension}\"\n    # create the file and then write the text,\n    # using indentation to ensure that JSON file is readable\n    results_path_with_file = results_path / complete_results_file_name\n    # use the built-in method from pathlib Path to write the JSON contents\n    results_path_with_file.write_text(results_json, \"utf-8\")\n    # return the name of the file that contains the JSON dictionary contents\n    return complete_results_file_name\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 234,
        "coloffset": 4,
        "linematch": "results_path_with_file.write_text(results_json, \"utf-8\")",
        "context": "    # create the file and then write the text,\n    # using indentation to ensure that JSON file is readable\n    results_path_with_file = results_path / complete_results_file_name\n    # use the built-in method from pathlib Path to write the JSON contents\n    results_path_with_file.write_text(results_json, \"utf-8\")\n    # return the name of the file that contains the JSON dictionary contents\n    return complete_results_file_name\n\n\ndef write_flattened_csv_and_database(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 236,
        "coloffset": 4,
        "linematch": "return complete_results_file_name",
        "context": "    results_path_with_file = results_path / complete_results_file_name\n    # use the built-in method from pathlib Path to write the JSON contents\n    results_path_with_file.write_text(results_json, \"utf-8\")\n    # return the name of the file that contains the JSON dictionary contents\n    return complete_results_file_name\n\n\ndef write_flattened_csv_and_database(\n    combined_results_json: str,\n    results_path: Path,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #319",
        "line": 223,
        "description": [
          "                    position_end = current_match.position.lineno"
        ],
        "failure": []
      },
      {
        "name": "Mutant #320",
        "line": 225,
        "description": [
          "                    column_offset = current_match.position.col_offset"
        ],
        "failure": []
      },
      {
        "name": "Mutant #321",
        "line": 230,
        "description": [
          "                    all_lines = current_match.file_lines"
        ],
        "failure": []
      },
      {
        "name": "Mutant #322",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1390",
        "line": 214,
        "description": [
          "                label=f\":tada: Found a total of {len(current_check._matches)} matches for '{check_name}' in {current_source.filename}\","
        ],
        "failure": []
      },
      {
        "name": "Mutant #1391",
        "line": 221,
        "description": [
          "                    opt_print_log(verbose, label=\":sparkles: Matching source code:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1392",
        "line": 234,
        "description": [
          "                    all_lines_for_marking = deepcopy(all_lines)"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "write_flattened_csv_and_database",
    "function_scope": "239-288",
    "patterns": [
      {
        "lineno": 239,
        "coloffset": 0,
        "linematch": "def write_flattened_csv_and_database(",
        "context": "    # return the name of the file that contains the JSON dictionary contents\n    return complete_results_file_name\n\n\ndef write_flattened_csv_and_database(\n    combined_results_json: str,\n    results_path: Path,\n    projectname: str,\n) -> str:\n    \"\"\"Write flattened CSV files with results to the specified directory and create the database.\"\"\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 244,
        "coloffset": 4,
        "linematch": "\"\"\"Write flattened CSV files with results to the specified directory and create the database.\"\"\"",
        "context": "    combined_results_json: str,\n    results_path: Path,\n    projectname: str,\n) -> str:\n    \"\"\"Write flattened CSV files with results to the specified directory and create the database.\"\"\"\n    # generate a unique hexadecimal code that will ensure that\n    # this file name is unique when it is being saved\n    results_file_uuid = uuid.uuid4().hex\n    # create a formatted datetime\n    formatted_datetime = str(datetime.now().strftime(\"%Y%m%d%H%M%S\"))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 247,
        "coloffset": 4,
        "linematch": "results_file_uuid = uuid.uuid4().hex",
        "context": ") -> str:\n    \"\"\"Write flattened CSV files with results to the specified directory and create the database.\"\"\"\n    # generate a unique hexadecimal code that will ensure that\n    # this file name is unique when it is being saved\n    results_file_uuid = uuid.uuid4().hex\n    # create a formatted datetime\n    formatted_datetime = str(datetime.now().strftime(\"%Y%m%d%H%M%S\"))\n    # create a string-based name for the JSON file that contains\n    # the combined results, suitable for input to the flatten function\n    combined_results_json_file = results_path / Path(combined_results_json)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 249,
        "coloffset": 4,
        "linematch": "formatted_datetime = str(datetime.now().strftime(\"%Y%m%d%H%M%S\"))",
        "context": "    # generate a unique hexadecimal code that will ensure that\n    # this file name is unique when it is being saved\n    results_file_uuid = uuid.uuid4().hex\n    # create a formatted datetime\n    formatted_datetime = str(datetime.now().strftime(\"%Y%m%d%H%M%S\"))\n    # create a string-based name for the JSON file that contains\n    # the combined results, suitable for input to the flatten function\n    combined_results_json_file = results_path / Path(combined_results_json)\n    combined_results_json_file_str = str(combined_results_json_file)\n    # create a final part of the directory name so that it includes:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 252,
        "coloffset": 4,
        "linematch": "combined_results_json_file = results_path / Path(combined_results_json)",
        "context": "    # create a formatted datetime\n    formatted_datetime = str(datetime.now().strftime(\"%Y%m%d%H%M%S\"))\n    # create a string-based name for the JSON file that contains\n    # the combined results, suitable for input to the flatten function\n    combined_results_json_file = results_path / Path(combined_results_json)\n    combined_results_json_file_str = str(combined_results_json_file)\n    # create a final part of the directory name so that it includes:\n    # a) the name of the project\n    # b) the date on which analysis was completed\n    # c) a unique identifier to handle cased when",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 253,
        "coloffset": 4,
        "linematch": "combined_results_json_file_str = str(combined_results_json_file)",
        "context": "    formatted_datetime = str(datetime.now().strftime(\"%Y%m%d%H%M%S\"))\n    # create a string-based name for the JSON file that contains\n    # the combined results, suitable for input to the flatten function\n    combined_results_json_file = results_path / Path(combined_results_json)\n    combined_results_json_file_str = str(combined_results_json_file)\n    # create a final part of the directory name so that it includes:\n    # a) the name of the project\n    # b) the date on which analysis was completed\n    # c) a unique identifier to handle cased when\n    #    two directories are created at \"same time\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 259,
        "coloffset": 4,
        "linematch": "complete_flattened_results_directory_name = f\"{constants.filesystem.Main_Results_Flattened_Directory_Name}-{projectname}-{formatted_datetime}-{results_file_uuid}\"",
        "context": "    # a) the name of the project\n    # b) the date on which analysis was completed\n    # c) a unique identifier to handle cased when\n    #    two directories are created at \"same time\"\n    complete_flattened_results_directory_name = f\"{constants.filesystem.Main_Results_Flattened_Directory_Name}-{projectname}-{formatted_datetime}-{results_file_uuid}\"\n    # the output directory is contained inside of the results_path\n    flattened_output_directory = (\n        results_path / complete_flattened_results_directory_name\n    )\n    # the flatten function expects a string-based directory name",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 261,
        "coloffset": 4,
        "linematch": "flattened_output_directory = (",
        "context": "    # c) a unique identifier to handle cased when\n    #    two directories are created at \"same time\"\n    complete_flattened_results_directory_name = f\"{constants.filesystem.Main_Results_Flattened_Directory_Name}-{projectname}-{formatted_datetime}-{results_file_uuid}\"\n    # the output directory is contained inside of the results_path\n    flattened_output_directory = (\n        results_path / complete_flattened_results_directory_name\n    )\n    # the flatten function expects a string-based directory name\n    flattened_output_directory_str = str(flattened_output_directory)\n    # the SQLite3 database file exists in the directory that will",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 265,
        "coloffset": 4,
        "linematch": "flattened_output_directory_str = str(flattened_output_directory)",
        "context": "    flattened_output_directory = (\n        results_path / complete_flattened_results_directory_name\n    )\n    # the flatten function expects a string-based directory name\n    flattened_output_directory_str = str(flattened_output_directory)\n    # the SQLite3 database file exists in the directory that will\n    # store all of the flattened results in the csv/ directory\n    database_file_name = (\n        flattened_output_directory / constants.datasette.Chasten_Database\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 268,
        "coloffset": 4,
        "linematch": "database_file_name = (",
        "context": "    # the flatten function expects a string-based directory name\n    flattened_output_directory_str = str(flattened_output_directory)\n    # the SQLite3 database file exists in the directory that will\n    # store all of the flattened results in the csv/ directory\n    database_file_name = (\n        flattened_output_directory / constants.datasette.Chasten_Database\n    )\n    database_file_name_str = str(database_file_name)\n    # perform the flattening, creating a directory called csv/ that\n    # contains all of the CSV files and a SQLite3 database called chasten.db",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 271,
        "coloffset": 4,
        "linematch": "database_file_name_str = str(database_file_name)",
        "context": "    # store all of the flattened results in the csv/ directory\n    database_file_name = (\n        flattened_output_directory / constants.datasette.Chasten_Database\n    )\n    database_file_name_str = str(database_file_name)\n    # perform the flattening, creating a directory called csv/ that\n    # contains all of the CSV files and a SQLite3 database called chasten.db\n    # that contains all of the contents of the CSV files; this chasten.db\n    # file is ready for browsing through the use of a tool like datasette\n    flatterer.flatten(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 276,
        "coloffset": 4,
        "linematch": "flatterer.flatten(",
        "context": "    # perform the flattening, creating a directory called csv/ that\n    # contains all of the CSV files and a SQLite3 database called chasten.db\n    # that contains all of the contents of the CSV files; this chasten.db\n    # file is ready for browsing through the use of a tool like datasette\n    flatterer.flatten(\n        combined_results_json_file_str,\n        flattened_output_directory_str,\n        csv=True,\n        sqlite=True,\n        sqlite_path=database_file_name_str,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 284,
        "coloffset": 4,
        "linematch": "database.create_chasten_view(database_file_name_str)",
        "context": "        sqlite=True,\n        sqlite_path=database_file_name_str,\n    )\n    # create a view that combines all of the data\n    database.create_chasten_view(database_file_name_str)\n    # enable full-text search in the SQLite3 database\n    database.enable_full_text_search(database_file_name_str)\n    # return the name of the directory that contains the flattened CSV files\n    return flattened_output_directory_str\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 286,
        "coloffset": 4,
        "linematch": "database.enable_full_text_search(database_file_name_str)",
        "context": "    )\n    # create a view that combines all of the data\n    database.create_chasten_view(database_file_name_str)\n    # enable full-text search in the SQLite3 database\n    database.enable_full_text_search(database_file_name_str)\n    # return the name of the directory that contains the flattened CSV files\n    return flattened_output_directory_str\n\n\ndef get_json_results(json_paths: List[Path]) -> List[Dict[Any, Any]]:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 288,
        "coloffset": 4,
        "linematch": "return flattened_output_directory_str",
        "context": "    database.create_chasten_view(database_file_name_str)\n    # enable full-text search in the SQLite3 database\n    database.enable_full_text_search(database_file_name_str)\n    # return the name of the directory that contains the flattened CSV files\n    return flattened_output_directory_str\n\n\ndef get_json_results(json_paths: List[Path]) -> List[Dict[Any, Any]]:\n    \"\"\"Get a list of dictionaries, one the contents of each JSON file path.\"\"\"\n    # create an empty list of dictionaries",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #323",
        "line": 240,
        "description": [
          "                    ]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #324",
        "line": 258,
        "description": [
          "                    )"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1395",
        "line": 239,
        "description": [
          "                        + constants.markers.Code_Context"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1396",
        "line": 249,
        "description": [
          "                        \"\\n\".join(str(line) for line in lines),"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1397",
        "line": 253,
        "description": [
          "                        line_numbers=True,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1398",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1399",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1400",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1401",
        "line": 255,
        "description": [
          "                            max(1, position_end - constants.markers.Code_Context + 1)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1402",
        "line": 264,
        "description": [
          "                            expand=False,"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1403",
        "line": 265,
        "description": [
          "                            title=f\"{current_match.path}:{position_end}:{column_offset}\","
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "get_json_results",
    "function_scope": "291-302",
    "patterns": [
      {
        "lineno": 291,
        "coloffset": 0,
        "linematch": "def get_json_results(json_paths: List[Path]) -> List[Dict[Any, Any]]:",
        "context": "    # return the name of the directory that contains the flattened CSV files\n    return flattened_output_directory_str\n\n\ndef get_json_results(json_paths: List[Path]) -> List[Dict[Any, Any]]:\n    \"\"\"Get a list of dictionaries, one the contents of each JSON file path.\"\"\"\n    # create an empty list of dictionaries\n    json_dicts_list: List[Dict[Any, Any]] = []\n    # iterate through each of the provided paths to a JSON file\n    for json_path in json_paths:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 292,
        "coloffset": 4,
        "linematch": "\"\"\"Get a list of dictionaries, one the contents of each JSON file path.\"\"\"",
        "context": "    return flattened_output_directory_str\n\n\ndef get_json_results(json_paths: List[Path]) -> List[Dict[Any, Any]]:\n    \"\"\"Get a list of dictionaries, one the contents of each JSON file path.\"\"\"\n    # create an empty list of dictionaries\n    json_dicts_list: List[Dict[Any, Any]] = []\n    # iterate through each of the provided paths to a JSON file\n    for json_path in json_paths:\n        # turn the contents of the current JSON file into a dictionary",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 294,
        "coloffset": 4,
        "linematch": "json_dicts_list: List[Dict[Any, Any]] = []",
        "context": "\ndef get_json_results(json_paths: List[Path]) -> List[Dict[Any, Any]]:\n    \"\"\"Get a list of dictionaries, one the contents of each JSON file path.\"\"\"\n    # create an empty list of dictionaries\n    json_dicts_list: List[Dict[Any, Any]] = []\n    # iterate through each of the provided paths to a JSON file\n    for json_path in json_paths:\n        # turn the contents of the current JSON file into a dictionary\n        json_dict = json.loads(json_path.read_text(\"utf-8\"))\n        # add the current dictionary to the list of dictionaries",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 296,
        "coloffset": 4,
        "linematch": "for json_path in json_paths:",
        "context": "    \"\"\"Get a list of dictionaries, one the contents of each JSON file path.\"\"\"\n    # create an empty list of dictionaries\n    json_dicts_list: List[Dict[Any, Any]] = []\n    # iterate through each of the provided paths to a JSON file\n    for json_path in json_paths:\n        # turn the contents of the current JSON file into a dictionary\n        json_dict = json.loads(json_path.read_text(\"utf-8\"))\n        # add the current dictionary to the list of dictionaries\n        json_dicts_list.append(json_dict)\n    # return the list of JSON dictionaries",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 302,
        "coloffset": 4,
        "linematch": "return json_dicts_list",
        "context": "        json_dict = json.loads(json_path.read_text(\"utf-8\"))\n        # add the current dictionary to the list of dictionaries\n        json_dicts_list.append(json_dict)\n    # return the list of JSON dictionaries\n    return json_dicts_list\n\n\ndef can_find_executable(executable_name: str) -> Tuple[bool, str]:\n    \"\"\"Determine whether or not it is possible to find an executable.\"\"\"\n    # use the shutil.which function to find the path of the executable",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "save_user_api_key",
    "function_scope": "59-64",
    "patterns": [
      {
        "lineno": 59,
        "coloffset": 0,
        "linematch": "def save_user_api_key(user_api_key):",
        "context": "\nAPI_KEY_FILE = \"userapikey.txt\"\n\n\ndef save_user_api_key(user_api_key):\n    key = Fernet.generate_key()\n    fernet = Fernet(key)\n    encrypted_key = fernet.encrypt(user_api_key.encode()).decode()\n    with open(API_KEY_FILE, \"w\") as f:\n        f.write(key.decode() + \"\\n\" + encrypted_key)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 60,
        "coloffset": 4,
        "linematch": "key = Fernet.generate_key()",
        "context": "API_KEY_FILE = \"userapikey.txt\"\n\n\ndef save_user_api_key(user_api_key):\n    key = Fernet.generate_key()\n    fernet = Fernet(key)\n    encrypted_key = fernet.encrypt(user_api_key.encode()).decode()\n    with open(API_KEY_FILE, \"w\") as f:\n        f.write(key.decode() + \"\\n\" + encrypted_key)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "fernet = Fernet(key)",
        "context": "\n\ndef save_user_api_key(user_api_key):\n    key = Fernet.generate_key()\n    fernet = Fernet(key)\n    encrypted_key = fernet.encrypt(user_api_key.encode()).decode()\n    with open(API_KEY_FILE, \"w\") as f:\n        f.write(key.decode() + \"\\n\" + encrypted_key)\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 62,
        "coloffset": 4,
        "linematch": "encrypted_key = fernet.encrypt(user_api_key.encode()).decode()",
        "context": "\ndef save_user_api_key(user_api_key):\n    key = Fernet.generate_key()\n    fernet = Fernet(key)\n    encrypted_key = fernet.encrypt(user_api_key.encode()).decode()\n    with open(API_KEY_FILE, \"w\") as f:\n        f.write(key.decode() + \"\\n\" + encrypted_key)\n\n\ndef load_user_api_key(file):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "with open(API_KEY_FILE, \"w\") as f:",
        "context": "def save_user_api_key(user_api_key):\n    key = Fernet.generate_key()\n    fernet = Fernet(key)\n    encrypted_key = fernet.encrypt(user_api_key.encode()).decode()\n    with open(API_KEY_FILE, \"w\") as f:\n        f.write(key.decode() + \"\\n\" + encrypted_key)\n\n\ndef load_user_api_key(file):\n    with open(file, \"r\") as f:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "is_valid_api_key",
    "function_scope": "77-86",
    "patterns": [
      {
        "lineno": 77,
        "coloffset": 0,
        "linematch": "def is_valid_api_key(api_key):",
        "context": "        fernet = Fernet(key)\n        return fernet.decrypt(encrypted_key.encode()).decode()\n\n\ndef is_valid_api_key(api_key):\n    try:\n        openai.api_key = api_key\n        openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\"role\": \"system\", \"content\": \"Test message\"}],",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "try:",
        "context": "        return fernet.decrypt(encrypted_key.encode()).decode()\n\n\ndef is_valid_api_key(api_key):\n    try:\n        openai.api_key = api_key\n        openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\"role\": \"system\", \"content\": \"Test message\"}],\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "generate_yaml_config",
    "function_scope": "89-118",
    "patterns": [
      {
        "lineno": 89,
        "coloffset": 0,
        "linematch": "def generate_yaml_config(file: Path, user_api_key, user_input: str) -> str:",
        "context": "    except openai.error.OpenAIError:\n        return False\n\n\ndef generate_yaml_config(file: Path, user_api_key, user_input: str) -> str:\n    try:\n        openai.api_key = user_api_key\n\n        prompts = [\n            genscript",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 90,
        "coloffset": 4,
        "linematch": "try:",
        "context": "        return False\n\n\ndef generate_yaml_config(file: Path, user_api_key, user_input: str) -> str:\n    try:\n        openai.api_key = user_api_key\n\n        prompts = [\n            genscript\n            + \"in the same format as what is shown above(do not just generate the example use it as a framework nothing else): \"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #302",
        "line": 115,
        "description": [
          "        directory = file_path.parent"
        ],
        "failure": []
      },
      {
        "name": "Mutant #303",
        "line": 118,
        "description": [
          "        file_name = file_path.name"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1365",
        "line": 95,
        "description": [
          "    console.print(\":sparkles: Finished running test suite for the specified program\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "validate_configuration",
    "function_scope": "121-137",
    "patterns": [
      {
        "lineno": 121,
        "coloffset": 0,
        "linematch": "def validate_configuration(",
        "context": "    # contents were not found and thus returen no filenames\n    return (False, [constants.markers.Empty_String])\n\n\ndef validate_configuration(\n    configuration: Dict[str, Dict[str, Any]],\n    schema: Dict[str, Any] = JSON_SCHEMA_CONFIG,\n) -> Tuple[bool, str]:\n    \"\"\"Validate the main configuration.\"\"\"\n    # indicate that validation passed; since there",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 125,
        "coloffset": 4,
        "linematch": "\"\"\"Validate the main configuration.\"\"\"",
        "context": "def validate_configuration(\n    configuration: Dict[str, Dict[str, Any]],\n    schema: Dict[str, Any] = JSON_SCHEMA_CONFIG,\n) -> Tuple[bool, str]:\n    \"\"\"Validate the main configuration.\"\"\"\n    # indicate that validation passed; since there\n    # were no validation errors, return an empty string\n    try:\n        jsonschema.validate(configuration, schema)\n        return (True, constants.markers.Empty_String)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 128,
        "coloffset": 4,
        "linematch": "try:",
        "context": ") -> Tuple[bool, str]:\n    \"\"\"Validate the main configuration.\"\"\"\n    # indicate that validation passed; since there\n    # were no validation errors, return an empty string\n    try:\n        jsonschema.validate(configuration, schema)\n        return (True, constants.markers.Empty_String)\n    # indicate that validation failed;\n    # since validation errors exist, package them up\n    # and return them along with the indication",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #304",
        "line": 123,
        "description": [
          "            grouped_files[directory] = []"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1367",
        "line": 122,
        "description": [
          "        if directory not in grouped_files:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1368",
        "line": 132,
        "description": [
          "    if len(file_name) > max_length:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1369",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1370",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1371",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1372",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1373",
        "line": 133,
        "description": [
          "        return \"... \" + file_name[-(max_length - 3) :]"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "validate_checks_configuration",
    "function_scope": "140-144",
    "patterns": [
      {
        "lineno": 140,
        "coloffset": 0,
        "linematch": "def validate_checks_configuration(",
        "context": "        error_message = error_message.lstrip()\n        return (False, error_message)\n\n\ndef validate_checks_configuration(\n    configuration: Dict[str, Dict[str, Any]]\n) -> Tuple[bool, str]:\n    \"\"\"Validate the checks configuration.\"\"\"\n    return validate_configuration(configuration, JSON_SCHEMA_CHECKS)\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 143,
        "coloffset": 4,
        "linematch": "\"\"\"Validate the checks configuration.\"\"\"",
        "context": "\ndef validate_checks_configuration(\n    configuration: Dict[str, Dict[str, Any]]\n) -> Tuple[bool, str]:\n    \"\"\"Validate the checks configuration.\"\"\"\n    return validate_configuration(configuration, JSON_SCHEMA_CHECKS)\n\n\ndef validate_file(\n    file_name: str,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 144,
        "coloffset": 4,
        "linematch": "return validate_configuration(configuration, JSON_SCHEMA_CHECKS)",
        "context": "def validate_checks_configuration(\n    configuration: Dict[str, Dict[str, Any]]\n) -> Tuple[bool, str]:\n    \"\"\"Validate the checks configuration.\"\"\"\n    return validate_configuration(configuration, JSON_SCHEMA_CHECKS)\n\n\ndef validate_file(\n    file_name: str,\n    configuration_file_yaml_str: str,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #305",
        "line": 143,
        "description": [
          "    grouped_files = group_files_by_directory(container)"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "store_in_file",
    "function_scope": "43-47",
    "patterns": [
      {
        "lineno": 43,
        "coloffset": 0,
        "linematch": "def store_in_file(File: Path, Pattern, Matches, Exact):",
        "context": "        return result\n    return \"[red][ERROR][/red] No checks were supplied\"\n\n\ndef store_in_file(File: Path, Pattern, Matches, Exact):\n    \"\"\"Store inputed values into a text file\"\"\"\n    File.touch()\n    with open(File, \"a\") as file:\n        file.write(f\"\\n{Pattern},{Matches},{Exact}\")  # Append input data to the file\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "\"\"\"Store inputed values into a text file\"\"\"",
        "context": "    return \"[red][ERROR][/red] No checks were supplied\"\n\n\ndef store_in_file(File: Path, Pattern, Matches, Exact):\n    \"\"\"Store inputed values into a text file\"\"\"\n    File.touch()\n    with open(File, \"a\") as file:\n        file.write(f\"\\n{Pattern},{Matches},{Exact}\")  # Append input data to the file\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "File.touch()",
        "context": "\n\ndef store_in_file(File: Path, Pattern, Matches, Exact):\n    \"\"\"Store inputed values into a text file\"\"\"\n    File.touch()\n    with open(File, \"a\") as file:\n        file.write(f\"\\n{Pattern},{Matches},{Exact}\")  # Append input data to the file\n\n\n# Define input fields and buttons for the user interface",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "with open(File, \"a\") as file:",
        "context": "\ndef store_in_file(File: Path, Pattern, Matches, Exact):\n    \"\"\"Store inputed values into a text file\"\"\"\n    File.touch()\n    with open(File, \"a\") as file:\n        file.write(f\"\\n{Pattern},{Matches},{Exact}\")  # Append input data to the file\n\n\n# Define input fields and buttons for the user interface\nCheck_Input = Input(placeholder=\"Check For:\", id=\"Check\", name=\"Check\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "compose",
    "function_scope": "158-161",
    "patterns": [
      {
        "lineno": 158,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "        else:\n            self.query_one(Pretty).update([\"Invalid Input Please enter a Integer\"])\n            Match_Input.value = \"\"  # Clear the \"Matches\" input field\n\n    def compose(self) -> ComposeResult:\n        \"\"\"For displaying the user interface\"\"\"\n        yield answers()  # Display the input fields for user input\n        yield button_prompts()  # Display the buttons for user interaction",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 159,
        "coloffset": 8,
        "linematch": "\"\"\"For displaying the user interface\"\"\"",
        "context": "            self.query_one(Pretty).update([\"Invalid Input Please enter a Integer\"])\n            Match_Input.value = \"\"  # Clear the \"Matches\" input field\n\n    def compose(self) -> ComposeResult:\n        \"\"\"For displaying the user interface\"\"\"\n        yield answers()  # Display the input fields for user input\n        yield button_prompts()  # Display the buttons for user interaction",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 160,
        "coloffset": 8,
        "linematch": "yield answers()  # Display the input fields for user input",
        "context": "            Match_Input.value = \"\"  # Clear the \"Matches\" input field\n\n    def compose(self) -> ComposeResult:\n        \"\"\"For displaying the user interface\"\"\"\n        yield answers()  # Display the input fields for user input\n        yield button_prompts()  # Display the buttons for user interaction",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 161,
        "coloffset": 8,
        "linematch": "yield button_prompts()  # Display the buttons for user interaction",
        "context": "\n    def compose(self) -> ComposeResult:\n        \"\"\"For displaying the user interface\"\"\"\n        yield answers()  # Display the input fields for user input\n        yield button_prompts()  # Display the buttons for user interaction",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1381",
        "line": 160,
        "description": [
          "def print_analysis_details(chasten: results.Chasten, verbose: bool = False) -> None:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "combine_dicts",
    "function_scope": "97-109",
    "patterns": [
      {
        "lineno": 97,
        "coloffset": 0,
        "linematch": "def combine_dicts(dict_list: List[Dict[Any, Any]]) -> str:",
        "context": "            match_dict[current_match_file_name] = current_match_list\n    return match_dict\n\n\ndef combine_dicts(dict_list: List[Dict[Any, Any]]) -> str:\n    \"\"\"Combine all dictionaries in the list into a single list of dictionaries as a string.\"\"\"\n    # combine all of the dictionaries in the list into\n    # a single string that is a list of each JSON-based\n    # dictionary represented as a string; this leads to:\n    # [",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 97,
        "coloffset": 0,
        "linematch": "def combine_dicts(dict_list: List[Dict[Any, Any]]) -> str:",
        "context": "            match_dict[current_match_file_name] = current_match_list\n    return match_dict\n\n\ndef combine_dicts(dict_list: List[Dict[Any, Any]]) -> str:\n    \"\"\"Combine all dictionaries in the list into a single list of dictionaries as a string.\"\"\"\n    # combine all of the dictionaries in the list into\n    # a single string that is a list of each JSON-based\n    # dictionary represented as a string; this leads to:\n    # [",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 98,
        "coloffset": 4,
        "linematch": "\"\"\"Combine all dictionaries in the list into a single list of dictionaries as a string.\"\"\"",
        "context": "    return match_dict\n\n\ndef combine_dicts(dict_list: List[Dict[Any, Any]]) -> str:\n    \"\"\"Combine all dictionaries in the list into a single list of dictionaries as a string.\"\"\"\n    # combine all of the dictionaries in the list into\n    # a single string that is a list of each JSON-based\n    # dictionary represented as a string; this leads to:\n    # [\n    #   { nested JSON for file 1 },",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 109,
        "coloffset": 4,
        "linematch": "return json.dumps(dict_list, indent=2)",
        "context": "    #   ...\n    #   { nested JSON for file n }\n    # ]\n    # which is a list of valid JSON objects\n    return json.dumps(dict_list, indent=2)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1366",
        "line": 108,
        "description": [
          "    grouped_files: Dict[Path, List[str]] = {}"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "output_preamble",
    "function_scope": "45-69",
    "patterns": [
      {
        "lineno": 45,
        "coloffset": 0,
        "linematch": "def output_preamble(",
        "context": "# Region: Helper functions {{{\n# ---\n\n\ndef output_preamble(\n    verbose: bool,\n    debug_level: debug.DebugLevel = debug.DebugLevel.ERROR,\n    debug_destination: debug.DebugDestination = debug.DebugDestination.CONSOLE,\n    **kwargs,\n) -> None:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 45,
        "coloffset": 0,
        "linematch": "def output_preamble(",
        "context": "# Region: Helper functions {{{\n# ---\n\n\ndef output_preamble(\n    verbose: bool,\n    debug_level: debug.DebugLevel = debug.DebugLevel.ERROR,\n    debug_destination: debug.DebugDestination = debug.DebugDestination.CONSOLE,\n    **kwargs,\n) -> None:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "\"\"\"Output all of the preamble content.\"\"\"",
        "context": "    debug_level: debug.DebugLevel = debug.DebugLevel.ERROR,\n    debug_destination: debug.DebugDestination = debug.DebugDestination.CONSOLE,\n    **kwargs,\n) -> None:\n    \"\"\"Output all of the preamble content.\"\"\"\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "output.setup(debug_level, debug_destination)",
        "context": "    **kwargs,\n) -> None:\n    \"\"\"Output all of the preamble content.\"\"\"\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the header\n    output.print_header()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 54,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Display verbose output? {verbose}\")",
        "context": ") -> None:\n    \"\"\"Output all of the preamble content.\"\"\"\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the header\n    output.print_header()\n    # display details about configuration as",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Debug level? {debug_level.value}\")",
        "context": "    \"\"\"Output all of the preamble content.\"\"\"\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the header\n    output.print_header()\n    # display details about configuration as\n    # long as verbose output was requested;",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Debug destination? {debug_destination.value}\")",
        "context": "    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the header\n    output.print_header()\n    # display details about configuration as\n    # long as verbose output was requested;\n    # note that passing **kwargs to this function",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "output.print_header()",
        "context": "    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display the header\n    output.print_header()\n    # display details about configuration as\n    # long as verbose output was requested;\n    # note that passing **kwargs to this function\n    # will pass along all of the extra keyword\n    # arguments that were input to the function",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 64,
        "coloffset": 4,
        "linematch": "output.print_diagnostics(",
        "context": "    # long as verbose output was requested;\n    # note that passing **kwargs to this function\n    # will pass along all of the extra keyword\n    # arguments that were input to the function\n    output.print_diagnostics(\n        verbose,\n        debug_level=debug_level.value,\n        debug_destination=debug_destination.value,\n        **kwargs,\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1361",
        "line": 45,
        "description": [
          "        console.print(\":sparkles: Configured with these parameters:\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1362",
        "line": 50,
        "description": [
          "                f\"{constants.markers.Indent}{configuration_current} = {configurations[configuration_current]}\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "datasette_serve",
    "function_scope": "821-892",
    "patterns": [
      {
        "lineno": 821,
        "coloffset": 0,
        "linematch": "def datasette_serve(  # noqa: PLR0913",
        "context": "        output.logger.debug(\"Integrate function completed successfully.\")\n\n\n@cli.command()\ndef datasette_serve(  # noqa: PLR0913\n    database_path: Path = typer.Argument(\n        help=\"SQLite3 database file storing chasten's results.\",\n        exists=True,\n        file_okay=True,\n        dir_okay=False,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 821,
        "coloffset": 0,
        "linematch": "def datasette_serve(  # noqa: PLR0913",
        "context": "        output.logger.debug(\"Integrate function completed successfully.\")\n\n\n@cli.command()\ndef datasette_serve(  # noqa: PLR0913\n    database_path: Path = typer.Argument(\n        help=\"SQLite3 database file storing chasten's results.\",\n        exists=True,\n        file_okay=True,\n        dir_okay=False,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 863,
        "coloffset": 4,
        "linematch": "\"\"\"\ud83c\udfc3 Start a local datasette server.\"\"\"",
        "context": "        help=\"Specify the destination for debugging output.\",\n    ),\n    verbose: bool = typer.Option(False, help=\"Display verbose debugging output\"),\n) -> None:\n    \"\"\"\ud83c\udfc3 Start a local datasette server.\"\"\"\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,\n        debug_destination,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 865,
        "coloffset": 4,
        "linematch": "output_preamble(",
        "context": "    verbose: bool = typer.Option(False, help=\"Display verbose debugging output\"),\n) -> None:\n    \"\"\"\ud83c\udfc3 Start a local datasette server.\"\"\"\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,\n        debug_destination,\n        database=database_path,\n        datasette_port=port,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 874,
        "coloffset": 4,
        "linematch": "output.setup(debug_level, debug_destination)",
        "context": "        datasette_port=port,\n        metadata=metadata,\n    )\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display diagnostic information about the datasette instance\n    label = \":sparkles: Starting a local datasette instance:\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 875,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Display verbose output? {verbose}\")",
        "context": "        metadata=metadata,\n    )\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display diagnostic information about the datasette instance\n    label = \":sparkles: Starting a local datasette instance:\"\n    display_serve_or_publish_details(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 876,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Debug level? {debug_level.value}\")",
        "context": "    )\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display diagnostic information about the datasette instance\n    label = \":sparkles: Starting a local datasette instance:\"\n    display_serve_or_publish_details(\n        label, database_path, metadata, port, publish=False",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 877,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Debug destination? {debug_destination.value}\")",
        "context": "    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display diagnostic information about the datasette instance\n    label = \":sparkles: Starting a local datasette instance:\"\n    display_serve_or_publish_details(\n        label, database_path, metadata, port, publish=False\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 879,
        "coloffset": 4,
        "linematch": "label = \":sparkles: Starting a local datasette instance:\"",
        "context": "    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display diagnostic information about the datasette instance\n    label = \":sparkles: Starting a local datasette instance:\"\n    display_serve_or_publish_details(\n        label, database_path, metadata, port, publish=False\n    )\n    # start the datasette server that will run indefinitely;\n    # shutting down the datasette server with a CTRL-C will",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 880,
        "coloffset": 4,
        "linematch": "display_serve_or_publish_details(",
        "context": "    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    # display diagnostic information about the datasette instance\n    label = \":sparkles: Starting a local datasette instance:\"\n    display_serve_or_publish_details(\n        label, database_path, metadata, port, publish=False\n    )\n    # start the datasette server that will run indefinitely;\n    # shutting down the datasette server with a CTRL-C will\n    # also shut down this command in chasten",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 886,
        "coloffset": 4,
        "linematch": "database.start_datasette_server(",
        "context": "    )\n    # start the datasette server that will run indefinitely;\n    # shutting down the datasette server with a CTRL-C will\n    # also shut down this command in chasten\n    database.start_datasette_server(\n        database_path=database_path,\n        datasette_port=port,\n        datasette_metadata=metadata,\n        publish=False,\n        OpSystem=util.get_OS(),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "datasette_publish",
    "function_scope": "896-968",
    "patterns": [
      {
        "lineno": 896,
        "coloffset": 0,
        "linematch": "def datasette_publish(  # noqa: PLR0913",
        "context": "    )\n\n\n@cli.command()\ndef datasette_publish(  # noqa: PLR0913\n    database_path: Path = typer.Argument(\n        help=\"SQLite3 database file storing chasten's results.\",\n        exists=True,\n        file_okay=True,\n        dir_okay=False,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 896,
        "coloffset": 0,
        "linematch": "def datasette_publish(  # noqa: PLR0913",
        "context": "    )\n\n\n@cli.command()\ndef datasette_publish(  # noqa: PLR0913\n    database_path: Path = typer.Argument(\n        help=\"SQLite3 database file storing chasten's results.\",\n        exists=True,\n        file_okay=True,\n        dir_okay=False,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 938,
        "coloffset": 4,
        "linematch": "\"\"\"\ud83c\udf0e Publish a datasette to Fly or Vercel.\"\"\"",
        "context": "        help=\"Specify the destination for debugging output.\",\n    ),\n    verbose: bool = typer.Option(False, help=\"Display verbose debugging output\"),\n) -> None:\n    \"\"\"\ud83c\udf0e Publish a datasette to Fly or Vercel.\"\"\"\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,\n        debug_destination,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 940,
        "coloffset": 4,
        "linematch": "output_preamble(",
        "context": "    verbose: bool = typer.Option(False, help=\"Display verbose debugging output\"),\n) -> None:\n    \"\"\"\ud83c\udf0e Publish a datasette to Fly or Vercel.\"\"\"\n    # output the preamble, including extra parameters specific to this function\n    output_preamble(\n        verbose,\n        debug_level,\n        debug_destination,\n        database=database_path,\n        metadata=metadata,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 948,
        "coloffset": 4,
        "linematch": "output.setup(debug_level, debug_destination)",
        "context": "        database=database_path,\n        metadata=metadata,\n    )\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    output.console.print()\n    output.console.print(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 949,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Display verbose output? {verbose}\")",
        "context": "        metadata=metadata,\n    )\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    output.console.print()\n    output.console.print(\n        f\":wave: Make sure that you have previously logged into the '{datasette_platform.value}' platform\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 950,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Debug level? {debug_level.value}\")",
        "context": "    )\n    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    output.console.print()\n    output.console.print(\n        f\":wave: Make sure that you have previously logged into the '{datasette_platform.value}' platform\"\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 951,
        "coloffset": 4,
        "linematch": "output.logger.debug(f\"Debug destination? {debug_destination.value}\")",
        "context": "    # setup the console and the logger through the output module\n    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    output.console.print()\n    output.console.print(\n        f\":wave: Make sure that you have previously logged into the '{datasette_platform.value}' platform\"\n    )\n    # display details about the publishing step",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 952,
        "coloffset": 4,
        "linematch": "output.console.print()",
        "context": "    output.setup(debug_level, debug_destination)\n    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    output.console.print()\n    output.console.print(\n        f\":wave: Make sure that you have previously logged into the '{datasette_platform.value}' platform\"\n    )\n    # display details about the publishing step\n    label = f\":sparkles: Publishing a datasette to {datasette_platform.value}:\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 953,
        "coloffset": 4,
        "linematch": "output.console.print(",
        "context": "    output.logger.debug(f\"Display verbose output? {verbose}\")\n    output.logger.debug(f\"Debug level? {debug_level.value}\")\n    output.logger.debug(f\"Debug destination? {debug_destination.value}\")\n    output.console.print()\n    output.console.print(\n        f\":wave: Make sure that you have previously logged into the '{datasette_platform.value}' platform\"\n    )\n    # display details about the publishing step\n    label = f\":sparkles: Publishing a datasette to {datasette_platform.value}:\"\n    display_serve_or_publish_details(label, database_path, metadata, publish=True)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 957,
        "coloffset": 4,
        "linematch": "label = f\":sparkles: Publishing a datasette to {datasette_platform.value}:\"",
        "context": "    output.console.print(\n        f\":wave: Make sure that you have previously logged into the '{datasette_platform.value}' platform\"\n    )\n    # display details about the publishing step\n    label = f\":sparkles: Publishing a datasette to {datasette_platform.value}:\"\n    display_serve_or_publish_details(label, database_path, metadata, publish=True)\n    # publish the datasette instance using fly.io;\n    # this passes control to datasette and then to\n    # the fly program that must be installed\n    database.start_datasette_server(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 958,
        "coloffset": 4,
        "linematch": "display_serve_or_publish_details(label, database_path, metadata, publish=True)",
        "context": "        f\":wave: Make sure that you have previously logged into the '{datasette_platform.value}' platform\"\n    )\n    # display details about the publishing step\n    label = f\":sparkles: Publishing a datasette to {datasette_platform.value}:\"\n    display_serve_or_publish_details(label, database_path, metadata, publish=True)\n    # publish the datasette instance using fly.io;\n    # this passes control to datasette and then to\n    # the fly program that must be installed\n    database.start_datasette_server(\n        database_path=database_path,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 962,
        "coloffset": 4,
        "linematch": "database.start_datasette_server(",
        "context": "    display_serve_or_publish_details(label, database_path, metadata, publish=True)\n    # publish the datasette instance using fly.io;\n    # this passes control to datasette and then to\n    # the fly program that must be installed\n    database.start_datasette_server(\n        database_path=database_path,\n        datasette_metadata=metadata,\n        datasette_platform=datasette_platform.value,\n        publish=True,\n        OpSystem=util.get_OS(),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "log",
    "function_scope": "972-984",
    "patterns": [
      {
        "lineno": 972,
        "coloffset": 0,
        "linematch": "def log() -> None:",
        "context": "    )\n\n\n@cli.command()\ndef log() -> None:\n    \"\"\"\ud83e\udd9a Start the logging server.\"\"\"\n    # display the header\n    output.print_header()\n    # display details about the server\n    output.print_server()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 972,
        "coloffset": 0,
        "linematch": "def log() -> None:",
        "context": "    )\n\n\n@cli.command()\ndef log() -> None:\n    \"\"\"\ud83e\udd9a Start the logging server.\"\"\"\n    # display the header\n    output.print_header()\n    # display details about the server\n    output.print_server()",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 973,
        "coloffset": 4,
        "linematch": "\"\"\"\ud83e\udd9a Start the logging server.\"\"\"",
        "context": "\n\n@cli.command()\ndef log() -> None:\n    \"\"\"\ud83e\udd9a Start the logging server.\"\"\"\n    # display the header\n    output.print_header()\n    # display details about the server\n    output.print_server()\n    # run the server; note that this",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 975,
        "coloffset": 4,
        "linematch": "output.print_header()",
        "context": "@cli.command()\ndef log() -> None:\n    \"\"\"\ud83e\udd9a Start the logging server.\"\"\"\n    # display the header\n    output.print_header()\n    # display details about the server\n    output.print_server()\n    # run the server; note that this\n    # syslog server receives debugging\n    # information from chasten.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 977,
        "coloffset": 4,
        "linematch": "output.print_server()",
        "context": "    \"\"\"\ud83e\udd9a Start the logging server.\"\"\"\n    # display the header\n    output.print_header()\n    # display details about the server\n    output.print_server()\n    # run the server; note that this\n    # syslog server receives debugging\n    # information from chasten.\n    # It must be started in a separate process\n    # before running any sub-command",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 984,
        "coloffset": 4,
        "linematch": "server.start_syslog_server()",
        "context": "    # information from chasten.\n    # It must be started in a separate process\n    # before running any sub-command\n    # of the chasten tool\n    server.start_syslog_server()\n\n\n@cli.command()\ndef version():\n    \"\"\"\ud83d\udda5\ufe0f  Display the version of Chasten.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "version",
    "function_scope": "988-993",
    "patterns": [
      {
        "lineno": 988,
        "coloffset": 0,
        "linematch": "def version():",
        "context": "    server.start_syslog_server()\n\n\n@cli.command()\ndef version():\n    \"\"\"\ud83d\udda5\ufe0f  Display the version of Chasten.\"\"\"\n    # Get Chasten version from util file\n    version_string = util.get_chasten_version()\n    # output chasten version\n    typer.echo(f\"chasten {version_string}\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 988,
        "coloffset": 0,
        "linematch": "def version():",
        "context": "    server.start_syslog_server()\n\n\n@cli.command()\ndef version():\n    \"\"\"\ud83d\udda5\ufe0f  Display the version of Chasten.\"\"\"\n    # Get Chasten version from util file\n    version_string = util.get_chasten_version()\n    # output chasten version\n    typer.echo(f\"chasten {version_string}\")",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 989,
        "coloffset": 4,
        "linematch": "\"\"\"\ud83d\udda5\ufe0f  Display the version of Chasten.\"\"\"",
        "context": "\n\n@cli.command()\ndef version():\n    \"\"\"\ud83d\udda5\ufe0f  Display the version of Chasten.\"\"\"\n    # Get Chasten version from util file\n    version_string = util.get_chasten_version()\n    # output chasten version\n    typer.echo(f\"chasten {version_string}\")\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 991,
        "coloffset": 4,
        "linematch": "version_string = util.get_chasten_version()",
        "context": "@cli.command()\ndef version():\n    \"\"\"\ud83d\udda5\ufe0f  Display the version of Chasten.\"\"\"\n    # Get Chasten version from util file\n    version_string = util.get_chasten_version()\n    # output chasten version\n    typer.echo(f\"chasten {version_string}\")\n\n\n# ---",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 993,
        "coloffset": 4,
        "linematch": "typer.echo(f\"chasten {version_string}\")",
        "context": "    \"\"\"\ud83d\udda5\ufe0f  Display the version of Chasten.\"\"\"\n    # Get Chasten version from util file\n    version_string = util.get_chasten_version()\n    # output chasten version\n    typer.echo(f\"chasten {version_string}\")\n\n\n# ---\n# End region: Command-line interface functions }}}\n# ---",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "setup",
    "function_scope": "25-37",
    "patterns": [
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def setup(",
        "context": "# define a small bullet for display\nsmall_bullet_unicode = constants.markers.Small_Bullet_Unicode\n\n\ndef setup(\n    debug_level: debug.DebugLevel, debug_destination: debug.DebugDestination\n) -> None:\n    \"\"\"Perform the setup steps and return a Console for terminal-based display.\"\"\"\n    global logger\n    # configure the use of rich for improved terminal output:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def setup(",
        "context": "# define a small bullet for display\nsmall_bullet_unicode = constants.markers.Small_Bullet_Unicode\n\n\ndef setup(\n    debug_level: debug.DebugLevel, debug_destination: debug.DebugDestination\n) -> None:\n    \"\"\"Perform the setup steps and return a Console for terminal-based display.\"\"\"\n    global logger\n    # configure the use of rich for improved terminal output:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "\"\"\"Perform the setup steps and return a Console for terminal-based display.\"\"\"",
        "context": "\ndef setup(\n    debug_level: debug.DebugLevel, debug_destination: debug.DebugDestination\n) -> None:\n    \"\"\"Perform the setup steps and return a Console for terminal-based display.\"\"\"\n    global logger\n    # configure the use of rich for improved terminal output:\n    # --> rich-based tracebacks to enable better debugging on program crash\n    configuration.configure_tracebacks()\n    # --> logging to keep track of key events during program execution;",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "global logger",
        "context": "def setup(\n    debug_level: debug.DebugLevel, debug_destination: debug.DebugDestination\n) -> None:\n    \"\"\"Perform the setup steps and return a Console for terminal-based display.\"\"\"\n    global logger\n    # configure the use of rich for improved terminal output:\n    # --> rich-based tracebacks to enable better debugging on program crash\n    configuration.configure_tracebacks()\n    # --> logging to keep track of key events during program execution;\n    # pass in the actual values as strings instead of using class enums",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "configuration.configure_tracebacks()",
        "context": "    \"\"\"Perform the setup steps and return a Console for terminal-based display.\"\"\"\n    global logger\n    # configure the use of rich for improved terminal output:\n    # --> rich-based tracebacks to enable better debugging on program crash\n    configuration.configure_tracebacks()\n    # --> logging to keep track of key events during program execution;\n    # pass in the actual values as strings instead of using class enums\n    logger, _ = configuration.configure_logging(\n        debug_level.value, debug_destination.value\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "logger, _ = configuration.configure_logging(",
        "context": "    # --> rich-based tracebacks to enable better debugging on program crash\n    configuration.configure_tracebacks()\n    # --> logging to keep track of key events during program execution;\n    # pass in the actual values as strings instead of using class enums\n    logger, _ = configuration.configure_logging(\n        debug_level.value, debug_destination.value\n    )\n\n\ndef print_diagnostics(verbose: bool, **configurations: Any) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "global logger",
        "context": "def setup(\n    debug_level: debug.DebugLevel, debug_destination: debug.DebugDestination\n) -> None:\n    \"\"\"Perform the setup steps and return a Console for terminal-based display.\"\"\"\n    global logger\n    # configure the use of rich for improved terminal output:\n    # --> rich-based tracebacks to enable better debugging on program crash\n    configuration.configure_tracebacks()\n    # --> logging to keep track of key events during program execution;\n    # pass in the actual values as strings instead of using class enums",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #301",
        "line": 37,
        "description": [
          "    )"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "print_header",
    "function_scope": "67-74",
    "patterns": [
      {
        "lineno": 67,
        "coloffset": 0,
        "linematch": "def print_header() -> None:",
        "context": "        # always log the information to the configured logger\n        logger.debug(contents[current])\n\n\ndef print_header() -> None:\n    \"\"\"Display tool details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\n        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 67,
        "coloffset": 0,
        "linematch": "def print_header() -> None:",
        "context": "        # always log the information to the configured logger\n        logger.debug(contents[current])\n\n\ndef print_header() -> None:\n    \"\"\"Display tool details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\n        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 68,
        "coloffset": 4,
        "linematch": "\"\"\"Display tool details in the header.\"\"\"",
        "context": "        logger.debug(contents[current])\n\n\ndef print_header() -> None:\n    \"\"\"Display tool details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\n        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline\n    )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 69,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_header() -> None:\n    \"\"\"Display tool details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\n        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline\n    )\n    console.print(constants.chasten.Website)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "\ndef print_header() -> None:\n    \"\"\"Display tool details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\n        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline\n    )\n    console.print(constants.chasten.Website)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 71,
        "coloffset": 4,
        "linematch": "console.print(",
        "context": "def print_header() -> None:\n    \"\"\"Display tool details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\n        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline\n    )\n    console.print(constants.chasten.Website)\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 74,
        "coloffset": 4,
        "linematch": "console.print(constants.chasten.Website)",
        "context": "    console.print()\n    console.print(\n        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline\n    )\n    console.print(constants.chasten.Website)\n\n\ndef print_server() -> None:\n    \"\"\"Display server details in the header.\"\"\"\n    global console  # noqa: PLW0602",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 69,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_header() -> None:\n    \"\"\"Display tool details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\n        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline\n    )\n    console.print(constants.chasten.Website)",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1363",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1364",
        "line": 72,
        "description": [
          "        constants.chasten.Emoji + constants.markers.Space + constants.chasten.Tagline"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "print_server",
    "function_scope": "77-81",
    "patterns": [
      {
        "lineno": 77,
        "coloffset": 0,
        "linematch": "def print_server() -> None:",
        "context": "    )\n    console.print(constants.chasten.Website)\n\n\ndef print_server() -> None:\n    \"\"\"Display server details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Syslog)\n    console.print()\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 77,
        "coloffset": 0,
        "linematch": "def print_server() -> None:",
        "context": "    )\n    console.print(constants.chasten.Website)\n\n\ndef print_server() -> None:\n    \"\"\"Display server details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Syslog)\n    console.print()\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "\"\"\"Display server details in the header.\"\"\"",
        "context": "    console.print(constants.chasten.Website)\n\n\ndef print_server() -> None:\n    \"\"\"Display server details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Syslog)\n    console.print()\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 79,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_server() -> None:\n    \"\"\"Display server details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Syslog)\n    console.print()\n\n\ndef print_test_start() -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 80,
        "coloffset": 4,
        "linematch": "console.print(constants.output.Syslog)",
        "context": "\ndef print_server() -> None:\n    \"\"\"Display server details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Syslog)\n    console.print()\n\n\ndef print_test_start() -> None:\n    \"\"\"Display details about the test run.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 81,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "def print_server() -> None:\n    \"\"\"Display server details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Syslog)\n    console.print()\n\n\ndef print_test_start() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 79,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_server() -> None:\n    \"\"\"Display server details in the header.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Syslog)\n    console.print()\n\n\ndef print_test_start() -> None:",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "print_test_start",
    "function_scope": "84-88",
    "patterns": [
      {
        "lineno": 84,
        "coloffset": 0,
        "linematch": "def print_test_start() -> None:",
        "context": "    console.print(constants.output.Syslog)\n    console.print()\n\n\ndef print_test_start() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Test_Start)\n    console.print()\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 84,
        "coloffset": 0,
        "linematch": "def print_test_start() -> None:",
        "context": "    console.print(constants.output.Syslog)\n    console.print()\n\n\ndef print_test_start() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Test_Start)\n    console.print()\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 85,
        "coloffset": 4,
        "linematch": "\"\"\"Display details about the test run.\"\"\"",
        "context": "    console.print()\n\n\ndef print_test_start() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Test_Start)\n    console.print()\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 86,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_test_start() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Test_Start)\n    console.print()\n\n\ndef print_test_finish() -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 87,
        "coloffset": 4,
        "linematch": "console.print(constants.output.Test_Start)",
        "context": "\ndef print_test_start() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Test_Start)\n    console.print()\n\n\ndef print_test_finish() -> None:\n    \"\"\"Display details about the test run.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 88,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "def print_test_start() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Test_Start)\n    console.print()\n\n\ndef print_test_finish() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 86,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_test_start() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print(constants.output.Test_Start)\n    console.print()\n\n\ndef print_test_finish() -> None:",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "print_test_finish",
    "function_scope": "91-96",
    "patterns": [
      {
        "lineno": 91,
        "coloffset": 0,
        "linematch": "def print_test_finish() -> None:",
        "context": "    console.print(constants.output.Test_Start)\n    console.print()\n\n\ndef print_test_finish() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\":sparkles: Finished running test suite for the specified program\")\n    console.print()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 91,
        "coloffset": 0,
        "linematch": "def print_test_finish() -> None:",
        "context": "    console.print(constants.output.Test_Start)\n    console.print()\n\n\ndef print_test_finish() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\":sparkles: Finished running test suite for the specified program\")\n    console.print()",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 92,
        "coloffset": 4,
        "linematch": "\"\"\"Display details about the test run.\"\"\"",
        "context": "    console.print()\n\n\ndef print_test_finish() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\":sparkles: Finished running test suite for the specified program\")\n    console.print()\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 93,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_test_finish() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\":sparkles: Finished running test suite for the specified program\")\n    console.print()\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "\ndef print_test_finish() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\":sparkles: Finished running test suite for the specified program\")\n    console.print()\n\n\ndef print_footer() -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 95,
        "coloffset": 4,
        "linematch": "console.print(\":sparkles: Finished running test suite for the specified program\")",
        "context": "def print_test_finish() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\":sparkles: Finished running test suite for the specified program\")\n    console.print()\n\n\ndef print_footer() -> None:\n    \"\"\"Display concluding details in the footer.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\":sparkles: Finished running test suite for the specified program\")\n    console.print()\n\n\ndef print_footer() -> None:\n    \"\"\"Display concluding details in the footer.\"\"\"\n    global console  # noqa: PLW0602",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 93,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_test_finish() -> None:\n    \"\"\"Display details about the test run.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n    console.print(\":sparkles: Finished running test suite for the specified program\")\n    console.print()\n\n",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1365",
        "line": 95,
        "description": [
          "    console.print(\":sparkles: Finished running test suite for the specified program\")"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "print_footer",
    "function_scope": "99-102",
    "patterns": [
      {
        "lineno": 99,
        "coloffset": 0,
        "linematch": "def print_footer() -> None:",
        "context": "    console.print(\":sparkles: Finished running test suite for the specified program\")\n    console.print()\n\n\ndef print_footer() -> None:\n    \"\"\"Display concluding details in the footer.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 99,
        "coloffset": 0,
        "linematch": "def print_footer() -> None:",
        "context": "    console.print(\":sparkles: Finished running test suite for the specified program\")\n    console.print()\n\n\ndef print_footer() -> None:\n    \"\"\"Display concluding details in the footer.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 100,
        "coloffset": 4,
        "linematch": "\"\"\"Display concluding details in the footer.\"\"\"",
        "context": "    console.print()\n\n\ndef print_footer() -> None:\n    \"\"\"Display concluding details in the footer.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n\n\ndef group_files_by_directory(file_paths: List[Path]) -> Dict[Path, List[str]]:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 101,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_footer() -> None:\n    \"\"\"Display concluding details in the footer.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n\n\ndef group_files_by_directory(file_paths: List[Path]) -> Dict[Path, List[str]]:\n    \"\"\"Organize the files in a list according to their base directory.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 102,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "\ndef print_footer() -> None:\n    \"\"\"Display concluding details in the footer.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n\n\ndef group_files_by_directory(file_paths: List[Path]) -> Dict[Path, List[str]]:\n    \"\"\"Organize the files in a list according to their base directory.\"\"\"\n    # create an empty dictionary",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 101,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_footer() -> None:\n    \"\"\"Display concluding details in the footer.\"\"\"\n    global console  # noqa: PLW0602\n    console.print()\n\n\ndef group_files_by_directory(file_paths: List[Path]) -> Dict[Path, List[str]]:\n    \"\"\"Organize the files in a list according to their base directory.\"\"\"",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "print_list_contents",
    "function_scope": "137-157",
    "patterns": [
      {
        "lineno": 137,
        "coloffset": 0,
        "linematch": "def print_list_contents(container: List[Path]) -> None:",
        "context": "        return \"... \" + file_name[-(max_length - 3) :]\n    return file_name\n\n\ndef print_list_contents(container: List[Path]) -> None:\n    \"\"\"Display the contents of the list in an easy-to-read fashion.\"\"\"\n    global console  # noqa: PLW0602\n    # group all of the files by the directory that contains them;\n    # note that this is important because the contain can contain\n    # paths that specify files in different directories",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 137,
        "coloffset": 0,
        "linematch": "def print_list_contents(container: List[Path]) -> None:",
        "context": "        return \"... \" + file_name[-(max_length - 3) :]\n    return file_name\n\n\ndef print_list_contents(container: List[Path]) -> None:\n    \"\"\"Display the contents of the list in an easy-to-read fashion.\"\"\"\n    global console  # noqa: PLW0602\n    # group all of the files by the directory that contains them;\n    # note that this is important because the contain can contain\n    # paths that specify files in different directories",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 147,
        "coloffset": 4,
        "linematch": "for directory, files in grouped_files.items():",
        "context": "    grouped_files = group_files_by_directory(container)\n    # iterate through each of the directories and\n    # --> display the name of the directory\n    # --> display the name of each file stored in this directory\n    for directory, files in grouped_files.items():\n        console.print(f\"{small_bullet_unicode} Directory: {directory}\")\n        filecount = 0\n        for file_name in files:\n            filecount = +1\n            console.print(",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 138,
        "coloffset": 4,
        "linematch": "\"\"\"Display the contents of the list in an easy-to-read fashion.\"\"\"",
        "context": "    return file_name\n\n\ndef print_list_contents(container: List[Path]) -> None:\n    \"\"\"Display the contents of the list in an easy-to-read fashion.\"\"\"\n    global console  # noqa: PLW0602\n    # group all of the files by the directory that contains them;\n    # note that this is important because the contain can contain\n    # paths that specify files in different directories\n    grouped_files = group_files_by_directory(container)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 139,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_list_contents(container: List[Path]) -> None:\n    \"\"\"Display the contents of the list in an easy-to-read fashion.\"\"\"\n    global console  # noqa: PLW0602\n    # group all of the files by the directory that contains them;\n    # note that this is important because the contain can contain\n    # paths that specify files in different directories\n    grouped_files = group_files_by_directory(container)\n    # iterate through each of the directories and",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 143,
        "coloffset": 4,
        "linematch": "grouped_files = group_files_by_directory(container)",
        "context": "    global console  # noqa: PLW0602\n    # group all of the files by the directory that contains them;\n    # note that this is important because the contain can contain\n    # paths that specify files in different directories\n    grouped_files = group_files_by_directory(container)\n    # iterate through each of the directories and\n    # --> display the name of the directory\n    # --> display the name of each file stored in this directory\n    for directory, files in grouped_files.items():\n        console.print(f\"{small_bullet_unicode} Directory: {directory}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 147,
        "coloffset": 4,
        "linematch": "for directory, files in grouped_files.items():",
        "context": "    grouped_files = group_files_by_directory(container)\n    # iterate through each of the directories and\n    # --> display the name of the directory\n    # --> display the name of each file stored in this directory\n    for directory, files in grouped_files.items():\n        console.print(f\"{small_bullet_unicode} Directory: {directory}\")\n        filecount = 0\n        for file_name in files:\n            filecount = +1\n            console.print(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 139,
        "coloffset": 4,
        "linematch": "global console  # noqa: PLW0602",
        "context": "\n\ndef print_list_contents(container: List[Path]) -> None:\n    \"\"\"Display the contents of the list in an easy-to-read fashion.\"\"\"\n    global console  # noqa: PLW0602\n    # group all of the files by the directory that contains them;\n    # note that this is important because the contain can contain\n    # paths that specify files in different directories\n    grouped_files = group_files_by_directory(container)\n    # iterate through each of the directories and",
        "pattern": ".//Global",
        "check_id": "F035",
        "check_name": "use-of-global-variables"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #305",
        "line": 143,
        "description": [
          "    grouped_files = group_files_by_directory(container)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #306",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #307",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1374",
        "line": 148,
        "description": [
          "        console.print(f\"{small_bullet_unicode} Directory: {directory}\")"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1375",
        "line": 149,
        "description": [
          "        filecount = 0"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1376",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1377",
        "line": 151,
        "description": [
          "            filecount = +1"
        ],
        "failure": []
      },
      {
        "name": "Mutant #1378",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1379",
        "line": 153,
        "description": [
          "                f\"  {small_bullet_unicode} File: '{shorten_file_name(file_name, 120)}'\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #1380",
        "line": 156,
        "description": [
          "                f\"  {small_bullet_unicode} file(s) {int(filecount)} in this directory\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  }
]