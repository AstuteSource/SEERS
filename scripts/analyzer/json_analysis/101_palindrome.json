[
  {
    "function_name": "test_human_readable_boolean_true",
    "function_scope": "6-14",
    "patterns": [
      {
        "lineno": 6,
        "coloffset": 0,
        "linematch": "def test_human_readable_boolean_true():",
        "context": "\nfrom src.util import human_readable_boolean\n\n\ndef test_human_readable_boolean_true():\n    \"\"\"Ensure that a human-readable true boolean works correctly.\"\"\"\n    # given the boolean value\n    true_value = True\n    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 6,
        "coloffset": 0,
        "linematch": "def test_human_readable_boolean_true():",
        "context": "\nfrom src.util import human_readable_boolean\n\n\ndef test_human_readable_boolean_true():\n    \"\"\"Ensure that a human-readable true boolean works correctly.\"\"\"\n    # given the boolean value\n    true_value = True\n    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert true_value_human_readable == \"Yes, it is!\"",
        "context": "    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)\n    # assert output\n    # to test if actual output === expected output\n    assert true_value_human_readable == \"Yes, it is!\"\n\n\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 7,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a human-readable true boolean works correctly.\"\"\"",
        "context": "from src.util import human_readable_boolean\n\n\ndef test_human_readable_boolean_true():\n    \"\"\"Ensure that a human-readable true boolean works correctly.\"\"\"\n    # given the boolean value\n    true_value = True\n    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)\n    # assert output",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "true_value = True",
        "context": "\ndef test_human_readable_boolean_true():\n    \"\"\"Ensure that a human-readable true boolean works correctly.\"\"\"\n    # given the boolean value\n    true_value = True\n    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)\n    # assert output\n    # to test if actual output === expected output\n    assert true_value_human_readable == \"Yes, it is!\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "true_value_human_readable = human_readable_boolean(true_value)",
        "context": "    \"\"\"Ensure that a human-readable true boolean works correctly.\"\"\"\n    # given the boolean value\n    true_value = True\n    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)\n    # assert output\n    # to test if actual output === expected output\n    assert true_value_human_readable == \"Yes, it is!\"\n\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert true_value_human_readable == \"Yes, it is!\"",
        "context": "    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)\n    # assert output\n    # to test if actual output === expected output\n    assert true_value_human_readable == \"Yes, it is!\"\n\n\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 7,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a human-readable true boolean works correctly.\"\"\"",
        "context": "from src.util import human_readable_boolean\n\n\ndef test_human_readable_boolean_true():\n    \"\"\"Ensure that a human-readable true boolean works correctly.\"\"\"\n    # given the boolean value\n    true_value = True\n    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)\n    # assert output",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "true_value = True",
        "context": "\ndef test_human_readable_boolean_true():\n    \"\"\"Ensure that a human-readable true boolean works correctly.\"\"\"\n    # given the boolean value\n    true_value = True\n    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)\n    # assert output\n    # to test if actual output === expected output\n    assert true_value_human_readable == \"Yes, it is!\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "true_value_human_readable = human_readable_boolean(true_value)",
        "context": "    \"\"\"Ensure that a human-readable true boolean works correctly.\"\"\"\n    # given the boolean value\n    true_value = True\n    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)\n    # assert output\n    # to test if actual output === expected output\n    assert true_value_human_readable == \"Yes, it is!\"\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "assert true_value_human_readable == \"Yes, it is!\"",
        "context": "    # call function with the given value\n    true_value_human_readable = human_readable_boolean(true_value)\n    # assert output\n    # to test if actual output === expected output\n    assert true_value_human_readable == \"Yes, it is!\"\n\n\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #23",
        "line": 14,
        "description": [
          "cli = typer.Typer()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_human_readable_boolean_false",
    "function_scope": "17-21",
    "patterns": [
      {
        "lineno": 17,
        "coloffset": 0,
        "linematch": "def test_human_readable_boolean_false():",
        "context": "    # to test if actual output === expected output\n    assert true_value_human_readable == \"Yes, it is!\"\n\n\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 21,
        "coloffset": 11,
        "linematch": "assert true_value_human_readable == \"No, it is not!\"",
        "context": "def test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 21,
        "coloffset": 11,
        "linematch": "assert true_value_human_readable == \"No, it is not!\"",
        "context": "def test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 17,
        "coloffset": 0,
        "linematch": "def test_human_readable_boolean_false():",
        "context": "    # to test if actual output === expected output\n    assert true_value_human_readable == \"Yes, it is!\"\n\n\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "assert true_value_human_readable == \"No, it is not!\"",
        "context": "def test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"",
        "context": "    assert true_value_human_readable == \"Yes, it is!\"\n\n\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "true_value = False",
        "context": "\n\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "true_value_human_readable = human_readable_boolean(true_value)",
        "context": "\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "assert true_value_human_readable == \"No, it is not!\"",
        "context": "def test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"",
        "context": "    assert true_value_human_readable == \"Yes, it is!\"\n\n\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "true_value = False",
        "context": "\n\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "true_value_human_readable = human_readable_boolean(true_value)",
        "context": "\ndef test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "assert true_value_human_readable == \"No, it is not!\"",
        "context": "def test_human_readable_boolean_false():\n    \"\"\"Ensure that a human-readable false boolean works correctly.\"\"\"\n    true_value = False\n    true_value_human_readable = human_readable_boolean(true_value)\n    assert true_value_human_readable == \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_short_palindrome_word_recursive",
    "function_scope": "8-15",
    "patterns": [
      {
        "lineno": 8,
        "coloffset": 0,
        "linematch": "def test_short_palindrome_word_recursive():",
        "context": "from src.palindrome import is_palindrome_reverse\n\n\n# test case for recursive approach, return the result True\ndef test_short_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with recursive.\"\"\"\n    # give the function a palindrome word\n    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 8,
        "coloffset": 0,
        "linematch": "def test_short_palindrome_word_recursive():",
        "context": "from src.palindrome import is_palindrome_reverse\n\n\n# test case for recursive approach, return the result True\ndef test_short_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with recursive.\"\"\"\n    # give the function a palindrome word\n    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)\n    # assert the result\n    assert result is True\n\n\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a short word of \"civic\" works correctly with recursive.\"\"\"",
        "context": "\n\n# test case for recursive approach, return the result True\ndef test_short_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with recursive.\"\"\"\n    # give the function a palindrome word\n    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)\n    # assert the result",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "word = \"civic\"",
        "context": "# test case for recursive approach, return the result True\ndef test_short_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with recursive.\"\"\"\n    # give the function a palindrome word\n    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)\n    # assert the result\n    assert result is True\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "result = is_palindrome_recursive(word)",
        "context": "    \"\"\"Ensure that a short word of \"civic\" works correctly with recursive.\"\"\"\n    # give the function a palindrome word\n    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)\n    # assert the result\n    assert result is True\n\n\ndef test_short_not_palindrome_word_recursive():",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)\n    # assert the result\n    assert result is True\n\n\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a short word of \"civic\" works correctly with recursive.\"\"\"",
        "context": "\n\n# test case for recursive approach, return the result True\ndef test_short_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with recursive.\"\"\"\n    # give the function a palindrome word\n    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)\n    # assert the result",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "word = \"civic\"",
        "context": "# test case for recursive approach, return the result True\ndef test_short_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with recursive.\"\"\"\n    # give the function a palindrome word\n    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)\n    # assert the result\n    assert result is True\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "result = is_palindrome_recursive(word)",
        "context": "    \"\"\"Ensure that a short word of \"civic\" works correctly with recursive.\"\"\"\n    # give the function a palindrome word\n    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)\n    # assert the result\n    assert result is True\n\n\ndef test_short_not_palindrome_word_recursive():",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "    word = \"civic\"\n    # calling the function from the palindrome.py\n    result = is_palindrome_recursive(word)\n    # assert the result\n    assert result is True\n\n\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #23",
        "line": 14,
        "description": [
          "cli = typer.Typer()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_short_not_palindrome_word_recursive",
    "function_scope": "18-22",
    "patterns": [
      {
        "lineno": 18,
        "coloffset": 0,
        "linematch": "def test_short_not_palindrome_word_recursive():",
        "context": "    # assert the result\n    assert result is True\n\n\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 18,
        "coloffset": 0,
        "linematch": "def test_short_not_palindrome_word_recursive():",
        "context": "    # assert the result\n    assert result is True\n\n\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert result is False",
        "context": "def test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"",
        "context": "    assert result is True\n\n\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "word = \"taylor\"",
        "context": "\n\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n\n\ndef test_short_palindrome_word_reverse():",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "result = is_palindrome_recursive(word)",
        "context": "\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert result is False",
        "context": "def test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"",
        "context": "    assert result is True\n\n\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "word = \"taylor\"",
        "context": "\n\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n\n\ndef test_short_palindrome_word_reverse():",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 21,
        "coloffset": 4,
        "linematch": "result = is_palindrome_recursive(word)",
        "context": "\ndef test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert result is False",
        "context": "def test_short_not_palindrome_word_recursive():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with recursive.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_recursive(word)\n    assert result is False\n\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_short_palindrome_word_reverse",
    "function_scope": "25-29",
    "patterns": [
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def test_short_palindrome_word_reverse():",
        "context": "    result = is_palindrome_recursive(word)\n    assert result is False\n\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def test_short_palindrome_word_reverse():",
        "context": "    result = is_palindrome_recursive(word)\n    assert result is False\n\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "def test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"",
        "context": "    assert result is False\n\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "word = \"civic\"",
        "context": "\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "result = is_palindrome_reverse(word)",
        "context": "\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "def test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"",
        "context": "    assert result is False\n\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "word = \"civic\"",
        "context": "\n\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "result = is_palindrome_reverse(word)",
        "context": "\ndef test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "assert result is True",
        "context": "def test_short_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"civic\" works correctly with reverse.\"\"\"\n    word = \"civic\"\n    result = is_palindrome_reverse(word)\n    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #26",
        "line": 25,
        "description": [
          "    REVERSE = \"reverse\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #27",
        "line": 25,
        "description": [
          "    REVERSE = \"reverse\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #28",
        "line": 29,
        "description": [
          "        return self.value if self is not None else \"\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #29",
        "line": 29,
        "description": [
          "        return self.value if self is not None else \"\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -26,7 +26,7 @@\n \n     def __str__(self):\n         \"\"\"Create string function.\"\"\"\n-        return self.value if self is not None else \"\"\n+        return self.value if self is not None else \"XXXX\"\n \n \n # When you are setting the default values of the --approach variable\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 75.0
  },
  {
    "function_name": "test_short_not_palindrome_word_reverse",
    "function_scope": "32-36",
    "patterns": [
      {
        "lineno": 32,
        "coloffset": 0,
        "linematch": "def test_short_not_palindrome_word_reverse():",
        "context": "    result = is_palindrome_reverse(word)\n    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 36,
        "coloffset": 11,
        "linematch": "assert result is False",
        "context": "def test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 36,
        "coloffset": 11,
        "linematch": "assert result is False",
        "context": "def test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 36,
        "coloffset": 11,
        "linematch": "assert result is False",
        "context": "def test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 36,
        "coloffset": 11,
        "linematch": "assert result is False",
        "context": "def test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 32,
        "coloffset": 0,
        "linematch": "def test_short_not_palindrome_word_reverse():",
        "context": "    result = is_palindrome_reverse(word)\n    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert result is False",
        "context": "def test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"",
        "context": "    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "word = \"taylor\"",
        "context": "\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "result = is_palindrome_reverse(word)",
        "context": "\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert result is False",
        "context": "def test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"",
        "context": "    assert result is True\n\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "word = \"taylor\"",
        "context": "\n\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "result = is_palindrome_reverse(word)",
        "context": "\ndef test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert result is False",
        "context": "def test_short_not_palindrome_word_reverse():\n    \"\"\"Ensure that a short word of \"taylor\" does not work correctly with reverse.\"\"\"\n    word = \"taylor\"\n    result = is_palindrome_reverse(word)\n    assert result is False",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_palindromechecker_recursive_is_palindrome",
    "function_scope": "15-27",
    "patterns": [
      {
        "lineno": 15,
        "coloffset": 0,
        "linematch": "def test_palindromechecker_recursive_is_palindrome():",
        "context": "# Reference:\n# https://typer.tiangolo.com/tutorial/testing/\n\n\ndef test_palindromechecker_recursive_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    # invoke() method of the `runner` object is called with the cli arguments\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 15,
        "coloffset": 0,
        "linematch": "def test_palindromechecker_recursive_is_palindrome():",
        "context": "# Reference:\n# https://typer.tiangolo.com/tutorial/testing/\n\n\ndef test_palindromechecker_recursive_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    # invoke() method of the `runner` object is called with the cli arguments\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    # invoke() method of the `runner` object is called with the cli arguments\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert \"recursive\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "assert \"reverse\" not in result.stdout",
        "context": "    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "assert \"Yes, it is!\" in result.stdout",
        "context": "    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_recursive_is_not_palindrome():",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert \"civic\" in result.stdout",
        "context": "    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"",
        "context": "# https://typer.tiangolo.com/tutorial/testing/\n\n\ndef test_palindromechecker_recursive_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    # invoke() method of the `runner` object is called with the cli arguments\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])",
        "context": "\ndef test_palindromechecker_recursive_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    # invoke() method of the `runner` object is called with the cli arguments\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    # invoke() method of the `runner` object is called with the cli arguments\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert \"recursive\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "assert \"reverse\" not in result.stdout",
        "context": "    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "assert \"Yes, it is!\" in result.stdout",
        "context": "    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_recursive_is_not_palindrome():",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert \"civic\" in result.stdout",
        "context": "    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"",
        "context": "# https://typer.tiangolo.com/tutorial/testing/\n\n\ndef test_palindromechecker_recursive_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    # invoke() method of the `runner` object is called with the cli arguments\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])",
        "context": "\ndef test_palindromechecker_recursive_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    # invoke() method of the `runner` object is called with the cli arguments\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    # invoke() method of the `runner` object is called with the cli arguments\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "assert \"recursive\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"recursive\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "assert \"reverse\" not in result.stdout",
        "context": "    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "assert \"Yes, it is!\" in result.stdout",
        "context": "    # assert Recursive in program output\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_recursive_is_not_palindrome():",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert \"civic\" in result.stdout",
        "context": "    assert \"reverse\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #24",
        "line": 24,
        "description": [
          "    RECURSIVE = \"recursive\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #25",
        "line": 24,
        "description": [
          "    RECURSIVE = \"recursive\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #26",
        "line": 25,
        "description": [
          "    REVERSE = \"reverse\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #27",
        "line": 25,
        "description": [
          "    REVERSE = \"reverse\""
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_palindromechecker_recursive_is_not_palindrome",
    "function_scope": "30-37",
    "patterns": [
      {
        "lineno": 30,
        "coloffset": 0,
        "linematch": "def test_palindromechecker_recursive_is_not_palindrome():",
        "context": "    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 30,
        "coloffset": 0,
        "linematch": "def test_palindromechecker_recursive_is_not_palindrome():",
        "context": "    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert \"recursive\" in result.stdout",
        "context": "def test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "assert \"reverse\" not in result.stdout",
        "context": "    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert \"No, it is not\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "assert \"love\" in result.stdout",
        "context": "    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"",
        "context": "    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])",
        "context": "\n\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert \"recursive\" in result.stdout",
        "context": "def test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "assert \"reverse\" not in result.stdout",
        "context": "    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert \"No, it is not\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "assert \"love\" in result.stdout",
        "context": "    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"",
        "context": "    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])",
        "context": "\n\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "\ndef test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "assert \"recursive\" in result.stdout",
        "context": "def test_palindromechecker_recursive_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "assert \"reverse\" not in result.stdout",
        "context": "    \"\"\"Ensure that the command-line interface works for recursive approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "assert \"No, it is not\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"recursive\"])\n    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "assert \"love\" in result.stdout",
        "context": "    assert result.exit_code == 0\n    assert \"recursive\" in result.stdout\n    assert \"reverse\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_palindromechecker_reverse_is_palindrome",
    "function_scope": "40-51",
    "patterns": [
      {
        "lineno": 40,
        "coloffset": 0,
        "linematch": "def test_palindromechecker_reverse_is_palindrome():",
        "context": "    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 40,
        "coloffset": 0,
        "linematch": "def test_palindromechecker_reverse_is_palindrome():",
        "context": "    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "def test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert \"reverse\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "assert \"recursive\" not in result.stdout",
        "context": "    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "assert \"Yes, it is!\" in result.stdout",
        "context": "    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_not_palindrome():",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "assert \"civic\" in result.stdout",
        "context": "    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"",
        "context": "    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])",
        "context": "\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "def test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert \"reverse\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "assert \"recursive\" not in result.stdout",
        "context": "    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "assert \"Yes, it is!\" in result.stdout",
        "context": "    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_not_palindrome():",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "assert \"civic\" in result.stdout",
        "context": "    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"",
        "context": "    assert \"love\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])",
        "context": "\n\ndef test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "def test_palindromechecker_reverse_is_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert \"reverse\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"civic\", \"--approach\", \"reverse\"])\n    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "assert \"recursive\" not in result.stdout",
        "context": "    # checks whether the program exited without errors\n    assert result.exit_code == 0\n    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "assert \"Yes, it is!\" in result.stdout",
        "context": "    # assert Recursive in program output\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_not_palindrome():",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "assert \"civic\" in result.stdout",
        "context": "    assert \"recursive\" not in result.stdout\n    # assert True in human_readable_boolean\n    assert \"Yes, it is!\" in result.stdout\n    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #31",
        "line": 45,
        "description": [
          "    console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #32",
        "line": 48,
        "description": [
          "    if approach == PalindromeApproach.RECURSIVE:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #33",
        "line": 49,
        "description": [
          "        result = palindrome.is_palindrome_recursive(word)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #34",
        "line": 51,
        "description": [
          "    elif approach == PalindromeApproach.REVERSE:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "test_palindromechecker_reverse_is_not_palindrome",
    "function_scope": "54-61",
    "patterns": [
      {
        "lineno": 54,
        "coloffset": 0,
        "linematch": "def test_palindromechecker_reverse_is_not_palindrome():",
        "context": "    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 57,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 57,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 57,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 57,
        "coloffset": 11,
        "linematch": "assert result.exit_code == 0",
        "context": "\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 54,
        "coloffset": 0,
        "linematch": "def test_palindromechecker_reverse_is_not_palindrome():",
        "context": "    # assert the word in the program output\n    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 57,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "assert \"reverse\" in result.stdout",
        "context": "def test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 59,
        "coloffset": 4,
        "linematch": "assert \"recursive\" not in result.stdout",
        "context": "    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 60,
        "coloffset": 4,
        "linematch": "assert \"No, it is not\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "assert \"love\" in result.stdout",
        "context": "    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"",
        "context": "    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])",
        "context": "\n\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 57,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "assert \"reverse\" in result.stdout",
        "context": "def test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 4,
        "linematch": "assert \"recursive\" not in result.stdout",
        "context": "    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 60,
        "coloffset": 4,
        "linematch": "assert \"No, it is not\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "assert \"love\" in result.stdout",
        "context": "    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"",
        "context": "    assert \"civic\" in result.stdout\n\n\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])",
        "context": "\n\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 57,
        "coloffset": 4,
        "linematch": "assert result.exit_code == 0",
        "context": "\ndef test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "assert \"reverse\" in result.stdout",
        "context": "def test_palindromechecker_reverse_is_not_palindrome():\n    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 4,
        "linematch": "assert \"recursive\" not in result.stdout",
        "context": "    \"\"\"Ensure that the command-line interface works for reverse approach.\"\"\"\n    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 60,
        "coloffset": 4,
        "linematch": "assert \"No, it is not\" in result.stdout",
        "context": "    result = runner.invoke(cli, [\"--word\", \"love\", \"--approach\", \"reverse\"])\n    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "assert \"love\" in result.stdout",
        "context": "    assert result.exit_code == 0\n    assert \"reverse\" in result.stdout\n    assert \"recursive\" not in result.stdout\n    assert \"No, it is not\" in result.stdout\n    assert \"love\" in result.stdout",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #36",
        "line": 54,
        "description": [
          "    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -51,7 +51,7 @@\n     elif approach == PalindromeApproach.REVERSE:\n         result = palindrome.is_palindrome_reverse(word)\n \n-    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n+    console.print(f\"XX\u2728 Awesome, using the {approach} approach for palindrome checking!XX\")\n     console.print()\n     console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n     console.print()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #37",
        "line": 56,
        "description": [
          "    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -53,7 +53,7 @@\n \n     console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n     console.print()\n-    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n+    console.print(f\"XX\ud83d\udd16 Going to check to see if the word {word} is a palindrome!XX\")\n     console.print()\n     console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #38",
        "line": 58,
        "description": [
          "    console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -55,7 +55,7 @@\n     console.print()\n     console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n     console.print()\n-    console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")\n+    console.print(f\"XX\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}XX\")\n \n \n # implement a command-line interface using typer that produces\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "to_char",
    "function_scope": "7-14",
    "patterns": [
      {
        "lineno": 7,
        "coloffset": 0,
        "linematch": "def to_char(word: str) -> str:",
        "context": "# Reference:\n# https://en.wikipedia.org/wiki/Palindrome\n\n\ndef to_char(word: str) -> str:\n    \"\"\"Convert string to character.\"\"\"\n    word = word.lower()\n    letters = \"\"\n    for char in word:\n        if char in \"abcdefghijklmnopqrstuvwxyz\":",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 7,
        "coloffset": 0,
        "linematch": "def to_char(word: str) -> str:",
        "context": "# Reference:\n# https://en.wikipedia.org/wiki/Palindrome\n\n\ndef to_char(word: str) -> str:\n    \"\"\"Convert string to character.\"\"\"\n    word = word.lower()\n    letters = \"\"\n    for char in word:\n        if char in \"abcdefghijklmnopqrstuvwxyz\":",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 12,
        "coloffset": 8,
        "linematch": "if char in \"abcdefghijklmnopqrstuvwxyz\":",
        "context": "    \"\"\"Convert string to character.\"\"\"\n    word = word.lower()\n    letters = \"\"\n    for char in word:\n        if char in \"abcdefghijklmnopqrstuvwxyz\":\n            letters = letters + char\n    return letters\n\n\n# implement def is_palindrome(word: str) -> bool:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 7,
        "coloffset": 0,
        "linematch": "def to_char(word: str) -> str:",
        "context": "# Reference:\n# https://en.wikipedia.org/wiki/Palindrome\n\n\ndef to_char(word: str) -> str:\n    \"\"\"Convert string to character.\"\"\"\n    word = word.lower()\n    letters = \"\"\n    for char in word:\n        if char in \"abcdefghijklmnopqrstuvwxyz\":",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 8,
        "coloffset": 4,
        "linematch": "\"\"\"Convert string to character.\"\"\"",
        "context": "# https://en.wikipedia.org/wiki/Palindrome\n\n\ndef to_char(word: str) -> str:\n    \"\"\"Convert string to character.\"\"\"\n    word = word.lower()\n    letters = \"\"\n    for char in word:\n        if char in \"abcdefghijklmnopqrstuvwxyz\":\n            letters = letters + char",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "word = word.lower()",
        "context": "\n\ndef to_char(word: str) -> str:\n    \"\"\"Convert string to character.\"\"\"\n    word = word.lower()\n    letters = \"\"\n    for char in word:\n        if char in \"abcdefghijklmnopqrstuvwxyz\":\n            letters = letters + char\n    return letters",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "letters = \"\"",
        "context": "\ndef to_char(word: str) -> str:\n    \"\"\"Convert string to character.\"\"\"\n    word = word.lower()\n    letters = \"\"\n    for char in word:\n        if char in \"abcdefghijklmnopqrstuvwxyz\":\n            letters = letters + char\n    return letters\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "for char in word:",
        "context": "def to_char(word: str) -> str:\n    \"\"\"Convert string to character.\"\"\"\n    word = word.lower()\n    letters = \"\"\n    for char in word:\n        if char in \"abcdefghijklmnopqrstuvwxyz\":\n            letters = letters + char\n    return letters\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "return letters",
        "context": "    letters = \"\"\n    for char in word:\n        if char in \"abcdefghijklmnopqrstuvwxyz\":\n            letters = letters + char\n    return letters\n\n\n# implement def is_palindrome(word: str) -> bool:\ndef is_palindrome(word: str) -> bool:\n    \"\"\"Check palindrome.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #23",
        "line": 14,
        "description": [
          "cli = typer.Typer()"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "is_palindrome",
    "function_scope": "18-22",
    "patterns": [
      {
        "lineno": 18,
        "coloffset": 0,
        "linematch": "def is_palindrome(word: str) -> bool:",
        "context": "    return letters\n\n\n# implement def is_palindrome(word: str) -> bool:\ndef is_palindrome(word: str) -> bool:\n    \"\"\"Check palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    return word[0] == word[-1] and is_palindrome(word[1:-1])\n",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 18,
        "coloffset": 0,
        "linematch": "def is_palindrome(word: str) -> bool:",
        "context": "    return letters\n\n\n# implement def is_palindrome(word: str) -> bool:\ndef is_palindrome(word: str) -> bool:\n    \"\"\"Check palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    return word[0] == word[-1] and is_palindrome(word[1:-1])\n",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "if len(word) <= 1:",
        "context": "\n# implement def is_palindrome(word: str) -> bool:\ndef is_palindrome(word: str) -> bool:\n    \"\"\"Check palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    return word[0] == word[-1] and is_palindrome(word[1:-1])\n\n\n# implement def is_palindrome_recursive(word: str) -> bool:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 22,
        "coloffset": 11,
        "linematch": "return word[0] == word[-1] and is_palindrome(word[1:-1])",
        "context": "def is_palindrome(word: str) -> bool:\n    \"\"\"Check palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    return word[0] == word[-1] and is_palindrome(word[1:-1])\n\n\n# implement def is_palindrome_recursive(word: str) -> bool:\ndef is_palindrome_recursive(word: str) -> bool:\n    \"\"\"Check palindrome with recursive approach.\"\"\"",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 22,
        "coloffset": 11,
        "linematch": "return word[0] == word[-1] and is_palindrome(word[1:-1])",
        "context": "def is_palindrome(word: str) -> bool:\n    \"\"\"Check palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    return word[0] == word[-1] and is_palindrome(word[1:-1])\n\n\n# implement def is_palindrome_recursive(word: str) -> bool:\ndef is_palindrome_recursive(word: str) -> bool:\n    \"\"\"Check palindrome with recursive approach.\"\"\"",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 18,
        "coloffset": 0,
        "linematch": "def is_palindrome(word: str) -> bool:",
        "context": "    return letters\n\n\n# implement def is_palindrome(word: str) -> bool:\ndef is_palindrome(word: str) -> bool:\n    \"\"\"Check palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    return word[0] == word[-1] and is_palindrome(word[1:-1])\n",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "\"\"\"Check palindrome.\"\"\"",
        "context": "\n\n# implement def is_palindrome(word: str) -> bool:\ndef is_palindrome(word: str) -> bool:\n    \"\"\"Check palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    return word[0] == word[-1] and is_palindrome(word[1:-1])\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "if len(word) <= 1:",
        "context": "\n# implement def is_palindrome(word: str) -> bool:\ndef is_palindrome(word: str) -> bool:\n    \"\"\"Check palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    return word[0] == word[-1] and is_palindrome(word[1:-1])\n\n\n# implement def is_palindrome_recursive(word: str) -> bool:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "return word[0] == word[-1] and is_palindrome(word[1:-1])",
        "context": "def is_palindrome(word: str) -> bool:\n    \"\"\"Check palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    return word[0] == word[-1] and is_palindrome(word[1:-1])\n\n\n# implement def is_palindrome_recursive(word: str) -> bool:\ndef is_palindrome_recursive(word: str) -> bool:\n    \"\"\"Check palindrome with recursive approach.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "is_palindrome_recursive",
    "function_scope": "26-28",
    "patterns": [
      {
        "lineno": 26,
        "coloffset": 0,
        "linematch": "def is_palindrome_recursive(word: str) -> bool:",
        "context": "    return word[0] == word[-1] and is_palindrome(word[1:-1])\n\n\n# implement def is_palindrome_recursive(word: str) -> bool:\ndef is_palindrome_recursive(word: str) -> bool:\n    \"\"\"Check palindrome with recursive approach.\"\"\"\n    return is_palindrome(to_char(word))\n\n\n# implement def is_palindrome_reverse(word: str) -> bool:",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 26,
        "coloffset": 0,
        "linematch": "def is_palindrome_recursive(word: str) -> bool:",
        "context": "    return word[0] == word[-1] and is_palindrome(word[1:-1])\n\n\n# implement def is_palindrome_recursive(word: str) -> bool:\ndef is_palindrome_recursive(word: str) -> bool:\n    \"\"\"Check palindrome with recursive approach.\"\"\"\n    return is_palindrome(to_char(word))\n\n\n# implement def is_palindrome_reverse(word: str) -> bool:",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 26,
        "coloffset": 0,
        "linematch": "def is_palindrome_recursive(word: str) -> bool:",
        "context": "    return word[0] == word[-1] and is_palindrome(word[1:-1])\n\n\n# implement def is_palindrome_recursive(word: str) -> bool:\ndef is_palindrome_recursive(word: str) -> bool:\n    \"\"\"Check palindrome with recursive approach.\"\"\"\n    return is_palindrome(to_char(word))\n\n\n# implement def is_palindrome_reverse(word: str) -> bool:",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "\"\"\"Check palindrome with recursive approach.\"\"\"",
        "context": "\n\n# implement def is_palindrome_recursive(word: str) -> bool:\ndef is_palindrome_recursive(word: str) -> bool:\n    \"\"\"Check palindrome with recursive approach.\"\"\"\n    return is_palindrome(to_char(word))\n\n\n# implement def is_palindrome_reverse(word: str) -> bool:\ndef is_palindrome_reverse(word: str) -> bool:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "return is_palindrome(to_char(word))",
        "context": "\n# implement def is_palindrome_recursive(word: str) -> bool:\ndef is_palindrome_recursive(word: str) -> bool:\n    \"\"\"Check palindrome with recursive approach.\"\"\"\n    return is_palindrome(to_char(word))\n\n\n# implement def is_palindrome_reverse(word: str) -> bool:\ndef is_palindrome_reverse(word: str) -> bool:\n    \"\"\"Check palindrome with reverse approach.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "is_palindrome_reverse",
    "function_scope": "32-36",
    "patterns": [
      {
        "lineno": 32,
        "coloffset": 0,
        "linematch": "def is_palindrome_reverse(word: str) -> bool:",
        "context": "    return is_palindrome(to_char(word))\n\n\n# implement def is_palindrome_reverse(word: str) -> bool:\ndef is_palindrome_reverse(word: str) -> bool:\n    \"\"\"Check palindrome with reverse approach.\"\"\"\n    char_list = list(word)\n    char_list.reverse()\n    return char_list == list(word)",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 32,
        "coloffset": 0,
        "linematch": "def is_palindrome_reverse(word: str) -> bool:",
        "context": "    return is_palindrome(to_char(word))\n\n\n# implement def is_palindrome_reverse(word: str) -> bool:\ndef is_palindrome_reverse(word: str) -> bool:\n    \"\"\"Check palindrome with reverse approach.\"\"\"\n    char_list = list(word)\n    char_list.reverse()\n    return char_list == list(word)",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 32,
        "coloffset": 0,
        "linematch": "def is_palindrome_reverse(word: str) -> bool:",
        "context": "    return is_palindrome(to_char(word))\n\n\n# implement def is_palindrome_reverse(word: str) -> bool:\ndef is_palindrome_reverse(word: str) -> bool:\n    \"\"\"Check palindrome with reverse approach.\"\"\"\n    char_list = list(word)\n    char_list.reverse()\n    return char_list == list(word)",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "\"\"\"Check palindrome with reverse approach.\"\"\"",
        "context": "\n\n# implement def is_palindrome_reverse(word: str) -> bool:\ndef is_palindrome_reverse(word: str) -> bool:\n    \"\"\"Check palindrome with reverse approach.\"\"\"\n    char_list = list(word)\n    char_list.reverse()\n    return char_list == list(word)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "char_list = list(word)",
        "context": "\n# implement def is_palindrome_reverse(word: str) -> bool:\ndef is_palindrome_reverse(word: str) -> bool:\n    \"\"\"Check palindrome with reverse approach.\"\"\"\n    char_list = list(word)\n    char_list.reverse()\n    return char_list == list(word)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "char_list.reverse()",
        "context": "# implement def is_palindrome_reverse(word: str) -> bool:\ndef is_palindrome_reverse(word: str) -> bool:\n    \"\"\"Check palindrome with reverse approach.\"\"\"\n    char_list = list(word)\n    char_list.reverse()\n    return char_list == list(word)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "return char_list == list(word)",
        "context": "def is_palindrome_reverse(word: str) -> bool:\n    \"\"\"Check palindrome with reverse approach.\"\"\"\n    char_list = list(word)\n    char_list.reverse()\n    return char_list == list(word)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "human_readable_boolean",
    "function_scope": "5-10",
    "patterns": [
      {
        "lineno": 5,
        "coloffset": 0,
        "linematch": "def human_readable_boolean(answer: bool) -> str:",
        "context": "\"\"\"Generate human_readable boolean expression.\"\"\"\n\n\n# implement the def get_human_readable_boolean(answer: bool) -> str function\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Express a bool value in a human-readable fashion.\"\"\"\n    # condition logic for answer\n    if answer:\n        return \"Yes, it is!\"\n    return \"No, it is not!\"",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 5,
        "coloffset": 0,
        "linematch": "def human_readable_boolean(answer: bool) -> str:",
        "context": "\"\"\"Generate human_readable boolean expression.\"\"\"\n\n\n# implement the def get_human_readable_boolean(answer: bool) -> str function\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Express a bool value in a human-readable fashion.\"\"\"\n    # condition logic for answer\n    if answer:\n        return \"Yes, it is!\"\n    return \"No, it is not!\"",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 8,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "# implement the def get_human_readable_boolean(answer: bool) -> str function\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Express a bool value in a human-readable fashion.\"\"\"\n    # condition logic for answer\n    if answer:\n        return \"Yes, it is!\"\n    return \"No, it is not!\"",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 5,
        "coloffset": 0,
        "linematch": "def human_readable_boolean(answer: bool) -> str:",
        "context": "\"\"\"Generate human_readable boolean expression.\"\"\"\n\n\n# implement the def get_human_readable_boolean(answer: bool) -> str function\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Express a bool value in a human-readable fashion.\"\"\"\n    # condition logic for answer\n    if answer:\n        return \"Yes, it is!\"\n    return \"No, it is not!\"",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 6,
        "coloffset": 4,
        "linematch": "\"\"\"Express a bool value in a human-readable fashion.\"\"\"",
        "context": "\n\n# implement the def get_human_readable_boolean(answer: bool) -> str function\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Express a bool value in a human-readable fashion.\"\"\"\n    # condition logic for answer\n    if answer:\n        return \"Yes, it is!\"\n    return \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 8,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "# implement the def get_human_readable_boolean(answer: bool) -> str function\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Express a bool value in a human-readable fashion.\"\"\"\n    # condition logic for answer\n    if answer:\n        return \"Yes, it is!\"\n    return \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "return \"No, it is not!\"",
        "context": "    \"\"\"Express a bool value in a human-readable fashion.\"\"\"\n    # condition logic for answer\n    if answer:\n        return \"Yes, it is!\"\n    return \"No, it is not!\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "palindrome_check",
    "function_scope": "39-58",
    "patterns": [
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def palindrome_check(",
        "context": "# https://github.com/tiangolo/typer/issues/290\n\n\n@cli.command()\ndef palindrome_check(\n    word: str = typer.Option(...),\n    approach: PalindromeApproach = PalindromeApproach.RECURSIVE,\n) -> None:\n    \"\"\"Test an input string to be a Palindrome.\"\"\"\n    # create a console for rich text output",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def palindrome_check(",
        "context": "# https://github.com/tiangolo/typer/issues/290\n\n\n@cli.command()\ndef palindrome_check(\n    word: str = typer.Option(...),\n    approach: PalindromeApproach = PalindromeApproach.RECURSIVE,\n) -> None:\n    \"\"\"Test an input string to be a Palindrome.\"\"\"\n    # create a console for rich text output",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "if approach == PalindromeApproach.RECURSIVE:",
        "context": "    # create a console for rich text output\n    console = Console()\n\n    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "elif approach == PalindromeApproach.REVERSE:",
        "context": "    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n    console.print()\n    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 51,
        "coloffset": 9,
        "linematch": "elif approach == PalindromeApproach.REVERSE:",
        "context": "    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n    console.print()\n    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 51,
        "coloffset": 9,
        "linematch": "elif approach == PalindromeApproach.REVERSE:",
        "context": "    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n    console.print()\n    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def palindrome_check(",
        "context": "# https://github.com/tiangolo/typer/issues/290\n\n\n@cli.command()\ndef palindrome_check(\n    word: str = typer.Option(...),\n    approach: PalindromeApproach = PalindromeApproach.RECURSIVE,\n) -> None:\n    \"\"\"Test an input string to be a Palindrome.\"\"\"\n    # create a console for rich text output",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "elif approach == PalindromeApproach.REVERSE:",
        "context": "    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n    console.print()\n    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")",
        "pattern": "//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "The number of nested conditions (e.g., if{if{}}) in a Function"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "\"\"\"Test an input string to be a Palindrome.\"\"\"",
        "context": "def palindrome_check(\n    word: str = typer.Option(...),\n    approach: PalindromeApproach = PalindromeApproach.RECURSIVE,\n) -> None:\n    \"\"\"Test an input string to be a Palindrome.\"\"\"\n    # create a console for rich text output\n    console = Console()\n\n    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "console = Console()",
        "context": "    approach: PalindromeApproach = PalindromeApproach.RECURSIVE,\n) -> None:\n    \"\"\"Test an input string to be a Palindrome.\"\"\"\n    # create a console for rich text output\n    console = Console()\n\n    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "if approach == PalindromeApproach.RECURSIVE:",
        "context": "    # create a console for rich text output\n    console = Console()\n\n    # Recursive: execution with Recursive approach\n    if approach == PalindromeApproach.RECURSIVE:\n        result = palindrome.is_palindrome_recursive(word)\n    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 54,
        "coloffset": 4,
        "linematch": "console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")",
        "context": "    # Reverse: execute with Reverse approach\n    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n    console.print()\n    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n    console.print()\n    console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "    elif approach == PalindromeApproach.REVERSE:\n        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n    console.print()\n    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n    console.print()\n    console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")",
        "context": "        result = palindrome.is_palindrome_reverse(word)\n\n    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n    console.print()\n    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n    console.print()\n    console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")\n\n\n# implement a command-line interface using typer that produces",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 57,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "\n    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n    console.print()\n    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n    console.print()\n    console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")\n\n\n# implement a command-line interface using typer that produces\n# output like those examples included in the remainder of this file",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")",
        "context": "    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n    console.print()\n    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n    console.print()\n    console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")\n\n\n# implement a command-line interface using typer that produces\n# output like those examples included in the remainder of this file\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #31",
        "line": 45,
        "description": [
          "    console = Console()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #32",
        "line": 48,
        "description": [
          "    if approach == PalindromeApproach.RECURSIVE:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #33",
        "line": 49,
        "description": [
          "        result = palindrome.is_palindrome_recursive(word)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #34",
        "line": 51,
        "description": [
          "    elif approach == PalindromeApproach.REVERSE:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #35",
        "line": 52,
        "description": [
          "        result = palindrome.is_palindrome_reverse(word)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #36",
        "line": 54,
        "description": [
          "    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -51,7 +51,7 @@\n     elif approach == PalindromeApproach.REVERSE:\n         result = palindrome.is_palindrome_reverse(word)\n \n-    console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n+    console.print(f\"XX\u2728 Awesome, using the {approach} approach for palindrome checking!XX\")\n     console.print()\n     console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n     console.print()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #37",
        "line": 56,
        "description": [
          "    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -53,7 +53,7 @@\n \n     console.print(f\"\u2728 Awesome, using the {approach} approach for palindrome checking!\")\n     console.print()\n-    console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n+    console.print(f\"XX\ud83d\udd16 Going to check to see if the word {word} is a palindrome!XX\")\n     console.print()\n     console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #38",
        "line": 58,
        "description": [
          "    console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -55,7 +55,7 @@\n     console.print()\n     console.print(f\"\ud83d\udd16 Going to check to see if the word {word} is a palindrome!\")\n     console.print()\n-    console.print(f\"\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}\")\n+    console.print(f\"XX\ud83d\ude06 Is this word a palindrome? {util.human_readable_boolean(result)}XX\")\n \n \n # implement a command-line interface using typer that produces\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 62.5
  },
  {
    "function_name": "__str__",
    "function_scope": "27-29",
    "patterns": [
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "def __str__(self):",
        "context": "\n    RECURSIVE = \"recursive\"\n    REVERSE = \"reverse\"\n\n    def __str__(self):\n        \"\"\"Create string function.\"\"\"\n        return self.value if self is not None else \"\"\n\n\n# When you are setting the default values of the --approach variable",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "def __str__(self):",
        "context": "\n    RECURSIVE = \"recursive\"\n    REVERSE = \"reverse\"\n\n    def __str__(self):\n        \"\"\"Create string function.\"\"\"\n        return self.value if self is not None else \"\"\n\n\n# When you are setting the default values of the --approach variable",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "def __str__(self):",
        "context": "\n    RECURSIVE = \"recursive\"\n    REVERSE = \"reverse\"\n\n    def __str__(self):\n        \"\"\"Create string function.\"\"\"\n        return self.value if self is not None else \"\"\n\n\n# When you are setting the default values of the --approach variable",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 28,
        "coloffset": 8,
        "linematch": "\"\"\"Create string function.\"\"\"",
        "context": "    RECURSIVE = \"recursive\"\n    REVERSE = \"reverse\"\n\n    def __str__(self):\n        \"\"\"Create string function.\"\"\"\n        return self.value if self is not None else \"\"\n\n\n# When you are setting the default values of the --approach variable\n# you may need to consider how to extract a value from PalindromeCheckingApproach",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 8,
        "linematch": "return self.value if self is not None else \"\"",
        "context": "    REVERSE = \"reverse\"\n\n    def __str__(self):\n        \"\"\"Create string function.\"\"\"\n        return self.value if self is not None else \"\"\n\n\n# When you are setting the default values of the --approach variable\n# you may need to consider how to extract a value from PalindromeCheckingApproach\n# Please refer to this GitHub issue tracker discussion for more details:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #28",
        "line": 29,
        "description": [
          "        return self.value if self is not None else \"\""
        ],
        "failure": []
      },
      {
        "name": "Mutant #29",
        "line": 29,
        "description": [
          "        return self.value if self is not None else \"\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -26,7 +26,7 @@\n \n     def __str__(self):\n         \"\"\"Create string function.\"\"\"\n-        return self.value if self is not None else \"\"\n+        return self.value if self is not None else \"XXXX\"\n \n \n # When you are setting the default values of the --approach variable\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 50.0
  }
]