[
  {
    "function_name": "string_name",
    "function_scope": "37-41",
    "patterns": [
      {
        "lineno": 38,
        "coloffset": 8,
        "linematch": "if isinstance(self.name, str):",
        "context": "    option_schema: OptionSchema\n\n    @property\n    def string_name(self) -> str:\n        if isinstance(self.name, str):\n            return self.name\n        else:\n            return self.name[0]\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "def string_name(self) -> str:",
        "context": "    value: tuple[Any]  # Multi-value options will be tuple length > 1\n    option_schema: OptionSchema\n\n    @property\n    def string_name(self) -> str:\n        if isinstance(self.name, str):\n            return self.name\n        else:\n            return self.name[0]\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "def string_name(self) -> str:",
        "context": "    value: tuple[Any]  # Multi-value options will be tuple length > 1\n    option_schema: OptionSchema\n\n    @property\n    def string_name(self) -> str:\n        if isinstance(self.name, str):\n            return self.name\n        else:\n            return self.name[0]\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 38,
        "coloffset": 8,
        "linematch": "if isinstance(self.name, str):",
        "context": "    option_schema: OptionSchema\n\n    @property\n    def string_name(self) -> str:\n        if isinstance(self.name, str):\n            return self.name\n        else:\n            return self.name[0]\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "to_cli_args",
    "function_scope": "80-91",
    "patterns": [
      {
        "lineno": 88,
        "coloffset": 8,
        "linematch": "if not include_root_command:",
        "context": "        Returns:\n            A list of strings that can be passed to subprocess.run to execute the command.\n        \"\"\"\n        cli_args = self._to_cli_args()\n        if not include_root_command:\n            cli_args = cli_args[1:]\n\n        return cli_args\n\n    def _to_cli_args(self):",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 80,
        "coloffset": 4,
        "linematch": "def to_cli_args(self, include_root_command: bool = False) -> List[str]:",
        "context": "    subcommand: Optional[\"UserCommandData\"] = None\n    parent: Optional[\"UserCommandData\"] = None\n    command_schema: Optional[\"CommandSchema\"] = None\n\n    def to_cli_args(self, include_root_command: bool = False) -> List[str]:\n        \"\"\"\n        Generates a list of strings representing the CLI invocation based on the user input data.\n\n        Returns:\n            A list of strings that can be passed to subprocess.run to execute the command.",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 80,
        "coloffset": 4,
        "linematch": "def to_cli_args(self, include_root_command: bool = False) -> List[str]:",
        "context": "    subcommand: Optional[\"UserCommandData\"] = None\n    parent: Optional[\"UserCommandData\"] = None\n    command_schema: Optional[\"CommandSchema\"] = None\n\n    def to_cli_args(self, include_root_command: bool = False) -> List[str]:\n        \"\"\"\n        Generates a list of strings representing the CLI invocation based on the user input data.\n\n        Returns:\n            A list of strings that can be passed to subprocess.run to execute the command.",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 81,
        "coloffset": 8,
        "linematch": "\"\"\"",
        "context": "    parent: Optional[\"UserCommandData\"] = None\n    command_schema: Optional[\"CommandSchema\"] = None\n\n    def to_cli_args(self, include_root_command: bool = False) -> List[str]:\n        \"\"\"\n        Generates a list of strings representing the CLI invocation based on the user input data.\n\n        Returns:\n            A list of strings that can be passed to subprocess.run to execute the command.\n        \"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 87,
        "coloffset": 8,
        "linematch": "cli_args = self._to_cli_args()",
        "context": "\n        Returns:\n            A list of strings that can be passed to subprocess.run to execute the command.\n        \"\"\"\n        cli_args = self._to_cli_args()\n        if not include_root_command:\n            cli_args = cli_args[1:]\n\n        return cli_args\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 88,
        "coloffset": 8,
        "linematch": "if not include_root_command:",
        "context": "        Returns:\n            A list of strings that can be passed to subprocess.run to execute the command.\n        \"\"\"\n        cli_args = self._to_cli_args()\n        if not include_root_command:\n            cli_args = cli_args[1:]\n\n        return cli_args\n\n    def _to_cli_args(self):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 91,
        "coloffset": 8,
        "linematch": "return cli_args",
        "context": "        cli_args = self._to_cli_args()\n        if not include_root_command:\n            cli_args = cli_args[1:]\n\n        return cli_args\n\n    def _to_cli_args(self):\n        args = [self.name]\n\n        multiples = defaultdict(list)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #626",
        "line": 82,
        "description": [
          "            self.command_data = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -79,7 +79,7 @@\n     class Changed(Message):\n         def __init__(self, command_data: UserCommandData):\n             super().__init__()\n-            self.command_data = command_data\n+            self.command_data = None\n             \"\"\"The new data taken from the form to be converted into a CLI invocation.\"\"\"\n \n     def __init__(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "_to_cli_args",
    "function_scope": "93-219",
    "patterns": [
      {
        "lineno": 216,
        "coloffset": 8,
        "linematch": "if self.subcommand:",
        "context": "            for argument_value in this_arg_values:\n                if argument_value != ValueNotSupplied():\n                    args.append(argument_value)\n\n        if self.subcommand:\n            args.extend(self.subcommand._to_cli_args())\n\n        return args\n\n    def to_cli_string(self, include_root_command: bool = False) -> Text:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 100,
        "coloffset": 12,
        "linematch": "if option.option_schema.multiple:",
        "context": "        multiples = defaultdict(list)\n        multiples_schemas = {}\n\n        for option in self.options:\n            if option.option_schema.multiple:\n                # We need to gather the items for the same option,\n                #  compare them to the default, then display them all\n                #  if they aren't equivalent to the default.\n                multiples[option.string_name].append(option.value)\n                multiples_schemas[option.string_name] = option.option_schema",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 111,
        "coloffset": 16,
        "linematch": "if option.option_schema.default is not None:",
        "context": "                value_data: list[tuple[Any]] = MultiValueParamData.process_cli_option(\n                    option.value\n                ).values\n\n                if option.option_schema.default is not None:\n                    default_data: list[tuple[Any]] = option.option_schema.default.values\n                else:\n                    default_data = [tuple()]\n\n                flattened_values = sorted(itertools.chain.from_iterable(value_data))",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 130,
        "coloffset": 16,
        "linematch": "if values_supplied and not values_are_defaults:",
        "context": "                )\n\n                # If the user has supplied values, and they're not the default values,\n                # then we want to display them in the command string...\n                if values_supplied and not values_are_defaults:\n                    if isinstance(option.name, str):\n                        option_name = option.name\n                    else:\n                        if option.option_schema.counting:\n                            # For count options, we use the shortest name, e.g. use",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 131,
        "coloffset": 20,
        "linematch": "if isinstance(option.name, str):",
        "context": "\n                # If the user has supplied values, and they're not the default values,\n                # then we want to display them in the command string...\n                if values_supplied and not values_are_defaults:\n                    if isinstance(option.name, str):\n                        option_name = option.name\n                    else:\n                        if option.option_schema.counting:\n                            # For count options, we use the shortest name, e.g. use\n                            # -v instead of --verbose.",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 148,
        "coloffset": 20,
        "linematch": "if is_flag:",
        "context": "\n                    is_flag = option.option_schema.is_flag\n                    secondary_opts = option.option_schema.secondary_opts\n\n                    if is_flag:\n                        # If the option is specified like `--thing/--not-thing`,\n                        # then secondary_opts will contain `--not-thing`, and if the\n                        # value is False, we should use that.\n                        if is_true_bool:\n                            args.append(option_name)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 134,
        "coloffset": 24,
        "linematch": "if option.option_schema.counting:",
        "context": "                if values_supplied and not values_are_defaults:\n                    if isinstance(option.name, str):\n                        option_name = option.name\n                    else:\n                        if option.option_schema.counting:\n                            # For count options, we use the shortest name, e.g. use\n                            # -v instead of --verbose.\n                            option_name = min(option.name, key=len)\n                        else:\n                            # Use the option with the longest name, since",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 152,
        "coloffset": 24,
        "linematch": "if is_true_bool:",
        "context": "                    if is_flag:\n                        # If the option is specified like `--thing/--not-thing`,\n                        # then secondary_opts will contain `--not-thing`, and if the\n                        # value is False, we should use that.\n                        if is_true_bool:\n                            args.append(option_name)\n                        else:\n                            if secondary_opts:\n                                longest_secondary_name = max(secondary_opts, key=len)\n                                args.append(longest_secondary_name)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 155,
        "coloffset": 28,
        "linematch": "if secondary_opts:",
        "context": "                        # value is False, we should use that.\n                        if is_true_bool:\n                            args.append(option_name)\n                        else:\n                            if secondary_opts:\n                                longest_secondary_name = max(secondary_opts, key=len)\n                                args.append(longest_secondary_name)\n                    else:\n                        if not option.option_schema.counting:\n                            # Although buried away a little, this branch here is",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 159,
        "coloffset": 24,
        "linematch": "if not option.option_schema.counting:",
        "context": "                            if secondary_opts:\n                                longest_secondary_name = max(secondary_opts, key=len)\n                                args.append(longest_secondary_name)\n                    else:\n                        if not option.option_schema.counting:\n                            # Although buried away a little, this branch here is\n                            # actually the nominal case... single value options e.g.\n                            # `--foo bar`.\n                            args.append(option_name)\n                            for subvalue_tuple in value_data:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 175,
        "coloffset": 28,
        "linematch": "if option_name.startswith(\"--\"):",
        "context": "                            except ValueError:\n                                # TODO: Not sure if this is the right thing to do\n                                count = 1\n                            count = max(1, min(count, 5))\n                            if option_name.startswith(\"--\"):\n                                args.extend([option_name] * count)\n                            else:\n                                clean_option_name = option_name.lstrip(\"-\")\n                                args.append(f\"-{clean_option_name * count}\")\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 204,
        "coloffset": 12,
        "linematch": "if values_supplied and not values_are_defaults:",
        "context": "                value != ValueNotSupplied() for value in supplied_values\n            )\n\n            # If the user has supplied any non-default values, include them...\n            if values_supplied and not values_are_defaults:\n                for value_data in values:\n                    if not all(value == ValueNotSupplied() for value in value_data):\n                        args.append(option_name)\n                        args.extend(v for v in value_data)\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 206,
        "coloffset": 20,
        "linematch": "if not all(value == ValueNotSupplied() for value in value_data):",
        "context": "\n            # If the user has supplied any non-default values, include them...\n            if values_supplied and not values_are_defaults:\n                for value_data in values:\n                    if not all(value == ValueNotSupplied() for value in value_data):\n                        args.append(option_name)\n                        args.extend(v for v in value_data)\n\n        for argument in self.arguments:\n            this_arg_values = argument.value",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 213,
        "coloffset": 16,
        "linematch": "if argument_value != ValueNotSupplied():",
        "context": "\n        for argument in self.arguments:\n            this_arg_values = argument.value\n            for argument_value in this_arg_values:\n                if argument_value != ValueNotSupplied():\n                    args.append(argument_value)\n\n        if self.subcommand:\n            args.extend(self.subcommand._to_cli_args())\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 131,
        "coloffset": 20,
        "linematch": "if isinstance(option.name, str):",
        "context": "\n                # If the user has supplied values, and they're not the default values,\n                # then we want to display them in the command string...\n                if values_supplied and not values_are_defaults:\n                    if isinstance(option.name, str):\n                        option_name = option.name\n                    else:\n                        if option.option_schema.counting:\n                            # For count options, we use the shortest name, e.g. use\n                            # -v instead of --verbose.",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 148,
        "coloffset": 20,
        "linematch": "if is_flag:",
        "context": "\n                    is_flag = option.option_schema.is_flag\n                    secondary_opts = option.option_schema.secondary_opts\n\n                    if is_flag:\n                        # If the option is specified like `--thing/--not-thing`,\n                        # then secondary_opts will contain `--not-thing`, and if the\n                        # value is False, we should use that.\n                        if is_true_bool:\n                            args.append(option_name)",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 152,
        "coloffset": 24,
        "linematch": "if is_true_bool:",
        "context": "                    if is_flag:\n                        # If the option is specified like `--thing/--not-thing`,\n                        # then secondary_opts will contain `--not-thing`, and if the\n                        # value is False, we should use that.\n                        if is_true_bool:\n                            args.append(option_name)\n                        else:\n                            if secondary_opts:\n                                longest_secondary_name = max(secondary_opts, key=len)\n                                args.append(longest_secondary_name)",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 206,
        "coloffset": 20,
        "linematch": "if not all(value == ValueNotSupplied() for value in value_data):",
        "context": "\n            # If the user has supplied any non-default values, include them...\n            if values_supplied and not values_are_defaults:\n                for value_data in values:\n                    if not all(value == ValueNotSupplied() for value in value_data):\n                        args.append(option_name)\n                        args.extend(v for v in value_data)\n\n        for argument in self.arguments:\n            this_arg_values = argument.value",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 206,
        "coloffset": 31,
        "linematch": "if not all(value == ValueNotSupplied() for value in value_data):",
        "context": "\n            # If the user has supplied any non-default values, include them...\n            if values_supplied and not values_are_defaults:\n                for value_data in values:\n                    if not all(value == ValueNotSupplied() for value in value_data):\n                        args.append(option_name)\n                        args.extend(v for v in value_data)\n\n        for argument in self.arguments:\n            this_arg_values = argument.value",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 206,
        "coloffset": 31,
        "linematch": "if not all(value == ValueNotSupplied() for value in value_data):",
        "context": "\n            # If the user has supplied any non-default values, include them...\n            if values_supplied and not values_are_defaults:\n                for value_data in values:\n                    if not all(value == ValueNotSupplied() for value in value_data):\n                        args.append(option_name)\n                        args.extend(v for v in value_data)\n\n        for argument in self.arguments:\n            this_arg_values = argument.value",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 206,
        "coloffset": 31,
        "linematch": "if not all(value == ValueNotSupplied() for value in value_data):",
        "context": "\n            # If the user has supplied any non-default values, include them...\n            if values_supplied and not values_are_defaults:\n                for value_data in values:\n                    if not all(value == ValueNotSupplied() for value in value_data):\n                        args.append(option_name)\n                        args.extend(v for v in value_data)\n\n        for argument in self.arguments:\n            this_arg_values = argument.value",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 206,
        "coloffset": 31,
        "linematch": "if not all(value == ValueNotSupplied() for value in value_data):",
        "context": "\n            # If the user has supplied any non-default values, include them...\n            if values_supplied and not values_are_defaults:\n                for value_data in values:\n                    if not all(value == ValueNotSupplied() for value in value_data):\n                        args.append(option_name)\n                        args.extend(v for v in value_data)\n\n        for argument in self.arguments:\n            this_arg_values = argument.value",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 93,
        "coloffset": 4,
        "linematch": "def _to_cli_args(self):",
        "context": "            cli_args = cli_args[1:]\n\n        return cli_args\n\n    def _to_cli_args(self):\n        args = [self.name]\n\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 93,
        "coloffset": 4,
        "linematch": "def _to_cli_args(self):",
        "context": "            cli_args = cli_args[1:]\n\n        return cli_args\n\n    def _to_cli_args(self):\n        args = [self.name]\n\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 130,
        "coloffset": 16,
        "linematch": "if values_supplied and not values_are_defaults:",
        "context": "                )\n\n                # If the user has supplied values, and they're not the default values,\n                # then we want to display them in the command string...\n                if values_supplied and not values_are_defaults:\n                    if isinstance(option.name, str):\n                        option_name = option.name\n                    else:\n                        if option.option_schema.counting:\n                            # For count options, we use the shortest name, e.g. use",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 148,
        "coloffset": 20,
        "linematch": "if is_flag:",
        "context": "\n                    is_flag = option.option_schema.is_flag\n                    secondary_opts = option.option_schema.secondary_opts\n\n                    if is_flag:\n                        # If the option is specified like `--thing/--not-thing`,\n                        # then secondary_opts will contain `--not-thing`, and if the\n                        # value is False, we should use that.\n                        if is_true_bool:\n                            args.append(option_name)",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 111,
        "coloffset": 16,
        "linematch": "if option.option_schema.default is not None:",
        "context": "                value_data: list[tuple[Any]] = MultiValueParamData.process_cli_option(\n                    option.value\n                ).values\n\n                if option.option_schema.default is not None:\n                    default_data: list[tuple[Any]] = option.option_schema.default.values\n                else:\n                    default_data = [tuple()]\n\n                flattened_values = sorted(itertools.chain.from_iterable(value_data))",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 130,
        "coloffset": 16,
        "linematch": "if values_supplied and not values_are_defaults:",
        "context": "                )\n\n                # If the user has supplied values, and they're not the default values,\n                # then we want to display them in the command string...\n                if values_supplied and not values_are_defaults:\n                    if isinstance(option.name, str):\n                        option_name = option.name\n                    else:\n                        if option.option_schema.counting:\n                            # For count options, we use the shortest name, e.g. use",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 131,
        "coloffset": 20,
        "linematch": "if isinstance(option.name, str):",
        "context": "\n                # If the user has supplied values, and they're not the default values,\n                # then we want to display them in the command string...\n                if values_supplied and not values_are_defaults:\n                    if isinstance(option.name, str):\n                        option_name = option.name\n                    else:\n                        if option.option_schema.counting:\n                            # For count options, we use the shortest name, e.g. use\n                            # -v instead of --verbose.",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 134,
        "coloffset": 24,
        "linematch": "if option.option_schema.counting:",
        "context": "                if values_supplied and not values_are_defaults:\n                    if isinstance(option.name, str):\n                        option_name = option.name\n                    else:\n                        if option.option_schema.counting:\n                            # For count options, we use the shortest name, e.g. use\n                            # -v instead of --verbose.\n                            option_name = min(option.name, key=len)\n                        else:\n                            # Use the option with the longest name, since",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 148,
        "coloffset": 20,
        "linematch": "if is_flag:",
        "context": "\n                    is_flag = option.option_schema.is_flag\n                    secondary_opts = option.option_schema.secondary_opts\n\n                    if is_flag:\n                        # If the option is specified like `--thing/--not-thing`,\n                        # then secondary_opts will contain `--not-thing`, and if the\n                        # value is False, we should use that.\n                        if is_true_bool:\n                            args.append(option_name)",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 152,
        "coloffset": 24,
        "linematch": "if is_true_bool:",
        "context": "                    if is_flag:\n                        # If the option is specified like `--thing/--not-thing`,\n                        # then secondary_opts will contain `--not-thing`, and if the\n                        # value is False, we should use that.\n                        if is_true_bool:\n                            args.append(option_name)\n                        else:\n                            if secondary_opts:\n                                longest_secondary_name = max(secondary_opts, key=len)\n                                args.append(longest_secondary_name)",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 155,
        "coloffset": 28,
        "linematch": "if secondary_opts:",
        "context": "                        # value is False, we should use that.\n                        if is_true_bool:\n                            args.append(option_name)\n                        else:\n                            if secondary_opts:\n                                longest_secondary_name = max(secondary_opts, key=len)\n                                args.append(longest_secondary_name)\n                    else:\n                        if not option.option_schema.counting:\n                            # Although buried away a little, this branch here is",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 159,
        "coloffset": 24,
        "linematch": "if not option.option_schema.counting:",
        "context": "                            if secondary_opts:\n                                longest_secondary_name = max(secondary_opts, key=len)\n                                args.append(longest_secondary_name)\n                    else:\n                        if not option.option_schema.counting:\n                            # Although buried away a little, this branch here is\n                            # actually the nominal case... single value options e.g.\n                            # `--foo bar`.\n                            args.append(option_name)\n                            for subvalue_tuple in value_data:",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 175,
        "coloffset": 28,
        "linematch": "if option_name.startswith(\"--\"):",
        "context": "                            except ValueError:\n                                # TODO: Not sure if this is the right thing to do\n                                count = 1\n                            count = max(1, min(count, 5))\n                            if option_name.startswith(\"--\"):\n                                args.extend([option_name] * count)\n                            else:\n                                clean_option_name = option_name.lstrip(\"-\")\n                                args.append(f\"-{clean_option_name * count}\")\n",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 206,
        "coloffset": 20,
        "linematch": "if not all(value == ValueNotSupplied() for value in value_data):",
        "context": "\n            # If the user has supplied any non-default values, include them...\n            if values_supplied and not values_are_defaults:\n                for value_data in values:\n                    if not all(value == ValueNotSupplied() for value in value_data):\n                        args.append(option_name)\n                        args.extend(v for v in value_data)\n\n        for argument in self.arguments:\n            this_arg_values = argument.value",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 93,
        "coloffset": 4,
        "linematch": "def _to_cli_args(self):",
        "context": "            cli_args = cli_args[1:]\n\n        return cli_args\n\n    def _to_cli_args(self):\n        args = [self.name]\n\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 99,
        "coloffset": 8,
        "linematch": "for option in self.options:",
        "context": "\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n\n        for option in self.options:\n            if option.option_schema.multiple:\n                # We need to gather the items for the same option,\n                #  compare them to the default, then display them all\n                #  if they aren't equivalent to the default.\n                multiples[option.string_name].append(option.value)",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 181,
        "coloffset": 8,
        "linematch": "for option_name, values in multiples.items():",
        "context": "                            else:\n                                clean_option_name = option_name.lstrip(\"-\")\n                                args.append(f\"-{clean_option_name * count}\")\n\n        for option_name, values in multiples.items():\n            # Check if the values given for this option differ from the default\n            defaults = multiples_schemas[option_name].default or []\n            default_values = list(itertools.chain.from_iterable(defaults.values))\n            supplied_defaults = [\n                value for value in default_values if value != ValueNotSupplied()",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 210,
        "coloffset": 8,
        "linematch": "for argument in self.arguments:",
        "context": "                    if not all(value == ValueNotSupplied() for value in value_data):\n                        args.append(option_name)\n                        args.extend(v for v in value_data)\n\n        for argument in self.arguments:\n            this_arg_values = argument.value\n            for argument_value in this_arg_values:\n                if argument_value != ValueNotSupplied():\n                    args.append(argument_value)\n",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 94,
        "coloffset": 8,
        "linematch": "args = [self.name]",
        "context": "\n        return cli_args\n\n    def _to_cli_args(self):\n        args = [self.name]\n\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n\n        for option in self.options:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 8,
        "linematch": "multiples = defaultdict(list)",
        "context": "\n    def _to_cli_args(self):\n        args = [self.name]\n\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n\n        for option in self.options:\n            if option.option_schema.multiple:\n                # We need to gather the items for the same option,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 97,
        "coloffset": 8,
        "linematch": "multiples_schemas = {}",
        "context": "    def _to_cli_args(self):\n        args = [self.name]\n\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n\n        for option in self.options:\n            if option.option_schema.multiple:\n                # We need to gather the items for the same option,\n                #  compare them to the default, then display them all",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 99,
        "coloffset": 8,
        "linematch": "for option in self.options:",
        "context": "\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n\n        for option in self.options:\n            if option.option_schema.multiple:\n                # We need to gather the items for the same option,\n                #  compare them to the default, then display them all\n                #  if they aren't equivalent to the default.\n                multiples[option.string_name].append(option.value)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 181,
        "coloffset": 8,
        "linematch": "for option_name, values in multiples.items():",
        "context": "                            else:\n                                clean_option_name = option_name.lstrip(\"-\")\n                                args.append(f\"-{clean_option_name * count}\")\n\n        for option_name, values in multiples.items():\n            # Check if the values given for this option differ from the default\n            defaults = multiples_schemas[option_name].default or []\n            default_values = list(itertools.chain.from_iterable(defaults.values))\n            supplied_defaults = [\n                value for value in default_values if value != ValueNotSupplied()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 210,
        "coloffset": 8,
        "linematch": "for argument in self.arguments:",
        "context": "                    if not all(value == ValueNotSupplied() for value in value_data):\n                        args.append(option_name)\n                        args.extend(v for v in value_data)\n\n        for argument in self.arguments:\n            this_arg_values = argument.value\n            for argument_value in this_arg_values:\n                if argument_value != ValueNotSupplied():\n                    args.append(argument_value)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 216,
        "coloffset": 8,
        "linematch": "if self.subcommand:",
        "context": "            for argument_value in this_arg_values:\n                if argument_value != ValueNotSupplied():\n                    args.append(argument_value)\n\n        if self.subcommand:\n            args.extend(self.subcommand._to_cli_args())\n\n        return args\n\n    def to_cli_string(self, include_root_command: bool = False) -> Text:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 219,
        "coloffset": 8,
        "linematch": "return args",
        "context": "\n        if self.subcommand:\n            args.extend(self.subcommand._to_cli_args())\n\n        return args\n\n    def to_cli_string(self, include_root_command: bool = False) -> Text:\n        \"\"\"\n        Generates a string representing the CLI invocation as if typed directly into the\n        command line.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 93,
        "coloffset": 4,
        "linematch": "def _to_cli_args(self):",
        "context": "            cli_args = cli_args[1:]\n\n        return cli_args\n\n    def _to_cli_args(self):\n        args = [self.name]\n\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]",
        "check_id": "F027",
        "check_name": "high-cyclomatic-complexity"
      },
      {
        "lineno": 93,
        "coloffset": 4,
        "linematch": "def _to_cli_args(self):",
        "context": "            cli_args = cli_args[1:]\n\n        return cli_args\n\n    def _to_cli_args(self):\n        args = [self.name]\n\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 93,
        "coloffset": 4,
        "linematch": "def _to_cli_args(self):",
        "context": "            cli_args = cli_args[1:]\n\n        return cli_args\n\n    def _to_cli_args(self):\n        args = [self.name]\n\n        multiples = defaultdict(list)\n        multiples_schemas = {}\n",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #628",
        "line": 95,
        "description": [
          "        self.command_schema = command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -92,7 +92,7 @@\n         disabled: bool = False,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n-        self.command_schema = command_schema\n+        self.command_schema = None\n         self.command_schemas = command_schemas\n         self.first_control: ParameterControls | None = None\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #629",
        "line": 96,
        "description": [
          "        self.command_schemas = command_schemas"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -93,7 +93,7 @@\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n-        self.command_schemas = command_schemas\n+        self.command_schemas = None\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #630",
        "line": 97,
        "description": [
          "        self.first_control: ParameterControls | None = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -94,7 +94,7 @@\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n         self.command_schemas = command_schemas\n-        self.first_control: ParameterControls | None = None\n+        self.first_control: ParameterControls & None = None\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #631",
        "line": 97,
        "description": [
          "        self.first_control: ParameterControls | None = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -94,7 +94,7 @@\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n         self.command_schemas = command_schemas\n-        self.first_control: ParameterControls | None = None\n+        self.first_control: ParameterControls | None = \"\"\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #632",
        "line": 100,
        "description": [
          "        path_from_root = iter(reversed(self.command_schema.path_from_root))"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -97,7 +97,7 @@\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n-        path_from_root = iter(reversed(self.command_schema.path_from_root))\n+        path_from_root = None\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n             vs.can_focus = False\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #633",
        "line": 101,
        "description": [
          "        command_node = next(path_from_root)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -98,7 +98,7 @@\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n-        command_node = next(path_from_root)\n+        command_node = None\n         with VerticalScroll() as vs:\n             vs.can_focus = False\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #634",
        "line": 103,
        "description": [
          "            vs.can_focus = False"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -100,7 +100,7 @@\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n-            vs.can_focus = False\n+            vs.can_focus = True\n \n             yield Input(\n                 placeholder=\"Search...\",\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #635",
        "line": 103,
        "description": [
          "            vs.can_focus = False"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -100,7 +100,7 @@\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n-            vs.can_focus = False\n+            vs.can_focus = None\n \n             yield Input(\n                 placeholder=\"Search...\",\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #636",
        "line": 106,
        "description": [
          "                placeholder=\"Search...\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -103,7 +103,7 @@\n             vs.can_focus = False\n \n             yield Input(\n-                placeholder=\"Search...\",\n+                placeholder=\"XXSearch...XX\",\n                 classes=\"command-form-filter-input\",\n                 id=\"search\",\n             )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #637",
        "line": 107,
        "description": [
          "                classes=\"command-form-filter-input\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -104,7 +104,7 @@\n \n             yield Input(\n                 placeholder=\"Search...\",\n-                classes=\"command-form-filter-input\",\n+                classes=\"XXcommand-form-filter-inputXX\",\n                 id=\"search\",\n             )\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #638",
        "line": 108,
        "description": [
          "                id=\"search\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -105,7 +105,7 @@\n             yield Input(\n                 placeholder=\"Search...\",\n                 classes=\"command-form-filter-input\",\n-                id=\"search\",\n+                id=\"XXsearchXX\",\n             )\n \n             while command_node is not None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #639",
        "line": 111,
        "description": [
          "            while command_node is not None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -108,7 +108,7 @@\n                 id=\"search\",\n             )\n \n-            while command_node is not None:\n+            while command_node is  None:\n                 options = command_node.options\n                 arguments = command_node.arguments\n                 if options or arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #640",
        "line": 112,
        "description": [
          "                options = command_node.options"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -109,7 +109,7 @@\n             )\n \n             while command_node is not None:\n-                options = command_node.options\n+                options = None\n                 arguments = command_node.arguments\n                 if options or arguments:\n                     with Vertical(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #641",
        "line": 113,
        "description": [
          "                arguments = command_node.arguments"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -110,7 +110,7 @@\n \n             while command_node is not None:\n                 options = command_node.options\n-                arguments = command_node.arguments\n+                arguments = None\n                 if options or arguments:\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #642",
        "line": 114,
        "description": [
          "                if options or arguments:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -111,7 +111,7 @@\n             while command_node is not None:\n                 options = command_node.options\n                 arguments = command_node.arguments\n-                if options or arguments:\n+                if options and arguments:\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #643",
        "line": 116,
        "description": [
          "                        classes=\"command-form-command-group\", id=command_node.key"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -113,7 +113,7 @@\n                 arguments = command_node.arguments\n                 if options or arguments:\n                     with Vertical(\n-                        classes=\"command-form-command-group\", id=command_node.key\n+                        classes=\"XXcommand-form-command-groupXX\", id=command_node.key\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #644",
        "line": 118,
        "description": [
          "                        is_inherited = command_node is not self.command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -115,7 +115,7 @@\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n-                        is_inherited = command_node is not self.command_schema\n+                        is_inherited = command_node is  self.command_schema\n                         v.border_title = (\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #645",
        "line": 118,
        "description": [
          "                        is_inherited = command_node is not self.command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -115,7 +115,7 @@\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n-                        is_inherited = command_node is not self.command_schema\n+                        is_inherited = None\n                         v.border_title = (\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #646",
        "line": 120,
        "description": [
          "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -117,7 +117,7 @@\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n+                            f\"{'XX\u21aa XX' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #647",
        "line": 120,
        "description": [
          "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -117,7 +117,7 @@\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n+                            f\"{'\u21aa ' if is_inherited else 'XXXX'}{command_node.name}\"\n                         )\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #648",
        "line": 120,
        "description": [
          "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -117,7 +117,7 @@\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n+                            f\"XX{'\u21aa ' if is_inherited else ''}{command_node.name}XX\"\n                         )\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #649",
        "line": 121,
        "description": [
          "                        )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -116,9 +116,7 @@\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n-                        v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n-                        )\n+                        v.border_title = None\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n                         if arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #650",
        "line": 123,
        "description": [
          "                            v.border_title += \" [dim not bold](inherited)\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -120,7 +120,7 @@\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n-                            v.border_title += \" [dim not bold](inherited)\"\n+                            v.border_title = \" [dim not bold](inherited)\"\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #651",
        "line": 123,
        "description": [
          "                            v.border_title += \" [dim not bold](inherited)\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -120,7 +120,7 @@\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n-                            v.border_title += \" [dim not bold](inherited)\"\n+                            v.border_title -= \" [dim not bold](inherited)\"\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #652",
        "line": 123,
        "description": [
          "                            v.border_title += \" [dim not bold](inherited)\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -120,7 +120,7 @@\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n-                            v.border_title += \" [dim not bold](inherited)\"\n+                            v.border_title += \"XX [dim not bold](inherited)XX\"\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #653",
        "line": 125,
        "description": [
          "                            yield Label(f\"Arguments\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -122,7 +122,7 @@\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n                         if arguments:\n-                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n+                            yield Label(f\"XXArgumentsXX\", classes=\"command-form-heading\")\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #654",
        "line": 125,
        "description": [
          "                            yield Label(f\"Arguments\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -122,7 +122,7 @@\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n                         if arguments:\n-                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n+                            yield Label(f\"Arguments\", classes=\"XXcommand-form-headingXX\")\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #655",
        "line": 127,
        "description": [
          "                                controls = ParameterControls(argument, id=argument.key)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -124,7 +124,7 @@\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n-                                controls = ParameterControls(argument, id=argument.key)\n+                                controls = None\n                                 if self.first_control is None:\n                                     self.first_control = controls\n                                 yield controls\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #656",
        "line": 128,
        "description": [
          "                                if self.first_control is None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -125,7 +125,7 @@\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n-                                if self.first_control is None:\n+                                if self.first_control is not None:\n                                     self.first_control = controls\n                                 yield controls\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #657",
        "line": 129,
        "description": [
          "                                    self.first_control = controls"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -126,7 +126,7 @@\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n                                 if self.first_control is None:\n-                                    self.first_control = controls\n+                                    self.first_control = None\n                                 yield controls\n \n                         if options:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #658",
        "line": 133,
        "description": [
          "                            yield Label(f\"Options\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -130,7 +130,7 @@\n                                 yield controls\n \n                         if options:\n-                            yield Label(f\"Options\", classes=\"command-form-heading\")\n+                            yield Label(f\"XXOptionsXX\", classes=\"command-form-heading\")\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #659",
        "line": 133,
        "description": [
          "                            yield Label(f\"Options\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -130,7 +130,7 @@\n                                 yield controls\n \n                         if options:\n-                            yield Label(f\"Options\", classes=\"command-form-heading\")\n+                            yield Label(f\"Options\", classes=\"XXcommand-form-headingXX\")\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #660",
        "line": 135,
        "description": [
          "                                controls = ParameterControls(option, id=option.key)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -132,7 +132,7 @@\n                         if options:\n                             yield Label(f\"Options\", classes=\"command-form-heading\")\n                             for option in options:\n-                                controls = ParameterControls(option, id=option.key)\n+                                controls = None\n                                 if self.first_control is None:\n                                     self.first_control = controls\n                                 yield controls\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #661",
        "line": 136,
        "description": [
          "                                if self.first_control is None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -133,7 +133,7 @@\n                             yield Label(f\"Options\", classes=\"command-form-heading\")\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n-                                if self.first_control is None:\n+                                if self.first_control is not None:\n                                     self.first_control = controls\n                                 yield controls\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #662",
        "line": 137,
        "description": [
          "                                    self.first_control = controls"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -134,7 +134,7 @@\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n                                 if self.first_control is None:\n-                                    self.first_control = controls\n+                                    self.first_control = None\n                                 yield controls\n \n                 command_node = next(path_from_root, None)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #663",
        "line": 140,
        "description": [
          "                command_node = next(path_from_root, None)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -137,7 +137,7 @@\n                                     self.first_control = controls\n                                 yield controls\n \n-                command_node = next(path_from_root, None)\n+                command_node = None\n \n     def on_mount(self) -> None:\n         self._form_changed()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #664",
        "line": 161,
        "description": [
          "        command_schema = self.command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -158,7 +158,7 @@\n         \"\"\"Take the current state of the form and build a UserCommandData from it,\n         then post a FormChanged message\"\"\"\n \n-        command_schema = self.command_schema\n+        command_schema = None\n         path_from_root = command_schema.path_from_root\n \n         # Sentinel root value to make constructing the tree a little easier.\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #665",
        "line": 162,
        "description": [
          "        path_from_root = command_schema.path_from_root"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -159,7 +159,7 @@\n         then post a FormChanged message\"\"\"\n \n         command_schema = self.command_schema\n-        path_from_root = command_schema.path_from_root\n+        path_from_root = None\n \n         # Sentinel root value to make constructing the tree a little easier.\n         parent_command_data = UserCommandData(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #666",
        "line": 166,
        "description": [
          "            name=CommandName(\"_\"), options=[], arguments=[]"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -163,7 +163,7 @@\n \n         # Sentinel root value to make constructing the tree a little easier.\n         parent_command_data = UserCommandData(\n-            name=CommandName(\"_\"), options=[], arguments=[]\n+            name=CommandName(\"XX_XX\"), options=[], arguments=[]\n         )\n \n         root_command_data = parent_command_data\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #667",
        "line": 167,
        "description": [
          "        )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -162,9 +162,7 @@\n         path_from_root = command_schema.path_from_root\n \n         # Sentinel root value to make constructing the tree a little easier.\n-        parent_command_data = UserCommandData(\n-            name=CommandName(\"_\"), options=[], arguments=[]\n-        )\n+        parent_command_data = None\n \n         root_command_data = parent_command_data\n         for command in path_from_root:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #668",
        "line": 169,
        "description": [
          "        root_command_data = parent_command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -166,7 +166,7 @@\n             name=CommandName(\"_\"), options=[], arguments=[]\n         )\n \n-        root_command_data = parent_command_data\n+        root_command_data = None\n         for command in path_from_root:\n             option_datas = []\n             # For each of the options in the schema for this command,\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #669",
        "line": 171,
        "description": [
          "            option_datas = []"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -168,7 +168,7 @@\n \n         root_command_data = parent_command_data\n         for command in path_from_root:\n-            option_datas = []\n+            option_datas = None\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #670",
        "line": 175,
        "description": [
          "                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -172,7 +172,7 @@\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n-                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n+                parameter_control = self.query_one(f\"XX#{option.key}XX\", ParameterControls)\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #671",
        "line": 175,
        "description": [
          "                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -172,7 +172,7 @@\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n-                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n+                parameter_control = None\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #672",
        "line": 176,
        "description": [
          "                value = parameter_control.get_values()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -173,7 +173,7 @@\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n                 parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n-                value = parameter_control.get_values()\n+                value = None\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n                     option_data = UserOptionData(option.name, v, option)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #673",
        "line": 179,
        "description": [
          "                    option_data = UserOptionData(option.name, v, option)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -176,7 +176,7 @@\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n-                    option_data = UserOptionData(option.name, v, option)\n+                    option_data = None\n                     option_datas.append(option_data)\n \n             # Now do the same for the arguments\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #674",
        "line": 183,
        "description": [
          "            argument_datas = []"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -180,7 +180,7 @@\n                     option_datas.append(option_data)\n \n             # Now do the same for the arguments\n-            argument_datas = []\n+            argument_datas = None\n             for argument in command.arguments:\n                 form_control_widget = self.query_one(\n                     f\"#{argument.key}\", ParameterControls\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #675",
        "line": 186,
        "description": [
          "                    f\"#{argument.key}\", ParameterControls"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -183,7 +183,7 @@\n             argument_datas = []\n             for argument in command.arguments:\n                 form_control_widget = self.query_one(\n-                    f\"#{argument.key}\", ParameterControls\n+                    f\"XX#{argument.key}XX\", ParameterControls\n                 )\n                 value = form_control_widget.get_values()\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #676",
        "line": 187,
        "description": [
          "                )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -182,9 +182,7 @@\n             # Now do the same for the arguments\n             argument_datas = []\n             for argument in command.arguments:\n-                form_control_widget = self.query_one(\n-                    f\"#{argument.key}\", ParameterControls\n-                )\n+                form_control_widget = None\n                 value = form_control_widget.get_values()\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #677",
        "line": 188,
        "description": [
          "                value = form_control_widget.get_values()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -185,7 +185,7 @@\n                 form_control_widget = self.query_one(\n                     f\"#{argument.key}\", ParameterControls\n                 )\n-                value = form_control_widget.get_values()\n+                value = None\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #678",
        "line": 192,
        "description": [
          "                    argument_data = UserArgumentData(argument.name, v, argument)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -189,7 +189,7 @@\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n-                    argument_data = UserArgumentData(argument.name, v, argument)\n+                    argument_data = None\n                     argument_datas.append(argument_data)\n \n             assert all(isinstance(option.value, tuple) for option in option_datas)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #679",
        "line": 203,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -194,13 +194,7 @@\n \n             assert all(isinstance(option.value, tuple) for option in option_datas)\n             assert all(isinstance(argument.value, tuple) for argument in argument_datas)\n-            command_data = UserCommandData(\n-                name=command.name,\n-                options=option_datas,\n-                arguments=argument_datas,\n-                parent=parent_command_data,\n-                command_schema=command,\n-            )\n+            command_data = None\n             parent_command_data.subcommand = command_data\n             parent_command_data = command_data\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #680",
        "line": 204,
        "description": [
          "            parent_command_data.subcommand = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -201,7 +201,7 @@\n                 parent=parent_command_data,\n                 command_schema=command,\n             )\n-            parent_command_data.subcommand = command_data\n+            parent_command_data.subcommand = None\n             parent_command_data = command_data\n \n         # Trim the sentinel\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #681",
        "line": 205,
        "description": [
          "            parent_command_data = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -202,7 +202,7 @@\n                 command_schema=command,\n             )\n             parent_command_data.subcommand = command_data\n-            parent_command_data = command_data\n+            parent_command_data = None\n \n         # Trim the sentinel\n         root_command_data = root_command_data.subcommand\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #682",
        "line": 208,
        "description": [
          "        root_command_data = root_command_data.subcommand"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -205,7 +205,7 @@\n             parent_command_data = command_data\n \n         # Trim the sentinel\n-        root_command_data = root_command_data.subcommand\n+        root_command_data = None\n         root_command_data.parent = None\n         self.post_message(self.Changed(root_command_data))\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #683",
        "line": 209,
        "description": [
          "        root_command_data.parent = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -206,7 +206,7 @@\n \n         # Trim the sentinel\n         root_command_data = root_command_data.subcommand\n-        root_command_data.parent = None\n+        root_command_data.parent = \"\"\n         self.post_message(self.Changed(root_command_data))\n \n     def focus(self, scroll_visible: bool = True):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #684",
        "line": 212,
        "description": [
          "    def focus(self, scroll_visible: bool = True):"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -209,7 +209,7 @@\n         root_command_data.parent = None\n         self.post_message(self.Changed(root_command_data))\n \n-    def focus(self, scroll_visible: bool = True):\n+    def focus(self, scroll_visible: bool = False):\n         if self.first_control is not None:\n             return self.first_control.focus()\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #685",
        "line": 213,
        "description": [
          "        if self.first_control is not None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -210,7 +210,7 @@\n         self.post_message(self.Changed(root_command_data))\n \n     def focus(self, scroll_visible: bool = True):\n-        if self.first_control is not None:\n+        if self.first_control is  None:\n             return self.first_control.focus()\n \n     @on(Input.Changed, \".command-form-filter-input\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #686",
        "line": 216,
        "description": [
          "    @on(Input.Changed, \".command-form-filter-input\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -213,7 +213,7 @@\n         if self.first_control is not None:\n             return self.first_control.focus()\n \n-    @on(Input.Changed, \".command-form-filter-input\")\n+    @on(Input.Changed, \"XX.command-form-filter-inputXX\")\n     def apply_filter(self, event: Input.Changed) -> None:\n         filter_query = event.value\n         all_controls = self.query(ParameterControls)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #687",
        "line": 216,
        "description": [
          "    @on(Input.Changed, \".command-form-filter-input\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -213,7 +213,6 @@\n         if self.first_control is not None:\n             return self.first_control.focus()\n \n-    @on(Input.Changed, \".command-form-filter-input\")\n     def apply_filter(self, event: Input.Changed) -> None:\n         filter_query = event.value\n         all_controls = self.query(ParameterControls)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #688",
        "line": 218,
        "description": [
          "        filter_query = event.value"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -215,7 +215,7 @@\n \n     @on(Input.Changed, \".command-form-filter-input\")\n     def apply_filter(self, event: Input.Changed) -> None:\n-        filter_query = event.value\n+        filter_query = None\n         all_controls = self.query(ParameterControls)\n         for control in all_controls:\n             filter_query = filter_query.casefold()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #689",
        "line": 219,
        "description": [
          "        all_controls = self.query(ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -216,7 +216,7 @@\n     @on(Input.Changed, \".command-form-filter-input\")\n     def apply_filter(self, event: Input.Changed) -> None:\n         filter_query = event.value\n-        all_controls = self.query(ParameterControls)\n+        all_controls = None\n         for control in all_controls:\n             filter_query = filter_query.casefold()\n             control.apply_filter(filter_query)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "tui",
    "function_scope": "292-308",
    "patterns": [
      {
        "lineno": 298,
        "coloffset": 8,
        "linematch": "if isinstance(app, click.Group):",
        "context": "        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n\n        if isinstance(app, click.Group):\n            app.command(name=command, help=help)(wrapped_tui)\n        else:\n            new_group = click.Group()\n            new_group.add_command(app)\n            new_group.command(name=command, help=help)(wrapped_tui)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 292,
        "coloffset": 0,
        "linematch": "def tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):",
        "context": "        \"\"\"\n        open_url(url)\n\n\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 293,
        "coloffset": 4,
        "linematch": "def decorator(app: click.Group | click.Command):",
        "context": "        open_url(url)\n\n\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n\n        if isinstance(app, click.Group):",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 295,
        "coloffset": 8,
        "linematch": "def wrapped_tui(ctx, *args, **kwargs):",
        "context": "\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n\n        if isinstance(app, click.Group):\n            app.command(name=command, help=help)(wrapped_tui)\n        else:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 292,
        "coloffset": 0,
        "linematch": "def tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):",
        "context": "        \"\"\"\n        open_url(url)\n\n\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n",
        "pattern": ".//FunctionDef//FunctionDef/ancestor::*",
        "check_id": "F001",
        "check_name": "nested-depth"
      },
      {
        "lineno": 293,
        "coloffset": 4,
        "linematch": "def decorator(app: click.Group | click.Command):",
        "context": "        open_url(url)\n\n\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n\n        if isinstance(app, click.Group):",
        "pattern": ".//FunctionDef//FunctionDef/ancestor::*",
        "check_id": "F001",
        "check_name": "nested-depth"
      },
      {
        "lineno": 292,
        "coloffset": 0,
        "linematch": "def tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):",
        "context": "        \"\"\"\n        open_url(url)\n\n\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 293,
        "coloffset": 4,
        "linematch": "def decorator(app: click.Group | click.Command):",
        "context": "        open_url(url)\n\n\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n\n        if isinstance(app, click.Group):",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 295,
        "coloffset": 8,
        "linematch": "def wrapped_tui(ctx, *args, **kwargs):",
        "context": "\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n\n        if isinstance(app, click.Group):\n            app.command(name=command, help=help)(wrapped_tui)\n        else:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 293,
        "coloffset": 4,
        "linematch": "def decorator(app: click.Group | click.Command):",
        "context": "        open_url(url)\n\n\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n\n        if isinstance(app, click.Group):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 295,
        "coloffset": 8,
        "linematch": "def wrapped_tui(ctx, *args, **kwargs):",
        "context": "\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n\n        if isinstance(app, click.Group):\n            app.command(name=command, help=help)(wrapped_tui)\n        else:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 296,
        "coloffset": 12,
        "linematch": "Trogon(app, app_name=name, command_name=command, click_context=ctx).run()",
        "context": "def tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n\n        if isinstance(app, click.Group):\n            app.command(name=command, help=help)(wrapped_tui)\n        else:\n            new_group = click.Group()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 298,
        "coloffset": 8,
        "linematch": "if isinstance(app, click.Group):",
        "context": "        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n\n        if isinstance(app, click.Group):\n            app.command(name=command, help=help)(wrapped_tui)\n        else:\n            new_group = click.Group()\n            new_group.add_command(app)\n            new_group.command(name=command, help=help)(wrapped_tui)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 306,
        "coloffset": 8,
        "linematch": "return app",
        "context": "            new_group.add_command(app)\n            new_group.command(name=command, help=help)(wrapped_tui)\n            return new_group\n\n        return app\n\n    return decorator",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 308,
        "coloffset": 4,
        "linematch": "return decorator",
        "context": "            return new_group\n\n        return app\n\n    return decorator",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 292,
        "coloffset": 0,
        "linematch": "def tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):",
        "context": "        \"\"\"\n        open_url(url)\n\n\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context\n        def wrapped_tui(ctx, *args, **kwargs):\n            Trogon(app, app_name=name, command_name=command, click_context=ctx).run()\n",
        "pattern": ".//FunctionDef[count(body//Return) > 2]",
        "check_id": "MRET001",
        "check_name": "multiple-returns-in-function"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "compose",
    "function_scope": "82-131",
    "patterns": [
      {
        "lineno": 86,
        "coloffset": 8,
        "linematch": "if self.version:",
        "context": "    def compose(self) -> ComposeResult:\n        tree = CommandTree(\"Commands\", self.command_schemas, self.command_name)\n\n        title_parts = [Text(self.click_app_name, style=\"b\")]\n        if self.version:\n            version_style = self.get_component_rich_style(\"version-string\")\n            title_parts.extend([\"\\n\", (f\"v{self.version}\", version_style)])\n\n        title = Text.assemble(*title_parts)\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 97,
        "coloffset": 8,
        "linematch": "if self.is_grouped_cli:",
        "context": "            Label(title, id=\"home-commands-label\"),\n            tree,\n            id=\"home-sidebar\",\n        )\n        if self.is_grouped_cli:\n            # If the root of the click app is a Group instance, then\n            #  we display the command tree to users and focus it.\n            tree.focus()\n        else:\n            # If the click app is structured using a single command,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 184,
        "coloffset": 8,
        "linematch": "if self.first_control is None:",
        "context": "                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n        # Take note of the first form control, so we can easily focus it\n        if self.first_control is None:\n            self.first_control = first_focus_control\n\n        # If it's a multiple, and it's a Choice parameter, then we display\n        # our special case MultiChoice widget, and so there's no need for this\n        # button.",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 190,
        "coloffset": 8,
        "linematch": "if multiple or nargs == -1 and not isinstance(argument_type, click.Choice):",
        "context": "\n        # If it's a multiple, and it's a Choice parameter, then we display\n        # our special case MultiChoice widget, and so there's no need for this\n        # button.\n        if multiple or nargs == -1 and not isinstance(argument_type, click.Choice):\n            with Horizontal(classes=\"add-another-button-container\"):\n                yield Button(\"+ value\", variant=\"success\", classes=\"add-another-button\")\n\n        # Render the dim help text below the form controls\n        if help_text:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 195,
        "coloffset": 8,
        "linematch": "if help_text:",
        "context": "            with Horizontal(classes=\"add-another-button-container\"):\n                yield Button(\"+ value\", variant=\"success\", classes=\"add-another-button\")\n\n        # Render the dim help text below the form controls\n        if help_text:\n            yield Static(help_text, classes=\"command-form-control-help-text\")\n\n    def make_widget_group(self) -> Iterable[Widget]:\n        \"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"\n        schema = self.schema",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 130,
        "coloffset": 12,
        "linematch": "if not argument_type == click.BOOL:",
        "context": "\n        # If there are N defaults, we render the \"group\" N times.\n        # Each group will contain `nargs` widgets.\n        with ControlGroupsContainer():\n            if not argument_type == click.BOOL:\n                yield Label(label, classes=\"command-form-label\")\n\n            if isinstance(argument_type, click.Choice) and multiple:\n                # Display a MultipleChoice widget\n                # There's a special case where we have a Choice with multiple=True,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 133,
        "coloffset": 12,
        "linematch": "if isinstance(argument_type, click.Choice) and multiple:",
        "context": "        with ControlGroupsContainer():\n            if not argument_type == click.BOOL:\n                yield Label(label, classes=\"command-form-label\")\n\n            if isinstance(argument_type, click.Choice) and multiple:\n                # Display a MultipleChoice widget\n                # There's a special case where we have a Choice with multiple=True,\n                # in this case, we can just render a single MultipleChoice widget\n                # instead of multiple radio-sets.\n                control_method = self.get_control_method(argument_type)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 171,
        "coloffset": 16,
        "linematch": "if multiple or not default.values:",
        "context": "                                first_focus_control = control_widget\n\n                # We always need to display the original group of controls,\n                # regardless of whether there are defaults\n                if multiple or not default.values:\n                    widget_group = list(self.make_widget_group())\n                    with ControlGroup() as control_group:\n                        if len(widget_group) == 1:\n                            control_group.add_class(\"single-item\")\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 153,
        "coloffset": 24,
        "linematch": "if len(widget_group) == 1:",
        "context": "                # If required, we'll generate widgets containing the defaults\n                for default_value_tuple in default.values:\n                    widget_group = list(self.make_widget_group())\n                    with ControlGroup() as control_group:\n                        if len(widget_group) == 1:\n                            control_group.add_class(\"single-item\")\n\n                        # Parameter types can be of length 1, but there could still\n                        # be multiple defaults. We need to render a widget for each\n                        # of those defaults. Extend the widget group such that",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 166,
        "coloffset": 28,
        "linematch": "if first_focus_control is None:",
        "context": "                        ):\n                            self._apply_default_value(control_widget, default_value)\n                            yield control_widget\n                            # Keep track of the first control we render, for easy focus\n                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n                # We always need to display the original group of controls,\n                # regardless of whether there are defaults\n                if multiple or not default.values:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 174,
        "coloffset": 24,
        "linematch": "if len(widget_group) == 1:",
        "context": "                # regardless of whether there are defaults\n                if multiple or not default.values:\n                    widget_group = list(self.make_widget_group())\n                    with ControlGroup() as control_group:\n                        if len(widget_group) == 1:\n                            control_group.add_class(\"single-item\")\n\n                        # No need to apply defaults to this group\n                        for control_widget in widget_group:\n                            yield control_widget",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 180,
        "coloffset": 28,
        "linematch": "if first_focus_control is None:",
        "context": "\n                        # No need to apply defaults to this group\n                        for control_widget in widget_group:\n                            yield control_widget\n                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n        # Take note of the first form control, so we can easily focus it\n        if self.first_control is None:\n            self.first_control = first_focus_control",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 114,
        "coloffset": 16,
        "linematch": "if options or arguments:",
        "context": "\n            while command_node is not None:\n                options = command_node.options\n                arguments = command_node.arguments\n                if options or arguments:\n                    with Vertical(\n                        classes=\"command-form-command-group\", id=command_node.key\n                    ) as v:\n                        is_inherited = command_node is not self.command_schema\n                        v.border_title = (",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 122,
        "coloffset": 24,
        "linematch": "if is_inherited:",
        "context": "                        is_inherited = command_node is not self.command_schema\n                        v.border_title = (\n                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                        )\n                        if is_inherited:\n                            v.border_title += \" [dim not bold](inherited)\"\n                        if arguments:\n                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                            for argument in arguments:\n                                controls = ParameterControls(argument, id=argument.key)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 124,
        "coloffset": 24,
        "linematch": "if arguments:",
        "context": "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                        )\n                        if is_inherited:\n                            v.border_title += \" [dim not bold](inherited)\"\n                        if arguments:\n                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                            for argument in arguments:\n                                controls = ParameterControls(argument, id=argument.key)\n                                if self.first_control is None:\n                                    self.first_control = controls",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 132,
        "coloffset": 24,
        "linematch": "if options:",
        "context": "                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")\n                            for option in options:\n                                controls = ParameterControls(option, id=option.key)\n                                if self.first_control is None:\n                                    self.first_control = controls",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 128,
        "coloffset": 32,
        "linematch": "if self.first_control is None:",
        "context": "                        if arguments:\n                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                            for argument in arguments:\n                                controls = ParameterControls(argument, id=argument.key)\n                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 136,
        "coloffset": 32,
        "linematch": "if self.first_control is None:",
        "context": "                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")\n                            for option in options:\n                                controls = ParameterControls(option, id=option.key)\n                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                command_node = next(path_from_root, None)\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 153,
        "coloffset": 24,
        "linematch": "if len(widget_group) == 1:",
        "context": "                # If required, we'll generate widgets containing the defaults\n                for default_value_tuple in default.values:\n                    widget_group = list(self.make_widget_group())\n                    with ControlGroup() as control_group:\n                        if len(widget_group) == 1:\n                            control_group.add_class(\"single-item\")\n\n                        # Parameter types can be of length 1, but there could still\n                        # be multiple defaults. We need to render a widget for each\n                        # of those defaults. Extend the widget group such that",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 166,
        "coloffset": 28,
        "linematch": "if first_focus_control is None:",
        "context": "                        ):\n                            self._apply_default_value(control_widget, default_value)\n                            yield control_widget\n                            # Keep track of the first control we render, for easy focus\n                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n                # We always need to display the original group of controls,\n                # regardless of whether there are defaults\n                if multiple or not default.values:",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 174,
        "coloffset": 24,
        "linematch": "if len(widget_group) == 1:",
        "context": "                # regardless of whether there are defaults\n                if multiple or not default.values:\n                    widget_group = list(self.make_widget_group())\n                    with ControlGroup() as control_group:\n                        if len(widget_group) == 1:\n                            control_group.add_class(\"single-item\")\n\n                        # No need to apply defaults to this group\n                        for control_widget in widget_group:\n                            yield control_widget",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 180,
        "coloffset": 28,
        "linematch": "if first_focus_control is None:",
        "context": "\n                        # No need to apply defaults to this group\n                        for control_widget in widget_group:\n                            yield control_widget\n                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n        # Take note of the first form control, so we can easily focus it\n        if self.first_control is None:\n            self.first_control = first_focus_control",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 122,
        "coloffset": 24,
        "linematch": "if is_inherited:",
        "context": "                        is_inherited = command_node is not self.command_schema\n                        v.border_title = (\n                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                        )\n                        if is_inherited:\n                            v.border_title += \" [dim not bold](inherited)\"\n                        if arguments:\n                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                            for argument in arguments:\n                                controls = ParameterControls(argument, id=argument.key)",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 124,
        "coloffset": 24,
        "linematch": "if arguments:",
        "context": "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                        )\n                        if is_inherited:\n                            v.border_title += \" [dim not bold](inherited)\"\n                        if arguments:\n                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                            for argument in arguments:\n                                controls = ParameterControls(argument, id=argument.key)\n                                if self.first_control is None:\n                                    self.first_control = controls",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 132,
        "coloffset": 24,
        "linematch": "if options:",
        "context": "                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")\n                            for option in options:\n                                controls = ParameterControls(option, id=option.key)\n                                if self.first_control is None:\n                                    self.first_control = controls",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 128,
        "coloffset": 32,
        "linematch": "if self.first_control is None:",
        "context": "                        if arguments:\n                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                            for argument in arguments:\n                                controls = ParameterControls(argument, id=argument.key)\n                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 136,
        "coloffset": 32,
        "linematch": "if self.first_control is None:",
        "context": "                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")\n                            for option in options:\n                                controls = ParameterControls(option, id=option.key)\n                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                command_node = next(path_from_root, None)\n",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 180,
        "coloffset": 31,
        "linematch": "if first_focus_control is None:",
        "context": "\n                        # No need to apply defaults to this group\n                        for control_widget in widget_group:\n                            yield control_widget\n                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n        # Take note of the first form control, so we can easily focus it\n        if self.first_control is None:\n            self.first_control = first_focus_control",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 180,
        "coloffset": 31,
        "linematch": "if first_focus_control is None:",
        "context": "\n                        # No need to apply defaults to this group\n                        for control_widget in widget_group:\n                            yield control_widget\n                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n        # Take note of the first form control, so we can easily focus it\n        if self.first_control is None:\n            self.first_control = first_focus_control",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 180,
        "coloffset": 31,
        "linematch": "if first_focus_control is None:",
        "context": "\n                        # No need to apply defaults to this group\n                        for control_widget in widget_group:\n                            yield control_widget\n                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n        # Take note of the first form control, so we can easily focus it\n        if self.first_control is None:\n            self.first_control = first_focus_control",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 180,
        "coloffset": 31,
        "linematch": "if first_focus_control is None:",
        "context": "\n                        # No need to apply defaults to this group\n                        for control_widget in widget_group:\n                            yield control_widget\n                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n        # Take note of the first form control, so we can easily focus it\n        if self.first_control is None:\n            self.first_control = first_focus_control",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 136,
        "coloffset": 35,
        "linematch": "if self.first_control is None:",
        "context": "                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")\n                            for option in options:\n                                controls = ParameterControls(option, id=option.key)\n                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                command_node = next(path_from_root, None)\n",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 136,
        "coloffset": 35,
        "linematch": "if self.first_control is None:",
        "context": "                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")\n                            for option in options:\n                                controls = ParameterControls(option, id=option.key)\n                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                command_node = next(path_from_root, None)\n",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 82,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "            self.version = None\n\n        self.highlighter = ReprHighlighter()\n\n    def compose(self) -> ComposeResult:\n        tree = CommandTree(\"Commands\", self.command_schemas, self.command_name)\n\n        title_parts = [Text(self.click_app_name, style=\"b\")]\n        if self.version:\n            version_style = self.get_component_rich_style(\"version-string\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 62,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "        def __init__(self, selected: list[Checkbox]):\n            super().__init__()\n            self.selected = selected\n\n    def compose(self) -> ComposeResult:\n        with NonFocusableVerticalScroll():\n            for option in self.options:\n                yield Checkbox(option, value=(option,) in self.defaults)\n\n    @on(Checkbox.Changed)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "    def button_style(self) -> ButtonVariant:\n        \"\"\"The style for the dialog's button.\"\"\"\n        return \"primary\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the content of the modal dialog.\"\"\"\n        with Vertical():\n            with Center():\n                yield Static(self._title, classes=\"spaced\")\n            yield Static(self._message, id=\"message\", classes=\"spaced\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 108,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "                pass\n\n        return should_be_visible\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Takes the schemas for each parameter of the current command, and converts it into a\n        form consisting of Textual widgets.\"\"\"\n        schema = self.schema\n        name = schema.name\n        argument_type = schema.type",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "        self.command_schema = command_schema\n        self.command_schemas = command_schemas\n        self.first_control: ParameterControls | None = None\n\n    def compose(self) -> ComposeResult:\n        path_from_root = iter(reversed(self.command_schema.path_from_root))\n        command_node = next(path_from_root)\n        with VerticalScroll() as vs:\n            vs.can_focus = False\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 72,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "            classes=classes,\n        )\n        self.command_schema = command_schema\n\n    def compose(self) -> ComposeResult:\n        schema = self.command_schema\n        path = schema.path_from_root\n        path_string = \" \u279c \".join(command.name for command in path)\n\n        title_style = self.get_component_rich_style(\"title\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 72,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "            classes=classes,\n        )\n        self.command_schema = command_schema\n\n    def compose(self) -> ComposeResult:\n        schema = self.command_schema\n        path = schema.path_from_root\n        path_string = \" \u279c \".join(command.name for command in path)\n\n        title_style = self.get_component_rich_style(\"title\")",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 97,
        "coloffset": 8,
        "linematch": "if self.is_grouped_cli:",
        "context": "            Label(title, id=\"home-commands-label\"),\n            tree,\n            id=\"home-sidebar\",\n        )\n        if self.is_grouped_cli:\n            # If the root of the click app is a Group instance, then\n            #  we display the command tree to users and focus it.\n            tree.focus()\n        else:\n            # If the click app is structured using a single command,",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 133,
        "coloffset": 12,
        "linematch": "if isinstance(argument_type, click.Choice) and multiple:",
        "context": "        with ControlGroupsContainer():\n            if not argument_type == click.BOOL:\n                yield Label(label, classes=\"command-form-label\")\n\n            if isinstance(argument_type, click.Choice) and multiple:\n                # Display a MultipleChoice widget\n                # There's a special case where we have a Choice with multiple=True,\n                # in this case, we can just render a single MultipleChoice widget\n                # instead of multiple radio-sets.\n                control_method = self.get_control_method(argument_type)",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 190,
        "coloffset": 8,
        "linematch": "if multiple or nargs == -1 and not isinstance(argument_type, click.Choice):",
        "context": "\n        # If it's a multiple, and it's a Choice parameter, then we display\n        # our special case MultiChoice widget, and so there's no need for this\n        # button.\n        if multiple or nargs == -1 and not isinstance(argument_type, click.Choice):\n            with Horizontal(classes=\"add-another-button-container\"):\n                yield Button(\"+ value\", variant=\"success\", classes=\"add-another-button\")\n\n        # Render the dim help text below the form controls\n        if help_text:",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 195,
        "coloffset": 8,
        "linematch": "if help_text:",
        "context": "            with Horizontal(classes=\"add-another-button-container\"):\n                yield Button(\"+ value\", variant=\"success\", classes=\"add-another-button\")\n\n        # Render the dim help text below the form controls\n        if help_text:\n            yield Static(help_text, classes=\"command-form-control-help-text\")\n\n    def make_widget_group(self) -> Iterable[Widget]:\n        \"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"\n        schema = self.schema",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 124,
        "coloffset": 24,
        "linematch": "if arguments:",
        "context": "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                        )\n                        if is_inherited:\n                            v.border_title += \" [dim not bold](inherited)\"\n                        if arguments:\n                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                            for argument in arguments:\n                                controls = ParameterControls(argument, id=argument.key)\n                                if self.first_control is None:\n                                    self.first_control = controls",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 132,
        "coloffset": 24,
        "linematch": "if options:",
        "context": "                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")\n                            for option in options:\n                                controls = ParameterControls(option, id=option.key)\n                                if self.first_control is None:\n                                    self.first_control = controls",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 153,
        "coloffset": 24,
        "linematch": "if len(widget_group) == 1:",
        "context": "                # If required, we'll generate widgets containing the defaults\n                for default_value_tuple in default.values:\n                    widget_group = list(self.make_widget_group())\n                    with ControlGroup() as control_group:\n                        if len(widget_group) == 1:\n                            control_group.add_class(\"single-item\")\n\n                        # Parameter types can be of length 1, but there could still\n                        # be multiple defaults. We need to render a widget for each\n                        # of those defaults. Extend the widget group such that",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 166,
        "coloffset": 28,
        "linematch": "if first_focus_control is None:",
        "context": "                        ):\n                            self._apply_default_value(control_widget, default_value)\n                            yield control_widget\n                            # Keep track of the first control we render, for easy focus\n                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n                # We always need to display the original group of controls,\n                # regardless of whether there are defaults\n                if multiple or not default.values:",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 171,
        "coloffset": 16,
        "linematch": "if multiple or not default.values:",
        "context": "                                first_focus_control = control_widget\n\n                # We always need to display the original group of controls,\n                # regardless of whether there are defaults\n                if multiple or not default.values:\n                    widget_group = list(self.make_widget_group())\n                    with ControlGroup() as control_group:\n                        if len(widget_group) == 1:\n                            control_group.add_class(\"single-item\")\n",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 174,
        "coloffset": 24,
        "linematch": "if len(widget_group) == 1:",
        "context": "                # regardless of whether there are defaults\n                if multiple or not default.values:\n                    widget_group = list(self.make_widget_group())\n                    with ControlGroup() as control_group:\n                        if len(widget_group) == 1:\n                            control_group.add_class(\"single-item\")\n\n                        # No need to apply defaults to this group\n                        for control_widget in widget_group:\n                            yield control_widget",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 180,
        "coloffset": 28,
        "linematch": "if first_focus_control is None:",
        "context": "\n                        # No need to apply defaults to this group\n                        for control_widget in widget_group:\n                            yield control_widget\n                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n        # Take note of the first form control, so we can easily focus it\n        if self.first_control is None:\n            self.first_control = first_focus_control",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 122,
        "coloffset": 24,
        "linematch": "if is_inherited:",
        "context": "                        is_inherited = command_node is not self.command_schema\n                        v.border_title = (\n                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                        )\n                        if is_inherited:\n                            v.border_title += \" [dim not bold](inherited)\"\n                        if arguments:\n                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                            for argument in arguments:\n                                controls = ParameterControls(argument, id=argument.key)",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 124,
        "coloffset": 24,
        "linematch": "if arguments:",
        "context": "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                        )\n                        if is_inherited:\n                            v.border_title += \" [dim not bold](inherited)\"\n                        if arguments:\n                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                            for argument in arguments:\n                                controls = ParameterControls(argument, id=argument.key)\n                                if self.first_control is None:\n                                    self.first_control = controls",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 128,
        "coloffset": 32,
        "linematch": "if self.first_control is None:",
        "context": "                        if arguments:\n                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                            for argument in arguments:\n                                controls = ParameterControls(argument, id=argument.key)\n                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 132,
        "coloffset": 24,
        "linematch": "if options:",
        "context": "                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")\n                            for option in options:\n                                controls = ParameterControls(option, id=option.key)\n                                if self.first_control is None:\n                                    self.first_control = controls",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 136,
        "coloffset": 32,
        "linematch": "if self.first_control is None:",
        "context": "                        if options:\n                            yield Label(f\"Options\", classes=\"command-form-heading\")\n                            for option in options:\n                                controls = ParameterControls(option, id=option.key)\n                                if self.first_control is None:\n                                    self.first_control = controls\n                                yield controls\n\n                command_node = next(path_from_root, None)\n",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 82,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "            self.version = None\n\n        self.highlighter = ReprHighlighter()\n\n    def compose(self) -> ComposeResult:\n        tree = CommandTree(\"Commands\", self.command_schemas, self.command_name)\n\n        title_parts = [Text(self.click_app_name, style=\"b\")]\n        if self.version:\n            version_style = self.get_component_rich_style(\"version-string\")",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 108,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "                pass\n\n        return should_be_visible\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Takes the schemas for each parameter of the current command, and converts it into a\n        form consisting of Textual widgets.\"\"\"\n        schema = self.schema\n        name = schema.name\n        argument_type = schema.type",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 150,
        "coloffset": 16,
        "linematch": "for default_value_tuple in default.values:",
        "context": "                yield from multiple_choice_widget\n            else:\n                # For other widgets, we'll render as normal...\n                # If required, we'll generate widgets containing the defaults\n                for default_value_tuple in default.values:\n                    widget_group = list(self.make_widget_group())\n                    with ControlGroup() as control_group:\n                        if len(widget_group) == 1:\n                            control_group.add_class(\"single-item\")\n",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 83,
        "coloffset": 8,
        "linematch": "tree = CommandTree(\"Commands\", self.command_schemas, self.command_name)",
        "context": "\n        self.highlighter = ReprHighlighter()\n\n    def compose(self) -> ComposeResult:\n        tree = CommandTree(\"Commands\", self.command_schemas, self.command_name)\n\n        title_parts = [Text(self.click_app_name, style=\"b\")]\n        if self.version:\n            version_style = self.get_component_rich_style(\"version-string\")\n            title_parts.extend([\"\\n\", (f\"v{self.version}\", version_style)])",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 85,
        "coloffset": 8,
        "linematch": "title_parts = [Text(self.click_app_name, style=\"b\")]",
        "context": "\n    def compose(self) -> ComposeResult:\n        tree = CommandTree(\"Commands\", self.command_schemas, self.command_name)\n\n        title_parts = [Text(self.click_app_name, style=\"b\")]\n        if self.version:\n            version_style = self.get_component_rich_style(\"version-string\")\n            title_parts.extend([\"\\n\", (f\"v{self.version}\", version_style)])\n\n        title = Text.assemble(*title_parts)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 86,
        "coloffset": 8,
        "linematch": "if self.version:",
        "context": "    def compose(self) -> ComposeResult:\n        tree = CommandTree(\"Commands\", self.command_schemas, self.command_name)\n\n        title_parts = [Text(self.click_app_name, style=\"b\")]\n        if self.version:\n            version_style = self.get_component_rich_style(\"version-string\")\n            title_parts.extend([\"\\n\", (f\"v{self.version}\", version_style)])\n\n        title = Text.assemble(*title_parts)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 90,
        "coloffset": 8,
        "linematch": "title = Text.assemble(*title_parts)",
        "context": "        if self.version:\n            version_style = self.get_component_rich_style(\"version-string\")\n            title_parts.extend([\"\\n\", (f\"v{self.version}\", version_style)])\n\n        title = Text.assemble(*title_parts)\n\n        sidebar = Vertical(\n            Label(title, id=\"home-commands-label\"),\n            tree,\n            id=\"home-sidebar\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 92,
        "coloffset": 8,
        "linematch": "sidebar = Vertical(",
        "context": "            title_parts.extend([\"\\n\", (f\"v{self.version}\", version_style)])\n\n        title = Text.assemble(*title_parts)\n\n        sidebar = Vertical(\n            Label(title, id=\"home-commands-label\"),\n            tree,\n            id=\"home-sidebar\",\n        )\n        if self.is_grouped_cli:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 97,
        "coloffset": 8,
        "linematch": "if self.is_grouped_cli:",
        "context": "            Label(title, id=\"home-commands-label\"),\n            tree,\n            id=\"home-sidebar\",\n        )\n        if self.is_grouped_cli:\n            # If the root of the click app is a Group instance, then\n            #  we display the command tree to users and focus it.\n            tree.focus()\n        else:\n            # If the click app is structured using a single command,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 106,
        "coloffset": 8,
        "linematch": "yield sidebar",
        "context": "            # If the click app is structured using a single command,\n            #  there's no need for us to display the command tree.\n            sidebar.display = False\n\n        yield sidebar\n\n        with Vertical(id=\"home-body\"):\n            with Horizontal(id=\"home-command-description-container\") as vs:\n                vs.can_focus = False\n                yield Static(self.click_app_name or \"\", id=\"home-command-description\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 108,
        "coloffset": 8,
        "linematch": "with Vertical(id=\"home-body\"):",
        "context": "            sidebar.display = False\n\n        yield sidebar\n\n        with Vertical(id=\"home-body\"):\n            with Horizontal(id=\"home-command-description-container\") as vs:\n                vs.can_focus = False\n                yield Static(self.click_app_name or \"\", id=\"home-command-description\")\n\n            scrollable_body = VerticalScroll(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 131,
        "coloffset": 8,
        "linematch": "yield Footer()",
        "context": "                # ),\n                id=\"home-exec-preview\",\n            )\n\n        yield Footer()\n\n    def action_close_and_run(self) -> None:\n        self.app.execute_on_exit = True\n        self.app.exit()\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 63,
        "coloffset": 8,
        "linematch": "with NonFocusableVerticalScroll():",
        "context": "            super().__init__()\n            self.selected = selected\n\n    def compose(self) -> ComposeResult:\n        with NonFocusableVerticalScroll():\n            for option in self.options:\n                yield Checkbox(option, value=(option,) in self.defaults)\n\n    @on(Checkbox.Changed)\n    def checkbox_toggled(self) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 71,
        "coloffset": 8,
        "linematch": "\"\"\"Compose the content of the modal dialog.\"\"\"",
        "context": "        \"\"\"The style for the dialog's button.\"\"\"\n        return \"primary\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the content of the modal dialog.\"\"\"\n        with Vertical():\n            with Center():\n                yield Static(self._title, classes=\"spaced\")\n            yield Static(self._message, id=\"message\", classes=\"spaced\")\n            with Center(classes=\"spaced\"):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 72,
        "coloffset": 8,
        "linematch": "with Vertical():",
        "context": "        return \"primary\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the content of the modal dialog.\"\"\"\n        with Vertical():\n            with Center():\n                yield Static(self._title, classes=\"spaced\")\n            yield Static(self._message, id=\"message\", classes=\"spaced\")\n            with Center(classes=\"spaced\"):\n                yield Button(\"OK\", variant=self.button_style)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 109,
        "coloffset": 8,
        "linematch": "\"\"\"Takes the schemas for each parameter of the current command, and converts it into a",
        "context": "\n        return should_be_visible\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Takes the schemas for each parameter of the current command, and converts it into a\n        form consisting of Textual widgets.\"\"\"\n        schema = self.schema\n        name = schema.name\n        argument_type = schema.type\n        default = schema.default",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 111,
        "coloffset": 8,
        "linematch": "schema = self.schema",
        "context": "\n    def compose(self) -> ComposeResult:\n        \"\"\"Takes the schemas for each parameter of the current command, and converts it into a\n        form consisting of Textual widgets.\"\"\"\n        schema = self.schema\n        name = schema.name\n        argument_type = schema.type\n        default = schema.default\n        help_text = getattr(schema, \"help\", \"\") or \"\"\n        multiple = schema.multiple",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 112,
        "coloffset": 8,
        "linematch": "name = schema.name",
        "context": "    def compose(self) -> ComposeResult:\n        \"\"\"Takes the schemas for each parameter of the current command, and converts it into a\n        form consisting of Textual widgets.\"\"\"\n        schema = self.schema\n        name = schema.name\n        argument_type = schema.type\n        default = schema.default\n        help_text = getattr(schema, \"help\", \"\") or \"\"\n        multiple = schema.multiple\n        is_option = isinstance(schema, OptionSchema)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 113,
        "coloffset": 8,
        "linematch": "argument_type = schema.type",
        "context": "        \"\"\"Takes the schemas for each parameter of the current command, and converts it into a\n        form consisting of Textual widgets.\"\"\"\n        schema = self.schema\n        name = schema.name\n        argument_type = schema.type\n        default = schema.default\n        help_text = getattr(schema, \"help\", \"\") or \"\"\n        multiple = schema.multiple\n        is_option = isinstance(schema, OptionSchema)\n        nargs = schema.nargs",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 114,
        "coloffset": 8,
        "linematch": "default = schema.default",
        "context": "        form consisting of Textual widgets.\"\"\"\n        schema = self.schema\n        name = schema.name\n        argument_type = schema.type\n        default = schema.default\n        help_text = getattr(schema, \"help\", \"\") or \"\"\n        multiple = schema.multiple\n        is_option = isinstance(schema, OptionSchema)\n        nargs = schema.nargs\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 115,
        "coloffset": 8,
        "linematch": "help_text = getattr(schema, \"help\", \"\") or \"\"",
        "context": "        schema = self.schema\n        name = schema.name\n        argument_type = schema.type\n        default = schema.default\n        help_text = getattr(schema, \"help\", \"\") or \"\"\n        multiple = schema.multiple\n        is_option = isinstance(schema, OptionSchema)\n        nargs = schema.nargs\n\n        label = self._make_command_form_control_label(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 116,
        "coloffset": 8,
        "linematch": "multiple = schema.multiple",
        "context": "        name = schema.name\n        argument_type = schema.type\n        default = schema.default\n        help_text = getattr(schema, \"help\", \"\") or \"\"\n        multiple = schema.multiple\n        is_option = isinstance(schema, OptionSchema)\n        nargs = schema.nargs\n\n        label = self._make_command_form_control_label(\n            name, argument_type, is_option, schema.required, multiple=multiple",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 117,
        "coloffset": 8,
        "linematch": "is_option = isinstance(schema, OptionSchema)",
        "context": "        argument_type = schema.type\n        default = schema.default\n        help_text = getattr(schema, \"help\", \"\") or \"\"\n        multiple = schema.multiple\n        is_option = isinstance(schema, OptionSchema)\n        nargs = schema.nargs\n\n        label = self._make_command_form_control_label(\n            name, argument_type, is_option, schema.required, multiple=multiple\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 118,
        "coloffset": 8,
        "linematch": "nargs = schema.nargs",
        "context": "        default = schema.default\n        help_text = getattr(schema, \"help\", \"\") or \"\"\n        multiple = schema.multiple\n        is_option = isinstance(schema, OptionSchema)\n        nargs = schema.nargs\n\n        label = self._make_command_form_control_label(\n            name, argument_type, is_option, schema.required, multiple=multiple\n        )\n        first_focus_control: Widget | None = (",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 120,
        "coloffset": 8,
        "linematch": "label = self._make_command_form_control_label(",
        "context": "        multiple = schema.multiple\n        is_option = isinstance(schema, OptionSchema)\n        nargs = schema.nargs\n\n        label = self._make_command_form_control_label(\n            name, argument_type, is_option, schema.required, multiple=multiple\n        )\n        first_focus_control: Widget | None = (\n            None  # The widget that will be focused when the form is focused.\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 123,
        "coloffset": 8,
        "linematch": "first_focus_control: Widget | None = (",
        "context": "\n        label = self._make_command_form_control_label(\n            name, argument_type, is_option, schema.required, multiple=multiple\n        )\n        first_focus_control: Widget | None = (\n            None  # The widget that will be focused when the form is focused.\n        )\n\n        # If there are N defaults, we render the \"group\" N times.\n        # Each group will contain `nargs` widgets.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 129,
        "coloffset": 8,
        "linematch": "with ControlGroupsContainer():",
        "context": "        )\n\n        # If there are N defaults, we render the \"group\" N times.\n        # Each group will contain `nargs` widgets.\n        with ControlGroupsContainer():\n            if not argument_type == click.BOOL:\n                yield Label(label, classes=\"command-form-label\")\n\n            if isinstance(argument_type, click.Choice) and multiple:\n                # Display a MultipleChoice widget",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 184,
        "coloffset": 8,
        "linematch": "if self.first_control is None:",
        "context": "                            if first_focus_control is None:\n                                first_focus_control = control_widget\n\n        # Take note of the first form control, so we can easily focus it\n        if self.first_control is None:\n            self.first_control = first_focus_control\n\n        # If it's a multiple, and it's a Choice parameter, then we display\n        # our special case MultiChoice widget, and so there's no need for this\n        # button.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 190,
        "coloffset": 8,
        "linematch": "if multiple or nargs == -1 and not isinstance(argument_type, click.Choice):",
        "context": "\n        # If it's a multiple, and it's a Choice parameter, then we display\n        # our special case MultiChoice widget, and so there's no need for this\n        # button.\n        if multiple or nargs == -1 and not isinstance(argument_type, click.Choice):\n            with Horizontal(classes=\"add-another-button-container\"):\n                yield Button(\"+ value\", variant=\"success\", classes=\"add-another-button\")\n\n        # Render the dim help text below the form controls\n        if help_text:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 195,
        "coloffset": 8,
        "linematch": "if help_text:",
        "context": "            with Horizontal(classes=\"add-another-button-container\"):\n                yield Button(\"+ value\", variant=\"success\", classes=\"add-another-button\")\n\n        # Render the dim help text below the form controls\n        if help_text:\n            yield Static(help_text, classes=\"command-form-control-help-text\")\n\n    def make_widget_group(self) -> Iterable[Widget]:\n        \"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"\n        schema = self.schema",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 100,
        "coloffset": 8,
        "linematch": "path_from_root = iter(reversed(self.command_schema.path_from_root))",
        "context": "        self.command_schemas = command_schemas\n        self.first_control: ParameterControls | None = None\n\n    def compose(self) -> ComposeResult:\n        path_from_root = iter(reversed(self.command_schema.path_from_root))\n        command_node = next(path_from_root)\n        with VerticalScroll() as vs:\n            vs.can_focus = False\n\n            yield Input(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 101,
        "coloffset": 8,
        "linematch": "command_node = next(path_from_root)",
        "context": "        self.first_control: ParameterControls | None = None\n\n    def compose(self) -> ComposeResult:\n        path_from_root = iter(reversed(self.command_schema.path_from_root))\n        command_node = next(path_from_root)\n        with VerticalScroll() as vs:\n            vs.can_focus = False\n\n            yield Input(\n                placeholder=\"Search...\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 102,
        "coloffset": 8,
        "linematch": "with VerticalScroll() as vs:",
        "context": "\n    def compose(self) -> ComposeResult:\n        path_from_root = iter(reversed(self.command_schema.path_from_root))\n        command_node = next(path_from_root)\n        with VerticalScroll() as vs:\n            vs.can_focus = False\n\n            yield Input(\n                placeholder=\"Search...\",\n                classes=\"command-form-filter-input\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 73,
        "coloffset": 8,
        "linematch": "schema = self.command_schema",
        "context": "        )\n        self.command_schema = command_schema\n\n    def compose(self) -> ComposeResult:\n        schema = self.command_schema\n        path = schema.path_from_root\n        path_string = \" \u279c \".join(command.name for command in path)\n\n        title_style = self.get_component_rich_style(\"title\")\n        subtitle_style = self.get_component_rich_style(\"subtitle\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 74,
        "coloffset": 8,
        "linematch": "path = schema.path_from_root",
        "context": "        self.command_schema = command_schema\n\n    def compose(self) -> ComposeResult:\n        schema = self.command_schema\n        path = schema.path_from_root\n        path_string = \" \u279c \".join(command.name for command in path)\n\n        title_style = self.get_component_rich_style(\"title\")\n        subtitle_style = self.get_component_rich_style(\"subtitle\")\n        modal_header = Text.assemble(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 75,
        "coloffset": 8,
        "linematch": "path_string = \" \u279c \".join(command.name for command in path)",
        "context": "\n    def compose(self) -> ComposeResult:\n        schema = self.command_schema\n        path = schema.path_from_root\n        path_string = \" \u279c \".join(command.name for command in path)\n\n        title_style = self.get_component_rich_style(\"title\")\n        subtitle_style = self.get_component_rich_style(\"subtitle\")\n        modal_header = Text.assemble(\n            (path_string, title_style), \"\\n\", (\"command info\", subtitle_style)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 77,
        "coloffset": 8,
        "linematch": "title_style = self.get_component_rich_style(\"title\")",
        "context": "        schema = self.command_schema\n        path = schema.path_from_root\n        path_string = \" \u279c \".join(command.name for command in path)\n\n        title_style = self.get_component_rich_style(\"title\")\n        subtitle_style = self.get_component_rich_style(\"subtitle\")\n        modal_header = Text.assemble(\n            (path_string, title_style), \"\\n\", (\"command info\", subtitle_style)\n        )\n        with NonFocusableVerticalScroll(classes=\"command-info-container\"):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 8,
        "linematch": "subtitle_style = self.get_component_rich_style(\"subtitle\")",
        "context": "        path = schema.path_from_root\n        path_string = \" \u279c \".join(command.name for command in path)\n\n        title_style = self.get_component_rich_style(\"title\")\n        subtitle_style = self.get_component_rich_style(\"subtitle\")\n        modal_header = Text.assemble(\n            (path_string, title_style), \"\\n\", (\"command info\", subtitle_style)\n        )\n        with NonFocusableVerticalScroll(classes=\"command-info-container\"):\n            with Vertical(classes=\"command-info-header\"):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 79,
        "coloffset": 8,
        "linematch": "modal_header = Text.assemble(",
        "context": "        path_string = \" \u279c \".join(command.name for command in path)\n\n        title_style = self.get_component_rich_style(\"title\")\n        subtitle_style = self.get_component_rich_style(\"subtitle\")\n        modal_header = Text.assemble(\n            (path_string, title_style), \"\\n\", (\"command info\", subtitle_style)\n        )\n        with NonFocusableVerticalScroll(classes=\"command-info-container\"):\n            with Vertical(classes=\"command-info-header\"):\n                yield Static(modal_header, classes=\"command-info-header-text\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 82,
        "coloffset": 8,
        "linematch": "with NonFocusableVerticalScroll(classes=\"command-info-container\"):",
        "context": "        subtitle_style = self.get_component_rich_style(\"subtitle\")\n        modal_header = Text.assemble(\n            (path_string, title_style), \"\\n\", (\"command info\", subtitle_style)\n        )\n        with NonFocusableVerticalScroll(classes=\"command-info-container\"):\n            with Vertical(classes=\"command-info-header\"):\n                yield Static(modal_header, classes=\"command-info-header-text\")\n                tabs = Tabs(\n                    Tab(\"Description\", id=\"command-info-text\"),\n                    Tab(\"Metadata\", id=\"command-info-metadata\"),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 108,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "                pass\n\n        return should_be_visible\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Takes the schemas for each parameter of the current command, and converts it into a\n        form consisting of Textual widgets.\"\"\"\n        schema = self.schema\n        name = schema.name\n        argument_type = schema.type",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]",
        "check_id": "F027",
        "check_name": "high-cyclomatic-complexity"
      },
      {
        "lineno": 108,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "                pass\n\n        return should_be_visible\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Takes the schemas for each parameter of the current command, and converts it into a\n        form consisting of Textual widgets.\"\"\"\n        schema = self.schema\n        name = schema.name\n        argument_type = schema.type",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "        self.command_schema = command_schema\n        self.command_schemas = command_schemas\n        self.first_control: ParameterControls | None = None\n\n    def compose(self) -> ComposeResult:\n        path_from_root = iter(reversed(self.command_schema.path_from_root))\n        command_node = next(path_from_root)\n        with VerticalScroll() as vs:\n            vs.can_focus = False\n",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 108,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "                pass\n\n        return should_be_visible\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Takes the schemas for each parameter of the current command, and converts it into a\n        form consisting of Textual widgets.\"\"\"\n        schema = self.schema\n        name = schema.name\n        argument_type = schema.type",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      },
      {
        "lineno": 99,
        "coloffset": 4,
        "linematch": "def compose(self) -> ComposeResult:",
        "context": "        self.command_schema = command_schema\n        self.command_schemas = command_schemas\n        self.first_control: ParameterControls | None = None\n\n    def compose(self) -> ComposeResult:\n        path_from_root = iter(reversed(self.command_schema.path_from_root))\n        command_node = next(path_from_root)\n        with VerticalScroll() as vs:\n            vs.can_focus = False\n",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #626",
        "line": 82,
        "description": [
          "            self.command_data = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -79,7 +79,7 @@\n     class Changed(Message):\n         def __init__(self, command_data: UserCommandData):\n             super().__init__()\n-            self.command_data = command_data\n+            self.command_data = None\n             \"\"\"The new data taken from the form to be converted into a CLI invocation.\"\"\"\n \n     def __init__(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #627",
        "line": 92,
        "description": [
          "        disabled: bool = False,"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -89,7 +89,7 @@\n         name: str | None = None,\n         id: str | None = None,\n         classes: str | None = None,\n-        disabled: bool = False,\n+        disabled: bool = True,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #628",
        "line": 95,
        "description": [
          "        self.command_schema = command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -92,7 +92,7 @@\n         disabled: bool = False,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n-        self.command_schema = command_schema\n+        self.command_schema = None\n         self.command_schemas = command_schemas\n         self.first_control: ParameterControls | None = None\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #629",
        "line": 96,
        "description": [
          "        self.command_schemas = command_schemas"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -93,7 +93,7 @@\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n-        self.command_schemas = command_schemas\n+        self.command_schemas = None\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #630",
        "line": 97,
        "description": [
          "        self.first_control: ParameterControls | None = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -94,7 +94,7 @@\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n         self.command_schemas = command_schemas\n-        self.first_control: ParameterControls | None = None\n+        self.first_control: ParameterControls & None = None\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #631",
        "line": 97,
        "description": [
          "        self.first_control: ParameterControls | None = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -94,7 +94,7 @@\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n         self.command_schemas = command_schemas\n-        self.first_control: ParameterControls | None = None\n+        self.first_control: ParameterControls | None = \"\"\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #632",
        "line": 100,
        "description": [
          "        path_from_root = iter(reversed(self.command_schema.path_from_root))"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -97,7 +97,7 @@\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n-        path_from_root = iter(reversed(self.command_schema.path_from_root))\n+        path_from_root = None\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n             vs.can_focus = False\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #633",
        "line": 101,
        "description": [
          "        command_node = next(path_from_root)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -98,7 +98,7 @@\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n-        command_node = next(path_from_root)\n+        command_node = None\n         with VerticalScroll() as vs:\n             vs.can_focus = False\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #634",
        "line": 103,
        "description": [
          "            vs.can_focus = False"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -100,7 +100,7 @@\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n-            vs.can_focus = False\n+            vs.can_focus = True\n \n             yield Input(\n                 placeholder=\"Search...\",\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #635",
        "line": 103,
        "description": [
          "            vs.can_focus = False"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -100,7 +100,7 @@\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n-            vs.can_focus = False\n+            vs.can_focus = None\n \n             yield Input(\n                 placeholder=\"Search...\",\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #636",
        "line": 106,
        "description": [
          "                placeholder=\"Search...\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -103,7 +103,7 @@\n             vs.can_focus = False\n \n             yield Input(\n-                placeholder=\"Search...\",\n+                placeholder=\"XXSearch...XX\",\n                 classes=\"command-form-filter-input\",\n                 id=\"search\",\n             )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #637",
        "line": 107,
        "description": [
          "                classes=\"command-form-filter-input\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -104,7 +104,7 @@\n \n             yield Input(\n                 placeholder=\"Search...\",\n-                classes=\"command-form-filter-input\",\n+                classes=\"XXcommand-form-filter-inputXX\",\n                 id=\"search\",\n             )\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #638",
        "line": 108,
        "description": [
          "                id=\"search\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -105,7 +105,7 @@\n             yield Input(\n                 placeholder=\"Search...\",\n                 classes=\"command-form-filter-input\",\n-                id=\"search\",\n+                id=\"XXsearchXX\",\n             )\n \n             while command_node is not None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #639",
        "line": 111,
        "description": [
          "            while command_node is not None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -108,7 +108,7 @@\n                 id=\"search\",\n             )\n \n-            while command_node is not None:\n+            while command_node is  None:\n                 options = command_node.options\n                 arguments = command_node.arguments\n                 if options or arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #640",
        "line": 112,
        "description": [
          "                options = command_node.options"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -109,7 +109,7 @@\n             )\n \n             while command_node is not None:\n-                options = command_node.options\n+                options = None\n                 arguments = command_node.arguments\n                 if options or arguments:\n                     with Vertical(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #641",
        "line": 113,
        "description": [
          "                arguments = command_node.arguments"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -110,7 +110,7 @@\n \n             while command_node is not None:\n                 options = command_node.options\n-                arguments = command_node.arguments\n+                arguments = None\n                 if options or arguments:\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #642",
        "line": 114,
        "description": [
          "                if options or arguments:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -111,7 +111,7 @@\n             while command_node is not None:\n                 options = command_node.options\n                 arguments = command_node.arguments\n-                if options or arguments:\n+                if options and arguments:\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #643",
        "line": 116,
        "description": [
          "                        classes=\"command-form-command-group\", id=command_node.key"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -113,7 +113,7 @@\n                 arguments = command_node.arguments\n                 if options or arguments:\n                     with Vertical(\n-                        classes=\"command-form-command-group\", id=command_node.key\n+                        classes=\"XXcommand-form-command-groupXX\", id=command_node.key\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #644",
        "line": 118,
        "description": [
          "                        is_inherited = command_node is not self.command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -115,7 +115,7 @@\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n-                        is_inherited = command_node is not self.command_schema\n+                        is_inherited = command_node is  self.command_schema\n                         v.border_title = (\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #645",
        "line": 118,
        "description": [
          "                        is_inherited = command_node is not self.command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -115,7 +115,7 @@\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n-                        is_inherited = command_node is not self.command_schema\n+                        is_inherited = None\n                         v.border_title = (\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #646",
        "line": 120,
        "description": [
          "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -117,7 +117,7 @@\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n+                            f\"{'XX\u21aa XX' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #647",
        "line": 120,
        "description": [
          "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -117,7 +117,7 @@\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n+                            f\"{'\u21aa ' if is_inherited else 'XXXX'}{command_node.name}\"\n                         )\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #648",
        "line": 120,
        "description": [
          "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -117,7 +117,7 @@\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n+                            f\"XX{'\u21aa ' if is_inherited else ''}{command_node.name}XX\"\n                         )\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #649",
        "line": 121,
        "description": [
          "                        )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -116,9 +116,7 @@\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n-                        v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n-                        )\n+                        v.border_title = None\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n                         if arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #650",
        "line": 123,
        "description": [
          "                            v.border_title += \" [dim not bold](inherited)\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -120,7 +120,7 @@\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n-                            v.border_title += \" [dim not bold](inherited)\"\n+                            v.border_title = \" [dim not bold](inherited)\"\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #651",
        "line": 123,
        "description": [
          "                            v.border_title += \" [dim not bold](inherited)\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -120,7 +120,7 @@\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n-                            v.border_title += \" [dim not bold](inherited)\"\n+                            v.border_title -= \" [dim not bold](inherited)\"\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #652",
        "line": 123,
        "description": [
          "                            v.border_title += \" [dim not bold](inherited)\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -120,7 +120,7 @@\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n-                            v.border_title += \" [dim not bold](inherited)\"\n+                            v.border_title += \"XX [dim not bold](inherited)XX\"\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #653",
        "line": 125,
        "description": [
          "                            yield Label(f\"Arguments\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -122,7 +122,7 @@\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n                         if arguments:\n-                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n+                            yield Label(f\"XXArgumentsXX\", classes=\"command-form-heading\")\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #654",
        "line": 125,
        "description": [
          "                            yield Label(f\"Arguments\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -122,7 +122,7 @@\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n                         if arguments:\n-                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n+                            yield Label(f\"Arguments\", classes=\"XXcommand-form-headingXX\")\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #655",
        "line": 127,
        "description": [
          "                                controls = ParameterControls(argument, id=argument.key)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -124,7 +124,7 @@\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n-                                controls = ParameterControls(argument, id=argument.key)\n+                                controls = None\n                                 if self.first_control is None:\n                                     self.first_control = controls\n                                 yield controls\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #656",
        "line": 128,
        "description": [
          "                                if self.first_control is None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -125,7 +125,7 @@\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n-                                if self.first_control is None:\n+                                if self.first_control is not None:\n                                     self.first_control = controls\n                                 yield controls\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #657",
        "line": 129,
        "description": [
          "                                    self.first_control = controls"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -126,7 +126,7 @@\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n                                 if self.first_control is None:\n-                                    self.first_control = controls\n+                                    self.first_control = None\n                                 yield controls\n \n                         if options:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "_update_execution_string_preview",
    "function_scope": "184-197",
    "patterns": [
      {
        "lineno": 188,
        "coloffset": 8,
        "linematch": "if self.command_data is not None:",
        "context": "    def _update_execution_string_preview(\n        self, command_schema: CommandSchema, command_data: UserCommandData\n    ) -> None:\n        \"\"\"Update the preview box showing the command string to be executed\"\"\"\n        if self.command_data is not None:\n            command_name_syntax_style = self.get_component_rich_style(\n                \"command-name-syntax\"\n            )\n            prefix = Text(f\"{self.click_app_name} \", command_name_syntax_style)\n            new_value = command_data.to_cli_string(include_root_command=False)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 184,
        "coloffset": 4,
        "linematch": "def _update_execution_string_preview(",
        "context": "        description_text = description_text.lstrip()\n        description_text = f\"[b]{node.label if self.is_grouped_cli else self.click_app_name}[/]\\n{description_text}\"\n        description_box.update(description_text)\n\n    def _update_execution_string_preview(\n        self, command_schema: CommandSchema, command_data: UserCommandData\n    ) -> None:\n        \"\"\"Update the preview box showing the command string to be executed\"\"\"\n        if self.command_data is not None:\n            command_name_syntax_style = self.get_component_rich_style(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 184,
        "coloffset": 4,
        "linematch": "def _update_execution_string_preview(",
        "context": "        description_text = description_text.lstrip()\n        description_text = f\"[b]{node.label if self.is_grouped_cli else self.click_app_name}[/]\\n{description_text}\"\n        description_box.update(description_text)\n\n    def _update_execution_string_preview(\n        self, command_schema: CommandSchema, command_data: UserCommandData\n    ) -> None:\n        \"\"\"Update the preview box showing the command string to be executed\"\"\"\n        if self.command_data is not None:\n            command_name_syntax_style = self.get_component_rich_style(",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 187,
        "coloffset": 8,
        "linematch": "\"\"\"Update the preview box showing the command string to be executed\"\"\"",
        "context": "\n    def _update_execution_string_preview(\n        self, command_schema: CommandSchema, command_data: UserCommandData\n    ) -> None:\n        \"\"\"Update the preview box showing the command string to be executed\"\"\"\n        if self.command_data is not None:\n            command_name_syntax_style = self.get_component_rich_style(\n                \"command-name-syntax\"\n            )\n            prefix = Text(f\"{self.click_app_name} \", command_name_syntax_style)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 188,
        "coloffset": 8,
        "linematch": "if self.command_data is not None:",
        "context": "    def _update_execution_string_preview(\n        self, command_schema: CommandSchema, command_data: UserCommandData\n    ) -> None:\n        \"\"\"Update the preview box showing the command string to be executed\"\"\"\n        if self.command_data is not None:\n            command_name_syntax_style = self.get_component_rich_style(\n                \"command-name-syntax\"\n            )\n            prefix = Text(f\"{self.click_app_name} \", command_name_syntax_style)\n            new_value = command_data.to_cli_string(include_root_command=False)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #675",
        "line": 186,
        "description": [
          "                    f\"#{argument.key}\", ParameterControls"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -183,7 +183,7 @@\n             argument_datas = []\n             for argument in command.arguments:\n                 form_control_widget = self.query_one(\n-                    f\"#{argument.key}\", ParameterControls\n+                    f\"XX#{argument.key}XX\", ParameterControls\n                 )\n                 value = form_control_widget.get_values()\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #676",
        "line": 187,
        "description": [
          "                )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -182,9 +182,7 @@\n             # Now do the same for the arguments\n             argument_datas = []\n             for argument in command.arguments:\n-                form_control_widget = self.query_one(\n-                    f\"#{argument.key}\", ParameterControls\n-                )\n+                form_control_widget = None\n                 value = form_control_widget.get_values()\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #677",
        "line": 188,
        "description": [
          "                value = form_control_widget.get_values()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -185,7 +185,7 @@\n                 form_control_widget = self.query_one(\n                     f\"#{argument.key}\", ParameterControls\n                 )\n-                value = form_control_widget.get_values()\n+                value = None\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #678",
        "line": 192,
        "description": [
          "                    argument_data = UserArgumentData(argument.name, v, argument)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -189,7 +189,7 @@\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n-                    argument_data = UserArgumentData(argument.name, v, argument)\n+                    argument_data = None\n                     argument_datas.append(argument_data)\n \n             assert all(isinstance(option.value, tuple) for option in option_datas)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "__init__",
    "function_scope": "218-234",
    "patterns": [
      {
        "lineno": 230,
        "coloffset": 8,
        "linematch": "if app_name is None and click_context is not None:",
        "context": "        self.cli = cli\n        self.post_run_command: list[str] = []\n        self.is_grouped_cli = isinstance(cli, click.Group)\n        self.execute_on_exit = False\n        if app_name is None and click_context is not None:\n            self.app_name = detect_run_string()\n        else:\n            self.app_name = app_name\n        self.command_name = command_name\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 230,
        "coloffset": 11,
        "linematch": "if app_name is None and click_context is not None:",
        "context": "        self.cli = cli\n        self.post_run_command: list[str] = []\n        self.is_grouped_cli = isinstance(cli, click.Group)\n        self.execute_on_exit = False\n        if app_name is None and click_context is not None:\n            self.app_name = detect_run_string()\n        else:\n            self.app_name = app_name\n        self.command_name = command_name\n",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 218,
        "coloffset": 4,
        "linematch": "def __init__(",
        "context": "\nclass Trogon(App):\n    CSS_PATH = Path(__file__).parent / \"trogon.scss\"\n\n    def __init__(\n        self,\n        cli: click.Group,\n        app_name: str | None = None,\n        command_name: str = \"tui\",\n        click_context: click.Context | None = None,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 58,
        "coloffset": 8,
        "linematch": "def __init__(self, selected: list[Checkbox]):",
        "context": "        self.defaults = defaults\n        self.selected = defaults\n\n    class Changed(Message):\n        def __init__(self, selected: list[Checkbox]):\n            super().__init__()\n            self.selected = selected\n\n    def compose(self) -> ComposeResult:\n        with NonFocusableVerticalScroll():",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "def __init__(self, label: TextType, cli_metadata: dict[CommandName, CommandSchema], command_name: str):",
        "context": "\nclass CommandTree(Tree[CommandSchema]):\n    COMPONENT_CLASSES = {\"group\"}\n\n    def __init__(self, label: TextType, cli_metadata: dict[CommandName, CommandSchema], command_name: str):\n        super().__init__(label)\n        self.show_root = False\n        self.guide_depth = 2\n        self.show_guides = False\n        self.cli_metadata = cli_metadata",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 95,
        "coloffset": 4,
        "linematch": "def __init__(self) -> None:",
        "context": "        border: thick $primary 50%;\n    }\n    \"\"\"\n\n    def __init__(self) -> None:\n        title = f\"About Trogon\"\n        message = Text.from_markup(\n            f\"Built with [@click=app.visit('https://github.com/textualize/textual')]Textual[/] \"\n            f\"by [@click=app.visit('https://textualize.io')]Textualize[/].\\n\\n\"\n            f\"[@click=app.visit('https://github.com/textualize/{constants.PACKAGE_NAME}')]\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "def __init__(",
        "context": "        return False\n\n\nclass ParameterControls(Widget):\n    def __init__(\n        self,\n        schema: ArgumentSchema | OptionSchema,\n        name: str | None = None,\n        id: str | None = None,\n        classes: str | None = None,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 85,
        "coloffset": 4,
        "linematch": "def __init__(",
        "context": "            super().__init__()\n            self.command_data = command_data\n            \"\"\"The new data taken from the form to be converted into a CLI invocation.\"\"\"\n\n    def __init__(\n        self,\n        command_schema: CommandSchema | None = None,\n        command_schemas: dict[CommandName, CommandSchema] | None = None,\n        name: str | None = None,\n        id: str | None = None,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "def __init__(",
        "context": "    COMPONENT_CLASSES = {\"title\", \"subtitle\"}\n\n    BINDINGS = [Binding(\"q,escape\", \"close_modal\", \"Close Modal\")]\n\n    def __init__(\n        self,\n        command_schema: CommandSchema,\n        name: str | None = None,\n        id: str | None = None,\n        classes: str | None = None,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 218,
        "coloffset": 4,
        "linematch": "def __init__(",
        "context": "\nclass Trogon(App):\n    CSS_PATH = Path(__file__).parent / \"trogon.scss\"\n\n    def __init__(\n        self,\n        cli: click.Group,\n        app_name: str | None = None,\n        command_name: str = \"tui\",\n        click_context: click.Context | None = None,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "def __init__(",
        "context": "        return False\n\n\nclass ParameterControls(Widget):\n    def __init__(\n        self,\n        schema: ArgumentSchema | OptionSchema,\n        name: str | None = None,\n        id: str | None = None,\n        classes: str | None = None,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 225,
        "coloffset": 8,
        "linematch": "super().__init__()",
        "context": "        app_name: str | None = None,\n        command_name: str = \"tui\",\n        click_context: click.Context | None = None,\n    ) -> None:\n        super().__init__()\n        self.cli = cli\n        self.post_run_command: list[str] = []\n        self.is_grouped_cli = isinstance(cli, click.Group)\n        self.execute_on_exit = False\n        if app_name is None and click_context is not None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 226,
        "coloffset": 8,
        "linematch": "self.cli = cli",
        "context": "        command_name: str = \"tui\",\n        click_context: click.Context | None = None,\n    ) -> None:\n        super().__init__()\n        self.cli = cli\n        self.post_run_command: list[str] = []\n        self.is_grouped_cli = isinstance(cli, click.Group)\n        self.execute_on_exit = False\n        if app_name is None and click_context is not None:\n            self.app_name = detect_run_string()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 227,
        "coloffset": 8,
        "linematch": "self.post_run_command: list[str] = []",
        "context": "        click_context: click.Context | None = None,\n    ) -> None:\n        super().__init__()\n        self.cli = cli\n        self.post_run_command: list[str] = []\n        self.is_grouped_cli = isinstance(cli, click.Group)\n        self.execute_on_exit = False\n        if app_name is None and click_context is not None:\n            self.app_name = detect_run_string()\n        else:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 228,
        "coloffset": 8,
        "linematch": "self.is_grouped_cli = isinstance(cli, click.Group)",
        "context": "    ) -> None:\n        super().__init__()\n        self.cli = cli\n        self.post_run_command: list[str] = []\n        self.is_grouped_cli = isinstance(cli, click.Group)\n        self.execute_on_exit = False\n        if app_name is None and click_context is not None:\n            self.app_name = detect_run_string()\n        else:\n            self.app_name = app_name",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 229,
        "coloffset": 8,
        "linematch": "self.execute_on_exit = False",
        "context": "        super().__init__()\n        self.cli = cli\n        self.post_run_command: list[str] = []\n        self.is_grouped_cli = isinstance(cli, click.Group)\n        self.execute_on_exit = False\n        if app_name is None and click_context is not None:\n            self.app_name = detect_run_string()\n        else:\n            self.app_name = app_name\n        self.command_name = command_name",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 230,
        "coloffset": 8,
        "linematch": "if app_name is None and click_context is not None:",
        "context": "        self.cli = cli\n        self.post_run_command: list[str] = []\n        self.is_grouped_cli = isinstance(cli, click.Group)\n        self.execute_on_exit = False\n        if app_name is None and click_context is not None:\n            self.app_name = detect_run_string()\n        else:\n            self.app_name = app_name\n        self.command_name = command_name\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 234,
        "coloffset": 8,
        "linematch": "self.command_name = command_name",
        "context": "        if app_name is None and click_context is not None:\n            self.app_name = detect_run_string()\n        else:\n            self.app_name = app_name\n        self.command_name = command_name\n\n    def on_mount(self):\n        self.push_screen(CommandBuilder(self.cli, self.app_name, self.command_name))\n\n    @on(Button.Pressed, \"#home-exec-button\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 12,
        "linematch": "super().__init__()",
        "context": "        self.selected = defaults\n\n    class Changed(Message):\n        def __init__(self, selected: list[Checkbox]):\n            super().__init__()\n            self.selected = selected\n\n    def compose(self) -> ComposeResult:\n        with NonFocusableVerticalScroll():\n            for option in self.options:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 60,
        "coloffset": 12,
        "linematch": "self.selected = selected",
        "context": "\n    class Changed(Message):\n        def __init__(self, selected: list[Checkbox]):\n            super().__init__()\n            self.selected = selected\n\n    def compose(self) -> ComposeResult:\n        with NonFocusableVerticalScroll():\n            for option in self.options:\n                yield Checkbox(option, value=(option,) in self.defaults)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 8,
        "linematch": "super().__init__(label)",
        "context": "class CommandTree(Tree[CommandSchema]):\n    COMPONENT_CLASSES = {\"group\"}\n\n    def __init__(self, label: TextType, cli_metadata: dict[CommandName, CommandSchema], command_name: str):\n        super().__init__(label)\n        self.show_root = False\n        self.guide_depth = 2\n        self.show_guides = False\n        self.cli_metadata = cli_metadata\n        self.command_name = command_name",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 8,
        "linematch": "self.show_root = False",
        "context": "    COMPONENT_CLASSES = {\"group\"}\n\n    def __init__(self, label: TextType, cli_metadata: dict[CommandName, CommandSchema], command_name: str):\n        super().__init__(label)\n        self.show_root = False\n        self.guide_depth = 2\n        self.show_guides = False\n        self.cli_metadata = cli_metadata\n        self.command_name = command_name\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 8,
        "linematch": "self.guide_depth = 2",
        "context": "\n    def __init__(self, label: TextType, cli_metadata: dict[CommandName, CommandSchema], command_name: str):\n        super().__init__(label)\n        self.show_root = False\n        self.guide_depth = 2\n        self.show_guides = False\n        self.cli_metadata = cli_metadata\n        self.command_name = command_name\n\n    def render_label(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 18,
        "coloffset": 8,
        "linematch": "self.show_guides = False",
        "context": "    def __init__(self, label: TextType, cli_metadata: dict[CommandName, CommandSchema], command_name: str):\n        super().__init__(label)\n        self.show_root = False\n        self.guide_depth = 2\n        self.show_guides = False\n        self.cli_metadata = cli_metadata\n        self.command_name = command_name\n\n    def render_label(\n        self, node: TreeNode[TreeDataType], base_style: Style, style: Style",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 8,
        "linematch": "self.cli_metadata = cli_metadata",
        "context": "        super().__init__(label)\n        self.show_root = False\n        self.guide_depth = 2\n        self.show_guides = False\n        self.cli_metadata = cli_metadata\n        self.command_name = command_name\n\n    def render_label(\n        self, node: TreeNode[TreeDataType], base_style: Style, style: Style\n    ) -> Text:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 8,
        "linematch": "self.command_name = command_name",
        "context": "        self.show_root = False\n        self.guide_depth = 2\n        self.show_guides = False\n        self.cli_metadata = cli_metadata\n        self.command_name = command_name\n\n    def render_label(\n        self, node: TreeNode[TreeDataType], base_style: Style, style: Style\n    ) -> Text:\n        label = node._label.copy()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 8,
        "linematch": "title = f\"About Trogon\"",
        "context": "    }\n    \"\"\"\n\n    def __init__(self) -> None:\n        title = f\"About Trogon\"\n        message = Text.from_markup(\n            f\"Built with [@click=app.visit('https://github.com/textualize/textual')]Textual[/] \"\n            f\"by [@click=app.visit('https://textualize.io')]Textualize[/].\\n\\n\"\n            f\"[@click=app.visit('https://github.com/textualize/{constants.PACKAGE_NAME}')]\"\n            f\"https://github.com/textualize/{constants.PACKAGE_NAME}[/]\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 97,
        "coloffset": 8,
        "linematch": "message = Text.from_markup(",
        "context": "    \"\"\"\n\n    def __init__(self) -> None:\n        title = f\"About Trogon\"\n        message = Text.from_markup(\n            f\"Built with [@click=app.visit('https://github.com/textualize/textual')]Textual[/] \"\n            f\"by [@click=app.visit('https://textualize.io')]Textualize[/].\\n\\n\"\n            f\"[@click=app.visit('https://github.com/textualize/{constants.PACKAGE_NAME}')]\"\n            f\"https://github.com/textualize/{constants.PACKAGE_NAME}[/]\",\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 103,
        "coloffset": 8,
        "linematch": "super().__init__(title, message)",
        "context": "            f\"by [@click=app.visit('https://textualize.io')]Textualize[/].\\n\\n\"\n            f\"[@click=app.visit('https://github.com/textualize/{constants.PACKAGE_NAME}')]\"\n            f\"https://github.com/textualize/{constants.PACKAGE_NAME}[/]\",\n        )\n        super().__init__(title, message)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 8,
        "linematch": "super().__init__(name=name, id=id, classes=classes, disabled=disabled)",
        "context": "        id: str | None = None,\n        classes: str | None = None,\n        disabled: bool = False,\n    ) -> None:\n        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.schema = schema\n        self.first_control: Widget | None = None\n\n    def apply_filter(self, filter_query: str) -> bool:\n        \"\"\"Show or hide this ParameterControls depending on whether it matches the filter query or not.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 60,
        "coloffset": 8,
        "linematch": "self.schema = schema",
        "context": "        classes: str | None = None,\n        disabled: bool = False,\n    ) -> None:\n        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.schema = schema\n        self.first_control: Widget | None = None\n\n    def apply_filter(self, filter_query: str) -> bool:\n        \"\"\"Show or hide this ParameterControls depending on whether it matches the filter query or not.\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 61,
        "coloffset": 8,
        "linematch": "self.first_control: Widget | None = None",
        "context": "        disabled: bool = False,\n    ) -> None:\n        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.schema = schema\n        self.first_control: Widget | None = None\n\n    def apply_filter(self, filter_query: str) -> bool:\n        \"\"\"Show or hide this ParameterControls depending on whether it matches the filter query or not.\n\n        Args:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 94,
        "coloffset": 8,
        "linematch": "super().__init__(name=name, id=id, classes=classes, disabled=disabled)",
        "context": "        id: str | None = None,\n        classes: str | None = None,\n        disabled: bool = False,\n    ):\n        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.command_schema = command_schema\n        self.command_schemas = command_schemas\n        self.first_control: ParameterControls | None = None\n\n    def compose(self) -> ComposeResult:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 95,
        "coloffset": 8,
        "linematch": "self.command_schema = command_schema",
        "context": "        classes: str | None = None,\n        disabled: bool = False,\n    ):\n        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.command_schema = command_schema\n        self.command_schemas = command_schemas\n        self.first_control: ParameterControls | None = None\n\n    def compose(self) -> ComposeResult:\n        path_from_root = iter(reversed(self.command_schema.path_from_root))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 96,
        "coloffset": 8,
        "linematch": "self.command_schemas = command_schemas",
        "context": "        disabled: bool = False,\n    ):\n        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.command_schema = command_schema\n        self.command_schemas = command_schemas\n        self.first_control: ParameterControls | None = None\n\n    def compose(self) -> ComposeResult:\n        path_from_root = iter(reversed(self.command_schema.path_from_root))\n        command_node = next(path_from_root)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 97,
        "coloffset": 8,
        "linematch": "self.first_control: ParameterControls | None = None",
        "context": "    ):\n        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.command_schema = command_schema\n        self.command_schemas = command_schemas\n        self.first_control: ParameterControls | None = None\n\n    def compose(self) -> ComposeResult:\n        path_from_root = iter(reversed(self.command_schema.path_from_root))\n        command_node = next(path_from_root)\n        with VerticalScroll() as vs:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 65,
        "coloffset": 8,
        "linematch": "super().__init__(",
        "context": "        name: str | None = None,\n        id: str | None = None,\n        classes: str | None = None,\n    ) -> None:\n        super().__init__(\n            name=name,\n            id=id,\n            classes=classes,\n        )\n        self.command_schema = command_schema",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 8,
        "linematch": "self.command_schema = command_schema",
        "context": "            name=name,\n            id=id,\n            classes=classes,\n        )\n        self.command_schema = command_schema\n\n    def compose(self) -> ComposeResult:\n        schema = self.command_schema\n        path = schema.path_from_root\n        path_string = \" \u279c \".join(command.name for command in path)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #688",
        "line": 218,
        "description": [
          "        filter_query = event.value"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -215,7 +215,7 @@\n \n     @on(Input.Changed, \".command-form-filter-input\")\n     def apply_filter(self, event: Input.Changed) -> None:\n-        filter_query = event.value\n+        filter_query = None\n         all_controls = self.query(ParameterControls)\n         for control in all_controls:\n             filter_query = filter_query.casefold()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #689",
        "line": 219,
        "description": [
          "        all_controls = self.query(ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -216,7 +216,7 @@\n     @on(Input.Changed, \".command-form-filter-input\")\n     def apply_filter(self, event: Input.Changed) -> None:\n         filter_query = event.value\n-        all_controls = self.query(ParameterControls)\n+        all_controls = None\n         for control in all_controls:\n             filter_query = filter_query.casefold()\n             control.apply_filter(filter_query)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #690",
        "line": 221,
        "description": [
          "            filter_query = filter_query.casefold()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -218,6 +218,6 @@\n         filter_query = event.value\n         all_controls = self.query(ParameterControls)\n         for control in all_controls:\n-            filter_query = filter_query.casefold()\n+            filter_query = None\n             control.apply_filter(filter_query)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "run",
    "function_scope": "244-264",
    "patterns": [
      {
        "lineno": 254,
        "coloffset": 12,
        "linematch": "if self.post_run_command:",
        "context": "    ) -> None:\n        try:\n            super().run(headless=headless, size=size, auto_pilot=auto_pilot)\n        finally:\n            if self.post_run_command:\n                console = Console()\n                if self.post_run_command and self.execute_on_exit:\n                    console.print(\n                        f\"Running [b cyan]{self.app_name} {' '.join(shlex.quote(s) for s in self.post_run_command)}[/]\"\n                    )",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 256,
        "coloffset": 16,
        "linematch": "if self.post_run_command and self.execute_on_exit:",
        "context": "            super().run(headless=headless, size=size, auto_pilot=auto_pilot)\n        finally:\n            if self.post_run_command:\n                console = Console()\n                if self.post_run_command and self.execute_on_exit:\n                    console.print(\n                        f\"Running [b cyan]{self.app_name} {' '.join(shlex.quote(s) for s in self.post_run_command)}[/]\"\n                    )\n\n                    split_app_name = shlex.split(self.app_name)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 256,
        "coloffset": 16,
        "linematch": "if self.post_run_command and self.execute_on_exit:",
        "context": "            super().run(headless=headless, size=size, auto_pilot=auto_pilot)\n        finally:\n            if self.post_run_command:\n                console = Console()\n                if self.post_run_command and self.execute_on_exit:\n                    console.print(\n                        f\"Running [b cyan]{self.app_name} {' '.join(shlex.quote(s) for s in self.post_run_command)}[/]\"\n                    )\n\n                    split_app_name = shlex.split(self.app_name)",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 244,
        "coloffset": 4,
        "linematch": "def run(",
        "context": "    def on_button_pressed(self):\n        self.execute_on_exit = True\n        self.exit()\n\n    def run(\n        self,\n        *,\n        headless: bool = False,\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 244,
        "coloffset": 4,
        "linematch": "def run(",
        "context": "    def on_button_pressed(self):\n        self.execute_on_exit = True\n        self.exit()\n\n    def run(\n        self,\n        *,\n        headless: bool = False,\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 256,
        "coloffset": 16,
        "linematch": "if self.post_run_command and self.execute_on_exit:",
        "context": "            super().run(headless=headless, size=size, auto_pilot=auto_pilot)\n        finally:\n            if self.post_run_command:\n                console = Console()\n                if self.post_run_command and self.execute_on_exit:\n                    console.print(\n                        f\"Running [b cyan]{self.app_name} {' '.join(shlex.quote(s) for s in self.post_run_command)}[/]\"\n                    )\n\n                    split_app_name = shlex.split(self.app_name)",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 244,
        "coloffset": 4,
        "linematch": "def run(",
        "context": "    def on_button_pressed(self):\n        self.execute_on_exit = True\n        self.exit()\n\n    def run(\n        self,\n        *,\n        headless: bool = False,\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 251,
        "coloffset": 8,
        "linematch": "try:",
        "context": "        headless: bool = False,\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,\n    ) -> None:\n        try:\n            super().run(headless=headless, size=size, auto_pilot=auto_pilot)\n        finally:\n            if self.post_run_command:\n                console = Console()\n                if self.post_run_command and self.execute_on_exit:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "introspect_click_app",
    "function_scope": "95-188",
    "patterns": [
      {
        "lineno": 174,
        "coloffset": 4,
        "linematch": "if isinstance(app, click.Group):",
        "context": "\n    data: dict[CommandName, CommandSchema] = {}\n\n    # Special case for the root group\n    if isinstance(app, click.Group):\n        root_cmd_name = CommandName(\"root\")\n        data[root_cmd_name] = process_command(root_cmd_name, app)\n        app = data[root_cmd_name]\n\n    if isinstance(app, click.Group):",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 179,
        "coloffset": 4,
        "linematch": "if isinstance(app, click.Group):",
        "context": "        root_cmd_name = CommandName(\"root\")\n        data[root_cmd_name] = process_command(root_cmd_name, app)\n        app = data[root_cmd_name]\n\n    if isinstance(app, click.Group):\n        for cmd_name, cmd_obj in app.commands.items():\n            data[CommandName(cmd_name)] = process_command(\n                CommandName(cmd_name), cmd_obj\n            )\n    elif isinstance(app, click.Command):",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 163,
        "coloffset": 8,
        "linematch": "if isinstance(cmd_obj, click.core.Group):",
        "context": "                if isinstance(param.type, click.Choice):\n                    argument_data.choices = param.type.choices\n                cmd_data.arguments.append(argument_data)\n\n        if isinstance(cmd_obj, click.core.Group):\n            for subcmd_name, subcmd_obj in cmd_obj.commands.items():\n                cmd_data.subcommands[CommandName(subcmd_name)] = process_command(\n                    CommandName(subcmd_name), subcmd_obj, parent=cmd_data\n                )\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 131,
        "coloffset": 12,
        "linematch": "if isinstance(param, (click.Option, click.core.Group)):",
        "context": "        )\n\n        for param in cmd_obj.params:\n            default = MultiValueParamData.process_cli_option(param.default)\n            if isinstance(param, (click.Option, click.core.Group)):\n                option_data = OptionSchema(\n                    name=param.opts,\n                    type=param.type,\n                    is_flag=param.is_flag,\n                    is_boolean_flag=param.is_bool_flag,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 147,
        "coloffset": 16,
        "linematch": "if isinstance(param.type, click.Choice):",
        "context": "                    help=param.help,\n                    multiple=param.multiple,\n                    nargs=param.nargs,\n                )\n                if isinstance(param.type, click.Choice):\n                    option_data.choices = param.type.choices\n                cmd_data.options.append(option_data)\n            elif isinstance(param, click.Argument):\n                argument_data = ArgumentSchema(\n                    name=param.name,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 150,
        "coloffset": 12,
        "linematch": "elif isinstance(param, click.Argument):",
        "context": "                )\n                if isinstance(param.type, click.Choice):\n                    option_data.choices = param.type.choices\n                cmd_data.options.append(option_data)\n            elif isinstance(param, click.Argument):\n                argument_data = ArgumentSchema(\n                    name=param.name,\n                    type=param.type,\n                    required=param.required,\n                    multiple=param.multiple,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 159,
        "coloffset": 16,
        "linematch": "if isinstance(param.type, click.Choice):",
        "context": "                    multiple=param.multiple,\n                    default=default,\n                    nargs=param.nargs,\n                )\n                if isinstance(param.type, click.Choice):\n                    argument_data.choices = param.type.choices\n                cmd_data.arguments.append(argument_data)\n\n        if isinstance(cmd_obj, click.core.Group):\n            for subcmd_name, subcmd_obj in cmd_obj.commands.items():",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 184,
        "coloffset": 4,
        "linematch": "elif isinstance(app, click.Command):",
        "context": "        for cmd_name, cmd_obj in app.commands.items():\n            data[CommandName(cmd_name)] = process_command(\n                CommandName(cmd_name), cmd_obj\n            )\n    elif isinstance(app, click.Command):\n        cmd_name = CommandName(app.name)\n        data[cmd_name] = process_command(cmd_name, app)\n\n    return data\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 147,
        "coloffset": 16,
        "linematch": "if isinstance(param.type, click.Choice):",
        "context": "                    help=param.help,\n                    multiple=param.multiple,\n                    nargs=param.nargs,\n                )\n                if isinstance(param.type, click.Choice):\n                    option_data.choices = param.type.choices\n                cmd_data.options.append(option_data)\n            elif isinstance(param, click.Argument):\n                argument_data = ArgumentSchema(\n                    name=param.name,",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 159,
        "coloffset": 16,
        "linematch": "if isinstance(param.type, click.Choice):",
        "context": "                    multiple=param.multiple,\n                    default=default,\n                    nargs=param.nargs,\n                )\n                if isinstance(param.type, click.Choice):\n                    argument_data.choices = param.type.choices\n                cmd_data.arguments.append(argument_data)\n\n        if isinstance(cmd_obj, click.core.Group):\n            for subcmd_name, subcmd_obj in cmd_obj.commands.items():",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 95,
        "coloffset": 0,
        "linematch": "def introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:",
        "context": "            path.append(node)\n        return list(reversed(path))\n\n\ndef introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:\n    \"\"\"\n    Introspect a Click application and build a data structure containing\n    information about all commands, options, arguments, and subcommands,\n    including the docstrings and command function references.\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "def process_command(",
        "context": "        structure. The structure is defined by the CommandData TypedDict and its related\n        TypedDicts (OptionData and ArgumentData).\n    \"\"\"\n\n    def process_command(\n        cmd_name: CommandName, cmd_obj: click.Command, parent=None\n    ) -> CommandSchema:\n        cmd_data = CommandSchema(\n            name=cmd_name,\n            docstring=cmd_obj.help,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 95,
        "coloffset": 0,
        "linematch": "def introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:",
        "context": "            path.append(node)\n        return list(reversed(path))\n\n\ndef introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:\n    \"\"\"\n    Introspect a Click application and build a data structure containing\n    information about all commands, options, arguments, and subcommands,\n    including the docstrings and command function references.\n",
        "pattern": ".//FunctionDef//FunctionDef/ancestor::*",
        "check_id": "F001",
        "check_name": "nested-depth"
      },
      {
        "lineno": 179,
        "coloffset": 4,
        "linematch": "if isinstance(app, click.Group):",
        "context": "        root_cmd_name = CommandName(\"root\")\n        data[root_cmd_name] = process_command(root_cmd_name, app)\n        app = data[root_cmd_name]\n\n    if isinstance(app, click.Group):\n        for cmd_name, cmd_obj in app.commands.items():\n            data[CommandName(cmd_name)] = process_command(\n                CommandName(cmd_name), cmd_obj\n            )\n    elif isinstance(app, click.Command):",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 184,
        "coloffset": 4,
        "linematch": "elif isinstance(app, click.Command):",
        "context": "        for cmd_name, cmd_obj in app.commands.items():\n            data[CommandName(cmd_name)] = process_command(\n                CommandName(cmd_name), cmd_obj\n            )\n    elif isinstance(app, click.Command):\n        cmd_name = CommandName(app.name)\n        data[cmd_name] = process_command(cmd_name, app)\n\n    return data\n",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 147,
        "coloffset": 16,
        "linematch": "if isinstance(param.type, click.Choice):",
        "context": "                    help=param.help,\n                    multiple=param.multiple,\n                    nargs=param.nargs,\n                )\n                if isinstance(param.type, click.Choice):\n                    option_data.choices = param.type.choices\n                cmd_data.options.append(option_data)\n            elif isinstance(param, click.Argument):\n                argument_data = ArgumentSchema(\n                    name=param.name,",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 150,
        "coloffset": 12,
        "linematch": "elif isinstance(param, click.Argument):",
        "context": "                )\n                if isinstance(param.type, click.Choice):\n                    option_data.choices = param.type.choices\n                cmd_data.options.append(option_data)\n            elif isinstance(param, click.Argument):\n                argument_data = ArgumentSchema(\n                    name=param.name,\n                    type=param.type,\n                    required=param.required,\n                    multiple=param.multiple,",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 159,
        "coloffset": 16,
        "linematch": "if isinstance(param.type, click.Choice):",
        "context": "                    multiple=param.multiple,\n                    default=default,\n                    nargs=param.nargs,\n                )\n                if isinstance(param.type, click.Choice):\n                    argument_data.choices = param.type.choices\n                cmd_data.arguments.append(argument_data)\n\n        if isinstance(cmd_obj, click.core.Group):\n            for subcmd_name, subcmd_obj in cmd_obj.commands.items():",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 95,
        "coloffset": 0,
        "linematch": "def introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:",
        "context": "            path.append(node)\n        return list(reversed(path))\n\n\ndef introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:\n    \"\"\"\n    Introspect a Click application and build a data structure containing\n    information about all commands, options, arguments, and subcommands,\n    including the docstrings and command function references.\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "def process_command(",
        "context": "        structure. The structure is defined by the CommandData TypedDict and its related\n        TypedDicts (OptionData and ArgumentData).\n    \"\"\"\n\n    def process_command(\n        cmd_name: CommandName, cmd_obj: click.Command, parent=None\n    ) -> CommandSchema:\n        cmd_data = CommandSchema(\n            name=cmd_name,\n            docstring=cmd_obj.help,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 96,
        "coloffset": 4,
        "linematch": "\"\"\"",
        "context": "        return list(reversed(path))\n\n\ndef introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:\n    \"\"\"\n    Introspect a Click application and build a data structure containing\n    information about all commands, options, arguments, and subcommands,\n    including the docstrings and command function references.\n\n    This function recursively processes each command and its subcommands",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "def process_command(",
        "context": "        structure. The structure is defined by the CommandData TypedDict and its related\n        TypedDicts (OptionData and ArgumentData).\n    \"\"\"\n\n    def process_command(\n        cmd_name: CommandName, cmd_obj: click.Command, parent=None\n    ) -> CommandSchema:\n        cmd_data = CommandSchema(\n            name=cmd_name,\n            docstring=cmd_obj.help,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 118,
        "coloffset": 8,
        "linematch": "cmd_data = CommandSchema(",
        "context": "\n    def process_command(\n        cmd_name: CommandName, cmd_obj: click.Command, parent=None\n    ) -> CommandSchema:\n        cmd_data = CommandSchema(\n            name=cmd_name,\n            docstring=cmd_obj.help,\n            function=cmd_obj.callback,\n            options=[],\n            arguments=[],",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 129,
        "coloffset": 8,
        "linematch": "for param in cmd_obj.params:",
        "context": "            parent=parent,\n            is_group=isinstance(cmd_obj, click.Group),\n        )\n\n        for param in cmd_obj.params:\n            default = MultiValueParamData.process_cli_option(param.default)\n            if isinstance(param, (click.Option, click.core.Group)):\n                option_data = OptionSchema(\n                    name=param.opts,\n                    type=param.type,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 163,
        "coloffset": 8,
        "linematch": "if isinstance(cmd_obj, click.core.Group):",
        "context": "                if isinstance(param.type, click.Choice):\n                    argument_data.choices = param.type.choices\n                cmd_data.arguments.append(argument_data)\n\n        if isinstance(cmd_obj, click.core.Group):\n            for subcmd_name, subcmd_obj in cmd_obj.commands.items():\n                cmd_data.subcommands[CommandName(subcmd_name)] = process_command(\n                    CommandName(subcmd_name), subcmd_obj, parent=cmd_data\n                )\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 169,
        "coloffset": 8,
        "linematch": "return cmd_data",
        "context": "                cmd_data.subcommands[CommandName(subcmd_name)] = process_command(\n                    CommandName(subcmd_name), subcmd_obj, parent=cmd_data\n                )\n\n        return cmd_data\n\n    data: dict[CommandName, CommandSchema] = {}\n\n    # Special case for the root group\n    if isinstance(app, click.Group):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 171,
        "coloffset": 4,
        "linematch": "data: dict[CommandName, CommandSchema] = {}",
        "context": "                )\n\n        return cmd_data\n\n    data: dict[CommandName, CommandSchema] = {}\n\n    # Special case for the root group\n    if isinstance(app, click.Group):\n        root_cmd_name = CommandName(\"root\")\n        data[root_cmd_name] = process_command(root_cmd_name, app)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 174,
        "coloffset": 4,
        "linematch": "if isinstance(app, click.Group):",
        "context": "\n    data: dict[CommandName, CommandSchema] = {}\n\n    # Special case for the root group\n    if isinstance(app, click.Group):\n        root_cmd_name = CommandName(\"root\")\n        data[root_cmd_name] = process_command(root_cmd_name, app)\n        app = data[root_cmd_name]\n\n    if isinstance(app, click.Group):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 179,
        "coloffset": 4,
        "linematch": "if isinstance(app, click.Group):",
        "context": "        root_cmd_name = CommandName(\"root\")\n        data[root_cmd_name] = process_command(root_cmd_name, app)\n        app = data[root_cmd_name]\n\n    if isinstance(app, click.Group):\n        for cmd_name, cmd_obj in app.commands.items():\n            data[CommandName(cmd_name)] = process_command(\n                CommandName(cmd_name), cmd_obj\n            )\n    elif isinstance(app, click.Command):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 188,
        "coloffset": 4,
        "linematch": "return data",
        "context": "    elif isinstance(app, click.Command):\n        cmd_name = CommandName(app.name)\n        data[cmd_name] = process_command(cmd_name, app)\n\n    return data\n\n\nCommandName = NewType(\"CommandName\", str)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 95,
        "coloffset": 0,
        "linematch": "def introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:",
        "context": "            path.append(node)\n        return list(reversed(path))\n\n\ndef introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:\n    \"\"\"\n    Introspect a Click application and build a data structure containing\n    information about all commands, options, arguments, and subcommands,\n    including the docstrings and command function references.\n",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]",
        "check_id": "F027",
        "check_name": "high-cyclomatic-complexity"
      },
      {
        "lineno": 95,
        "coloffset": 0,
        "linematch": "def introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:",
        "context": "            path.append(node)\n        return list(reversed(path))\n\n\ndef introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:\n    \"\"\"\n    Introspect a Click application and build a data structure containing\n    information about all commands, options, arguments, and subcommands,\n    including the docstrings and command function references.\n",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "def process_command(",
        "context": "        structure. The structure is defined by the CommandData TypedDict and its related\n        TypedDicts (OptionData and ArgumentData).\n    \"\"\"\n\n    def process_command(\n        cmd_name: CommandName, cmd_obj: click.Command, parent=None\n    ) -> CommandSchema:\n        cmd_data = CommandSchema(\n            name=cmd_name,\n            docstring=cmd_obj.help,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 95,
        "coloffset": 0,
        "linematch": "def introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:",
        "context": "            path.append(node)\n        return list(reversed(path))\n\n\ndef introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:\n    \"\"\"\n    Introspect a Click application and build a data structure containing\n    information about all commands, options, arguments, and subcommands,\n    including the docstrings and command function references.\n",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      },
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "def process_command(",
        "context": "        structure. The structure is defined by the CommandData TypedDict and its related\n        TypedDicts (OptionData and ArgumentData).\n    \"\"\"\n\n    def process_command(\n        cmd_name: CommandName, cmd_obj: click.Command, parent=None\n    ) -> CommandSchema:\n        cmd_data = CommandSchema(\n            name=cmd_name,\n            docstring=cmd_obj.help,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #628",
        "line": 95,
        "description": [
          "        self.command_schema = command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -92,7 +92,7 @@\n         disabled: bool = False,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n-        self.command_schema = command_schema\n+        self.command_schema = None\n         self.command_schemas = command_schemas\n         self.first_control: ParameterControls | None = None\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #629",
        "line": 96,
        "description": [
          "        self.command_schemas = command_schemas"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -93,7 +93,7 @@\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n-        self.command_schemas = command_schemas\n+        self.command_schemas = None\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #630",
        "line": 97,
        "description": [
          "        self.first_control: ParameterControls | None = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -94,7 +94,7 @@\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n         self.command_schemas = command_schemas\n-        self.first_control: ParameterControls | None = None\n+        self.first_control: ParameterControls & None = None\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #631",
        "line": 97,
        "description": [
          "        self.first_control: ParameterControls | None = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -94,7 +94,7 @@\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n         self.command_schemas = command_schemas\n-        self.first_control: ParameterControls | None = None\n+        self.first_control: ParameterControls | None = \"\"\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #632",
        "line": 100,
        "description": [
          "        path_from_root = iter(reversed(self.command_schema.path_from_root))"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -97,7 +97,7 @@\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n-        path_from_root = iter(reversed(self.command_schema.path_from_root))\n+        path_from_root = None\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n             vs.can_focus = False\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #633",
        "line": 101,
        "description": [
          "        command_node = next(path_from_root)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -98,7 +98,7 @@\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n-        command_node = next(path_from_root)\n+        command_node = None\n         with VerticalScroll() as vs:\n             vs.can_focus = False\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #634",
        "line": 103,
        "description": [
          "            vs.can_focus = False"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -100,7 +100,7 @@\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n-            vs.can_focus = False\n+            vs.can_focus = True\n \n             yield Input(\n                 placeholder=\"Search...\",\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #635",
        "line": 103,
        "description": [
          "            vs.can_focus = False"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -100,7 +100,7 @@\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n-            vs.can_focus = False\n+            vs.can_focus = None\n \n             yield Input(\n                 placeholder=\"Search...\",\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #636",
        "line": 106,
        "description": [
          "                placeholder=\"Search...\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -103,7 +103,7 @@\n             vs.can_focus = False\n \n             yield Input(\n-                placeholder=\"Search...\",\n+                placeholder=\"XXSearch...XX\",\n                 classes=\"command-form-filter-input\",\n                 id=\"search\",\n             )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #637",
        "line": 107,
        "description": [
          "                classes=\"command-form-filter-input\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -104,7 +104,7 @@\n \n             yield Input(\n                 placeholder=\"Search...\",\n-                classes=\"command-form-filter-input\",\n+                classes=\"XXcommand-form-filter-inputXX\",\n                 id=\"search\",\n             )\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #638",
        "line": 108,
        "description": [
          "                id=\"search\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -105,7 +105,7 @@\n             yield Input(\n                 placeholder=\"Search...\",\n                 classes=\"command-form-filter-input\",\n-                id=\"search\",\n+                id=\"XXsearchXX\",\n             )\n \n             while command_node is not None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #639",
        "line": 111,
        "description": [
          "            while command_node is not None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -108,7 +108,7 @@\n                 id=\"search\",\n             )\n \n-            while command_node is not None:\n+            while command_node is  None:\n                 options = command_node.options\n                 arguments = command_node.arguments\n                 if options or arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #640",
        "line": 112,
        "description": [
          "                options = command_node.options"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -109,7 +109,7 @@\n             )\n \n             while command_node is not None:\n-                options = command_node.options\n+                options = None\n                 arguments = command_node.arguments\n                 if options or arguments:\n                     with Vertical(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #641",
        "line": 113,
        "description": [
          "                arguments = command_node.arguments"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -110,7 +110,7 @@\n \n             while command_node is not None:\n                 options = command_node.options\n-                arguments = command_node.arguments\n+                arguments = None\n                 if options or arguments:\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #642",
        "line": 114,
        "description": [
          "                if options or arguments:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -111,7 +111,7 @@\n             while command_node is not None:\n                 options = command_node.options\n                 arguments = command_node.arguments\n-                if options or arguments:\n+                if options and arguments:\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #643",
        "line": 116,
        "description": [
          "                        classes=\"command-form-command-group\", id=command_node.key"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -113,7 +113,7 @@\n                 arguments = command_node.arguments\n                 if options or arguments:\n                     with Vertical(\n-                        classes=\"command-form-command-group\", id=command_node.key\n+                        classes=\"XXcommand-form-command-groupXX\", id=command_node.key\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #644",
        "line": 118,
        "description": [
          "                        is_inherited = command_node is not self.command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -115,7 +115,7 @@\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n-                        is_inherited = command_node is not self.command_schema\n+                        is_inherited = command_node is  self.command_schema\n                         v.border_title = (\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #645",
        "line": 118,
        "description": [
          "                        is_inherited = command_node is not self.command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -115,7 +115,7 @@\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n-                        is_inherited = command_node is not self.command_schema\n+                        is_inherited = None\n                         v.border_title = (\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #646",
        "line": 120,
        "description": [
          "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -117,7 +117,7 @@\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n+                            f\"{'XX\u21aa XX' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #647",
        "line": 120,
        "description": [
          "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -117,7 +117,7 @@\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n+                            f\"{'\u21aa ' if is_inherited else 'XXXX'}{command_node.name}\"\n                         )\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #648",
        "line": 120,
        "description": [
          "                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -117,7 +117,7 @@\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n+                            f\"XX{'\u21aa ' if is_inherited else ''}{command_node.name}XX\"\n                         )\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #649",
        "line": 121,
        "description": [
          "                        )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -116,9 +116,7 @@\n                         classes=\"command-form-command-group\", id=command_node.key\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n-                        v.border_title = (\n-                            f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n-                        )\n+                        v.border_title = None\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n                         if arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #650",
        "line": 123,
        "description": [
          "                            v.border_title += \" [dim not bold](inherited)\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -120,7 +120,7 @@\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n-                            v.border_title += \" [dim not bold](inherited)\"\n+                            v.border_title = \" [dim not bold](inherited)\"\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #651",
        "line": 123,
        "description": [
          "                            v.border_title += \" [dim not bold](inherited)\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -120,7 +120,7 @@\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n-                            v.border_title += \" [dim not bold](inherited)\"\n+                            v.border_title -= \" [dim not bold](inherited)\"\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #652",
        "line": 123,
        "description": [
          "                            v.border_title += \" [dim not bold](inherited)\""
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -120,7 +120,7 @@\n                             f\"{'\u21aa ' if is_inherited else ''}{command_node.name}\"\n                         )\n                         if is_inherited:\n-                            v.border_title += \" [dim not bold](inherited)\"\n+                            v.border_title += \"XX [dim not bold](inherited)XX\"\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #653",
        "line": 125,
        "description": [
          "                            yield Label(f\"Arguments\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -122,7 +122,7 @@\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n                         if arguments:\n-                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n+                            yield Label(f\"XXArgumentsXX\", classes=\"command-form-heading\")\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #654",
        "line": 125,
        "description": [
          "                            yield Label(f\"Arguments\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -122,7 +122,7 @@\n                         if is_inherited:\n                             v.border_title += \" [dim not bold](inherited)\"\n                         if arguments:\n-                            yield Label(f\"Arguments\", classes=\"command-form-heading\")\n+                            yield Label(f\"Arguments\", classes=\"XXcommand-form-headingXX\")\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #655",
        "line": 127,
        "description": [
          "                                controls = ParameterControls(argument, id=argument.key)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -124,7 +124,7 @@\n                         if arguments:\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n-                                controls = ParameterControls(argument, id=argument.key)\n+                                controls = None\n                                 if self.first_control is None:\n                                     self.first_control = controls\n                                 yield controls\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #656",
        "line": 128,
        "description": [
          "                                if self.first_control is None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -125,7 +125,7 @@\n                             yield Label(f\"Arguments\", classes=\"command-form-heading\")\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n-                                if self.first_control is None:\n+                                if self.first_control is not None:\n                                     self.first_control = controls\n                                 yield controls\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #657",
        "line": 129,
        "description": [
          "                                    self.first_control = controls"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -126,7 +126,7 @@\n                             for argument in arguments:\n                                 controls = ParameterControls(argument, id=argument.key)\n                                 if self.first_control is None:\n-                                    self.first_control = controls\n+                                    self.first_control = None\n                                 yield controls\n \n                         if options:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #658",
        "line": 133,
        "description": [
          "                            yield Label(f\"Options\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -130,7 +130,7 @@\n                                 yield controls\n \n                         if options:\n-                            yield Label(f\"Options\", classes=\"command-form-heading\")\n+                            yield Label(f\"XXOptionsXX\", classes=\"command-form-heading\")\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #659",
        "line": 133,
        "description": [
          "                            yield Label(f\"Options\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -130,7 +130,7 @@\n                                 yield controls\n \n                         if options:\n-                            yield Label(f\"Options\", classes=\"command-form-heading\")\n+                            yield Label(f\"Options\", classes=\"XXcommand-form-headingXX\")\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #660",
        "line": 135,
        "description": [
          "                                controls = ParameterControls(option, id=option.key)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -132,7 +132,7 @@\n                         if options:\n                             yield Label(f\"Options\", classes=\"command-form-heading\")\n                             for option in options:\n-                                controls = ParameterControls(option, id=option.key)\n+                                controls = None\n                                 if self.first_control is None:\n                                     self.first_control = controls\n                                 yield controls\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #661",
        "line": 136,
        "description": [
          "                                if self.first_control is None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -133,7 +133,7 @@\n                             yield Label(f\"Options\", classes=\"command-form-heading\")\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n-                                if self.first_control is None:\n+                                if self.first_control is not None:\n                                     self.first_control = controls\n                                 yield controls\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #662",
        "line": 137,
        "description": [
          "                                    self.first_control = controls"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -134,7 +134,7 @@\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n                                 if self.first_control is None:\n-                                    self.first_control = controls\n+                                    self.first_control = None\n                                 yield controls\n \n                 command_node = next(path_from_root, None)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #663",
        "line": 140,
        "description": [
          "                command_node = next(path_from_root, None)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -137,7 +137,7 @@\n                                     self.first_control = controls\n                                 yield controls\n \n-                command_node = next(path_from_root, None)\n+                command_node = None\n \n     def on_mount(self) -> None:\n         self._form_changed()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #664",
        "line": 161,
        "description": [
          "        command_schema = self.command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -158,7 +158,7 @@\n         \"\"\"Take the current state of the form and build a UserCommandData from it,\n         then post a FormChanged message\"\"\"\n \n-        command_schema = self.command_schema\n+        command_schema = None\n         path_from_root = command_schema.path_from_root\n \n         # Sentinel root value to make constructing the tree a little easier.\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #665",
        "line": 162,
        "description": [
          "        path_from_root = command_schema.path_from_root"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -159,7 +159,7 @@\n         then post a FormChanged message\"\"\"\n \n         command_schema = self.command_schema\n-        path_from_root = command_schema.path_from_root\n+        path_from_root = None\n \n         # Sentinel root value to make constructing the tree a little easier.\n         parent_command_data = UserCommandData(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #666",
        "line": 166,
        "description": [
          "            name=CommandName(\"_\"), options=[], arguments=[]"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -163,7 +163,7 @@\n \n         # Sentinel root value to make constructing the tree a little easier.\n         parent_command_data = UserCommandData(\n-            name=CommandName(\"_\"), options=[], arguments=[]\n+            name=CommandName(\"XX_XX\"), options=[], arguments=[]\n         )\n \n         root_command_data = parent_command_data\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #667",
        "line": 167,
        "description": [
          "        )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -162,9 +162,7 @@\n         path_from_root = command_schema.path_from_root\n \n         # Sentinel root value to make constructing the tree a little easier.\n-        parent_command_data = UserCommandData(\n-            name=CommandName(\"_\"), options=[], arguments=[]\n-        )\n+        parent_command_data = None\n \n         root_command_data = parent_command_data\n         for command in path_from_root:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #668",
        "line": 169,
        "description": [
          "        root_command_data = parent_command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -166,7 +166,7 @@\n             name=CommandName(\"_\"), options=[], arguments=[]\n         )\n \n-        root_command_data = parent_command_data\n+        root_command_data = None\n         for command in path_from_root:\n             option_datas = []\n             # For each of the options in the schema for this command,\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #669",
        "line": 171,
        "description": [
          "            option_datas = []"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -168,7 +168,7 @@\n \n         root_command_data = parent_command_data\n         for command in path_from_root:\n-            option_datas = []\n+            option_datas = None\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #670",
        "line": 175,
        "description": [
          "                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -172,7 +172,7 @@\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n-                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n+                parameter_control = self.query_one(f\"XX#{option.key}XX\", ParameterControls)\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #671",
        "line": 175,
        "description": [
          "                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -172,7 +172,7 @@\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n-                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n+                parameter_control = None\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #672",
        "line": 176,
        "description": [
          "                value = parameter_control.get_values()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -173,7 +173,7 @@\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n                 parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n-                value = parameter_control.get_values()\n+                value = None\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n                     option_data = UserOptionData(option.name, v, option)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #673",
        "line": 179,
        "description": [
          "                    option_data = UserOptionData(option.name, v, option)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -176,7 +176,7 @@\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n-                    option_data = UserOptionData(option.name, v, option)\n+                    option_data = None\n                     option_datas.append(option_data)\n \n             # Now do the same for the arguments\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #674",
        "line": 183,
        "description": [
          "            argument_datas = []"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -180,7 +180,7 @@\n                     option_datas.append(option_data)\n \n             # Now do the same for the arguments\n-            argument_datas = []\n+            argument_datas = None\n             for argument in command.arguments:\n                 form_control_widget = self.query_one(\n                     f\"#{argument.key}\", ParameterControls\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #675",
        "line": 186,
        "description": [
          "                    f\"#{argument.key}\", ParameterControls"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -183,7 +183,7 @@\n             argument_datas = []\n             for argument in command.arguments:\n                 form_control_widget = self.query_one(\n-                    f\"#{argument.key}\", ParameterControls\n+                    f\"XX#{argument.key}XX\", ParameterControls\n                 )\n                 value = form_control_widget.get_values()\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #676",
        "line": 187,
        "description": [
          "                )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -182,9 +182,7 @@\n             # Now do the same for the arguments\n             argument_datas = []\n             for argument in command.arguments:\n-                form_control_widget = self.query_one(\n-                    f\"#{argument.key}\", ParameterControls\n-                )\n+                form_control_widget = None\n                 value = form_control_widget.get_values()\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #677",
        "line": 188,
        "description": [
          "                value = form_control_widget.get_values()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -185,7 +185,7 @@\n                 form_control_widget = self.query_one(\n                     f\"#{argument.key}\", ParameterControls\n                 )\n-                value = form_control_widget.get_values()\n+                value = None\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "process_cli_option",
    "function_scope": "20-33",
    "patterns": [
      {
        "lineno": 21,
        "coloffset": 8,
        "linematch": "if value is None:",
        "context": "    values: list[tuple[int | float | str]]\n\n    @staticmethod\n    def process_cli_option(value) -> \"MultiValueParamData\":\n        if value is None:\n            value = MultiValueParamData([])\n        elif isinstance(value, tuple):\n            value = MultiValueParamData([value])\n        elif isinstance(value, list):\n            processed_list = [",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 23,
        "coloffset": 8,
        "linematch": "elif isinstance(value, tuple):",
        "context": "    @staticmethod\n    def process_cli_option(value) -> \"MultiValueParamData\":\n        if value is None:\n            value = MultiValueParamData([])\n        elif isinstance(value, tuple):\n            value = MultiValueParamData([value])\n        elif isinstance(value, list):\n            processed_list = [\n                (item,) if not isinstance(item, tuple) else item for item in value\n            ]",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 25,
        "coloffset": 8,
        "linematch": "elif isinstance(value, list):",
        "context": "        if value is None:\n            value = MultiValueParamData([])\n        elif isinstance(value, tuple):\n            value = MultiValueParamData([value])\n        elif isinstance(value, list):\n            processed_list = [\n                (item,) if not isinstance(item, tuple) else item for item in value\n            ]\n            value = MultiValueParamData(processed_list)\n        else:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "def process_cli_option(value) -> \"MultiValueParamData\":",
        "context": "class MultiValueParamData:\n    values: list[tuple[int | float | str]]\n\n    @staticmethod\n    def process_cli_option(value) -> \"MultiValueParamData\":\n        if value is None:\n            value = MultiValueParamData([])\n        elif isinstance(value, tuple):\n            value = MultiValueParamData([value])\n        elif isinstance(value, list):",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "def process_cli_option(value) -> \"MultiValueParamData\":",
        "context": "class MultiValueParamData:\n    values: list[tuple[int | float | str]]\n\n    @staticmethod\n    def process_cli_option(value) -> \"MultiValueParamData\":\n        if value is None:\n            value = MultiValueParamData([])\n        elif isinstance(value, tuple):\n            value = MultiValueParamData([value])\n        elif isinstance(value, list):",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 23,
        "coloffset": 8,
        "linematch": "elif isinstance(value, tuple):",
        "context": "    @staticmethod\n    def process_cli_option(value) -> \"MultiValueParamData\":\n        if value is None:\n            value = MultiValueParamData([])\n        elif isinstance(value, tuple):\n            value = MultiValueParamData([value])\n        elif isinstance(value, list):\n            processed_list = [\n                (item,) if not isinstance(item, tuple) else item for item in value\n            ]",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 25,
        "coloffset": 8,
        "linematch": "elif isinstance(value, list):",
        "context": "        if value is None:\n            value = MultiValueParamData([])\n        elif isinstance(value, tuple):\n            value = MultiValueParamData([value])\n        elif isinstance(value, list):\n            processed_list = [\n                (item,) if not isinstance(item, tuple) else item for item in value\n            ]\n            value = MultiValueParamData(processed_list)\n        else:",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "def process_cli_option(value) -> \"MultiValueParamData\":",
        "context": "class MultiValueParamData:\n    values: list[tuple[int | float | str]]\n\n    @staticmethod\n    def process_cli_option(value) -> \"MultiValueParamData\":\n        if value is None:\n            value = MultiValueParamData([])\n        elif isinstance(value, tuple):\n            value = MultiValueParamData([value])\n        elif isinstance(value, list):",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 21,
        "coloffset": 8,
        "linematch": "if value is None:",
        "context": "    values: list[tuple[int | float | str]]\n\n    @staticmethod\n    def process_cli_option(value) -> \"MultiValueParamData\":\n        if value is None:\n            value = MultiValueParamData([])\n        elif isinstance(value, tuple):\n            value = MultiValueParamData([value])\n        elif isinstance(value, list):\n            processed_list = [",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 8,
        "linematch": "return value",
        "context": "            value = MultiValueParamData(processed_list)\n        else:\n            value = MultiValueParamData([(value,)])\n\n        return value\n\n\n@dataclass\nclass OptionSchema:\n    name: list[str]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #624",
        "line": 22,
        "description": [
          "@dataclasses.dataclass"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -18,8 +18,6 @@\n from trogon.run_command import UserCommandData, UserOptionData, UserArgumentData\n from trogon.widgets.parameter_controls import ParameterControls\n \n-\n-@dataclasses.dataclass\n class FormControlMeta:\n     widget: Widget\n     meta: OptionSchema | ArgumentSchema\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #625",
        "line": 32,
        "description": [
          "    DEFAULT_CSS = \"\"\"    "
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -29,52 +29,7 @@\n     \"\"\"Form which is constructed from an introspected Click app. Users\n     make use of this form in order to construct CLI invocation strings.\"\"\"\n \n-    DEFAULT_CSS = \"\"\"    \n-    .command-form-heading {\n-        padding: 1 0 0 1;\n-        text-style: u;\n-        color: $text;\n-    }\n-    .command-form-input {        \n-        border: tall transparent;\n-    }\n-    .command-form-label {\n-        padding: 1 0 0 1;\n-    }\n-    .command-form-checkbox {\n-        background: $boost;\n-        margin: 1 0 0 0;\n-        padding-left: 1;\n-        border: tall transparent;\n-    }\n-    .command-form-checkbox:focus {\n-      border: tall $accent;      \n-    }\n-    .command-form-checkbox:focus > .toggle--label {\n-        text-style: none;\n-    }\n-    .command-form-command-group {\n-        \n-        margin: 1 2;\n-        padding: 0 1;\n-        height: auto;\n-        background: $foreground 3%;\n-        border: panel $background;\n-        border-title-color: $text 80%;\n-        border-title-style: bold;\n-        border-subtitle-color: $text 30%;\n-        padding-bottom: 1;\n-    }\n-    .command-form-command-group:focus-within {\n-        border: panel $primary;\n-    }\n-    .command-form-control-help-text {        \n-        height: auto;\n-        color: $text 40%;\n-        padding-top: 0;\n-        padding-left: 1;\n-    }\n-    \"\"\"\n+    DEFAULT_CSS = None\n \n     class Changed(Message):\n         def __init__(self, command_data: UserCommandData):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "path_from_root",
    "function_scope": "84-92",
    "patterns": [
      {
        "lineno": 89,
        "coloffset": 12,
        "linematch": "if node is None:",
        "context": "        node = self\n        path = [self]\n        while True:\n            node = node.parent\n            if node is None:\n                break\n            path.append(node)\n        return list(reversed(path))\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 89,
        "coloffset": 15,
        "linematch": "if node is None:",
        "context": "        node = self\n        path = [self]\n        while True:\n            node = node.parent\n            if node is None:\n                break\n            path.append(node)\n        return list(reversed(path))\n\n",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 89,
        "coloffset": 15,
        "linematch": "if node is None:",
        "context": "        node = self\n        path = [self]\n        while True:\n            node = node.parent\n            if node is None:\n                break\n            path.append(node)\n        return list(reversed(path))\n\n",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "def path_from_root(self) -> list[\"CommandSchema\"]:",
        "context": "    parent: \"CommandSchema | None\" = None\n    is_group: bool = False\n\n    @property\n    def path_from_root(self) -> list[\"CommandSchema\"]:\n        node = self\n        path = [self]\n        while True:\n            node = node.parent\n            if node is None:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "def path_from_root(self) -> list[\"CommandSchema\"]:",
        "context": "    parent: \"CommandSchema | None\" = None\n    is_group: bool = False\n\n    @property\n    def path_from_root(self) -> list[\"CommandSchema\"]:\n        node = self\n        path = [self]\n        while True:\n            node = node.parent\n            if node is None:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 85,
        "coloffset": 8,
        "linematch": "node = self",
        "context": "    is_group: bool = False\n\n    @property\n    def path_from_root(self) -> list[\"CommandSchema\"]:\n        node = self\n        path = [self]\n        while True:\n            node = node.parent\n            if node is None:\n                break",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 86,
        "coloffset": 8,
        "linematch": "path = [self]",
        "context": "\n    @property\n    def path_from_root(self) -> list[\"CommandSchema\"]:\n        node = self\n        path = [self]\n        while True:\n            node = node.parent\n            if node is None:\n                break\n            path.append(node)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 87,
        "coloffset": 8,
        "linematch": "while True:",
        "context": "    @property\n    def path_from_root(self) -> list[\"CommandSchema\"]:\n        node = self\n        path = [self]\n        while True:\n            node = node.parent\n            if node is None:\n                break\n            path.append(node)\n        return list(reversed(path))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 92,
        "coloffset": 8,
        "linematch": "return list(reversed(path))",
        "context": "            node = node.parent\n            if node is None:\n                break\n            path.append(node)\n        return list(reversed(path))\n\n\ndef introspect_click_app(app: BaseCommand) -> dict[CommandName, CommandSchema]:\n    \"\"\"\n    Introspect a Click application and build a data structure containing",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #627",
        "line": 92,
        "description": [
          "        disabled: bool = False,"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -89,7 +89,7 @@\n         name: str | None = None,\n         id: str | None = None,\n         classes: str | None = None,\n-        disabled: bool = False,\n+        disabled: bool = True,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "get_orig_argv",
    "function_scope": "8-20",
    "patterns": [
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "if hasattr(sys, \"orig_argv\"):",
        "context": "\n\ndef get_orig_argv() -> list[str]:\n    \"\"\"Polyfil for orig_argv\"\"\"\n    if hasattr(sys, \"orig_argv\"):\n        return sys.orig_argv\n    import ctypes\n\n    _argv = ctypes.POINTER(ctypes.c_wchar_p)()\n    _argc = ctypes.c_int()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 8,
        "coloffset": 0,
        "linematch": "def get_orig_argv() -> list[str]:",
        "context": "import shlex\nimport sys\n\n\ndef get_orig_argv() -> list[str]:\n    \"\"\"Polyfil for orig_argv\"\"\"\n    if hasattr(sys, \"orig_argv\"):\n        return sys.orig_argv\n    import ctypes\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "\"\"\"Polyfil for orig_argv\"\"\"",
        "context": "import sys\n\n\ndef get_orig_argv() -> list[str]:\n    \"\"\"Polyfil for orig_argv\"\"\"\n    if hasattr(sys, \"orig_argv\"):\n        return sys.orig_argv\n    import ctypes\n\n    _argv = ctypes.POINTER(ctypes.c_wchar_p)()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "if hasattr(sys, \"orig_argv\"):",
        "context": "\n\ndef get_orig_argv() -> list[str]:\n    \"\"\"Polyfil for orig_argv\"\"\"\n    if hasattr(sys, \"orig_argv\"):\n        return sys.orig_argv\n    import ctypes\n\n    _argv = ctypes.POINTER(ctypes.c_wchar_p)()\n    _argc = ctypes.c_int()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 12,
        "coloffset": 4,
        "linematch": "import ctypes",
        "context": "def get_orig_argv() -> list[str]:\n    \"\"\"Polyfil for orig_argv\"\"\"\n    if hasattr(sys, \"orig_argv\"):\n        return sys.orig_argv\n    import ctypes\n\n    _argv = ctypes.POINTER(ctypes.c_wchar_p)()\n    _argc = ctypes.c_int()\n\n    ctypes.pythonapi.Py_GetArgcArgv(ctypes.byref(_argc), ctypes.byref(_argv))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "_argv = ctypes.POINTER(ctypes.c_wchar_p)()",
        "context": "    if hasattr(sys, \"orig_argv\"):\n        return sys.orig_argv\n    import ctypes\n\n    _argv = ctypes.POINTER(ctypes.c_wchar_p)()\n    _argc = ctypes.c_int()\n\n    ctypes.pythonapi.Py_GetArgcArgv(ctypes.byref(_argc), ctypes.byref(_argv))\n\n    argv = _argv[: _argc.value]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "_argc = ctypes.c_int()",
        "context": "        return sys.orig_argv\n    import ctypes\n\n    _argv = ctypes.POINTER(ctypes.c_wchar_p)()\n    _argc = ctypes.c_int()\n\n    ctypes.pythonapi.Py_GetArgcArgv(ctypes.byref(_argc), ctypes.byref(_argv))\n\n    argv = _argv[: _argc.value]\n    return argv",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "ctypes.pythonapi.Py_GetArgcArgv(ctypes.byref(_argc), ctypes.byref(_argv))",
        "context": "\n    _argv = ctypes.POINTER(ctypes.c_wchar_p)()\n    _argc = ctypes.c_int()\n\n    ctypes.pythonapi.Py_GetArgcArgv(ctypes.byref(_argc), ctypes.byref(_argv))\n\n    argv = _argv[: _argc.value]\n    return argv\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 19,
        "coloffset": 4,
        "linematch": "argv = _argv[: _argc.value]",
        "context": "    _argc = ctypes.c_int()\n\n    ctypes.pythonapi.Py_GetArgcArgv(ctypes.byref(_argc), ctypes.byref(_argv))\n\n    argv = _argv[: _argc.value]\n    return argv\n\n\ndef detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:\n    \"\"\"This is a slightly modified version of a function from Click.\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "return argv",
        "context": "\n    ctypes.pythonapi.Py_GetArgcArgv(ctypes.byref(_argc), ctypes.byref(_argv))\n\n    argv = _argv[: _argc.value]\n    return argv\n\n\ndef detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:\n    \"\"\"This is a slightly modified version of a function from Click.\"\"\"\n    if not path:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "detect_run_string",
    "function_scope": "23-56",
    "patterns": [
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "if not path:",
        "context": "\n\ndef detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:\n    \"\"\"This is a slightly modified version of a function from Click.\"\"\"\n    if not path:\n        path = sys.argv[0]\n\n    # The value of __package__ indicates how Python was called. It may\n    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "if getattr(_main, \"__package__\", None) is None or (",
        "context": "\n    # The value of __package__ indicates how Python was called. It may\n    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.\n    if getattr(_main, \"__package__\", None) is None or (\n        os.name == \"nt\"\n        and _main.__package__ == \"\"\n        and not os.path.exists(path)\n        and os.path.exists(f\"{path}.exe\")\n    ):",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "if name != \"__main__\":",
        "context": "    py_module = _main.__package__\n    name = os.path.splitext(os.path.basename(path))[0]\n\n    # A submodule like \"example.cli\".\n    if name != \"__main__\":\n        py_module = f\"{py_module}.{name}\"\n\n    return f\"python -m {py_module.lstrip('.')}\"",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 40,
        "coloffset": 8,
        "linematch": "if argv[0] == \"python\":",
        "context": "    ):\n        # Executed a file, like \"python app.py\".\n        file_path = shlex.quote(os.path.basename(path))\n        argv = get_orig_argv()\n        if argv[0] == \"python\":\n            prefix = f\"{argv[0]} \"\n        else:\n            prefix = \"\"\n        return f\"{prefix}{file_path}\"\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 40,
        "coloffset": 8,
        "linematch": "if argv[0] == \"python\":",
        "context": "    ):\n        # Executed a file, like \"python app.py\".\n        file_path = shlex.quote(os.path.basename(path))\n        argv = get_orig_argv()\n        if argv[0] == \"python\":\n            prefix = f\"{argv[0]} \"\n        else:\n            prefix = \"\"\n        return f\"{prefix}{file_path}\"\n",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 31,
        "coloffset": 7,
        "linematch": "if getattr(_main, \"__package__\", None) is None or (",
        "context": "\n    # The value of __package__ indicates how Python was called. It may\n    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.\n    if getattr(_main, \"__package__\", None) is None or (\n        os.name == \"nt\"\n        and _main.__package__ == \"\"\n        and not os.path.exists(path)\n        and os.path.exists(f\"{path}.exe\")\n    ):",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 33,
        "coloffset": 12,
        "linematch": "and _main.__package__ == \"\"",
        "context": "    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.\n    if getattr(_main, \"__package__\", None) is None or (\n        os.name == \"nt\"\n        and _main.__package__ == \"\"\n        and not os.path.exists(path)\n        and os.path.exists(f\"{path}.exe\")\n    ):\n        # Executed a file, like \"python app.py\".\n        file_path = shlex.quote(os.path.basename(path))",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 33,
        "coloffset": 12,
        "linematch": "and _main.__package__ == \"\"",
        "context": "    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.\n    if getattr(_main, \"__package__\", None) is None or (\n        os.name == \"nt\"\n        and _main.__package__ == \"\"\n        and not os.path.exists(path)\n        and os.path.exists(f\"{path}.exe\")\n    ):\n        # Executed a file, like \"python app.py\".\n        file_path = shlex.quote(os.path.basename(path))",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 33,
        "coloffset": 12,
        "linematch": "and _main.__package__ == \"\"",
        "context": "    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.\n    if getattr(_main, \"__package__\", None) is None or (\n        os.name == \"nt\"\n        and _main.__package__ == \"\"\n        and not os.path.exists(path)\n        and os.path.exists(f\"{path}.exe\")\n    ):\n        # Executed a file, like \"python app.py\".\n        file_path = shlex.quote(os.path.basename(path))",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 23,
        "coloffset": 0,
        "linematch": "def detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:",
        "context": "    argv = _argv[: _argc.value]\n    return argv\n\n\ndef detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:\n    \"\"\"This is a slightly modified version of a function from Click.\"\"\"\n    if not path:\n        path = sys.argv[0]\n\n    # The value of __package__ indicates how Python was called. It may",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "if getattr(_main, \"__package__\", None) is None or (",
        "context": "\n    # The value of __package__ indicates how Python was called. It may\n    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.\n    if getattr(_main, \"__package__\", None) is None or (\n        os.name == \"nt\"\n        and _main.__package__ == \"\"\n        and not os.path.exists(path)\n        and os.path.exists(f\"{path}.exe\")\n    ):",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "if name != \"__main__\":",
        "context": "    py_module = _main.__package__\n    name = os.path.splitext(os.path.basename(path))[0]\n\n    # A submodule like \"example.cli\".\n    if name != \"__main__\":\n        py_module = f\"{py_module}.{name}\"\n\n    return f\"python -m {py_module.lstrip('.')}\"",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 40,
        "coloffset": 8,
        "linematch": "if argv[0] == \"python\":",
        "context": "    ):\n        # Executed a file, like \"python app.py\".\n        file_path = shlex.quote(os.path.basename(path))\n        argv = get_orig_argv()\n        if argv[0] == \"python\":\n            prefix = f\"{argv[0]} \"\n        else:\n            prefix = \"\"\n        return f\"{prefix}{file_path}\"\n",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "\"\"\"This is a slightly modified version of a function from Click.\"\"\"",
        "context": "    return argv\n\n\ndef detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:\n    \"\"\"This is a slightly modified version of a function from Click.\"\"\"\n    if not path:\n        path = sys.argv[0]\n\n    # The value of __package__ indicates how Python was called. It may\n    # not exist if a setuptools script is installed as an egg. It may be",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "if not path:",
        "context": "\n\ndef detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:\n    \"\"\"This is a slightly modified version of a function from Click.\"\"\"\n    if not path:\n        path = sys.argv[0]\n\n    # The value of __package__ indicates how Python was called. It may\n    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "if getattr(_main, \"__package__\", None) is None or (",
        "context": "\n    # The value of __package__ indicates how Python was called. It may\n    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.\n    if getattr(_main, \"__package__\", None) is None or (\n        os.name == \"nt\"\n        and _main.__package__ == \"\"\n        and not os.path.exists(path)\n        and os.path.exists(f\"{path}.exe\")\n    ):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "py_module = _main.__package__",
        "context": "\n    # Executed a module, like \"python -m example\".\n    # Rewritten by Python from \"-m script\" to \"/path/to/script.py\".\n    # Need to look at main module to determine how it was executed.\n    py_module = _main.__package__\n    name = os.path.splitext(os.path.basename(path))[0]\n\n    # A submodule like \"example.cli\".\n    if name != \"__main__\":\n        py_module = f\"{py_module}.{name}\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "name = os.path.splitext(os.path.basename(path))[0]",
        "context": "    # Executed a module, like \"python -m example\".\n    # Rewritten by Python from \"-m script\" to \"/path/to/script.py\".\n    # Need to look at main module to determine how it was executed.\n    py_module = _main.__package__\n    name = os.path.splitext(os.path.basename(path))[0]\n\n    # A submodule like \"example.cli\".\n    if name != \"__main__\":\n        py_module = f\"{py_module}.{name}\"\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "if name != \"__main__\":",
        "context": "    py_module = _main.__package__\n    name = os.path.splitext(os.path.basename(path))[0]\n\n    # A submodule like \"example.cli\".\n    if name != \"__main__\":\n        py_module = f\"{py_module}.{name}\"\n\n    return f\"python -m {py_module.lstrip('.')}\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "return f\"python -m {py_module.lstrip('.')}\"",
        "context": "    # A submodule like \"example.cli\".\n    if name != \"__main__\":\n        py_module = f\"{py_module}.{name}\"\n\n    return f\"python -m {py_module.lstrip('.')}\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 0,
        "linematch": "def detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:",
        "context": "    argv = _argv[: _argc.value]\n    return argv\n\n\ndef detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:\n    \"\"\"This is a slightly modified version of a function from Click.\"\"\"\n    if not path:\n        path = sys.argv[0]\n\n    # The value of __package__ indicates how Python was called. It may",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 23,
        "coloffset": 0,
        "linematch": "def detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:",
        "context": "    argv = _argv[: _argc.value]\n    return argv\n\n\ndef detect_run_string(path=None, _main=sys.modules[\"__main__\"]) -> str:\n    \"\"\"This is a slightly modified version of a function from Click.\"\"\"\n    if not path:\n        path = sys.argv[0]\n\n    # The value of __package__ indicates how Python was called. It may",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #625",
        "line": 32,
        "description": [
          "    DEFAULT_CSS = \"\"\"    "
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -29,52 +29,7 @@\n     \"\"\"Form which is constructed from an introspected Click app. Users\n     make use of this form in order to construct CLI invocation strings.\"\"\"\n \n-    DEFAULT_CSS = \"\"\"    \n-    .command-form-heading {\n-        padding: 1 0 0 1;\n-        text-style: u;\n-        color: $text;\n-    }\n-    .command-form-input {        \n-        border: tall transparent;\n-    }\n-    .command-form-label {\n-        padding: 1 0 0 1;\n-    }\n-    .command-form-checkbox {\n-        background: $boost;\n-        margin: 1 0 0 0;\n-        padding-left: 1;\n-        border: tall transparent;\n-    }\n-    .command-form-checkbox:focus {\n-      border: tall $accent;      \n-    }\n-    .command-form-checkbox:focus > .toggle--label {\n-        text-style: none;\n-    }\n-    .command-form-command-group {\n-        \n-        margin: 1 2;\n-        padding: 0 1;\n-        height: auto;\n-        background: $foreground 3%;\n-        border: panel $background;\n-        border-title-color: $text 80%;\n-        border-title-style: bold;\n-        border-subtitle-color: $text 30%;\n-        padding-bottom: 1;\n-    }\n-    .command-form-command-group:focus-within {\n-        border: panel $primary;\n-    }\n-    .command-form-control-help-text {        \n-        height: auto;\n-        color: $text 40%;\n-        padding-top: 0;\n-        padding-left: 1;\n-    }\n-    \"\"\"\n+    DEFAULT_CSS = None\n \n     class Changed(Message):\n         def __init__(self, command_data: UserCommandData):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "checkbox_toggled",
    "function_scope": "68-75",
    "patterns": [
      {
        "lineno": 72,
        "coloffset": 12,
        "linematch": "if checkbox.value is True:",
        "context": "    def checkbox_toggled(self) -> None:\n        checkboxes = self.query(Checkbox)\n        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))\n\n    def select_by_label(self, label: str) -> None:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 72,
        "coloffset": 15,
        "linematch": "if checkbox.value is True:",
        "context": "    def checkbox_toggled(self) -> None:\n        checkboxes = self.query(Checkbox)\n        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))\n\n    def select_by_label(self, label: str) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 72,
        "coloffset": 15,
        "linematch": "if checkbox.value is True:",
        "context": "    def checkbox_toggled(self) -> None:\n        checkboxes = self.query(Checkbox)\n        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))\n\n    def select_by_label(self, label: str) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 72,
        "coloffset": 15,
        "linematch": "if checkbox.value is True:",
        "context": "    def checkbox_toggled(self) -> None:\n        checkboxes = self.query(Checkbox)\n        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))\n\n    def select_by_label(self, label: str) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 72,
        "coloffset": 15,
        "linematch": "if checkbox.value is True:",
        "context": "    def checkbox_toggled(self) -> None:\n        checkboxes = self.query(Checkbox)\n        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))\n\n    def select_by_label(self, label: str) -> None:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 68,
        "coloffset": 4,
        "linematch": "def checkbox_toggled(self) -> None:",
        "context": "            for option in self.options:\n                yield Checkbox(option, value=(option,) in self.defaults)\n\n    @on(Checkbox.Changed)\n    def checkbox_toggled(self) -> None:\n        checkboxes = self.query(Checkbox)\n        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 68,
        "coloffset": 4,
        "linematch": "def checkbox_toggled(self) -> None:",
        "context": "            for option in self.options:\n                yield Checkbox(option, value=(option,) in self.defaults)\n\n    @on(Checkbox.Changed)\n    def checkbox_toggled(self) -> None:\n        checkboxes = self.query(Checkbox)\n        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 69,
        "coloffset": 8,
        "linematch": "checkboxes = self.query(Checkbox)",
        "context": "                yield Checkbox(option, value=(option,) in self.defaults)\n\n    @on(Checkbox.Changed)\n    def checkbox_toggled(self) -> None:\n        checkboxes = self.query(Checkbox)\n        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 8,
        "linematch": "selected = []",
        "context": "\n    @on(Checkbox.Changed)\n    def checkbox_toggled(self) -> None:\n        checkboxes = self.query(Checkbox)\n        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 71,
        "coloffset": 8,
        "linematch": "for checkbox in checkboxes:",
        "context": "    @on(Checkbox.Changed)\n    def checkbox_toggled(self) -> None:\n        checkboxes = self.query(Checkbox)\n        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 74,
        "coloffset": 8,
        "linematch": "self.selected = [(checkbox.label.plain,) for checkbox in selected]",
        "context": "        selected = []\n        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))\n\n    def select_by_label(self, label: str) -> None:\n        checkboxes = self.query(Checkbox)\n        for checkbox in checkboxes:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 75,
        "coloffset": 8,
        "linematch": "self.post_message(self.Changed(selected))",
        "context": "        for checkbox in checkboxes:\n            if checkbox.value is True:\n                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))\n\n    def select_by_label(self, label: str) -> None:\n        checkboxes = self.query(Checkbox)\n        for checkbox in checkboxes:\n            checkbox.value = checkbox.label == label",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "action_next_button",
    "function_scope": "82-88",
    "patterns": [
      {
        "lineno": 85,
        "coloffset": 8,
        "linematch": "if focused is checkboxes[-1]:",
        "context": "\n    def action_next_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[-1]:\n            checkboxes[0].focus()\n        else:\n            self.app.action_focus_next()\n\n    def action_previous_button(self) -> None:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 82,
        "coloffset": 4,
        "linematch": "def action_next_button(self) -> None:",
        "context": "        checkboxes = self.query(Checkbox)\n        for checkbox in checkboxes:\n            checkbox.value = checkbox.label == label\n\n    def action_next_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[-1]:\n            checkboxes[0].focus()\n        else:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 83,
        "coloffset": 8,
        "linematch": "focused = self.app.focused",
        "context": "        for checkbox in checkboxes:\n            checkbox.value = checkbox.label == label\n\n    def action_next_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[-1]:\n            checkboxes[0].focus()\n        else:\n            self.app.action_focus_next()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 84,
        "coloffset": 8,
        "linematch": "checkboxes = list(self.query(Checkbox))",
        "context": "            checkbox.value = checkbox.label == label\n\n    def action_next_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[-1]:\n            checkboxes[0].focus()\n        else:\n            self.app.action_focus_next()\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 85,
        "coloffset": 8,
        "linematch": "if focused is checkboxes[-1]:",
        "context": "\n    def action_next_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[-1]:\n            checkboxes[0].focus()\n        else:\n            self.app.action_focus_next()\n\n    def action_previous_button(self) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #626",
        "line": 82,
        "description": [
          "            self.command_data = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -79,7 +79,7 @@\n     class Changed(Message):\n         def __init__(self, command_data: UserCommandData):\n             super().__init__()\n-            self.command_data = command_data\n+            self.command_data = None\n             \"\"\"The new data taken from the form to be converted into a CLI invocation.\"\"\"\n \n     def __init__(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "action_previous_button",
    "function_scope": "90-96",
    "patterns": [
      {
        "lineno": 93,
        "coloffset": 8,
        "linematch": "if focused is checkboxes[0]:",
        "context": "\n    def action_previous_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[0]:\n            checkboxes[-1].focus()\n        else:\n            self.app.action_focus_previous()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 90,
        "coloffset": 4,
        "linematch": "def action_previous_button(self) -> None:",
        "context": "            checkboxes[0].focus()\n        else:\n            self.app.action_focus_next()\n\n    def action_previous_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[0]:\n            checkboxes[-1].focus()\n        else:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 91,
        "coloffset": 8,
        "linematch": "focused = self.app.focused",
        "context": "        else:\n            self.app.action_focus_next()\n\n    def action_previous_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[0]:\n            checkboxes[-1].focus()\n        else:\n            self.app.action_focus_previous()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 92,
        "coloffset": 8,
        "linematch": "checkboxes = list(self.query(Checkbox))",
        "context": "            self.app.action_focus_next()\n\n    def action_previous_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[0]:\n            checkboxes[-1].focus()\n        else:\n            self.app.action_focus_previous()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 93,
        "coloffset": 8,
        "linematch": "if focused is checkboxes[0]:",
        "context": "\n    def action_previous_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[0]:\n            checkboxes[-1].focus()\n        else:\n            self.app.action_focus_previous()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #627",
        "line": 92,
        "description": [
          "        disabled: bool = False,"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -89,7 +89,7 @@\n         name: str | None = None,\n         id: str | None = None,\n         classes: str | None = None,\n-        disabled: bool = False,\n+        disabled: bool = True,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #628",
        "line": 95,
        "description": [
          "        self.command_schema = command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -92,7 +92,7 @@\n         disabled: bool = False,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n-        self.command_schema = command_schema\n+        self.command_schema = None\n         self.command_schemas = command_schemas\n         self.first_control: ParameterControls | None = None\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #629",
        "line": 96,
        "description": [
          "        self.command_schemas = command_schemas"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -93,7 +93,7 @@\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n-        self.command_schemas = command_schemas\n+        self.command_schemas = None\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "on_mount",
    "function_scope": "29-52",
    "patterns": [
      {
        "lineno": 35,
        "coloffset": 16,
        "linematch": "if cmd_name == self.command_name:",
        "context": "            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:\n                    continue\n                if cmd_data.subcommands:\n                    label = Text(cmd_name)\n                    if cmd_data.is_group:\n                        group_style = self.get_component_rich_style(\"group\")",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 37,
        "coloffset": 16,
        "linematch": "if cmd_data.subcommands:",
        "context": "            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:\n                    continue\n                if cmd_data.subcommands:\n                    label = Text(cmd_name)\n                    if cmd_data.is_group:\n                        group_style = self.get_component_rich_style(\"group\")\n                        label.stylize(group_style)\n                        label.append(\" \")",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 39,
        "coloffset": 20,
        "linematch": "if cmd_data.is_group:",
        "context": "                if cmd_name == self.command_name:\n                    continue\n                if cmd_data.subcommands:\n                    label = Text(cmd_name)\n                    if cmd_data.is_group:\n                        group_style = self.get_component_rich_style(\"group\")\n                        label.stylize(group_style)\n                        label.append(\" \")\n                        label.append(\"group\", \"dim i\")\n                    child = node.add(label, allow_expand=False, data=cmd_data)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 39,
        "coloffset": 20,
        "linematch": "if cmd_data.is_group:",
        "context": "                if cmd_name == self.command_name:\n                    continue\n                if cmd_data.subcommands:\n                    label = Text(cmd_name)\n                    if cmd_data.is_group:\n                        group_style = self.get_component_rich_style(\"group\")\n                        label.stylize(group_style)\n                        label.append(\" \")\n                        label.append(\"group\", \"dim i\")\n                    child = node.add(label, allow_expand=False, data=cmd_data)",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 35,
        "coloffset": 19,
        "linematch": "if cmd_name == self.command_name:",
        "context": "            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:\n                    continue\n                if cmd_data.subcommands:\n                    label = Text(cmd_name)\n                    if cmd_data.is_group:\n                        group_style = self.get_component_rich_style(\"group\")",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 236,
        "coloffset": 4,
        "linematch": "def on_mount(self):",
        "context": "        else:\n            self.app_name = app_name\n        self.command_name = command_name\n\n    def on_mount(self):\n        self.push_screen(CommandBuilder(self.cli, self.app_name, self.command_name))\n\n    @on(Button.Pressed, \"#home-exec-button\")\n    def on_button_pressed(self):\n        self.execute_on_exit = True",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "def on_mount(self):",
        "context": "        label = node._label.copy()\n        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 30,
        "coloffset": 8,
        "linematch": "def build_tree(",
        "context": "        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 79,
        "coloffset": 4,
        "linematch": "def on_mount(self) -> None:",
        "context": "            yield Static(self._message, id=\"message\", classes=\"spaced\")\n            with Center(classes=\"spaced\"):\n                yield Button(\"OK\", variant=self.button_style)\n\n    def on_mount(self) -> None:\n        \"\"\"Configure the dialog once the DOM has loaded.\"\"\"\n        self.query_one(Button).focus()\n\n    def on_button_pressed(self) -> None:\n        \"\"\"Handle the OK button being pressed.\"\"\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 142,
        "coloffset": 4,
        "linematch": "def on_mount(self) -> None:",
        "context": "                                yield controls\n\n                command_node = next(path_from_root, None)\n\n    def on_mount(self) -> None:\n        self._form_changed()\n\n    def on_input_changed(self) -> None:\n        self._form_changed()\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "def on_mount(self) -> None:",
        "context": "        self.zebra_stripes = True\n        self.cursor_type = \"none\"\n        self.command_schema = command_schema\n\n    def on_mount(self) -> None:\n        self.add_columns(\"Key\", \"Value\")\n        schema = self.command_schema\n        self.add_rows(\n            [\n                (Text(\"Name\", style=\"b\"), schema.name),",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 45,
        "coloffset": 54,
        "linematch": "(Text(\"Subcommands\", style=\"b\"), list(schema.subcommands.keys())),",
        "context": "                (\n                    Text(\"Parent\", style=\"b\"),\n                    getattr(schema.parent, \"name\", \"No parent\"),\n                ),\n                (Text(\"Subcommands\", style=\"b\"), list(schema.subcommands.keys())),\n                (Text(\"Group\", style=\"b\"), schema.is_group),\n                (Text(\"Arguments\", style=\"b\"), len(schema.arguments)),\n                (Text(\"Options\", style=\"b\"), len(schema.options)),\n            ]\n        )",
        "pattern": ".//FunctionDef//Call/func/Attribute[@attr=\"keys\"]",
        "check_id": "KF001",
        "check_name": "key-function"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "def on_mount(self):",
        "context": "        label = node._label.copy()\n        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 30,
        "coloffset": 8,
        "linematch": "def build_tree(",
        "context": "        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "def on_mount(self):",
        "context": "        label = node._label.copy()\n        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():",
        "pattern": ".//FunctionDef//FunctionDef/ancestor::*",
        "check_id": "F001",
        "check_name": "nested-depth"
      },
      {
        "lineno": 37,
        "coloffset": 16,
        "linematch": "if cmd_data.subcommands:",
        "context": "            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:\n                    continue\n                if cmd_data.subcommands:\n                    label = Text(cmd_name)\n                    if cmd_data.is_group:\n                        group_style = self.get_component_rich_style(\"group\")\n                        label.stylize(group_style)\n                        label.append(\" \")",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 39,
        "coloffset": 20,
        "linematch": "if cmd_data.is_group:",
        "context": "                if cmd_name == self.command_name:\n                    continue\n                if cmd_data.subcommands:\n                    label = Text(cmd_name)\n                    if cmd_data.is_group:\n                        group_style = self.get_component_rich_style(\"group\")\n                        label.stylize(group_style)\n                        label.append(\" \")\n                        label.append(\"group\", \"dim i\")\n                    child = node.add(label, allow_expand=False, data=cmd_data)",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 236,
        "coloffset": 4,
        "linematch": "def on_mount(self):",
        "context": "        else:\n            self.app_name = app_name\n        self.command_name = command_name\n\n    def on_mount(self):\n        self.push_screen(CommandBuilder(self.cli, self.app_name, self.command_name))\n\n    @on(Button.Pressed, \"#home-exec-button\")\n    def on_button_pressed(self):\n        self.execute_on_exit = True",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 237,
        "coloffset": 8,
        "linematch": "self.push_screen(CommandBuilder(self.cli, self.app_name, self.command_name))",
        "context": "            self.app_name = app_name\n        self.command_name = command_name\n\n    def on_mount(self):\n        self.push_screen(CommandBuilder(self.cli, self.app_name, self.command_name))\n\n    @on(Button.Pressed, \"#home-exec-button\")\n    def on_button_pressed(self):\n        self.execute_on_exit = True\n        self.exit()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 8,
        "linematch": "def build_tree(",
        "context": "        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 12,
        "linematch": "data = {key: data[key] for key in sorted(data)}",
        "context": "    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:\n                    continue\n                if cmd_data.subcommands:\n                    label = Text(cmd_name)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 12,
        "linematch": "for cmd_name, cmd_data in data.items():",
        "context": "        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:\n                    continue\n                if cmd_data.subcommands:\n                    label = Text(cmd_name)\n                    if cmd_data.is_group:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 48,
        "coloffset": 12,
        "linematch": "return node",
        "context": "                    child = node.add(label, allow_expand=False, data=cmd_data)\n                    build_tree(cmd_data.subcommands, child)\n                else:\n                    node.add_leaf(cmd_name, data=cmd_data)\n            return node\n\n        build_tree(self.cli_metadata, self.root)\n        self.root.expand_all()\n        self.select_node(self.root)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 8,
        "linematch": "build_tree(self.cli_metadata, self.root)",
        "context": "                else:\n                    node.add_leaf(cmd_name, data=cmd_data)\n            return node\n\n        build_tree(self.cli_metadata, self.root)\n        self.root.expand_all()\n        self.select_node(self.root)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 51,
        "coloffset": 8,
        "linematch": "self.root.expand_all()",
        "context": "                    node.add_leaf(cmd_name, data=cmd_data)\n            return node\n\n        build_tree(self.cli_metadata, self.root)\n        self.root.expand_all()\n        self.select_node(self.root)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 52,
        "coloffset": 8,
        "linematch": "self.select_node(self.root)",
        "context": "            return node\n\n        build_tree(self.cli_metadata, self.root)\n        self.root.expand_all()\n        self.select_node(self.root)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 80,
        "coloffset": 8,
        "linematch": "\"\"\"Configure the dialog once the DOM has loaded.\"\"\"",
        "context": "            with Center(classes=\"spaced\"):\n                yield Button(\"OK\", variant=self.button_style)\n\n    def on_mount(self) -> None:\n        \"\"\"Configure the dialog once the DOM has loaded.\"\"\"\n        self.query_one(Button).focus()\n\n    def on_button_pressed(self) -> None:\n        \"\"\"Handle the OK button being pressed.\"\"\"\n        self.dismiss(None)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 81,
        "coloffset": 8,
        "linematch": "self.query_one(Button).focus()",
        "context": "                yield Button(\"OK\", variant=self.button_style)\n\n    def on_mount(self) -> None:\n        \"\"\"Configure the dialog once the DOM has loaded.\"\"\"\n        self.query_one(Button).focus()\n\n    def on_button_pressed(self) -> None:\n        \"\"\"Handle the OK button being pressed.\"\"\"\n        self.dismiss(None)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 143,
        "coloffset": 8,
        "linematch": "self._form_changed()",
        "context": "\n                command_node = next(path_from_root, None)\n\n    def on_mount(self) -> None:\n        self._form_changed()\n\n    def on_input_changed(self) -> None:\n        self._form_changed()\n\n    def on_select_changed(self) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 8,
        "linematch": "self.add_columns(\"Key\", \"Value\")",
        "context": "        self.cursor_type = \"none\"\n        self.command_schema = command_schema\n\n    def on_mount(self) -> None:\n        self.add_columns(\"Key\", \"Value\")\n        schema = self.command_schema\n        self.add_rows(\n            [\n                (Text(\"Name\", style=\"b\"), schema.name),\n                (",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 8,
        "linematch": "schema = self.command_schema",
        "context": "        self.command_schema = command_schema\n\n    def on_mount(self) -> None:\n        self.add_columns(\"Key\", \"Value\")\n        schema = self.command_schema\n        self.add_rows(\n            [\n                (Text(\"Name\", style=\"b\"), schema.name),\n                (\n                    Text(\"Parent\", style=\"b\"),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 38,
        "coloffset": 8,
        "linematch": "self.add_rows(",
        "context": "\n    def on_mount(self) -> None:\n        self.add_columns(\"Key\", \"Value\")\n        schema = self.command_schema\n        self.add_rows(\n            [\n                (Text(\"Name\", style=\"b\"), schema.name),\n                (\n                    Text(\"Parent\", style=\"b\"),\n                    getattr(schema.parent, \"name\", \"No parent\"),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "def on_mount(self):",
        "context": "        label = node._label.copy()\n        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 30,
        "coloffset": 8,
        "linematch": "def build_tree(",
        "context": "        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "def on_mount(self):",
        "context": "        label = node._label.copy()\n        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      },
      {
        "lineno": 30,
        "coloffset": 8,
        "linematch": "def build_tree(",
        "context": "        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:\n            data = {key: data[key] for key in sorted(data)}\n            for cmd_name, cmd_data in data.items():\n                if cmd_name == self.command_name:",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #625",
        "line": 32,
        "description": [
          "    DEFAULT_CSS = \"\"\"    "
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -29,52 +29,7 @@\n     \"\"\"Form which is constructed from an introspected Click app. Users\n     make use of this form in order to construct CLI invocation strings.\"\"\"\n \n-    DEFAULT_CSS = \"\"\"    \n-    .command-form-heading {\n-        padding: 1 0 0 1;\n-        text-style: u;\n-        color: $text;\n-    }\n-    .command-form-input {        \n-        border: tall transparent;\n-    }\n-    .command-form-label {\n-        padding: 1 0 0 1;\n-    }\n-    .command-form-checkbox {\n-        background: $boost;\n-        margin: 1 0 0 0;\n-        padding-left: 1;\n-        border: tall transparent;\n-    }\n-    .command-form-checkbox:focus {\n-      border: tall $accent;      \n-    }\n-    .command-form-checkbox:focus > .toggle--label {\n-        text-style: none;\n-    }\n-    .command-form-command-group {\n-        \n-        margin: 1 2;\n-        padding: 0 1;\n-        height: auto;\n-        background: $foreground 3%;\n-        border: panel $background;\n-        border-title-color: $text 80%;\n-        border-title-style: bold;\n-        border-subtitle-color: $text 30%;\n-        padding-bottom: 1;\n-    }\n-    .command-form-command-group:focus-within {\n-        border: panel $primary;\n-    }\n-    .command-form-control-help-text {        \n-        height: auto;\n-        color: $text 40%;\n-        padding-top: 0;\n-        padding-left: 1;\n-    }\n-    \"\"\"\n+    DEFAULT_CSS = None\n \n     class Changed(Message):\n         def __init__(self, command_data: UserCommandData):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "apply_filter",
    "function_scope": "63-106",
    "patterns": [
      {
        "lineno": 73,
        "coloffset": 8,
        "linematch": "if not filter_query:",
        "context": "        Returns:\n            True if the filter matched (and the widget is visible).\n        \"\"\"\n        help_text = getattr(self.schema, \"help\", \"\") or \"\"\n        if not filter_query:\n            should_be_visible = True\n            self.display = should_be_visible\n        else:\n            name = self.schema.name\n            if isinstance(name, str):",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 95,
        "coloffset": 8,
        "linematch": "if help_text:",
        "context": "\n            self.display = should_be_visible\n\n        # Update the highlighting of the help text\n        if help_text:\n            try:\n                help_label = self.query_one(\".command-form-control-help-text\", Static)\n                new_help_text = Text(help_text)\n                new_help_text.highlight_words(\n                    filter_query.split(), \"black on yellow\", case_sensitive=False",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 78,
        "coloffset": 12,
        "linematch": "if isinstance(name, str):",
        "context": "            should_be_visible = True\n            self.display = should_be_visible\n        else:\n            name = self.schema.name\n            if isinstance(name, str):\n                # Argument names are strings, there's only one name\n                name_contains_query = filter_query in name.casefold()\n                should_be_visible = name_contains_query\n            else:\n                # Option names are lists since they can have multiple names (e.g. -v and --verbose)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "def apply_filter(self, filter_query: str) -> bool:",
        "context": "        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.schema = schema\n        self.first_control: Widget | None = None\n\n    def apply_filter(self, filter_query: str) -> bool:\n        \"\"\"Show or hide this ParameterControls depending on whether it matches the filter query or not.\n\n        Args:\n            filter_query: The string to filter on.\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 217,
        "coloffset": 4,
        "linematch": "def apply_filter(self, event: Input.Changed) -> None:",
        "context": "        if self.first_control is not None:\n            return self.first_control.focus()\n\n    @on(Input.Changed, \".command-form-filter-input\")\n    def apply_filter(self, event: Input.Changed) -> None:\n        filter_query = event.value\n        all_controls = self.query(ParameterControls)\n        for control in all_controls:\n            filter_query = filter_query.casefold()\n            control.apply_filter(filter_query)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "def apply_filter(self, filter_query: str) -> bool:",
        "context": "        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.schema = schema\n        self.first_control: Widget | None = None\n\n    def apply_filter(self, filter_query: str) -> bool:\n        \"\"\"Show or hide this ParameterControls depending on whether it matches the filter query or not.\n\n        Args:\n            filter_query: The string to filter on.\n",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 95,
        "coloffset": 8,
        "linematch": "if help_text:",
        "context": "\n            self.display = should_be_visible\n\n        # Update the highlighting of the help text\n        if help_text:\n            try:\n                help_label = self.query_one(\".command-form-control-help-text\", Static)\n                new_help_text = Text(help_text)\n                new_help_text.highlight_words(\n                    filter_query.split(), \"black on yellow\", case_sensitive=False",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 78,
        "coloffset": 12,
        "linematch": "if isinstance(name, str):",
        "context": "            should_be_visible = True\n            self.display = should_be_visible\n        else:\n            name = self.schema.name\n            if isinstance(name, str):\n                # Argument names are strings, there's only one name\n                name_contains_query = filter_query in name.casefold()\n                should_be_visible = name_contains_query\n            else:\n                # Option names are lists since they can have multiple names (e.g. -v and --verbose)",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "def apply_filter(self, filter_query: str) -> bool:",
        "context": "        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.schema = schema\n        self.first_control: Widget | None = None\n\n    def apply_filter(self, filter_query: str) -> bool:\n        \"\"\"Show or hide this ParameterControls depending on whether it matches the filter query or not.\n\n        Args:\n            filter_query: The string to filter on.\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 64,
        "coloffset": 8,
        "linematch": "\"\"\"Show or hide this ParameterControls depending on whether it matches the filter query or not.",
        "context": "        self.schema = schema\n        self.first_control: Widget | None = None\n\n    def apply_filter(self, filter_query: str) -> bool:\n        \"\"\"Show or hide this ParameterControls depending on whether it matches the filter query or not.\n\n        Args:\n            filter_query: The string to filter on.\n\n        Returns:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 72,
        "coloffset": 8,
        "linematch": "help_text = getattr(self.schema, \"help\", \"\") or \"\"",
        "context": "\n        Returns:\n            True if the filter matched (and the widget is visible).\n        \"\"\"\n        help_text = getattr(self.schema, \"help\", \"\") or \"\"\n        if not filter_query:\n            should_be_visible = True\n            self.display = should_be_visible\n        else:\n            name = self.schema.name",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 73,
        "coloffset": 8,
        "linematch": "if not filter_query:",
        "context": "        Returns:\n            True if the filter matched (and the widget is visible).\n        \"\"\"\n        help_text = getattr(self.schema, \"help\", \"\") or \"\"\n        if not filter_query:\n            should_be_visible = True\n            self.display = should_be_visible\n        else:\n            name = self.schema.name\n            if isinstance(name, str):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 95,
        "coloffset": 8,
        "linematch": "if help_text:",
        "context": "\n            self.display = should_be_visible\n\n        # Update the highlighting of the help text\n        if help_text:\n            try:\n                help_label = self.query_one(\".command-form-control-help-text\", Static)\n                new_help_text = Text(help_text)\n                new_help_text.highlight_words(\n                    filter_query.split(), \"black on yellow\", case_sensitive=False",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 106,
        "coloffset": 8,
        "linematch": "return should_be_visible",
        "context": "                help_label.update(new_help_text)\n            except NoMatches:\n                pass\n\n        return should_be_visible\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Takes the schemas for each parameter of the current command, and converts it into a\n        form consisting of Textual widgets.\"\"\"\n        schema = self.schema",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 218,
        "coloffset": 8,
        "linematch": "filter_query = event.value",
        "context": "            return self.first_control.focus()\n\n    @on(Input.Changed, \".command-form-filter-input\")\n    def apply_filter(self, event: Input.Changed) -> None:\n        filter_query = event.value\n        all_controls = self.query(ParameterControls)\n        for control in all_controls:\n            filter_query = filter_query.casefold()\n            control.apply_filter(filter_query)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 219,
        "coloffset": 8,
        "linematch": "all_controls = self.query(ParameterControls)",
        "context": "\n    @on(Input.Changed, \".command-form-filter-input\")\n    def apply_filter(self, event: Input.Changed) -> None:\n        filter_query = event.value\n        all_controls = self.query(ParameterControls)\n        for control in all_controls:\n            filter_query = filter_query.casefold()\n            control.apply_filter(filter_query)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 220,
        "coloffset": 8,
        "linematch": "for control in all_controls:",
        "context": "    @on(Input.Changed, \".command-form-filter-input\")\n    def apply_filter(self, event: Input.Changed) -> None:\n        filter_query = event.value\n        all_controls = self.query(ParameterControls)\n        for control in all_controls:\n            filter_query = filter_query.casefold()\n            control.apply_filter(filter_query)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "def apply_filter(self, filter_query: str) -> bool:",
        "context": "        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.schema = schema\n        self.first_control: Widget | None = None\n\n    def apply_filter(self, filter_query: str) -> bool:\n        \"\"\"Show or hide this ParameterControls depending on whether it matches the filter query or not.\n\n        Args:\n            filter_query: The string to filter on.\n",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 63,
        "coloffset": 4,
        "linematch": "def apply_filter(self, filter_query: str) -> bool:",
        "context": "        super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n        self.schema = schema\n        self.first_control: Widget | None = None\n\n    def apply_filter(self, filter_query: str) -> bool:\n        \"\"\"Show or hide this ParameterControls depending on whether it matches the filter query or not.\n\n        Args:\n            filter_query: The string to filter on.\n",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #626",
        "line": 82,
        "description": [
          "            self.command_data = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -79,7 +79,7 @@\n     class Changed(Message):\n         def __init__(self, command_data: UserCommandData):\n             super().__init__()\n-            self.command_data = command_data\n+            self.command_data = None\n             \"\"\"The new data taken from the form to be converted into a CLI invocation.\"\"\"\n \n     def __init__(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #627",
        "line": 92,
        "description": [
          "        disabled: bool = False,"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -89,7 +89,7 @@\n         name: str | None = None,\n         id: str | None = None,\n         classes: str | None = None,\n-        disabled: bool = False,\n+        disabled: bool = True,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #628",
        "line": 95,
        "description": [
          "        self.command_schema = command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -92,7 +92,7 @@\n         disabled: bool = False,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n-        self.command_schema = command_schema\n+        self.command_schema = None\n         self.command_schemas = command_schemas\n         self.first_control: ParameterControls | None = None\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #629",
        "line": 96,
        "description": [
          "        self.command_schemas = command_schemas"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -93,7 +93,7 @@\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n-        self.command_schemas = command_schemas\n+        self.command_schemas = None\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #630",
        "line": 97,
        "description": [
          "        self.first_control: ParameterControls | None = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -94,7 +94,7 @@\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n         self.command_schemas = command_schemas\n-        self.first_control: ParameterControls | None = None\n+        self.first_control: ParameterControls & None = None\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #631",
        "line": 97,
        "description": [
          "        self.first_control: ParameterControls | None = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -94,7 +94,7 @@\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n         self.command_schemas = command_schemas\n-        self.first_control: ParameterControls | None = None\n+        self.first_control: ParameterControls | None = \"\"\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #632",
        "line": 100,
        "description": [
          "        path_from_root = iter(reversed(self.command_schema.path_from_root))"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -97,7 +97,7 @@\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n-        path_from_root = iter(reversed(self.command_schema.path_from_root))\n+        path_from_root = None\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n             vs.can_focus = False\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #633",
        "line": 101,
        "description": [
          "        command_node = next(path_from_root)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -98,7 +98,7 @@\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n-        command_node = next(path_from_root)\n+        command_node = None\n         with VerticalScroll() as vs:\n             vs.can_focus = False\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #634",
        "line": 103,
        "description": [
          "            vs.can_focus = False"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -100,7 +100,7 @@\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n-            vs.can_focus = False\n+            vs.can_focus = True\n \n             yield Input(\n                 placeholder=\"Search...\",\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #635",
        "line": 103,
        "description": [
          "            vs.can_focus = False"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -100,7 +100,7 @@\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n-            vs.can_focus = False\n+            vs.can_focus = None\n \n             yield Input(\n                 placeholder=\"Search...\",\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #636",
        "line": 106,
        "description": [
          "                placeholder=\"Search...\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -103,7 +103,7 @@\n             vs.can_focus = False\n \n             yield Input(\n-                placeholder=\"Search...\",\n+                placeholder=\"XXSearch...XX\",\n                 classes=\"command-form-filter-input\",\n                 id=\"search\",\n             )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "add_another_widget_group",
    "function_scope": "228-236",
    "patterns": [
      {
        "lineno": 232,
        "coloffset": 8,
        "linematch": "if len(widget_group) <= 1:",
        "context": "    def add_another_widget_group(self, event: Button.Pressed) -> None:\n        widget_group = list(self.make_widget_group())\n        widget_group[0].focus()\n        control_group = ControlGroup(*widget_group)\n        if len(widget_group) <= 1:\n            control_group.add_class(\"single-item\")\n        control_groups_container = self.query_one(ControlGroupsContainer)\n        control_groups_container.mount(control_group)\n        event.button.scroll_visible(animate=False)\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 228,
        "coloffset": 4,
        "linematch": "def add_another_widget_group(self, event: Button.Pressed) -> None:",
        "context": "            )\n            yield from control_widgets\n\n    @on(Button.Pressed, \".add-another-button\")\n    def add_another_widget_group(self, event: Button.Pressed) -> None:\n        widget_group = list(self.make_widget_group())\n        widget_group[0].focus()\n        control_group = ControlGroup(*widget_group)\n        if len(widget_group) <= 1:\n            control_group.add_class(\"single-item\")",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 228,
        "coloffset": 4,
        "linematch": "def add_another_widget_group(self, event: Button.Pressed) -> None:",
        "context": "            )\n            yield from control_widgets\n\n    @on(Button.Pressed, \".add-another-button\")\n    def add_another_widget_group(self, event: Button.Pressed) -> None:\n        widget_group = list(self.make_widget_group())\n        widget_group[0].focus()\n        control_group = ControlGroup(*widget_group)\n        if len(widget_group) <= 1:\n            control_group.add_class(\"single-item\")",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 229,
        "coloffset": 8,
        "linematch": "widget_group = list(self.make_widget_group())",
        "context": "            yield from control_widgets\n\n    @on(Button.Pressed, \".add-another-button\")\n    def add_another_widget_group(self, event: Button.Pressed) -> None:\n        widget_group = list(self.make_widget_group())\n        widget_group[0].focus()\n        control_group = ControlGroup(*widget_group)\n        if len(widget_group) <= 1:\n            control_group.add_class(\"single-item\")\n        control_groups_container = self.query_one(ControlGroupsContainer)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 230,
        "coloffset": 8,
        "linematch": "widget_group[0].focus()",
        "context": "\n    @on(Button.Pressed, \".add-another-button\")\n    def add_another_widget_group(self, event: Button.Pressed) -> None:\n        widget_group = list(self.make_widget_group())\n        widget_group[0].focus()\n        control_group = ControlGroup(*widget_group)\n        if len(widget_group) <= 1:\n            control_group.add_class(\"single-item\")\n        control_groups_container = self.query_one(ControlGroupsContainer)\n        control_groups_container.mount(control_group)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 231,
        "coloffset": 8,
        "linematch": "control_group = ControlGroup(*widget_group)",
        "context": "    @on(Button.Pressed, \".add-another-button\")\n    def add_another_widget_group(self, event: Button.Pressed) -> None:\n        widget_group = list(self.make_widget_group())\n        widget_group[0].focus()\n        control_group = ControlGroup(*widget_group)\n        if len(widget_group) <= 1:\n            control_group.add_class(\"single-item\")\n        control_groups_container = self.query_one(ControlGroupsContainer)\n        control_groups_container.mount(control_group)\n        event.button.scroll_visible(animate=False)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 232,
        "coloffset": 8,
        "linematch": "if len(widget_group) <= 1:",
        "context": "    def add_another_widget_group(self, event: Button.Pressed) -> None:\n        widget_group = list(self.make_widget_group())\n        widget_group[0].focus()\n        control_group = ControlGroup(*widget_group)\n        if len(widget_group) <= 1:\n            control_group.add_class(\"single-item\")\n        control_groups_container = self.query_one(ControlGroupsContainer)\n        control_groups_container.mount(control_group)\n        event.button.scroll_visible(animate=False)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 234,
        "coloffset": 8,
        "linematch": "control_groups_container = self.query_one(ControlGroupsContainer)",
        "context": "        widget_group[0].focus()\n        control_group = ControlGroup(*widget_group)\n        if len(widget_group) <= 1:\n            control_group.add_class(\"single-item\")\n        control_groups_container = self.query_one(ControlGroupsContainer)\n        control_groups_container.mount(control_group)\n        event.button.scroll_visible(animate=False)\n\n    @staticmethod\n    def _apply_default_value(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 235,
        "coloffset": 8,
        "linematch": "control_groups_container.mount(control_group)",
        "context": "        control_group = ControlGroup(*widget_group)\n        if len(widget_group) <= 1:\n            control_group.add_class(\"single-item\")\n        control_groups_container = self.query_one(ControlGroupsContainer)\n        control_groups_container.mount(control_group)\n        event.button.scroll_visible(animate=False)\n\n    @staticmethod\n    def _apply_default_value(\n        control_widget: ControlWidgetType, default_value: Any",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 236,
        "coloffset": 8,
        "linematch": "event.button.scroll_visible(animate=False)",
        "context": "        if len(widget_group) <= 1:\n            control_group.add_class(\"single-item\")\n        control_groups_container = self.query_one(ControlGroupsContainer)\n        control_groups_container.mount(control_group)\n        event.button.scroll_visible(animate=False)\n\n    @staticmethod\n    def _apply_default_value(\n        control_widget: ControlWidgetType, default_value: Any\n    ) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "_apply_default_value",
    "function_scope": "239-248",
    "patterns": [
      {
        "lineno": 243,
        "coloffset": 8,
        "linematch": "if isinstance(control_widget, Input):",
        "context": "    def _apply_default_value(\n        control_widget: ControlWidgetType, default_value: Any\n    ) -> None:\n        \"\"\"Set the default value of a parameter-handling widget.\"\"\"\n        if isinstance(control_widget, Input):\n            control_widget.value = str(default_value)\n            control_widget.placeholder = f\"{default_value} (default)\"\n        elif isinstance(control_widget, Select):\n            control_widget.value = str(default_value)\n            control_widget.prompt = f\"{default_value} (default)\"",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 246,
        "coloffset": 8,
        "linematch": "elif isinstance(control_widget, Select):",
        "context": "        \"\"\"Set the default value of a parameter-handling widget.\"\"\"\n        if isinstance(control_widget, Input):\n            control_widget.value = str(default_value)\n            control_widget.placeholder = f\"{default_value} (default)\"\n        elif isinstance(control_widget, Select):\n            control_widget.value = str(default_value)\n            control_widget.prompt = f\"{default_value} (default)\"\n\n    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 239,
        "coloffset": 4,
        "linematch": "def _apply_default_value(",
        "context": "        control_groups_container.mount(control_group)\n        event.button.scroll_visible(animate=False)\n\n    @staticmethod\n    def _apply_default_value(\n        control_widget: ControlWidgetType, default_value: Any\n    ) -> None:\n        \"\"\"Set the default value of a parameter-handling widget.\"\"\"\n        if isinstance(control_widget, Input):\n            control_widget.value = str(default_value)",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 246,
        "coloffset": 8,
        "linematch": "elif isinstance(control_widget, Select):",
        "context": "        \"\"\"Set the default value of a parameter-handling widget.\"\"\"\n        if isinstance(control_widget, Input):\n            control_widget.value = str(default_value)\n            control_widget.placeholder = f\"{default_value} (default)\"\n        elif isinstance(control_widget, Select):\n            control_widget.value = str(default_value)\n            control_widget.prompt = f\"{default_value} (default)\"\n\n    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 239,
        "coloffset": 4,
        "linematch": "def _apply_default_value(",
        "context": "        control_groups_container.mount(control_group)\n        event.button.scroll_visible(animate=False)\n\n    @staticmethod\n    def _apply_default_value(\n        control_widget: ControlWidgetType, default_value: Any\n    ) -> None:\n        \"\"\"Set the default value of a parameter-handling widget.\"\"\"\n        if isinstance(control_widget, Input):\n            control_widget.value = str(default_value)",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 242,
        "coloffset": 8,
        "linematch": "\"\"\"Set the default value of a parameter-handling widget.\"\"\"",
        "context": "    @staticmethod\n    def _apply_default_value(\n        control_widget: ControlWidgetType, default_value: Any\n    ) -> None:\n        \"\"\"Set the default value of a parameter-handling widget.\"\"\"\n        if isinstance(control_widget, Input):\n            control_widget.value = str(default_value)\n            control_widget.placeholder = f\"{default_value} (default)\"\n        elif isinstance(control_widget, Select):\n            control_widget.value = str(default_value)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 243,
        "coloffset": 8,
        "linematch": "if isinstance(control_widget, Input):",
        "context": "    def _apply_default_value(\n        control_widget: ControlWidgetType, default_value: Any\n    ) -> None:\n        \"\"\"Set the default value of a parameter-handling widget.\"\"\"\n        if isinstance(control_widget, Input):\n            control_widget.value = str(default_value)\n            control_widget.placeholder = f\"{default_value} (default)\"\n        elif isinstance(control_widget, Select):\n            control_widget.value = str(default_value)\n            control_widget.prompt = f\"{default_value} (default)\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "_get_form_control_value",
    "function_scope": "251-263",
    "patterns": [
      {
        "lineno": 252,
        "coloffset": 8,
        "linematch": "if isinstance(control, MultipleChoice):",
        "context": "            control_widget.prompt = f\"{default_value} (default)\"\n\n    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()\n            return control.value",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 254,
        "coloffset": 8,
        "linematch": "elif isinstance(control, Select):",
        "context": "    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 255,
        "coloffset": 12,
        "linematch": "if control.value is None:",
        "context": "    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 258,
        "coloffset": 8,
        "linematch": "elif isinstance(control, Input):",
        "context": "        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 262,
        "coloffset": 8,
        "linematch": "elif isinstance(control, Checkbox):",
        "context": "        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 255,
        "coloffset": 12,
        "linematch": "if control.value is None:",
        "context": "    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 260,
        "coloffset": 38,
        "linematch": "ValueNotSupplied() if control.value == \"\" else control.value",
        "context": "                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 260,
        "coloffset": 38,
        "linematch": "ValueNotSupplied() if control.value == \"\" else control.value",
        "context": "                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 260,
        "coloffset": 38,
        "linematch": "ValueNotSupplied() if control.value == \"\" else control.value",
        "context": "                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 260,
        "coloffset": 38,
        "linematch": "ValueNotSupplied() if control.value == \"\" else control.value",
        "context": "                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 260,
        "coloffset": 38,
        "linematch": "ValueNotSupplied() if control.value == \"\" else control.value",
        "context": "                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 260,
        "coloffset": 38,
        "linematch": "ValueNotSupplied() if control.value == \"\" else control.value",
        "context": "                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 260,
        "coloffset": 38,
        "linematch": "ValueNotSupplied() if control.value == \"\" else control.value",
        "context": "                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 260,
        "coloffset": 38,
        "linematch": "ValueNotSupplied() if control.value == \"\" else control.value",
        "context": "                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 260,
        "coloffset": 38,
        "linematch": "ValueNotSupplied() if control.value == \"\" else control.value",
        "context": "                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 251,
        "coloffset": 4,
        "linematch": "def _get_form_control_value(control: ControlWidgetType) -> Any:",
        "context": "            control_widget.value = str(default_value)\n            control_widget.prompt = f\"{default_value} (default)\"\n\n    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 254,
        "coloffset": 8,
        "linematch": "elif isinstance(control, Select):",
        "context": "    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 255,
        "coloffset": 12,
        "linematch": "if control.value is None:",
        "context": "    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 258,
        "coloffset": 8,
        "linematch": "elif isinstance(control, Input):",
        "context": "        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()\n            return control.value\n        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 262,
        "coloffset": 8,
        "linematch": "elif isinstance(control, Checkbox):",
        "context": "        elif isinstance(control, Input):\n            return (\n                ValueNotSupplied() if control.value == \"\" else control.value\n            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 251,
        "coloffset": 4,
        "linematch": "def _get_form_control_value(control: ControlWidgetType) -> Any:",
        "context": "            control_widget.value = str(default_value)\n            control_widget.prompt = f\"{default_value} (default)\"\n\n    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 252,
        "coloffset": 8,
        "linematch": "if isinstance(control, MultipleChoice):",
        "context": "            control_widget.prompt = f\"{default_value} (default)\"\n\n    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()\n            return control.value",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 251,
        "coloffset": 4,
        "linematch": "def _get_form_control_value(control: ControlWidgetType) -> Any:",
        "context": "            control_widget.value = str(default_value)\n            control_widget.prompt = f\"{default_value} (default)\"\n\n    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()",
        "pattern": ".//FunctionDef[count(body//Return) > 2]",
        "check_id": "MRET001",
        "check_name": "multiple-returns-in-function"
      },
      {
        "lineno": 251,
        "coloffset": 4,
        "linematch": "def _get_form_control_value(control: ControlWidgetType) -> Any:",
        "context": "            control_widget.value = str(default_value)\n            control_widget.prompt = f\"{default_value} (default)\"\n\n    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 251,
        "coloffset": 4,
        "linematch": "def _get_form_control_value(control: ControlWidgetType) -> Any:",
        "context": "            control_widget.value = str(default_value)\n            control_widget.prompt = f\"{default_value} (default)\"\n\n    @staticmethod\n    def _get_form_control_value(control: ControlWidgetType) -> Any:\n        if isinstance(control, MultipleChoice):\n            return control.selected\n        elif isinstance(control, Select):\n            if control.value is None:\n                return ValueNotSupplied()",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "get_values",
    "function_scope": "265-305",
    "patterns": [
      {
        "lineno": 283,
        "coloffset": 8,
        "linematch": "if len(controls) == 1 and isinstance(controls[0], MultipleChoice):",
        "context": "            ]\n\n        controls = list(self.query(f\".{self.schema.key}\"))\n\n        if len(controls) == 1 and isinstance(controls[0], MultipleChoice):\n            # Since MultipleChoice widgets are a special case that appear in\n            # isolation, our logic to fetch the values out of them is slightly\n            # modified from the nominal case presented in the other branch.\n            # MultiChoice never appears for multi-value options, only for options\n            # where multiple=True.",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 272,
        "coloffset": 12,
        "linematch": "if tuple_size == 0:",
        "context": "\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int\n        ) -> list[tuple[int | float | str, ...]]:\n            if tuple_size == 0:\n                return [tuple()]\n            elif tuple_size == -1:\n                # Unspecified number of arguments as per Click docs.\n                tuple_size = 1\n            return [",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 274,
        "coloffset": 12,
        "linematch": "elif tuple_size == -1:",
        "context": "            lst: list[int | float | str], tuple_size: int\n        ) -> list[tuple[int | float | str, ...]]:\n            if tuple_size == 0:\n                return [tuple()]\n            elif tuple_size == -1:\n                # Unspecified number of arguments as per Click docs.\n                tuple_size = 1\n            return [\n                tuple(lst[i : i + tuple_size]) for i in range(0, len(lst), tuple_size)\n            ]",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 265,
        "coloffset": 4,
        "linematch": "def get_values(self) -> MultiValueParamData:",
        "context": "            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 269,
        "coloffset": 8,
        "linematch": "def list_to_tuples(",
        "context": "    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int\n        ) -> list[tuple[int | float | str, ...]]:\n            if tuple_size == 0:\n                return [tuple()]\n            elif tuple_size == -1:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 265,
        "coloffset": 4,
        "linematch": "def get_values(self) -> MultiValueParamData:",
        "context": "            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 269,
        "coloffset": 8,
        "linematch": "def list_to_tuples(",
        "context": "    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int\n        ) -> list[tuple[int | float | str, ...]]:\n            if tuple_size == 0:\n                return [tuple()]\n            elif tuple_size == -1:",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 265,
        "coloffset": 4,
        "linematch": "def get_values(self) -> MultiValueParamData:",
        "context": "            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int",
        "pattern": ".//FunctionDef//FunctionDef/ancestor::*",
        "check_id": "F001",
        "check_name": "nested-depth"
      },
      {
        "lineno": 274,
        "coloffset": 12,
        "linematch": "elif tuple_size == -1:",
        "context": "            lst: list[int | float | str], tuple_size: int\n        ) -> list[tuple[int | float | str, ...]]:\n            if tuple_size == 0:\n                return [tuple()]\n            elif tuple_size == -1:\n                # Unspecified number of arguments as per Click docs.\n                tuple_size = 1\n            return [\n                tuple(lst[i : i + tuple_size]) for i in range(0, len(lst), tuple_size)\n            ]",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 265,
        "coloffset": 4,
        "linematch": "def get_values(self) -> MultiValueParamData:",
        "context": "            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 269,
        "coloffset": 8,
        "linematch": "def list_to_tuples(",
        "context": "    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int\n        ) -> list[tuple[int | float | str, ...]]:\n            if tuple_size == 0:\n                return [tuple()]\n            elif tuple_size == -1:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 269,
        "coloffset": 8,
        "linematch": "def list_to_tuples(",
        "context": "    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int\n        ) -> list[tuple[int | float | str, ...]]:\n            if tuple_size == 0:\n                return [tuple()]\n            elif tuple_size == -1:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 272,
        "coloffset": 12,
        "linematch": "if tuple_size == 0:",
        "context": "\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int\n        ) -> list[tuple[int | float | str, ...]]:\n            if tuple_size == 0:\n                return [tuple()]\n            elif tuple_size == -1:\n                # Unspecified number of arguments as per Click docs.\n                tuple_size = 1\n            return [",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 277,
        "coloffset": 12,
        "linematch": "return [",
        "context": "                return [tuple()]\n            elif tuple_size == -1:\n                # Unspecified number of arguments as per Click docs.\n                tuple_size = 1\n            return [\n                tuple(lst[i : i + tuple_size]) for i in range(0, len(lst), tuple_size)\n            ]\n\n        controls = list(self.query(f\".{self.schema.key}\"))\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 281,
        "coloffset": 8,
        "linematch": "controls = list(self.query(f\".{self.schema.key}\"))",
        "context": "            return [\n                tuple(lst[i : i + tuple_size]) for i in range(0, len(lst), tuple_size)\n            ]\n\n        controls = list(self.query(f\".{self.schema.key}\"))\n\n        if len(controls) == 1 and isinstance(controls[0], MultipleChoice):\n            # Since MultipleChoice widgets are a special case that appear in\n            # isolation, our logic to fetch the values out of them is slightly\n            # modified from the nominal case presented in the other branch.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 283,
        "coloffset": 8,
        "linematch": "if len(controls) == 1 and isinstance(controls[0], MultipleChoice):",
        "context": "            ]\n\n        controls = list(self.query(f\".{self.schema.key}\"))\n\n        if len(controls) == 1 and isinstance(controls[0], MultipleChoice):\n            # Since MultipleChoice widgets are a special case that appear in\n            # isolation, our logic to fetch the values out of them is slightly\n            # modified from the nominal case presented in the other branch.\n            # MultiChoice never appears for multi-value options, only for options\n            # where multiple=True.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 265,
        "coloffset": 4,
        "linematch": "def get_values(self) -> MultiValueParamData:",
        "context": "            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int",
        "pattern": ".//FunctionDef[count(body//Return) > 2]",
        "check_id": "MRET001",
        "check_name": "multiple-returns-in-function"
      },
      {
        "lineno": 265,
        "coloffset": 4,
        "linematch": "def get_values(self) -> MultiValueParamData:",
        "context": "            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 265,
        "coloffset": 4,
        "linematch": "def get_values(self) -> MultiValueParamData:",
        "context": "            )  # TODO: We should only return \"\" when user selects a checkbox - needs custom widget.\n        elif isinstance(control, Checkbox):\n            return control.value\n\n    def get_values(self) -> MultiValueParamData:\n        # We can find all relevant control widgets by querying the parameter schema\n        # key as a class.\n\n        def list_to_tuples(\n            lst: list[int | float | str], tuple_size: int",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "get_control_method",
    "function_scope": "307-334",
    "patterns": [
      {
        "lineno": 327,
        "coloffset": 8,
        "linematch": "if is_text_type:",
        "context": "\n        is_text_type = argument_type in text_click_types or isinstance(\n            argument_type, text_types\n        )\n        if is_text_type:\n            return self.make_text_control\n        elif argument_type == click.BOOL:\n            return self.make_checkbox_control\n        elif isinstance(argument_type, click.types.Choice):\n            return partial(self.make_choice_control, choices=argument_type.choices)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 329,
        "coloffset": 8,
        "linematch": "elif argument_type == click.BOOL:",
        "context": "            argument_type, text_types\n        )\n        if is_text_type:\n            return self.make_text_control\n        elif argument_type == click.BOOL:\n            return self.make_checkbox_control\n        elif isinstance(argument_type, click.types.Choice):\n            return partial(self.make_choice_control, choices=argument_type.choices)\n        else:\n            return self.make_text_control",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 331,
        "coloffset": 8,
        "linematch": "elif isinstance(argument_type, click.types.Choice):",
        "context": "        if is_text_type:\n            return self.make_text_control\n        elif argument_type == click.BOOL:\n            return self.make_checkbox_control\n        elif isinstance(argument_type, click.types.Choice):\n            return partial(self.make_choice_control, choices=argument_type.choices)\n        else:\n            return self.make_text_control\n\n    @staticmethod",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 307,
        "coloffset": 4,
        "linematch": "def get_control_method(",
        "context": "            # of widget values into a list of tuples, each tuple of length nargs.\n            collected_values = list_to_tuples(collected_values, self.schema.nargs)\n            return MultiValueParamData.process_cli_option(collected_values)\n\n    def get_control_method(\n        self, argument_type: Any\n    ) -> Callable[[Any, Text, bool, OptionSchema | ArgumentSchema, str], Widget]:\n        text_click_types = {\n            click.STRING,\n            click.FLOAT,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 329,
        "coloffset": 8,
        "linematch": "elif argument_type == click.BOOL:",
        "context": "            argument_type, text_types\n        )\n        if is_text_type:\n            return self.make_text_control\n        elif argument_type == click.BOOL:\n            return self.make_checkbox_control\n        elif isinstance(argument_type, click.types.Choice):\n            return partial(self.make_choice_control, choices=argument_type.choices)\n        else:\n            return self.make_text_control",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 331,
        "coloffset": 8,
        "linematch": "elif isinstance(argument_type, click.types.Choice):",
        "context": "        if is_text_type:\n            return self.make_text_control\n        elif argument_type == click.BOOL:\n            return self.make_checkbox_control\n        elif isinstance(argument_type, click.types.Choice):\n            return partial(self.make_choice_control, choices=argument_type.choices)\n        else:\n            return self.make_text_control\n\n    @staticmethod",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 307,
        "coloffset": 4,
        "linematch": "def get_control_method(",
        "context": "            # of widget values into a list of tuples, each tuple of length nargs.\n            collected_values = list_to_tuples(collected_values, self.schema.nargs)\n            return MultiValueParamData.process_cli_option(collected_values)\n\n    def get_control_method(\n        self, argument_type: Any\n    ) -> Callable[[Any, Text, bool, OptionSchema | ArgumentSchema, str], Widget]:\n        text_click_types = {\n            click.STRING,\n            click.FLOAT,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 310,
        "coloffset": 8,
        "linematch": "text_click_types = {",
        "context": "\n    def get_control_method(\n        self, argument_type: Any\n    ) -> Callable[[Any, Text, bool, OptionSchema | ArgumentSchema, str], Widget]:\n        text_click_types = {\n            click.STRING,\n            click.FLOAT,\n            click.INT,\n            click.UUID,\n        }",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 316,
        "coloffset": 8,
        "linematch": "text_types = (",
        "context": "            click.FLOAT,\n            click.INT,\n            click.UUID,\n        }\n        text_types = (\n            click.Path,\n            click.File,\n            click.IntRange,\n            click.FloatRange,\n            click.types.FuncParamType,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 324,
        "coloffset": 8,
        "linematch": "is_text_type = argument_type in text_click_types or isinstance(",
        "context": "            click.FloatRange,\n            click.types.FuncParamType,\n        )\n\n        is_text_type = argument_type in text_click_types or isinstance(\n            argument_type, text_types\n        )\n        if is_text_type:\n            return self.make_text_control\n        elif argument_type == click.BOOL:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 327,
        "coloffset": 8,
        "linematch": "if is_text_type:",
        "context": "\n        is_text_type = argument_type in text_click_types or isinstance(\n            argument_type, text_types\n        )\n        if is_text_type:\n            return self.make_text_control\n        elif argument_type == click.BOOL:\n            return self.make_checkbox_control\n        elif isinstance(argument_type, click.types.Choice):\n            return partial(self.make_choice_control, choices=argument_type.choices)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 307,
        "coloffset": 4,
        "linematch": "def get_control_method(",
        "context": "            # of widget values into a list of tuples, each tuple of length nargs.\n            collected_values = list_to_tuples(collected_values, self.schema.nargs)\n            return MultiValueParamData.process_cli_option(collected_values)\n\n    def get_control_method(\n        self, argument_type: Any\n    ) -> Callable[[Any, Text, bool, OptionSchema | ArgumentSchema, str], Widget]:\n        text_click_types = {\n            click.STRING,\n            click.FLOAT,",
        "pattern": ".//FunctionDef[count(body//Return) > 2]",
        "check_id": "MRET001",
        "check_name": "multiple-returns-in-function"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "make_checkbox_control",
    "function_scope": "351-370",
    "patterns": [
      {
        "lineno": 358,
        "coloffset": 8,
        "linematch": "if default.values:",
        "context": "        multiple: bool,\n        schema: OptionSchema | ArgumentSchema,\n        control_id: str,\n    ) -> Widget:\n        if default.values:\n            default = default.values[0][0]\n        else:\n            default = ValueNotSupplied()\n\n        control = Checkbox(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 351,
        "coloffset": 4,
        "linematch": "def make_checkbox_control(",
        "context": "        yield control\n        return control\n\n    @staticmethod\n    def make_checkbox_control(\n        default: MultiValueParamData,\n        label: Text | None,\n        multiple: bool,\n        schema: OptionSchema | ArgumentSchema,\n        control_id: str,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 351,
        "coloffset": 4,
        "linematch": "def make_checkbox_control(",
        "context": "        yield control\n        return control\n\n    @staticmethod\n    def make_checkbox_control(\n        default: MultiValueParamData,\n        label: Text | None,\n        multiple: bool,\n        schema: OptionSchema | ArgumentSchema,\n        control_id: str,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 358,
        "coloffset": 8,
        "linematch": "if default.values:",
        "context": "        multiple: bool,\n        schema: OptionSchema | ArgumentSchema,\n        control_id: str,\n    ) -> Widget:\n        if default.values:\n            default = default.values[0][0]\n        else:\n            default = ValueNotSupplied()\n\n        control = Checkbox(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 363,
        "coloffset": 8,
        "linematch": "control = Checkbox(",
        "context": "            default = default.values[0][0]\n        else:\n            default = ValueNotSupplied()\n\n        control = Checkbox(\n            label,\n            button_first=True,\n            classes=f\"command-form-checkbox {control_id}\",\n            value=default,\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 369,
        "coloffset": 8,
        "linematch": "yield control",
        "context": "            button_first=True,\n            classes=f\"command-form-checkbox {control_id}\",\n            value=default,\n        )\n        yield control\n        return control\n\n    @staticmethod\n    def make_choice_control(\n        default: MultiValueParamData,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 370,
        "coloffset": 8,
        "linematch": "return control",
        "context": "            classes=f\"command-form-checkbox {control_id}\",\n            value=default,\n        )\n        yield control\n        return control\n\n    @staticmethod\n    def make_choice_control(\n        default: MultiValueParamData,\n        label: Text | None,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "make_choice_control",
    "function_scope": "373-399",
    "patterns": [
      {
        "lineno": 382,
        "coloffset": 8,
        "linematch": "if isinstance(schema.type, click.Tuple):",
        "context": "        control_id: str,\n        choices: list[str],\n    ) -> Widget:\n        # The MultipleChoice widget is only for single-valued parameters.\n        if isinstance(schema.type, click.Tuple):\n            multiple = False\n\n        if multiple:\n            multi_choice = MultipleChoice(\n                choices,",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 385,
        "coloffset": 8,
        "linematch": "if multiple:",
        "context": "        # The MultipleChoice widget is only for single-valued parameters.\n        if isinstance(schema.type, click.Tuple):\n            multiple = False\n\n        if multiple:\n            multi_choice = MultipleChoice(\n                choices,\n                classes=f\"command-form-multiple-choice {control_id}\",\n                defaults=default.values,\n            )",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 373,
        "coloffset": 4,
        "linematch": "def make_choice_control(",
        "context": "        yield control\n        return control\n\n    @staticmethod\n    def make_choice_control(\n        default: MultiValueParamData,\n        label: Text | None,\n        multiple: bool,\n        schema: OptionSchema | ArgumentSchema,\n        control_id: str,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 373,
        "coloffset": 4,
        "linematch": "def make_choice_control(",
        "context": "        yield control\n        return control\n\n    @staticmethod\n    def make_choice_control(\n        default: MultiValueParamData,\n        label: Text | None,\n        multiple: bool,\n        schema: OptionSchema | ArgumentSchema,\n        control_id: str,",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 385,
        "coloffset": 8,
        "linematch": "if multiple:",
        "context": "        # The MultipleChoice widget is only for single-valued parameters.\n        if isinstance(schema.type, click.Tuple):\n            multiple = False\n\n        if multiple:\n            multi_choice = MultipleChoice(\n                choices,\n                classes=f\"command-form-multiple-choice {control_id}\",\n                defaults=default.values,\n            )",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 373,
        "coloffset": 4,
        "linematch": "def make_choice_control(",
        "context": "        yield control\n        return control\n\n    @staticmethod\n    def make_choice_control(\n        default: MultiValueParamData,\n        label: Text | None,\n        multiple: bool,\n        schema: OptionSchema | ArgumentSchema,\n        control_id: str,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 382,
        "coloffset": 8,
        "linematch": "if isinstance(schema.type, click.Tuple):",
        "context": "        control_id: str,\n        choices: list[str],\n    ) -> Widget:\n        # The MultipleChoice widget is only for single-valued parameters.\n        if isinstance(schema.type, click.Tuple):\n            multiple = False\n\n        if multiple:\n            multi_choice = MultipleChoice(\n                choices,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 385,
        "coloffset": 8,
        "linematch": "if multiple:",
        "context": "        # The MultipleChoice widget is only for single-valued parameters.\n        if isinstance(schema.type, click.Tuple):\n            multiple = False\n\n        if multiple:\n            multi_choice = MultipleChoice(\n                choices,\n                classes=f\"command-form-multiple-choice {control_id}\",\n                defaults=default.values,\n            )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "_make_command_form_control_label",
    "function_scope": "402-425",
    "patterns": [
      {
        "lineno": 409,
        "coloffset": 8,
        "linematch": "if isinstance(name, str):",
        "context": "        is_option: bool,\n        is_required: bool,\n        multiple: bool,\n    ) -> Text:\n        if isinstance(name, str):\n            text = Text.from_markup(\n                f\"{name}[dim]{' multiple' if multiple else ''} {type.name}[/] {' [b red]*[/]required' if is_required else ''}\"\n            )\n        else:\n            names = Text(\" / \", style=\"dim\").join([Text(n) for n in name])",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 419,
        "coloffset": 8,
        "linematch": "if isinstance(type, (click.IntRange, click.FloatRange)):",
        "context": "            text = Text.from_markup(\n                f\"{names}[dim]{' multiple' if multiple else ''} {type.name}[/] {' [b red]*[/]required' if is_required else ''}\"\n            )\n\n        if isinstance(type, (click.IntRange, click.FloatRange)):\n            if type.min is not None:\n                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 420,
        "coloffset": 12,
        "linematch": "if type.min is not None:",
        "context": "                f\"{names}[dim]{' multiple' if multiple else ''} {type.name}[/] {' [b red]*[/]required' if is_required else ''}\"\n            )\n\n        if isinstance(type, (click.IntRange, click.FloatRange)):\n            if type.min is not None:\n                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n\n        return text",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 422,
        "coloffset": 12,
        "linematch": "if type.max is not None:",
        "context": "\n        if isinstance(type, (click.IntRange, click.FloatRange)):\n            if type.min is not None:\n                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n\n        return text\n\n    def focus(self, scroll_visible: bool = True):",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 420,
        "coloffset": 12,
        "linematch": "if type.min is not None:",
        "context": "                f\"{names}[dim]{' multiple' if multiple else ''} {type.name}[/] {' [b red]*[/]required' if is_required else ''}\"\n            )\n\n        if isinstance(type, (click.IntRange, click.FloatRange)):\n            if type.min is not None:\n                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n\n        return text",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 422,
        "coloffset": 12,
        "linematch": "if type.max is not None:",
        "context": "\n        if isinstance(type, (click.IntRange, click.FloatRange)):\n            if type.min is not None:\n                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n\n        return text\n\n    def focus(self, scroll_visible: bool = True):",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "double-nested-if"
      },
      {
        "lineno": 402,
        "coloffset": 4,
        "linematch": "def _make_command_form_control_label(",
        "context": "            yield select\n            return select\n\n    @staticmethod\n    def _make_command_form_control_label(\n        name: str | list[str],\n        type: click.ParamType,\n        is_option: bool,\n        is_required: bool,\n        multiple: bool,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 402,
        "coloffset": 4,
        "linematch": "def _make_command_form_control_label(",
        "context": "            yield select\n            return select\n\n    @staticmethod\n    def _make_command_form_control_label(\n        name: str | list[str],\n        type: click.ParamType,\n        is_option: bool,\n        is_required: bool,\n        multiple: bool,",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 419,
        "coloffset": 8,
        "linematch": "if isinstance(type, (click.IntRange, click.FloatRange)):",
        "context": "            text = Text.from_markup(\n                f\"{names}[dim]{' multiple' if multiple else ''} {type.name}[/] {' [b red]*[/]required' if is_required else ''}\"\n            )\n\n        if isinstance(type, (click.IntRange, click.FloatRange)):\n            if type.min is not None:\n                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 422,
        "coloffset": 12,
        "linematch": "if type.max is not None:",
        "context": "\n        if isinstance(type, (click.IntRange, click.FloatRange)):\n            if type.min is not None:\n                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n\n        return text\n\n    def focus(self, scroll_visible: bool = True):",
        "pattern": ".//FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "number-of-conditions-in-function"
      },
      {
        "lineno": 420,
        "coloffset": 12,
        "linematch": "if type.min is not None:",
        "context": "                f\"{names}[dim]{' multiple' if multiple else ''} {type.name}[/] {' [b red]*[/]required' if is_required else ''}\"\n            )\n\n        if isinstance(type, (click.IntRange, click.FloatRange)):\n            if type.min is not None:\n                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n\n        return text",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 422,
        "coloffset": 12,
        "linematch": "if type.max is not None:",
        "context": "\n        if isinstance(type, (click.IntRange, click.FloatRange)):\n            if type.min is not None:\n                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n\n        return text\n\n    def focus(self, scroll_visible: bool = True):",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 402,
        "coloffset": 4,
        "linematch": "def _make_command_form_control_label(",
        "context": "            yield select\n            return select\n\n    @staticmethod\n    def _make_command_form_control_label(\n        name: str | list[str],\n        type: click.ParamType,\n        is_option: bool,\n        is_required: bool,\n        multiple: bool,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 409,
        "coloffset": 8,
        "linematch": "if isinstance(name, str):",
        "context": "        is_option: bool,\n        is_required: bool,\n        multiple: bool,\n    ) -> Text:\n        if isinstance(name, str):\n            text = Text.from_markup(\n                f\"{name}[dim]{' multiple' if multiple else ''} {type.name}[/] {' [b red]*[/]required' if is_required else ''}\"\n            )\n        else:\n            names = Text(\" / \", style=\"dim\").join([Text(n) for n in name])",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 419,
        "coloffset": 8,
        "linematch": "if isinstance(type, (click.IntRange, click.FloatRange)):",
        "context": "            text = Text.from_markup(\n                f\"{names}[dim]{' multiple' if multiple else ''} {type.name}[/] {' [b red]*[/]required' if is_required else ''}\"\n            )\n\n        if isinstance(type, (click.IntRange, click.FloatRange)):\n            if type.min is not None:\n                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 425,
        "coloffset": 8,
        "linematch": "return text",
        "context": "                text = Text.assemble(text, Text(f\"min={type.min} \", \"dim\"))\n            if type.max is not None:\n                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n\n        return text\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:\n            self.first_control.focus()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 402,
        "coloffset": 4,
        "linematch": "def _make_command_form_control_label(",
        "context": "            yield select\n            return select\n\n    @staticmethod\n    def _make_command_form_control_label(\n        name: str | list[str],\n        type: click.ParamType,\n        is_option: bool,\n        is_required: bool,\n        multiple: bool,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 402,
        "coloffset": 4,
        "linematch": "def _make_command_form_control_label(",
        "context": "            yield select\n            return select\n\n    @staticmethod\n    def _make_command_form_control_label(\n        name: str | list[str],\n        type: click.ParamType,\n        is_option: bool,\n        is_required: bool,\n        multiple: bool,",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "focus",
    "function_scope": "427-429",
    "patterns": [
      {
        "lineno": 428,
        "coloffset": 8,
        "linematch": "if self.first_control is not None:",
        "context": "\n        return text\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:\n            self.first_control.focus()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 213,
        "coloffset": 8,
        "linematch": "if self.first_control is not None:",
        "context": "        root_command_data.parent = None\n        self.post_message(self.Changed(root_command_data))\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:\n            return self.first_control.focus()\n\n    @on(Input.Changed, \".command-form-filter-input\")\n    def apply_filter(self, event: Input.Changed) -> None:\n        filter_query = event.value",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 427,
        "coloffset": 4,
        "linematch": "def focus(self, scroll_visible: bool = True):",
        "context": "                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n\n        return text\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:\n            self.first_control.focus()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 212,
        "coloffset": 4,
        "linematch": "def focus(self, scroll_visible: bool = True):",
        "context": "        root_command_data = root_command_data.subcommand\n        root_command_data.parent = None\n        self.post_message(self.Changed(root_command_data))\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:\n            return self.first_control.focus()\n\n    @on(Input.Changed, \".command-form-filter-input\")\n    def apply_filter(self, event: Input.Changed) -> None:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 427,
        "coloffset": 4,
        "linematch": "def focus(self, scroll_visible: bool = True):",
        "context": "                text = Text.assemble(text, Text(f\"max={type.max}\", \"dim\"))\n\n        return text\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:\n            self.first_control.focus()",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 428,
        "coloffset": 8,
        "linematch": "if self.first_control is not None:",
        "context": "\n        return text\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:\n            self.first_control.focus()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 213,
        "coloffset": 8,
        "linematch": "if self.first_control is not None:",
        "context": "        root_command_data.parent = None\n        self.post_message(self.Changed(root_command_data))\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:\n            return self.first_control.focus()\n\n    @on(Input.Changed, \".command-form-filter-input\")\n    def apply_filter(self, event: Input.Changed) -> None:\n        filter_query = event.value",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "add",
    "function_scope": "35-47",
    "patterns": [
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "if verbose >= 2:",
        "context": "@click.argument(\"task\")\n@click.command()\ndef add(verbose, task, priority, tags, extra, category, labels):\n    \"\"\"Add a new task to the to-do list.\"\"\"\n    if verbose >= 2:\n        click.echo(f\"Adding task: {task}\")\n        click.echo(f\"Priority: {priority}\")\n        click.echo(f'Tags: {\", \".join(tags)}')\n        click.echo(f\"Extra data: {extra}\")\n        click.echo(f\"Category: {category}\")",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "elif verbose >= 1:",
        "context": "        click.echo(f'Tags: {\", \".join(tags)}')\n        click.echo(f\"Extra data: {extra}\")\n        click.echo(f\"Category: {category}\")\n        click.echo(f'Labels: {\", \".join(labels)}')\n    elif verbose >= 1:\n        click.echo(f\"Adding task: {task}\")\n    else:\n        pass\n    # Implement the task adding functionality here\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "if ctx.obj[\"verbose\"] >= 2:",
        "context": "    \"\"\"Add a new task to the to-do list.\n    Note:\n    Control the output of this using the verbosity option.\n    \"\"\"\n    if ctx.obj[\"verbose\"] >= 2:\n        click.echo(f\"Adding task: {task}\")\n        click.echo(f\"Priority: {priority}\")\n        click.echo(f'Tags: {\", \".join(tags)}')\n        click.echo(f\"Extra data: {extra}\")\n    elif ctx.obj[\"verbose\"] >= 1:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "elif ctx.obj[\"verbose\"] >= 1:",
        "context": "        click.echo(f\"Adding task: {task}\")\n        click.echo(f\"Priority: {priority}\")\n        click.echo(f'Tags: {\", \".join(tags)}')\n        click.echo(f\"Extra data: {extra}\")\n    elif ctx.obj[\"verbose\"] >= 1:\n        click.echo(f\"Adding task: {task}\")\n    else:\n        pass\n    # Implement the task adding functionality here\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 35,
        "coloffset": 0,
        "linematch": "def add(verbose, task, priority, tags, extra, category, labels):",
        "context": "    help=\"Add labels to the task (repeatable)\",\n)\n@click.argument(\"task\")\n@click.command()\ndef add(verbose, task, priority, tags, extra, category, labels):\n    \"\"\"Add a new task to the to-do list.\"\"\"\n    if verbose >= 2:\n        click.echo(f\"Adding task: {task}\")\n        click.echo(f\"Priority: {priority}\")\n        click.echo(f'Tags: {\", \".join(tags)}')",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 48,
        "coloffset": 0,
        "linematch": "def add(ctx, task, priority, tags, extra):",
        "context": "    default=[\"urgent\"],\n    help=\"Add labels to the task (repeatable)\",\n)\n@click.pass_context\ndef add(ctx, task, priority, tags, extra):\n    \"\"\"Add a new task to the to-do list.\n    Note:\n    Control the output of this using the verbosity option.\n    \"\"\"\n    if ctx.obj[\"verbose\"] >= 2:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "elif verbose >= 1:",
        "context": "        click.echo(f'Tags: {\", \".join(tags)}')\n        click.echo(f\"Extra data: {extra}\")\n        click.echo(f\"Category: {category}\")\n        click.echo(f'Labels: {\", \".join(labels)}')\n    elif verbose >= 1:\n        click.echo(f\"Adding task: {task}\")\n    else:\n        pass\n    # Implement the task adding functionality here\n",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "elif ctx.obj[\"verbose\"] >= 1:",
        "context": "        click.echo(f\"Adding task: {task}\")\n        click.echo(f\"Priority: {priority}\")\n        click.echo(f'Tags: {\", \".join(tags)}')\n        click.echo(f\"Extra data: {extra}\")\n    elif ctx.obj[\"verbose\"] >= 1:\n        click.echo(f\"Adding task: {task}\")\n    else:\n        pass\n    # Implement the task adding functionality here\n",
        "pattern": ".//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "nested-conditions"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "\"\"\"Add a new task to the to-do list.\"\"\"",
        "context": ")\n@click.argument(\"task\")\n@click.command()\ndef add(verbose, task, priority, tags, extra, category, labels):\n    \"\"\"Add a new task to the to-do list.\"\"\"\n    if verbose >= 2:\n        click.echo(f\"Adding task: {task}\")\n        click.echo(f\"Priority: {priority}\")\n        click.echo(f'Tags: {\", \".join(tags)}')\n        click.echo(f\"Extra data: {extra}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "if verbose >= 2:",
        "context": "@click.argument(\"task\")\n@click.command()\ndef add(verbose, task, priority, tags, extra, category, labels):\n    \"\"\"Add a new task to the to-do list.\"\"\"\n    if verbose >= 2:\n        click.echo(f\"Adding task: {task}\")\n        click.echo(f\"Priority: {priority}\")\n        click.echo(f'Tags: {\", \".join(tags)}')\n        click.echo(f\"Extra data: {extra}\")\n        click.echo(f\"Category: {category}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "\"\"\"Add a new task to the to-do list.",
        "context": "    help=\"Add labels to the task (repeatable)\",\n)\n@click.pass_context\ndef add(ctx, task, priority, tags, extra):\n    \"\"\"Add a new task to the to-do list.\n    Note:\n    Control the output of this using the verbosity option.\n    \"\"\"\n    if ctx.obj[\"verbose\"] >= 2:\n        click.echo(f\"Adding task: {task}\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "if ctx.obj[\"verbose\"] >= 2:",
        "context": "    \"\"\"Add a new task to the to-do list.\n    Note:\n    Control the output of this using the verbosity option.\n    \"\"\"\n    if ctx.obj[\"verbose\"] >= 2:\n        click.echo(f\"Adding task: {task}\")\n        click.echo(f\"Priority: {priority}\")\n        click.echo(f'Tags: {\", \".join(tags)}')\n        click.echo(f\"Extra data: {extra}\")\n    elif ctx.obj[\"verbose\"] >= 1:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "remove",
    "function_scope": "68-71",
    "patterns": [
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "if ctx.obj[\"verbose\"] >= 1:",
        "context": "@click.argument(\"task_id\", type=int)\n@click.pass_context\ndef remove(ctx, task_id):\n    \"\"\"Remove a task from the to-do list by its ID.\"\"\"\n    if ctx.obj[\"verbose\"] >= 1:\n        click.echo(f\"Removing task with ID: {task_id}\")\n    # Implement the task removal functionality here\n\n\n@cli.command()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 68,
        "coloffset": 0,
        "linematch": "def remove(ctx, task_id):",
        "context": "\n@cli.command()\n@click.argument(\"task_id\", type=int)\n@click.pass_context\ndef remove(ctx, task_id):\n    \"\"\"Remove a task from the to-do list by its ID.\"\"\"\n    if ctx.obj[\"verbose\"] >= 1:\n        click.echo(f\"Removing task with ID: {task_id}\")\n    # Implement the task removal functionality here\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 69,
        "coloffset": 4,
        "linematch": "\"\"\"Remove a task from the to-do list by its ID.\"\"\"",
        "context": "@cli.command()\n@click.argument(\"task_id\", type=int)\n@click.pass_context\ndef remove(ctx, task_id):\n    \"\"\"Remove a task from the to-do list by its ID.\"\"\"\n    if ctx.obj[\"verbose\"] >= 1:\n        click.echo(f\"Removing task with ID: {task_id}\")\n    # Implement the task removal functionality here\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 70,
        "coloffset": 4,
        "linematch": "if ctx.obj[\"verbose\"] >= 1:",
        "context": "@click.argument(\"task_id\", type=int)\n@click.pass_context\ndef remove(ctx, task_id):\n    \"\"\"Remove a task from the to-do list by its ID.\"\"\"\n    if ctx.obj[\"verbose\"] >= 1:\n        click.echo(f\"Removing task with ID: {task_id}\")\n    # Implement the task removal functionality here\n\n\n@cli.command()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "list_tasks",
    "function_scope": "81-84",
    "patterns": [
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "if ctx.obj[\"verbose\"] >= 1:",
        "context": "@click.option(\"--completed\", \"-c\", is_flag=True, help=\"List only completed tasks.\")\n@click.pass_context\ndef list_tasks(ctx, all, completed):\n    \"\"\"List tasks from the to-do list.\"\"\"\n    if ctx.obj[\"verbose\"] >= 1:\n        click.echo(f\"Listing tasks:\")\n    # Implement the task listing functionality here\n\n\nif __name__ == \"__main__\":",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "single-nested-if"
      },
      {
        "lineno": 81,
        "coloffset": 0,
        "linematch": "def list_tasks(ctx, all, completed):",
        "context": "    \"--all/--not-all\", default=True, help=\"List all tasks, including completed ones.\"\n)\n@click.option(\"--completed\", \"-c\", is_flag=True, help=\"List only completed tasks.\")\n@click.pass_context\ndef list_tasks(ctx, all, completed):\n    \"\"\"List tasks from the to-do list.\"\"\"\n    if ctx.obj[\"verbose\"] >= 1:\n        click.echo(f\"Listing tasks:\")\n    # Implement the task listing functionality here\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 82,
        "coloffset": 4,
        "linematch": "\"\"\"List tasks from the to-do list.\"\"\"",
        "context": ")\n@click.option(\"--completed\", \"-c\", is_flag=True, help=\"List only completed tasks.\")\n@click.pass_context\ndef list_tasks(ctx, all, completed):\n    \"\"\"List tasks from the to-do list.\"\"\"\n    if ctx.obj[\"verbose\"] >= 1:\n        click.echo(f\"Listing tasks:\")\n    # Implement the task listing functionality here\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "if ctx.obj[\"verbose\"] >= 1:",
        "context": "@click.option(\"--completed\", \"-c\", is_flag=True, help=\"List only completed tasks.\")\n@click.pass_context\ndef list_tasks(ctx, all, completed):\n    \"\"\"List tasks from the to-do list.\"\"\"\n    if ctx.obj[\"verbose\"] >= 1:\n        click.echo(f\"Listing tasks:\")\n    # Implement the task listing functionality here\n\n\nif __name__ == \"__main__\":",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #626",
        "line": 82,
        "description": [
          "            self.command_data = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -79,7 +79,7 @@\n     class Changed(Message):\n         def __init__(self, command_data: UserCommandData):\n             super().__init__()\n-            self.command_data = command_data\n+            self.command_data = None\n             \"\"\"The new data taken from the form to be converted into a CLI invocation.\"\"\"\n \n     def __init__(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "select_by_label",
    "function_scope": "77-80",
    "patterns": [
      {
        "lineno": 80,
        "coloffset": 29,
        "linematch": "checkbox.value = checkbox.label == label",
        "context": "\n    def select_by_label(self, label: str) -> None:\n        checkboxes = self.query(Checkbox)\n        for checkbox in checkboxes:\n            checkbox.value = checkbox.label == label\n\n    def action_next_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))\n        if focused is checkboxes[-1]:",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 77,
        "coloffset": 4,
        "linematch": "def select_by_label(self, label: str) -> None:",
        "context": "                selected.append(checkbox)\n        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))\n\n    def select_by_label(self, label: str) -> None:\n        checkboxes = self.query(Checkbox)\n        for checkbox in checkboxes:\n            checkbox.value = checkbox.label == label\n\n    def action_next_button(self) -> None:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 78,
        "coloffset": 8,
        "linematch": "checkboxes = self.query(Checkbox)",
        "context": "        self.selected = [(checkbox.label.plain,) for checkbox in selected]\n        self.post_message(self.Changed(selected))\n\n    def select_by_label(self, label: str) -> None:\n        checkboxes = self.query(Checkbox)\n        for checkbox in checkboxes:\n            checkbox.value = checkbox.label == label\n\n    def action_next_button(self) -> None:\n        focused = self.app.focused",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 79,
        "coloffset": 8,
        "linematch": "for checkbox in checkboxes:",
        "context": "        self.post_message(self.Changed(selected))\n\n    def select_by_label(self, label: str) -> None:\n        checkboxes = self.query(Checkbox)\n        for checkbox in checkboxes:\n            checkbox.value = checkbox.label == label\n\n    def action_next_button(self) -> None:\n        focused = self.app.focused\n        checkboxes = list(self.query(Checkbox))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_to_cli_string_with_subcommand",
    "function_scope": "109-112",
    "patterns": [
      {
        "lineno": 112,
        "coloffset": 11,
        "linematch": "assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "context": "\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 112,
        "coloffset": 11,
        "linematch": "assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "context": "\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 112,
        "coloffset": 11,
        "linematch": "assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "context": "\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 112,
        "coloffset": 11,
        "linematch": "assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "context": "\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "pattern": ".//FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 109,
        "coloffset": 0,
        "linematch": "def test_to_cli_string_with_subcommand(user_command_data_with_subcommand):",
        "context": "\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123\"\n\n\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "context": "\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 110,
        "coloffset": 4,
        "linematch": "cli_string = user_command_data_with_subcommand.to_cli_string(True)",
        "context": "    assert cli_string.plain == \"test --option1 value1 --option2 42 123\"\n\n\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "context": "\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 110,
        "coloffset": 4,
        "linematch": "cli_string = user_command_data_with_subcommand.to_cli_string(True)",
        "context": "    assert cli_string.plain == \"test --option1 value1 --option2 42 123\"\n\n\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "context": "\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123 sub --sub-option True\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #639",
        "line": 111,
        "description": [
          "            while command_node is not None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -108,7 +108,7 @@\n                 id=\"search\",\n             )\n \n-            while command_node is not None:\n+            while command_node is  None:\n                 options = command_node.options\n                 arguments = command_node.arguments\n                 if options or arguments:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #640",
        "line": 112,
        "description": [
          "                options = command_node.options"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -109,7 +109,7 @@\n             )\n \n             while command_node is not None:\n-                options = command_node.options\n+                options = None\n                 arguments = command_node.arguments\n                 if options or arguments:\n                     with Vertical(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "to_cli_string",
    "function_scope": "221-238",
    "patterns": [
      {
        "lineno": 221,
        "coloffset": 4,
        "linematch": "def to_cli_string(self, include_root_command: bool = False) -> Text:",
        "context": "            args.extend(self.subcommand._to_cli_args())\n\n        return args\n\n    def to_cli_string(self, include_root_command: bool = False) -> Text:\n        \"\"\"\n        Generates a string representing the CLI invocation as if typed directly into the\n        command line.\n\n        Returns:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 221,
        "coloffset": 4,
        "linematch": "def to_cli_string(self, include_root_command: bool = False) -> Text:",
        "context": "            args.extend(self.subcommand._to_cli_args())\n\n        return args\n\n    def to_cli_string(self, include_root_command: bool = False) -> Text:\n        \"\"\"\n        Generates a string representing the CLI invocation as if typed directly into the\n        command line.\n\n        Returns:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 222,
        "coloffset": 8,
        "linematch": "\"\"\"",
        "context": "\n        return args\n\n    def to_cli_string(self, include_root_command: bool = False) -> Text:\n        \"\"\"\n        Generates a string representing the CLI invocation as if typed directly into the\n        command line.\n\n        Returns:\n            A string representing the command invocation.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 229,
        "coloffset": 8,
        "linematch": "args = self.to_cli_args(include_root_command=include_root_command)",
        "context": "\n        Returns:\n            A string representing the command invocation.\n        \"\"\"\n        args = self.to_cli_args(include_root_command=include_root_command)\n\n        text_renderables = []\n        for arg in args:\n            text_renderables.append(\n                Text(shlex.quote(str(arg)))",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 231,
        "coloffset": 8,
        "linematch": "text_renderables = []",
        "context": "            A string representing the command invocation.\n        \"\"\"\n        args = self.to_cli_args(include_root_command=include_root_command)\n\n        text_renderables = []\n        for arg in args:\n            text_renderables.append(\n                Text(shlex.quote(str(arg)))\n                if arg != ValueNotSupplied()\n                else Text(\"???\", style=\"bold black on red\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 232,
        "coloffset": 8,
        "linematch": "for arg in args:",
        "context": "        \"\"\"\n        args = self.to_cli_args(include_root_command=include_root_command)\n\n        text_renderables = []\n        for arg in args:\n            text_renderables.append(\n                Text(shlex.quote(str(arg)))\n                if arg != ValueNotSupplied()\n                else Text(\"???\", style=\"bold black on red\")\n            )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 238,
        "coloffset": 8,
        "linematch": "return Text(\" \").join(text_renderables)",
        "context": "                Text(shlex.quote(str(arg)))\n                if arg != ValueNotSupplied()\n                else Text(\"???\", style=\"bold black on red\")\n            )\n        return Text(\" \").join(text_renderables)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #690",
        "line": 221,
        "description": [
          "            filter_query = filter_query.casefold()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -218,6 +218,6 @@\n         filter_query = event.value\n         all_controls = self.query(ParameterControls)\n         for control in all_controls:\n-            filter_query = filter_query.casefold()\n+            filter_query = None\n             control.apply_filter(filter_query)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "action_close_and_run",
    "function_scope": "133-135",
    "patterns": [
      {
        "lineno": 133,
        "coloffset": 4,
        "linematch": "def action_close_and_run(self) -> None:",
        "context": "            )\n\n        yield Footer()\n\n    def action_close_and_run(self) -> None:\n        self.app.execute_on_exit = True\n        self.app.exit()\n\n    def action_about(self) -> None:\n        from .widgets.about import AboutDialog",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 133,
        "coloffset": 4,
        "linematch": "def action_close_and_run(self) -> None:",
        "context": "            )\n\n        yield Footer()\n\n    def action_close_and_run(self) -> None:\n        self.app.execute_on_exit = True\n        self.app.exit()\n\n    def action_about(self) -> None:\n        from .widgets.about import AboutDialog",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 134,
        "coloffset": 8,
        "linematch": "self.app.execute_on_exit = True",
        "context": "\n        yield Footer()\n\n    def action_close_and_run(self) -> None:\n        self.app.execute_on_exit = True\n        self.app.exit()\n\n    def action_about(self) -> None:\n        from .widgets.about import AboutDialog\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 135,
        "coloffset": 8,
        "linematch": "self.app.exit()",
        "context": "        yield Footer()\n\n    def action_close_and_run(self) -> None:\n        self.app.execute_on_exit = True\n        self.app.exit()\n\n    def action_about(self) -> None:\n        from .widgets.about import AboutDialog\n\n        self.app.push_screen(AboutDialog())",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #658",
        "line": 133,
        "description": [
          "                            yield Label(f\"Options\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -130,7 +130,7 @@\n                                 yield controls\n \n                         if options:\n-                            yield Label(f\"Options\", classes=\"command-form-heading\")\n+                            yield Label(f\"XXOptionsXX\", classes=\"command-form-heading\")\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #659",
        "line": 133,
        "description": [
          "                            yield Label(f\"Options\", classes=\"command-form-heading\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -130,7 +130,7 @@\n                                 yield controls\n \n                         if options:\n-                            yield Label(f\"Options\", classes=\"command-form-heading\")\n+                            yield Label(f\"Options\", classes=\"XXcommand-form-headingXX\")\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n                                 if self.first_control is None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #660",
        "line": 135,
        "description": [
          "                                controls = ParameterControls(option, id=option.key)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -132,7 +132,7 @@\n                         if options:\n                             yield Label(f\"Options\", classes=\"command-form-heading\")\n                             for option in options:\n-                                controls = ParameterControls(option, id=option.key)\n+                                controls = None\n                                 if self.first_control is None:\n                                     self.first_control = controls\n                                 yield controls\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "action_about",
    "function_scope": "137-140",
    "patterns": [
      {
        "lineno": 137,
        "coloffset": 4,
        "linematch": "def action_about(self) -> None:",
        "context": "    def action_close_and_run(self) -> None:\n        self.app.execute_on_exit = True\n        self.app.exit()\n\n    def action_about(self) -> None:\n        from .widgets.about import AboutDialog\n\n        self.app.push_screen(AboutDialog())\n\n    async def on_mount(self, event: events.Mount) -> None:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 137,
        "coloffset": 4,
        "linematch": "def action_about(self) -> None:",
        "context": "    def action_close_and_run(self) -> None:\n        self.app.execute_on_exit = True\n        self.app.exit()\n\n    def action_about(self) -> None:\n        from .widgets.about import AboutDialog\n\n        self.app.push_screen(AboutDialog())\n\n    async def on_mount(self, event: events.Mount) -> None:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 138,
        "coloffset": 8,
        "linematch": "from .widgets.about import AboutDialog",
        "context": "        self.app.execute_on_exit = True\n        self.app.exit()\n\n    def action_about(self) -> None:\n        from .widgets.about import AboutDialog\n\n        self.app.push_screen(AboutDialog())\n\n    async def on_mount(self, event: events.Mount) -> None:\n        await self._refresh_command_form()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 140,
        "coloffset": 8,
        "linematch": "self.app.push_screen(AboutDialog())",
        "context": "\n    def action_about(self) -> None:\n        from .widgets.about import AboutDialog\n\n        self.app.push_screen(AboutDialog())\n\n    async def on_mount(self, event: events.Mount) -> None:\n        await self._refresh_command_form()\n\n    async def _refresh_command_form(self, node: TreeNode[CommandSchema] | None = None):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #662",
        "line": 137,
        "description": [
          "                                    self.first_control = controls"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -134,7 +134,7 @@\n                             for option in options:\n                                 controls = ParameterControls(option, id=option.key)\n                                 if self.first_control is None:\n-                                    self.first_control = controls\n+                                    self.first_control = None\n                                 yield controls\n \n                 command_node = next(path_from_root, None)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #663",
        "line": 140,
        "description": [
          "                command_node = next(path_from_root, None)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -137,7 +137,7 @@\n                                     self.first_control = controls\n                                 yield controls\n \n-                command_node = next(path_from_root, None)\n+                command_node = None\n \n     def on_mount(self) -> None:\n         self._form_changed()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "update_command_data",
    "function_scope": "169-173",
    "patterns": [
      {
        "lineno": 169,
        "coloffset": 4,
        "linematch": "def update_command_data(self, event: CommandForm.Changed) -> None:",
        "context": "        to display a form specific to the highlighted command.\"\"\"\n        await self._refresh_command_form(event.node)\n\n    @on(CommandForm.Changed)\n    def update_command_data(self, event: CommandForm.Changed) -> None:\n        self.command_data = event.command_data\n        self._update_execution_string_preview(\n            self.selected_command_schema, self.command_data\n        )\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 169,
        "coloffset": 4,
        "linematch": "def update_command_data(self, event: CommandForm.Changed) -> None:",
        "context": "        to display a form specific to the highlighted command.\"\"\"\n        await self._refresh_command_form(event.node)\n\n    @on(CommandForm.Changed)\n    def update_command_data(self, event: CommandForm.Changed) -> None:\n        self.command_data = event.command_data\n        self._update_execution_string_preview(\n            self.selected_command_schema, self.command_data\n        )\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 170,
        "coloffset": 8,
        "linematch": "self.command_data = event.command_data",
        "context": "        await self._refresh_command_form(event.node)\n\n    @on(CommandForm.Changed)\n    def update_command_data(self, event: CommandForm.Changed) -> None:\n        self.command_data = event.command_data\n        self._update_execution_string_preview(\n            self.selected_command_schema, self.command_data\n        )\n\n    def _update_command_description(self, node: TreeNode[CommandSchema]) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 171,
        "coloffset": 8,
        "linematch": "self._update_execution_string_preview(",
        "context": "\n    @on(CommandForm.Changed)\n    def update_command_data(self, event: CommandForm.Changed) -> None:\n        self.command_data = event.command_data\n        self._update_execution_string_preview(\n            self.selected_command_schema, self.command_data\n        )\n\n    def _update_command_description(self, node: TreeNode[CommandSchema]) -> None:\n        \"\"\"Update the description of the command at the bottom of the sidebar",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #668",
        "line": 169,
        "description": [
          "        root_command_data = parent_command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -166,7 +166,7 @@\n             name=CommandName(\"_\"), options=[], arguments=[]\n         )\n \n-        root_command_data = parent_command_data\n+        root_command_data = None\n         for command in path_from_root:\n             option_datas = []\n             # For each of the options in the schema for this command,\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #669",
        "line": 171,
        "description": [
          "            option_datas = []"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -168,7 +168,7 @@\n \n         root_command_data = parent_command_data\n         for command in path_from_root:\n-            option_datas = []\n+            option_datas = None\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "_update_command_description",
    "function_scope": "175-182",
    "patterns": [
      {
        "lineno": 175,
        "coloffset": 4,
        "linematch": "def _update_command_description(self, node: TreeNode[CommandSchema]) -> None:",
        "context": "        self._update_execution_string_preview(\n            self.selected_command_schema, self.command_data\n        )\n\n    def _update_command_description(self, node: TreeNode[CommandSchema]) -> None:\n        \"\"\"Update the description of the command at the bottom of the sidebar\n        based on the currently selected node in the command tree.\"\"\"\n        description_box = self.query_one(\"#home-command-description\", Static)\n        description_text = node.data.docstring or \"\"\n        description_text = description_text.lstrip()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 175,
        "coloffset": 4,
        "linematch": "def _update_command_description(self, node: TreeNode[CommandSchema]) -> None:",
        "context": "        self._update_execution_string_preview(\n            self.selected_command_schema, self.command_data\n        )\n\n    def _update_command_description(self, node: TreeNode[CommandSchema]) -> None:\n        \"\"\"Update the description of the command at the bottom of the sidebar\n        based on the currently selected node in the command tree.\"\"\"\n        description_box = self.query_one(\"#home-command-description\", Static)\n        description_text = node.data.docstring or \"\"\n        description_text = description_text.lstrip()",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 176,
        "coloffset": 8,
        "linematch": "\"\"\"Update the description of the command at the bottom of the sidebar",
        "context": "            self.selected_command_schema, self.command_data\n        )\n\n    def _update_command_description(self, node: TreeNode[CommandSchema]) -> None:\n        \"\"\"Update the description of the command at the bottom of the sidebar\n        based on the currently selected node in the command tree.\"\"\"\n        description_box = self.query_one(\"#home-command-description\", Static)\n        description_text = node.data.docstring or \"\"\n        description_text = description_text.lstrip()\n        description_text = f\"[b]{node.label if self.is_grouped_cli else self.click_app_name}[/]\\n{description_text}\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 178,
        "coloffset": 8,
        "linematch": "description_box = self.query_one(\"#home-command-description\", Static)",
        "context": "\n    def _update_command_description(self, node: TreeNode[CommandSchema]) -> None:\n        \"\"\"Update the description of the command at the bottom of the sidebar\n        based on the currently selected node in the command tree.\"\"\"\n        description_box = self.query_one(\"#home-command-description\", Static)\n        description_text = node.data.docstring or \"\"\n        description_text = description_text.lstrip()\n        description_text = f\"[b]{node.label if self.is_grouped_cli else self.click_app_name}[/]\\n{description_text}\"\n        description_box.update(description_text)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 179,
        "coloffset": 8,
        "linematch": "description_text = node.data.docstring or \"\"",
        "context": "    def _update_command_description(self, node: TreeNode[CommandSchema]) -> None:\n        \"\"\"Update the description of the command at the bottom of the sidebar\n        based on the currently selected node in the command tree.\"\"\"\n        description_box = self.query_one(\"#home-command-description\", Static)\n        description_text = node.data.docstring or \"\"\n        description_text = description_text.lstrip()\n        description_text = f\"[b]{node.label if self.is_grouped_cli else self.click_app_name}[/]\\n{description_text}\"\n        description_box.update(description_text)\n\n    def _update_execution_string_preview(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 180,
        "coloffset": 8,
        "linematch": "description_text = description_text.lstrip()",
        "context": "        \"\"\"Update the description of the command at the bottom of the sidebar\n        based on the currently selected node in the command tree.\"\"\"\n        description_box = self.query_one(\"#home-command-description\", Static)\n        description_text = node.data.docstring or \"\"\n        description_text = description_text.lstrip()\n        description_text = f\"[b]{node.label if self.is_grouped_cli else self.click_app_name}[/]\\n{description_text}\"\n        description_box.update(description_text)\n\n    def _update_execution_string_preview(\n        self, command_schema: CommandSchema, command_data: UserCommandData",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 181,
        "coloffset": 8,
        "linematch": "description_text = f\"[b]{node.label if self.is_grouped_cli else self.click_app_name}[/]\\n{description_text}\"",
        "context": "        based on the currently selected node in the command tree.\"\"\"\n        description_box = self.query_one(\"#home-command-description\", Static)\n        description_text = node.data.docstring or \"\"\n        description_text = description_text.lstrip()\n        description_text = f\"[b]{node.label if self.is_grouped_cli else self.click_app_name}[/]\\n{description_text}\"\n        description_box.update(description_text)\n\n    def _update_execution_string_preview(\n        self, command_schema: CommandSchema, command_data: UserCommandData\n    ) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 182,
        "coloffset": 8,
        "linematch": "description_box.update(description_text)",
        "context": "        description_box = self.query_one(\"#home-command-description\", Static)\n        description_text = node.data.docstring or \"\"\n        description_text = description_text.lstrip()\n        description_text = f\"[b]{node.label if self.is_grouped_cli else self.click_app_name}[/]\\n{description_text}\"\n        description_box.update(description_text)\n\n    def _update_execution_string_preview(\n        self, command_schema: CommandSchema, command_data: UserCommandData\n    ) -> None:\n        \"\"\"Update the preview box showing the command string to be executed\"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #670",
        "line": 175,
        "description": [
          "                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -172,7 +172,7 @@\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n-                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n+                parameter_control = self.query_one(f\"XX#{option.key}XX\", ParameterControls)\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #671",
        "line": 175,
        "description": [
          "                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -172,7 +172,7 @@\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n-                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n+                parameter_control = None\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #672",
        "line": 176,
        "description": [
          "                value = parameter_control.get_values()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -173,7 +173,7 @@\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n                 parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n-                value = parameter_control.get_values()\n+                value = None\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n                     option_data = UserOptionData(option.name, v, option)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #673",
        "line": 179,
        "description": [
          "                    option_data = UserOptionData(option.name, v, option)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -176,7 +176,7 @@\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n-                    option_data = UserOptionData(option.name, v, option)\n+                    option_data = None\n                     option_datas.append(option_data)\n \n             # Now do the same for the arguments\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "on_button_pressed",
    "function_scope": "240-242",
    "patterns": [
      {
        "lineno": 240,
        "coloffset": 4,
        "linematch": "def on_button_pressed(self):",
        "context": "    def on_mount(self):\n        self.push_screen(CommandBuilder(self.cli, self.app_name, self.command_name))\n\n    @on(Button.Pressed, \"#home-exec-button\")\n    def on_button_pressed(self):\n        self.execute_on_exit = True\n        self.exit()\n\n    def run(\n        self,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 83,
        "coloffset": 4,
        "linematch": "def on_button_pressed(self) -> None:",
        "context": "    def on_mount(self) -> None:\n        \"\"\"Configure the dialog once the DOM has loaded.\"\"\"\n        self.query_one(Button).focus()\n\n    def on_button_pressed(self) -> None:\n        \"\"\"Handle the OK button being pressed.\"\"\"\n        self.dismiss(None)\n\n\nclass AboutDialog(TextDialog):",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 240,
        "coloffset": 4,
        "linematch": "def on_button_pressed(self):",
        "context": "    def on_mount(self):\n        self.push_screen(CommandBuilder(self.cli, self.app_name, self.command_name))\n\n    @on(Button.Pressed, \"#home-exec-button\")\n    def on_button_pressed(self):\n        self.execute_on_exit = True\n        self.exit()\n\n    def run(\n        self,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 241,
        "coloffset": 8,
        "linematch": "self.execute_on_exit = True",
        "context": "        self.push_screen(CommandBuilder(self.cli, self.app_name, self.command_name))\n\n    @on(Button.Pressed, \"#home-exec-button\")\n    def on_button_pressed(self):\n        self.execute_on_exit = True\n        self.exit()\n\n    def run(\n        self,\n        *,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 242,
        "coloffset": 8,
        "linematch": "self.exit()",
        "context": "\n    @on(Button.Pressed, \"#home-exec-button\")\n    def on_button_pressed(self):\n        self.execute_on_exit = True\n        self.exit()\n\n    def run(\n        self,\n        *,\n        headless: bool = False,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 84,
        "coloffset": 8,
        "linematch": "\"\"\"Handle the OK button being pressed.\"\"\"",
        "context": "        \"\"\"Configure the dialog once the DOM has loaded.\"\"\"\n        self.query_one(Button).focus()\n\n    def on_button_pressed(self) -> None:\n        \"\"\"Handle the OK button being pressed.\"\"\"\n        self.dismiss(None)\n\n\nclass AboutDialog(TextDialog):\n    DEFAULT_CSS = \"\"\"",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 85,
        "coloffset": 8,
        "linematch": "self.dismiss(None)",
        "context": "        self.query_one(Button).focus()\n\n    def on_button_pressed(self) -> None:\n        \"\"\"Handle the OK button being pressed.\"\"\"\n        self.dismiss(None)\n\n\nclass AboutDialog(TextDialog):\n    DEFAULT_CSS = \"\"\"\n    TextDialog > Vertical {",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "update_command_to_run",
    "function_scope": "267-269",
    "patterns": [
      {
        "lineno": 267,
        "coloffset": 4,
        "linematch": "def update_command_to_run(self, event: CommandForm.Changed):",
        "context": "                    arguments = [*split_app_name, *self.post_run_command]\n                    os.execvp(program_name, arguments)\n\n    @on(CommandForm.Changed)\n    def update_command_to_run(self, event: CommandForm.Changed):\n        include_root_command = not self.is_grouped_cli\n        self.post_run_command = event.command_data.to_cli_args(include_root_command)\n\n    def action_focus_command_tree(self) -> None:\n        try:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 267,
        "coloffset": 4,
        "linematch": "def update_command_to_run(self, event: CommandForm.Changed):",
        "context": "                    arguments = [*split_app_name, *self.post_run_command]\n                    os.execvp(program_name, arguments)\n\n    @on(CommandForm.Changed)\n    def update_command_to_run(self, event: CommandForm.Changed):\n        include_root_command = not self.is_grouped_cli\n        self.post_run_command = event.command_data.to_cli_args(include_root_command)\n\n    def action_focus_command_tree(self) -> None:\n        try:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 268,
        "coloffset": 8,
        "linematch": "include_root_command = not self.is_grouped_cli",
        "context": "                    os.execvp(program_name, arguments)\n\n    @on(CommandForm.Changed)\n    def update_command_to_run(self, event: CommandForm.Changed):\n        include_root_command = not self.is_grouped_cli\n        self.post_run_command = event.command_data.to_cli_args(include_root_command)\n\n    def action_focus_command_tree(self) -> None:\n        try:\n            command_tree = self.query_one(CommandTree)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 269,
        "coloffset": 8,
        "linematch": "self.post_run_command = event.command_data.to_cli_args(include_root_command)",
        "context": "\n    @on(CommandForm.Changed)\n    def update_command_to_run(self, event: CommandForm.Changed):\n        include_root_command = not self.is_grouped_cli\n        self.post_run_command = event.command_data.to_cli_args(include_root_command)\n\n    def action_focus_command_tree(self) -> None:\n        try:\n            command_tree = self.query_one(CommandTree)\n        except NoMatches:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "action_focus_command_tree",
    "function_scope": "271-277",
    "patterns": [
      {
        "lineno": 271,
        "coloffset": 4,
        "linematch": "def action_focus_command_tree(self) -> None:",
        "context": "    def update_command_to_run(self, event: CommandForm.Changed):\n        include_root_command = not self.is_grouped_cli\n        self.post_run_command = event.command_data.to_cli_args(include_root_command)\n\n    def action_focus_command_tree(self) -> None:\n        try:\n            command_tree = self.query_one(CommandTree)\n        except NoMatches:\n            return\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 271,
        "coloffset": 4,
        "linematch": "def action_focus_command_tree(self) -> None:",
        "context": "    def update_command_to_run(self, event: CommandForm.Changed):\n        include_root_command = not self.is_grouped_cli\n        self.post_run_command = event.command_data.to_cli_args(include_root_command)\n\n    def action_focus_command_tree(self) -> None:\n        try:\n            command_tree = self.query_one(CommandTree)\n        except NoMatches:\n            return\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 272,
        "coloffset": 8,
        "linematch": "try:",
        "context": "        include_root_command = not self.is_grouped_cli\n        self.post_run_command = event.command_data.to_cli_args(include_root_command)\n\n    def action_focus_command_tree(self) -> None:\n        try:\n            command_tree = self.query_one(CommandTree)\n        except NoMatches:\n            return\n\n        command_tree.focus()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 277,
        "coloffset": 8,
        "linematch": "command_tree.focus()",
        "context": "            command_tree = self.query_one(CommandTree)\n        except NoMatches:\n            return\n\n        command_tree.focus()\n\n    def action_show_command_info(self) -> None:\n        command_builder = self.query_one(CommandBuilder)\n        self.push_screen(CommandInfo(command_builder.selected_command_schema))\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "action_show_command_info",
    "function_scope": "279-281",
    "patterns": [
      {
        "lineno": 279,
        "coloffset": 4,
        "linematch": "def action_show_command_info(self) -> None:",
        "context": "            return\n\n        command_tree.focus()\n\n    def action_show_command_info(self) -> None:\n        command_builder = self.query_one(CommandBuilder)\n        self.push_screen(CommandInfo(command_builder.selected_command_schema))\n\n    def action_visit(self, url: str) -> None:\n        \"\"\"Visit the given URL, via the operating system.",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 279,
        "coloffset": 4,
        "linematch": "def action_show_command_info(self) -> None:",
        "context": "            return\n\n        command_tree.focus()\n\n    def action_show_command_info(self) -> None:\n        command_builder = self.query_one(CommandBuilder)\n        self.push_screen(CommandInfo(command_builder.selected_command_schema))\n\n    def action_visit(self, url: str) -> None:\n        \"\"\"Visit the given URL, via the operating system.",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 280,
        "coloffset": 8,
        "linematch": "command_builder = self.query_one(CommandBuilder)",
        "context": "\n        command_tree.focus()\n\n    def action_show_command_info(self) -> None:\n        command_builder = self.query_one(CommandBuilder)\n        self.push_screen(CommandInfo(command_builder.selected_command_schema))\n\n    def action_visit(self, url: str) -> None:\n        \"\"\"Visit the given URL, via the operating system.\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 281,
        "coloffset": 8,
        "linematch": "self.push_screen(CommandInfo(command_builder.selected_command_schema))",
        "context": "        command_tree.focus()\n\n    def action_show_command_info(self) -> None:\n        command_builder = self.query_one(CommandBuilder)\n        self.push_screen(CommandInfo(command_builder.selected_command_schema))\n\n    def action_visit(self, url: str) -> None:\n        \"\"\"Visit the given URL, via the operating system.\n\n        Args:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "action_visit",
    "function_scope": "283-289",
    "patterns": [
      {
        "lineno": 283,
        "coloffset": 4,
        "linematch": "def action_visit(self, url: str) -> None:",
        "context": "    def action_show_command_info(self) -> None:\n        command_builder = self.query_one(CommandBuilder)\n        self.push_screen(CommandInfo(command_builder.selected_command_schema))\n\n    def action_visit(self, url: str) -> None:\n        \"\"\"Visit the given URL, via the operating system.\n\n        Args:\n            url: The URL to visit.\n        \"\"\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 283,
        "coloffset": 4,
        "linematch": "def action_visit(self, url: str) -> None:",
        "context": "    def action_show_command_info(self) -> None:\n        command_builder = self.query_one(CommandBuilder)\n        self.push_screen(CommandInfo(command_builder.selected_command_schema))\n\n    def action_visit(self, url: str) -> None:\n        \"\"\"Visit the given URL, via the operating system.\n\n        Args:\n            url: The URL to visit.\n        \"\"\"",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 284,
        "coloffset": 8,
        "linematch": "\"\"\"Visit the given URL, via the operating system.",
        "context": "        command_builder = self.query_one(CommandBuilder)\n        self.push_screen(CommandInfo(command_builder.selected_command_schema))\n\n    def action_visit(self, url: str) -> None:\n        \"\"\"Visit the given URL, via the operating system.\n\n        Args:\n            url: The URL to visit.\n        \"\"\"\n        open_url(url)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 289,
        "coloffset": 8,
        "linematch": "open_url(url)",
        "context": "\n        Args:\n            url: The URL to visit.\n        \"\"\"\n        open_url(url)\n\n\ndef tui(name: str | None = None, command: str = \"tui\", help: str = \"Open Textual TUI.\"):\n    def decorator(app: click.Group | click.Command):\n        @click.pass_context",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "generate_unique_id",
    "function_scope": "11-12",
    "patterns": [
      {
        "lineno": 11,
        "coloffset": 0,
        "linematch": "def generate_unique_id():",
        "context": "import click\nfrom click import BaseCommand, ParamType\n\n\ndef generate_unique_id():\n    return f\"id_{str(uuid.uuid4())[:8]}\"\n\n\n@dataclass\nclass MultiValueParamData:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 11,
        "coloffset": 0,
        "linematch": "def generate_unique_id():",
        "context": "import click\nfrom click import BaseCommand, ParamType\n\n\ndef generate_unique_id():\n    return f\"id_{str(uuid.uuid4())[:8]}\"\n\n\n@dataclass\nclass MultiValueParamData:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 12,
        "coloffset": 4,
        "linematch": "return f\"id_{str(uuid.uuid4())[:8]}\"",
        "context": "from click import BaseCommand, ParamType\n\n\ndef generate_unique_id():\n    return f\"id_{str(uuid.uuid4())[:8]}\"\n\n\n@dataclass\nclass MultiValueParamData:\n    values: list[tuple[int | float | str]]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "__post_init__",
    "function_scope": "55-56",
    "patterns": [
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "def __post_init__(self):",
        "context": "    multiple: bool = False\n    multi_value: bool = False\n    nargs: int = 1\n\n    def __post_init__(self):\n        self.multi_value = isinstance(self.type, click.Tuple)\n\n\n@dataclass\nclass ArgumentSchema:",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "def __post_init__(self):",
        "context": "    multiple: bool = False\n    multi_value: bool = False\n    nargs: int = 1\n\n    def __post_init__(self):\n        self.multi_value = isinstance(self.type, click.Tuple)\n\n\n@dataclass\nclass ArgumentSchema:",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 56,
        "coloffset": 8,
        "linematch": "self.multi_value = isinstance(self.type, click.Tuple)",
        "context": "    multi_value: bool = False\n    nargs: int = 1\n\n    def __post_init__(self):\n        self.multi_value = isinstance(self.type, click.Tuple)\n\n\n@dataclass\nclass ArgumentSchema:\n    name: str",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "render_label",
    "function_scope": "22-27",
    "patterns": [
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "def render_label(",
        "context": "        self.show_guides = False\n        self.cli_metadata = cli_metadata\n        self.command_name = command_name\n\n    def render_label(\n        self, node: TreeNode[TreeDataType], base_style: Style, style: Style\n    ) -> Text:\n        label = node._label.copy()\n        label.stylize(style)\n        return label",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 25,
        "coloffset": 8,
        "linematch": "label = node._label.copy()",
        "context": "\n    def render_label(\n        self, node: TreeNode[TreeDataType], base_style: Style, style: Style\n    ) -> Text:\n        label = node._label.copy()\n        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 26,
        "coloffset": 8,
        "linematch": "label.stylize(style)",
        "context": "    def render_label(\n        self, node: TreeNode[TreeDataType], base_style: Style, style: Style\n    ) -> Text:\n        label = node._label.copy()\n        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 8,
        "linematch": "return label",
        "context": "        self, node: TreeNode[TreeDataType], base_style: Style, style: Style\n    ) -> Text:\n        label = node._label.copy()\n        label.stylize(style)\n        return label\n\n    def on_mount(self):\n        def build_tree(\n            data: dict[CommandName, CommandSchema], node: TreeNode\n        ) -> TreeNode:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #624",
        "line": 22,
        "description": [
          "@dataclasses.dataclass"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -18,8 +18,6 @@\n from trogon.run_command import UserCommandData, UserOptionData, UserArgumentData\n from trogon.widgets.parameter_controls import ParameterControls\n \n-\n-@dataclasses.dataclass\n class FormControlMeta:\n     widget: Widget\n     meta: OptionSchema | ArgumentSchema\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "button_style",
    "function_scope": "66-68",
    "patterns": [
      {
        "lineno": 66,
        "coloffset": 4,
        "linematch": "def button_style(self) -> ButtonVariant:",
        "context": "        self._title = title\n        self._message = message\n\n    @property\n    def button_style(self) -> ButtonVariant:\n        \"\"\"The style for the dialog's button.\"\"\"\n        return \"primary\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the content of the modal dialog.\"\"\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 67,
        "coloffset": 8,
        "linematch": "\"\"\"The style for the dialog's button.\"\"\"",
        "context": "        self._message = message\n\n    @property\n    def button_style(self) -> ButtonVariant:\n        \"\"\"The style for the dialog's button.\"\"\"\n        return \"primary\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the content of the modal dialog.\"\"\"\n        with Vertical():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 68,
        "coloffset": 8,
        "linematch": "return \"primary\"",
        "context": "\n    @property\n    def button_style(self) -> ButtonVariant:\n        \"\"\"The style for the dialog's button.\"\"\"\n        return \"primary\"\n\n    def compose(self) -> ComposeResult:\n        \"\"\"Compose the content of the modal dialog.\"\"\"\n        with Vertical():\n            with Center():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "__eq__",
    "function_scope": "40-41",
    "patterns": [
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "def __eq__(self, other):",
        "context": "\n\n@functools.total_ordering\nclass ValueNotSupplied:\n    def __eq__(self, other):\n        return isinstance(other, ValueNotSupplied)\n\n    def __lt__(self, other):\n        return False\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "def __eq__(self, other):",
        "context": "\n\n@functools.total_ordering\nclass ValueNotSupplied:\n    def __eq__(self, other):\n        return isinstance(other, ValueNotSupplied)\n\n    def __lt__(self, other):\n        return False\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 41,
        "coloffset": 8,
        "linematch": "return isinstance(other, ValueNotSupplied)",
        "context": "\n@functools.total_ordering\nclass ValueNotSupplied:\n    def __eq__(self, other):\n        return isinstance(other, ValueNotSupplied)\n\n    def __lt__(self, other):\n        return False\n\n    def __bool__(self):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "__lt__",
    "function_scope": "43-44",
    "patterns": [
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "def __lt__(self, other):",
        "context": "class ValueNotSupplied:\n    def __eq__(self, other):\n        return isinstance(other, ValueNotSupplied)\n\n    def __lt__(self, other):\n        return False\n\n    def __bool__(self):\n        return False\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "def __lt__(self, other):",
        "context": "class ValueNotSupplied:\n    def __eq__(self, other):\n        return isinstance(other, ValueNotSupplied)\n\n    def __lt__(self, other):\n        return False\n\n    def __bool__(self):\n        return False\n",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 44,
        "coloffset": 8,
        "linematch": "return False",
        "context": "    def __eq__(self, other):\n        return isinstance(other, ValueNotSupplied)\n\n    def __lt__(self, other):\n        return False\n\n    def __bool__(self):\n        return False\n\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "__bool__",
    "function_scope": "46-47",
    "patterns": [
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "def __bool__(self):",
        "context": "\n    def __lt__(self, other):\n        return False\n\n    def __bool__(self):\n        return False\n\n\nclass ParameterControls(Widget):\n    def __init__(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "def __bool__(self):",
        "context": "\n    def __lt__(self, other):\n        return False\n\n    def __bool__(self):\n        return False\n\n\nclass ParameterControls(Widget):\n    def __init__(",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 47,
        "coloffset": 8,
        "linematch": "return False",
        "context": "    def __lt__(self, other):\n        return False\n\n    def __bool__(self):\n        return False\n\n\nclass ParameterControls(Widget):\n    def __init__(\n        self,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "make_widget_group",
    "function_scope": "198-225",
    "patterns": [
      {
        "lineno": 198,
        "coloffset": 4,
        "linematch": "def make_widget_group(self) -> Iterable[Widget]:",
        "context": "        # Render the dim help text below the form controls\n        if help_text:\n            yield Static(help_text, classes=\"command-form-control-help-text\")\n\n    def make_widget_group(self) -> Iterable[Widget]:\n        \"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"\n        schema = self.schema\n        default = schema.default\n        parameter_type = schema.type\n        name = schema.name",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 198,
        "coloffset": 4,
        "linematch": "def make_widget_group(self) -> Iterable[Widget]:",
        "context": "        # Render the dim help text below the form controls\n        if help_text:\n            yield Static(help_text, classes=\"command-form-control-help-text\")\n\n    def make_widget_group(self) -> Iterable[Widget]:\n        \"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"\n        schema = self.schema\n        default = schema.default\n        parameter_type = schema.type\n        name = schema.name",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 199,
        "coloffset": 8,
        "linematch": "\"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"",
        "context": "        if help_text:\n            yield Static(help_text, classes=\"command-form-control-help-text\")\n\n    def make_widget_group(self) -> Iterable[Widget]:\n        \"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"\n        schema = self.schema\n        default = schema.default\n        parameter_type = schema.type\n        name = schema.name\n        multiple = schema.multiple",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 200,
        "coloffset": 8,
        "linematch": "schema = self.schema",
        "context": "            yield Static(help_text, classes=\"command-form-control-help-text\")\n\n    def make_widget_group(self) -> Iterable[Widget]:\n        \"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"\n        schema = self.schema\n        default = schema.default\n        parameter_type = schema.type\n        name = schema.name\n        multiple = schema.multiple\n        required = schema.required",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 201,
        "coloffset": 8,
        "linematch": "default = schema.default",
        "context": "\n    def make_widget_group(self) -> Iterable[Widget]:\n        \"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"\n        schema = self.schema\n        default = schema.default\n        parameter_type = schema.type\n        name = schema.name\n        multiple = schema.multiple\n        required = schema.required\n        is_option = isinstance(schema, OptionSchema)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 202,
        "coloffset": 8,
        "linematch": "parameter_type = schema.type",
        "context": "    def make_widget_group(self) -> Iterable[Widget]:\n        \"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"\n        schema = self.schema\n        default = schema.default\n        parameter_type = schema.type\n        name = schema.name\n        multiple = schema.multiple\n        required = schema.required\n        is_option = isinstance(schema, OptionSchema)\n        label = self._make_command_form_control_label(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 203,
        "coloffset": 8,
        "linematch": "name = schema.name",
        "context": "        \"\"\"For this option, yield a single set of widgets required to receive user input for it.\"\"\"\n        schema = self.schema\n        default = schema.default\n        parameter_type = schema.type\n        name = schema.name\n        multiple = schema.multiple\n        required = schema.required\n        is_option = isinstance(schema, OptionSchema)\n        label = self._make_command_form_control_label(\n            name, parameter_type, is_option, required, multiple",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 204,
        "coloffset": 8,
        "linematch": "multiple = schema.multiple",
        "context": "        schema = self.schema\n        default = schema.default\n        parameter_type = schema.type\n        name = schema.name\n        multiple = schema.multiple\n        required = schema.required\n        is_option = isinstance(schema, OptionSchema)\n        label = self._make_command_form_control_label(\n            name, parameter_type, is_option, required, multiple\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 205,
        "coloffset": 8,
        "linematch": "required = schema.required",
        "context": "        default = schema.default\n        parameter_type = schema.type\n        name = schema.name\n        multiple = schema.multiple\n        required = schema.required\n        is_option = isinstance(schema, OptionSchema)\n        label = self._make_command_form_control_label(\n            name, parameter_type, is_option, required, multiple\n        )\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 206,
        "coloffset": 8,
        "linematch": "is_option = isinstance(schema, OptionSchema)",
        "context": "        parameter_type = schema.type\n        name = schema.name\n        multiple = schema.multiple\n        required = schema.required\n        is_option = isinstance(schema, OptionSchema)\n        label = self._make_command_form_control_label(\n            name, parameter_type, is_option, required, multiple\n        )\n\n        # Get the types of the parameter. We can map these types on to widgets that will be rendered.",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 207,
        "coloffset": 8,
        "linematch": "label = self._make_command_form_control_label(",
        "context": "        name = schema.name\n        multiple = schema.multiple\n        required = schema.required\n        is_option = isinstance(schema, OptionSchema)\n        label = self._make_command_form_control_label(\n            name, parameter_type, is_option, required, multiple\n        )\n\n        # Get the types of the parameter. We can map these types on to widgets that will be rendered.\n        parameter_types = (",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 212,
        "coloffset": 8,
        "linematch": "parameter_types = (",
        "context": "            name, parameter_type, is_option, required, multiple\n        )\n\n        # Get the types of the parameter. We can map these types on to widgets that will be rendered.\n        parameter_types = (\n            parameter_type.types\n            if isinstance(parameter_type, click.Tuple)\n            else [parameter_type]\n        )\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 220,
        "coloffset": 8,
        "linematch": "for _type in parameter_types:",
        "context": "        )\n\n        # For each of the these parameters, render the corresponding widget for it.\n        # At this point we don't care about filling in the default values.\n        for _type in parameter_types:\n            control_method = self.get_control_method(_type)\n            control_widgets = control_method(\n                default, label, multiple, schema, schema.key\n            )\n            yield from control_widgets",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #679",
        "line": 203,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -194,13 +194,7 @@\n \n             assert all(isinstance(option.value, tuple) for option in option_datas)\n             assert all(isinstance(argument.value, tuple) for argument in argument_datas)\n-            command_data = UserCommandData(\n-                name=command.name,\n-                options=option_datas,\n-                arguments=argument_datas,\n-                parent=parent_command_data,\n-                command_schema=command,\n-            )\n+            command_data = None\n             parent_command_data.subcommand = command_data\n             parent_command_data = command_data\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #680",
        "line": 204,
        "description": [
          "            parent_command_data.subcommand = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -201,7 +201,7 @@\n                 parent=parent_command_data,\n                 command_schema=command,\n             )\n-            parent_command_data.subcommand = command_data\n+            parent_command_data.subcommand = None\n             parent_command_data = command_data\n \n         # Trim the sentinel\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #681",
        "line": 205,
        "description": [
          "            parent_command_data = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -202,7 +202,7 @@\n                 command_schema=command,\n             )\n             parent_command_data.subcommand = command_data\n-            parent_command_data = command_data\n+            parent_command_data = None\n \n         # Trim the sentinel\n         root_command_data = root_command_data.subcommand\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #682",
        "line": 208,
        "description": [
          "        root_command_data = root_command_data.subcommand"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -205,7 +205,7 @@\n             parent_command_data = command_data\n \n         # Trim the sentinel\n-        root_command_data = root_command_data.subcommand\n+        root_command_data = None\n         root_command_data.parent = None\n         self.post_message(self.Changed(root_command_data))\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #683",
        "line": 209,
        "description": [
          "        root_command_data.parent = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -206,7 +206,7 @@\n \n         # Trim the sentinel\n         root_command_data = root_command_data.subcommand\n-        root_command_data.parent = None\n+        root_command_data.parent = \"\"\n         self.post_message(self.Changed(root_command_data))\n \n     def focus(self, scroll_visible: bool = True):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #684",
        "line": 212,
        "description": [
          "    def focus(self, scroll_visible: bool = True):"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -209,7 +209,7 @@\n         root_command_data.parent = None\n         self.post_message(self.Changed(root_command_data))\n \n-    def focus(self, scroll_visible: bool = True):\n+    def focus(self, scroll_visible: bool = False):\n         if self.first_control is not None:\n             return self.first_control.focus()\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #685",
        "line": 213,
        "description": [
          "        if self.first_control is not None:"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -210,7 +210,7 @@\n         self.post_message(self.Changed(root_command_data))\n \n     def focus(self, scroll_visible: bool = True):\n-        if self.first_control is not None:\n+        if self.first_control is  None:\n             return self.first_control.focus()\n \n     @on(Input.Changed, \".command-form-filter-input\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #686",
        "line": 216,
        "description": [
          "    @on(Input.Changed, \".command-form-filter-input\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -213,7 +213,7 @@\n         if self.first_control is not None:\n             return self.first_control.focus()\n \n-    @on(Input.Changed, \".command-form-filter-input\")\n+    @on(Input.Changed, \"XX.command-form-filter-inputXX\")\n     def apply_filter(self, event: Input.Changed) -> None:\n         filter_query = event.value\n         all_controls = self.query(ParameterControls)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #687",
        "line": 216,
        "description": [
          "    @on(Input.Changed, \".command-form-filter-input\")"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -213,7 +213,6 @@\n         if self.first_control is not None:\n             return self.first_control.focus()\n \n-    @on(Input.Changed, \".command-form-filter-input\")\n     def apply_filter(self, event: Input.Changed) -> None:\n         filter_query = event.value\n         all_controls = self.query(ParameterControls)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #688",
        "line": 218,
        "description": [
          "        filter_query = event.value"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -215,7 +215,7 @@\n \n     @on(Input.Changed, \".command-form-filter-input\")\n     def apply_filter(self, event: Input.Changed) -> None:\n-        filter_query = event.value\n+        filter_query = None\n         all_controls = self.query(ParameterControls)\n         for control in all_controls:\n             filter_query = filter_query.casefold()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #689",
        "line": 219,
        "description": [
          "        all_controls = self.query(ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -216,7 +216,7 @@\n     @on(Input.Changed, \".command-form-filter-input\")\n     def apply_filter(self, event: Input.Changed) -> None:\n         filter_query = event.value\n-        all_controls = self.query(ParameterControls)\n+        all_controls = None\n         for control in all_controls:\n             filter_query = filter_query.casefold()\n             control.apply_filter(filter_query)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #690",
        "line": 221,
        "description": [
          "            filter_query = filter_query.casefold()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -218,6 +218,6 @@\n         filter_query = event.value\n         all_controls = self.query(ParameterControls)\n         for control in all_controls:\n-            filter_query = filter_query.casefold()\n+            filter_query = None\n             control.apply_filter(filter_query)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "make_text_control",
    "function_scope": "337-348",
    "patterns": [
      {
        "lineno": 337,
        "coloffset": 4,
        "linematch": "def make_text_control(",
        "context": "        else:\n            return self.make_text_control\n\n    @staticmethod\n    def make_text_control(\n        default: Any,\n        label: Text | None,\n        multiple: bool,\n        schema: OptionSchema | ArgumentSchema,\n        control_id: str,",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 337,
        "coloffset": 4,
        "linematch": "def make_text_control(",
        "context": "        else:\n            return self.make_text_control\n\n    @staticmethod\n    def make_text_control(\n        default: Any,\n        label: Text | None,\n        multiple: bool,\n        schema: OptionSchema | ArgumentSchema,\n        control_id: str,",
        "pattern": ".//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "nested-loop-conditions"
      },
      {
        "lineno": 344,
        "coloffset": 8,
        "linematch": "control = Input(",
        "context": "        multiple: bool,\n        schema: OptionSchema | ArgumentSchema,\n        control_id: str,\n    ) -> Widget:\n        control = Input(\n            classes=f\"command-form-input {control_id}\",\n        )\n        yield control\n        return control\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 347,
        "coloffset": 8,
        "linematch": "yield control",
        "context": "    ) -> Widget:\n        control = Input(\n            classes=f\"command-form-input {control_id}\",\n        )\n        yield control\n        return control\n\n    @staticmethod\n    def make_checkbox_control(\n        default: MultiValueParamData,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 348,
        "coloffset": 8,
        "linematch": "return control",
        "context": "        control = Input(\n            classes=f\"command-form-input {control_id}\",\n        )\n        yield control\n        return control\n\n    @staticmethod\n    def make_checkbox_control(\n        default: MultiValueParamData,\n        label: Text | None,",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "on_input_changed",
    "function_scope": "145-146",
    "patterns": [
      {
        "lineno": 145,
        "coloffset": 4,
        "linematch": "def on_input_changed(self) -> None:",
        "context": "\n    def on_mount(self) -> None:\n        self._form_changed()\n\n    def on_input_changed(self) -> None:\n        self._form_changed()\n\n    def on_select_changed(self) -> None:\n        self._form_changed()\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 146,
        "coloffset": 8,
        "linematch": "self._form_changed()",
        "context": "    def on_mount(self) -> None:\n        self._form_changed()\n\n    def on_input_changed(self) -> None:\n        self._form_changed()\n\n    def on_select_changed(self) -> None:\n        self._form_changed()\n\n    def on_checkbox_changed(self) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "on_select_changed",
    "function_scope": "148-149",
    "patterns": [
      {
        "lineno": 148,
        "coloffset": 4,
        "linematch": "def on_select_changed(self) -> None:",
        "context": "\n    def on_input_changed(self) -> None:\n        self._form_changed()\n\n    def on_select_changed(self) -> None:\n        self._form_changed()\n\n    def on_checkbox_changed(self) -> None:\n        self._form_changed()\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 149,
        "coloffset": 8,
        "linematch": "self._form_changed()",
        "context": "    def on_input_changed(self) -> None:\n        self._form_changed()\n\n    def on_select_changed(self) -> None:\n        self._form_changed()\n\n    def on_checkbox_changed(self) -> None:\n        self._form_changed()\n\n    def on_multiple_choice_changed(self) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "on_checkbox_changed",
    "function_scope": "151-152",
    "patterns": [
      {
        "lineno": 151,
        "coloffset": 4,
        "linematch": "def on_checkbox_changed(self) -> None:",
        "context": "\n    def on_select_changed(self) -> None:\n        self._form_changed()\n\n    def on_checkbox_changed(self) -> None:\n        self._form_changed()\n\n    def on_multiple_choice_changed(self) -> None:\n        self._form_changed()\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 152,
        "coloffset": 8,
        "linematch": "self._form_changed()",
        "context": "    def on_select_changed(self) -> None:\n        self._form_changed()\n\n    def on_checkbox_changed(self) -> None:\n        self._form_changed()\n\n    def on_multiple_choice_changed(self) -> None:\n        self._form_changed()\n\n    def _form_changed(self) -> None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "on_multiple_choice_changed",
    "function_scope": "154-155",
    "patterns": [
      {
        "lineno": 154,
        "coloffset": 4,
        "linematch": "def on_multiple_choice_changed(self) -> None:",
        "context": "\n    def on_checkbox_changed(self) -> None:\n        self._form_changed()\n\n    def on_multiple_choice_changed(self) -> None:\n        self._form_changed()\n\n    def _form_changed(self) -> None:\n        \"\"\"Take the current state of the form and build a UserCommandData from it,\n        then post a FormChanged message\"\"\"",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 155,
        "coloffset": 8,
        "linematch": "self._form_changed()",
        "context": "    def on_checkbox_changed(self) -> None:\n        self._form_changed()\n\n    def on_multiple_choice_changed(self) -> None:\n        self._form_changed()\n\n    def _form_changed(self) -> None:\n        \"\"\"Take the current state of the form and build a UserCommandData from it,\n        then post a FormChanged message\"\"\"\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "_form_changed",
    "function_scope": "157-210",
    "patterns": [
      {
        "lineno": 157,
        "coloffset": 4,
        "linematch": "def _form_changed(self) -> None:",
        "context": "\n    def on_multiple_choice_changed(self) -> None:\n        self._form_changed()\n\n    def _form_changed(self) -> None:\n        \"\"\"Take the current state of the form and build a UserCommandData from it,\n        then post a FormChanged message\"\"\"\n\n        command_schema = self.command_schema\n        path_from_root = command_schema.path_from_root",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 157,
        "coloffset": 4,
        "linematch": "def _form_changed(self) -> None:",
        "context": "\n    def on_multiple_choice_changed(self) -> None:\n        self._form_changed()\n\n    def _form_changed(self) -> None:\n        \"\"\"Take the current state of the form and build a UserCommandData from it,\n        then post a FormChanged message\"\"\"\n\n        command_schema = self.command_schema\n        path_from_root = command_schema.path_from_root",
        "pattern": ".//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "function-uses-loop-variable"
      },
      {
        "lineno": 170,
        "coloffset": 8,
        "linematch": "for command in path_from_root:",
        "context": "            name=CommandName(\"_\"), options=[], arguments=[]\n        )\n\n        root_command_data = parent_command_data\n        for command in path_from_root:\n            option_datas = []\n            # For each of the options in the schema for this command,\n            # lets grab the values the user has supplied for them in the form.\n            for option in command.options:\n                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 174,
        "coloffset": 12,
        "linematch": "for option in command.options:",
        "context": "        for command in path_from_root:\n            option_datas = []\n            # For each of the options in the schema for this command,\n            # lets grab the values the user has supplied for them in the form.\n            for option in command.options:\n                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n                value = parameter_control.get_values()\n                for v in value.values:\n                    assert isinstance(v, tuple)\n                    option_data = UserOptionData(option.name, v, option)",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 184,
        "coloffset": 12,
        "linematch": "for argument in command.arguments:",
        "context": "                    option_datas.append(option_data)\n\n            # Now do the same for the arguments\n            argument_datas = []\n            for argument in command.arguments:\n                form_control_widget = self.query_one(\n                    f\"#{argument.key}\", ParameterControls\n                )\n                value = form_control_widget.get_values()\n                # This should only ever loop once since arguments can be multi-value but not multiple=True.",
        "pattern": ".//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "nested-loop-conditions-ff"
      },
      {
        "lineno": 158,
        "coloffset": 8,
        "linematch": "\"\"\"Take the current state of the form and build a UserCommandData from it,",
        "context": "    def on_multiple_choice_changed(self) -> None:\n        self._form_changed()\n\n    def _form_changed(self) -> None:\n        \"\"\"Take the current state of the form and build a UserCommandData from it,\n        then post a FormChanged message\"\"\"\n\n        command_schema = self.command_schema\n        path_from_root = command_schema.path_from_root\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 161,
        "coloffset": 8,
        "linematch": "command_schema = self.command_schema",
        "context": "    def _form_changed(self) -> None:\n        \"\"\"Take the current state of the form and build a UserCommandData from it,\n        then post a FormChanged message\"\"\"\n\n        command_schema = self.command_schema\n        path_from_root = command_schema.path_from_root\n\n        # Sentinel root value to make constructing the tree a little easier.\n        parent_command_data = UserCommandData(\n            name=CommandName(\"_\"), options=[], arguments=[]",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 162,
        "coloffset": 8,
        "linematch": "path_from_root = command_schema.path_from_root",
        "context": "        \"\"\"Take the current state of the form and build a UserCommandData from it,\n        then post a FormChanged message\"\"\"\n\n        command_schema = self.command_schema\n        path_from_root = command_schema.path_from_root\n\n        # Sentinel root value to make constructing the tree a little easier.\n        parent_command_data = UserCommandData(\n            name=CommandName(\"_\"), options=[], arguments=[]\n        )",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 165,
        "coloffset": 8,
        "linematch": "parent_command_data = UserCommandData(",
        "context": "        command_schema = self.command_schema\n        path_from_root = command_schema.path_from_root\n\n        # Sentinel root value to make constructing the tree a little easier.\n        parent_command_data = UserCommandData(\n            name=CommandName(\"_\"), options=[], arguments=[]\n        )\n\n        root_command_data = parent_command_data\n        for command in path_from_root:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 169,
        "coloffset": 8,
        "linematch": "root_command_data = parent_command_data",
        "context": "        parent_command_data = UserCommandData(\n            name=CommandName(\"_\"), options=[], arguments=[]\n        )\n\n        root_command_data = parent_command_data\n        for command in path_from_root:\n            option_datas = []\n            # For each of the options in the schema for this command,\n            # lets grab the values the user has supplied for them in the form.\n            for option in command.options:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 170,
        "coloffset": 8,
        "linematch": "for command in path_from_root:",
        "context": "            name=CommandName(\"_\"), options=[], arguments=[]\n        )\n\n        root_command_data = parent_command_data\n        for command in path_from_root:\n            option_datas = []\n            # For each of the options in the schema for this command,\n            # lets grab the values the user has supplied for them in the form.\n            for option in command.options:\n                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 208,
        "coloffset": 8,
        "linematch": "root_command_data = root_command_data.subcommand",
        "context": "            parent_command_data.subcommand = command_data\n            parent_command_data = command_data\n\n        # Trim the sentinel\n        root_command_data = root_command_data.subcommand\n        root_command_data.parent = None\n        self.post_message(self.Changed(root_command_data))\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 209,
        "coloffset": 8,
        "linematch": "root_command_data.parent = None",
        "context": "            parent_command_data = command_data\n\n        # Trim the sentinel\n        root_command_data = root_command_data.subcommand\n        root_command_data.parent = None\n        self.post_message(self.Changed(root_command_data))\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:\n            return self.first_control.focus()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 210,
        "coloffset": 8,
        "linematch": "self.post_message(self.Changed(root_command_data))",
        "context": "\n        # Trim the sentinel\n        root_command_data = root_command_data.subcommand\n        root_command_data.parent = None\n        self.post_message(self.Changed(root_command_data))\n\n    def focus(self, scroll_visible: bool = True):\n        if self.first_control is not None:\n            return self.first_control.focus()\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 157,
        "coloffset": 4,
        "linematch": "def _form_changed(self) -> None:",
        "context": "\n    def on_multiple_choice_changed(self) -> None:\n        self._form_changed()\n\n    def _form_changed(self) -> None:\n        \"\"\"Take the current state of the form and build a UserCommandData from it,\n        then post a FormChanged message\"\"\"\n\n        command_schema = self.command_schema\n        path_from_root = command_schema.path_from_root",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "F030",
        "check_name": "deeply-nested-control-structures"
      },
      {
        "lineno": 157,
        "coloffset": 4,
        "linematch": "def _form_changed(self) -> None:",
        "context": "\n    def on_multiple_choice_changed(self) -> None:\n        self._form_changed()\n\n    def _form_changed(self) -> None:\n        \"\"\"Take the current state of the form and build a UserCommandData from it,\n        then post a FormChanged message\"\"\"\n\n        command_schema = self.command_schema\n        path_from_root = command_schema.path_from_root",
        "pattern": ".//FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]",
        "check_id": "P005",
        "check_name": "long-scope-chaining"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #664",
        "line": 161,
        "description": [
          "        command_schema = self.command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -158,7 +158,7 @@\n         \"\"\"Take the current state of the form and build a UserCommandData from it,\n         then post a FormChanged message\"\"\"\n \n-        command_schema = self.command_schema\n+        command_schema = None\n         path_from_root = command_schema.path_from_root\n \n         # Sentinel root value to make constructing the tree a little easier.\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #665",
        "line": 162,
        "description": [
          "        path_from_root = command_schema.path_from_root"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -159,7 +159,7 @@\n         then post a FormChanged message\"\"\"\n \n         command_schema = self.command_schema\n-        path_from_root = command_schema.path_from_root\n+        path_from_root = None\n \n         # Sentinel root value to make constructing the tree a little easier.\n         parent_command_data = UserCommandData(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #666",
        "line": 166,
        "description": [
          "            name=CommandName(\"_\"), options=[], arguments=[]"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -163,7 +163,7 @@\n \n         # Sentinel root value to make constructing the tree a little easier.\n         parent_command_data = UserCommandData(\n-            name=CommandName(\"_\"), options=[], arguments=[]\n+            name=CommandName(\"XX_XX\"), options=[], arguments=[]\n         )\n \n         root_command_data = parent_command_data\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #667",
        "line": 167,
        "description": [
          "        )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -162,9 +162,7 @@\n         path_from_root = command_schema.path_from_root\n \n         # Sentinel root value to make constructing the tree a little easier.\n-        parent_command_data = UserCommandData(\n-            name=CommandName(\"_\"), options=[], arguments=[]\n-        )\n+        parent_command_data = None\n \n         root_command_data = parent_command_data\n         for command in path_from_root:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #668",
        "line": 169,
        "description": [
          "        root_command_data = parent_command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -166,7 +166,7 @@\n             name=CommandName(\"_\"), options=[], arguments=[]\n         )\n \n-        root_command_data = parent_command_data\n+        root_command_data = None\n         for command in path_from_root:\n             option_datas = []\n             # For each of the options in the schema for this command,\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #669",
        "line": 171,
        "description": [
          "            option_datas = []"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -168,7 +168,7 @@\n \n         root_command_data = parent_command_data\n         for command in path_from_root:\n-            option_datas = []\n+            option_datas = None\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #670",
        "line": 175,
        "description": [
          "                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -172,7 +172,7 @@\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n-                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n+                parameter_control = self.query_one(f\"XX#{option.key}XX\", ParameterControls)\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #671",
        "line": 175,
        "description": [
          "                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -172,7 +172,7 @@\n             # For each of the options in the schema for this command,\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n-                parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n+                parameter_control = None\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #672",
        "line": 176,
        "description": [
          "                value = parameter_control.get_values()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -173,7 +173,7 @@\n             # lets grab the values the user has supplied for them in the form.\n             for option in command.options:\n                 parameter_control = self.query_one(f\"#{option.key}\", ParameterControls)\n-                value = parameter_control.get_values()\n+                value = None\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n                     option_data = UserOptionData(option.name, v, option)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #673",
        "line": 179,
        "description": [
          "                    option_data = UserOptionData(option.name, v, option)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -176,7 +176,7 @@\n                 value = parameter_control.get_values()\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n-                    option_data = UserOptionData(option.name, v, option)\n+                    option_data = None\n                     option_datas.append(option_data)\n \n             # Now do the same for the arguments\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #674",
        "line": 183,
        "description": [
          "            argument_datas = []"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -180,7 +180,7 @@\n                     option_datas.append(option_data)\n \n             # Now do the same for the arguments\n-            argument_datas = []\n+            argument_datas = None\n             for argument in command.arguments:\n                 form_control_widget = self.query_one(\n                     f\"#{argument.key}\", ParameterControls\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #675",
        "line": 186,
        "description": [
          "                    f\"#{argument.key}\", ParameterControls"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -183,7 +183,7 @@\n             argument_datas = []\n             for argument in command.arguments:\n                 form_control_widget = self.query_one(\n-                    f\"#{argument.key}\", ParameterControls\n+                    f\"XX#{argument.key}XX\", ParameterControls\n                 )\n                 value = form_control_widget.get_values()\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #676",
        "line": 187,
        "description": [
          "                )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -182,9 +182,7 @@\n             # Now do the same for the arguments\n             argument_datas = []\n             for argument in command.arguments:\n-                form_control_widget = self.query_one(\n-                    f\"#{argument.key}\", ParameterControls\n-                )\n+                form_control_widget = None\n                 value = form_control_widget.get_values()\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #677",
        "line": 188,
        "description": [
          "                value = form_control_widget.get_values()"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -185,7 +185,7 @@\n                 form_control_widget = self.query_one(\n                     f\"#{argument.key}\", ParameterControls\n                 )\n-                value = form_control_widget.get_values()\n+                value = None\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #678",
        "line": 192,
        "description": [
          "                    argument_data = UserArgumentData(argument.name, v, argument)"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -189,7 +189,7 @@\n                 # This should only ever loop once since arguments can be multi-value but not multiple=True.\n                 for v in value.values:\n                     assert isinstance(v, tuple)\n-                    argument_data = UserArgumentData(argument.name, v, argument)\n+                    argument_data = None\n                     argument_datas.append(argument_data)\n \n             assert all(isinstance(option.value, tuple) for option in option_datas)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #679",
        "line": 203,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -194,13 +194,7 @@\n \n             assert all(isinstance(option.value, tuple) for option in option_datas)\n             assert all(isinstance(argument.value, tuple) for argument in argument_datas)\n-            command_data = UserCommandData(\n-                name=command.name,\n-                options=option_datas,\n-                arguments=argument_datas,\n-                parent=parent_command_data,\n-                command_schema=command,\n-            )\n+            command_data = None\n             parent_command_data.subcommand = command_data\n             parent_command_data = command_data\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #680",
        "line": 204,
        "description": [
          "            parent_command_data.subcommand = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -201,7 +201,7 @@\n                 parent=parent_command_data,\n                 command_schema=command,\n             )\n-            parent_command_data.subcommand = command_data\n+            parent_command_data.subcommand = None\n             parent_command_data = command_data\n \n         # Trim the sentinel\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #681",
        "line": 205,
        "description": [
          "            parent_command_data = command_data"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -202,7 +202,7 @@\n                 command_schema=command,\n             )\n             parent_command_data.subcommand = command_data\n-            parent_command_data = command_data\n+            parent_command_data = None\n \n         # Trim the sentinel\n         root_command_data = root_command_data.subcommand\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #682",
        "line": 208,
        "description": [
          "        root_command_data = root_command_data.subcommand"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -205,7 +205,7 @@\n             parent_command_data = command_data\n \n         # Trim the sentinel\n-        root_command_data = root_command_data.subcommand\n+        root_command_data = None\n         root_command_data.parent = None\n         self.post_message(self.Changed(root_command_data))\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #683",
        "line": 209,
        "description": [
          "        root_command_data.parent = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -206,7 +206,7 @@\n \n         # Trim the sentinel\n         root_command_data = root_command_data.subcommand\n-        root_command_data.parent = None\n+        root_command_data.parent = \"\"\n         self.post_message(self.Changed(root_command_data))\n \n     def focus(self, scroll_visible: bool = True):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "switch_content",
    "function_scope": "112-113",
    "patterns": [
      {
        "lineno": 112,
        "coloffset": 4,
        "linematch": "def switch_content(self, event: Tabs.TabActivated) -> None:",
        "context": "                    classes=\"command-info-metadata\",\n                )\n\n    @on(Tabs.TabActivated)\n    def switch_content(self, event: Tabs.TabActivated) -> None:\n        self.query_one(ContentSwitcher).current = event.tab.id\n\n    def action_close_modal(self):\n        self.app.pop_screen()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 113,
        "coloffset": 8,
        "linematch": "self.query_one(ContentSwitcher).current = event.tab.id",
        "context": "                )\n\n    @on(Tabs.TabActivated)\n    def switch_content(self, event: Tabs.TabActivated) -> None:\n        self.query_one(ContentSwitcher).current = event.tab.id\n\n    def action_close_modal(self):\n        self.app.pop_screen()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #640",
        "line": 112,
        "description": [
          "                options = command_node.options"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -109,7 +109,7 @@\n             )\n \n             while command_node is not None:\n-                options = command_node.options\n+                options = None\n                 arguments = command_node.arguments\n                 if options or arguments:\n                     with Vertical(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #641",
        "line": 113,
        "description": [
          "                arguments = command_node.arguments"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -110,7 +110,7 @@\n \n             while command_node is not None:\n                 options = command_node.options\n-                arguments = command_node.arguments\n+                arguments = None\n                 if options or arguments:\n                     with Vertical(\n                         classes=\"command-form-command-group\", id=command_node.key\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "action_close_modal",
    "function_scope": "115-116",
    "patterns": [
      {
        "lineno": 115,
        "coloffset": 4,
        "linematch": "def action_close_modal(self):",
        "context": "    @on(Tabs.TabActivated)\n    def switch_content(self, event: Tabs.TabActivated) -> None:\n        self.query_one(ContentSwitcher).current = event.tab.id\n\n    def action_close_modal(self):\n        self.app.pop_screen()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 116,
        "coloffset": 8,
        "linematch": "self.app.pop_screen()",
        "context": "    def switch_content(self, event: Tabs.TabActivated) -> None:\n        self.query_one(ContentSwitcher).current = event.tab.id\n\n    def action_close_modal(self):\n        self.app.pop_screen()",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #643",
        "line": 116,
        "description": [
          "                        classes=\"command-form-command-group\", id=command_node.key"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -113,7 +113,7 @@\n                 arguments = command_node.arguments\n                 if options or arguments:\n                     with Vertical(\n-                        classes=\"command-form-command-group\", id=command_node.key\n+                        classes=\"XXcommand-form-command-groupXX\", id=command_node.key\n                     ) as v:\n                         is_inherited = command_node is not self.command_schema\n                         v.border_title = (\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "command_schema",
    "function_scope": "14-30",
    "patterns": [
      {
        "lineno": 14,
        "coloffset": 0,
        "linematch": "def command_schema():",
        "context": "from trogon.run_command import UserCommandData, UserOptionData, UserArgumentData\n\n\n@pytest.fixture\ndef command_schema():\n    return CommandSchema(\n        name=CommandName(\"test\"),\n        arguments=[\n            ArgumentSchema(name=\"arg1\", type=click.INT, required=False, default=MultiValueParamData([(123,)])),\n        ],",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "return CommandSchema(",
        "context": "\n\n@pytest.fixture\ndef command_schema():\n    return CommandSchema(\n        name=CommandName(\"test\"),\n        arguments=[\n            ArgumentSchema(name=\"arg1\", type=click.INT, required=False, default=MultiValueParamData([(123,)])),\n        ],\n        options=[",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #624",
        "line": 22,
        "description": [
          "@dataclasses.dataclass"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -18,8 +18,6 @@\n from trogon.run_command import UserCommandData, UserOptionData, UserArgumentData\n from trogon.widgets.parameter_controls import ParameterControls\n \n-\n-@dataclasses.dataclass\n class FormControlMeta:\n     widget: Widget\n     meta: OptionSchema | ArgumentSchema\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "command_schema_with_subcommand",
    "function_scope": "34-47",
    "patterns": [
      {
        "lineno": 34,
        "coloffset": 0,
        "linematch": "def command_schema_with_subcommand(command_schema):",
        "context": "    )\n\n\n@pytest.fixture\ndef command_schema_with_subcommand(command_schema):\n    command_schema.subcommands = {\n        \"sub\": CommandSchema(\n            name=CommandName(\"sub\"),\n            options=[\n                OptionSchema(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "command_schema.subcommands = {",
        "context": "\n\n@pytest.fixture\ndef command_schema_with_subcommand(command_schema):\n    command_schema.subcommands = {\n        \"sub\": CommandSchema(\n            name=CommandName(\"sub\"),\n            options=[\n                OptionSchema(\n                    name=[\"--sub-option\"], type=click.BOOL, required=False, default=MultiValueParamData([(False,)])",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "return command_schema",
        "context": "            arguments=[],\n            function=lambda: 2,\n        )\n    }\n    return command_schema\n\n\n@pytest.fixture\ndef user_command_data_no_subcommand():\n    return UserCommandData(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "user_command_data_no_subcommand",
    "function_scope": "51-63",
    "patterns": [
      {
        "lineno": 51,
        "coloffset": 0,
        "linematch": "def user_command_data_no_subcommand():",
        "context": "    return command_schema\n\n\n@pytest.fixture\ndef user_command_data_no_subcommand():\n    return UserCommandData(\n        name=CommandName(\"test\"),\n        options=[\n            UserOptionData(name=\"--option1\", value=(\"value1\",),\n                           option_schema=OptionSchema(name=[\"--option1\", \"-o1\"], type=click.STRING)),",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 52,
        "coloffset": 4,
        "linematch": "return UserCommandData(",
        "context": "\n\n@pytest.fixture\ndef user_command_data_no_subcommand():\n    return UserCommandData(\n        name=CommandName(\"test\"),\n        options=[\n            UserOptionData(name=\"--option1\", value=(\"value1\",),\n                           option_schema=OptionSchema(name=[\"--option1\", \"-o1\"], type=click.STRING)),\n            UserOptionData(name=\"--option2\", value=(\"42\",),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "user_command_data_with_subcommand",
    "function_scope": "67-80",
    "patterns": [
      {
        "lineno": 67,
        "coloffset": 0,
        "linematch": "def user_command_data_with_subcommand(user_command_data_no_subcommand):",
        "context": "    )\n\n\n@pytest.fixture\ndef user_command_data_with_subcommand(user_command_data_no_subcommand):\n    return UserCommandData(\n        name=CommandName(\"test\"),\n        options=user_command_data_no_subcommand.options,\n        arguments=user_command_data_no_subcommand.arguments,\n        subcommand=UserCommandData(",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 68,
        "coloffset": 4,
        "linematch": "return UserCommandData(",
        "context": "\n\n@pytest.fixture\ndef user_command_data_with_subcommand(user_command_data_no_subcommand):\n    return UserCommandData(\n        name=CommandName(\"test\"),\n        options=user_command_data_no_subcommand.options,\n        arguments=user_command_data_no_subcommand.arguments,\n        subcommand=UserCommandData(\n            name=CommandName(\"sub\"),",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_to_cli_args_no_subcommand",
    "function_scope": "83-85",
    "patterns": [
      {
        "lineno": 83,
        "coloffset": 0,
        "linematch": "def test_to_cli_args_no_subcommand(user_command_data_no_subcommand):",
        "context": "        ),\n    )\n\n\ndef test_to_cli_args_no_subcommand(user_command_data_no_subcommand):\n    cli_args = user_command_data_no_subcommand.to_cli_args(True)\n    assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]\n\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 85,
        "coloffset": 4,
        "linematch": "assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]",
        "context": "\n\ndef test_to_cli_args_no_subcommand(user_command_data_no_subcommand):\n    cli_args = user_command_data_no_subcommand.to_cli_args(True)\n    assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]\n\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)\n    assert cli_args == [",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "cli_args = user_command_data_no_subcommand.to_cli_args(True)",
        "context": "    )\n\n\ndef test_to_cli_args_no_subcommand(user_command_data_no_subcommand):\n    cli_args = user_command_data_no_subcommand.to_cli_args(True)\n    assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]\n\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 85,
        "coloffset": 4,
        "linematch": "assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]",
        "context": "\n\ndef test_to_cli_args_no_subcommand(user_command_data_no_subcommand):\n    cli_args = user_command_data_no_subcommand.to_cli_args(True)\n    assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]\n\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)\n    assert cli_args == [",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "cli_args = user_command_data_no_subcommand.to_cli_args(True)",
        "context": "    )\n\n\ndef test_to_cli_args_no_subcommand(user_command_data_no_subcommand):\n    cli_args = user_command_data_no_subcommand.to_cli_args(True)\n    assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]\n\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 85,
        "coloffset": 4,
        "linematch": "assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]",
        "context": "\n\ndef test_to_cli_args_no_subcommand(user_command_data_no_subcommand):\n    cli_args = user_command_data_no_subcommand.to_cli_args(True)\n    assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]\n\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)\n    assert cli_args == [",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_to_cli_args_with_subcommand",
    "function_scope": "88-100",
    "patterns": [
      {
        "lineno": 88,
        "coloffset": 0,
        "linematch": "def test_to_cli_args_with_subcommand(user_command_data_with_subcommand):",
        "context": "    cli_args = user_command_data_no_subcommand.to_cli_args(True)\n    assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]\n\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)\n    assert cli_args == [\n        \"test\",\n        \"--option1\",\n        \"value1\",",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 90,
        "coloffset": 4,
        "linematch": "assert cli_args == [",
        "context": "\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)\n    assert cli_args == [\n        \"test\",\n        \"--option1\",\n        \"value1\",\n        \"--option2\",\n        \"42\",",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 89,
        "coloffset": 4,
        "linematch": "cli_args = user_command_data_with_subcommand.to_cli_args(True)",
        "context": "    assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]\n\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)\n    assert cli_args == [\n        \"test\",\n        \"--option1\",\n        \"value1\",\n        \"--option2\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 90,
        "coloffset": 4,
        "linematch": "assert cli_args == [",
        "context": "\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)\n    assert cli_args == [\n        \"test\",\n        \"--option1\",\n        \"value1\",\n        \"--option2\",\n        \"42\",",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 89,
        "coloffset": 4,
        "linematch": "cli_args = user_command_data_with_subcommand.to_cli_args(True)",
        "context": "    assert cli_args == [\"test\", \"--option1\", \"value1\", \"--option2\", \"42\", \"123\"]\n\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)\n    assert cli_args == [\n        \"test\",\n        \"--option1\",\n        \"value1\",\n        \"--option2\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 90,
        "coloffset": 4,
        "linematch": "assert cli_args == [",
        "context": "\n\ndef test_to_cli_args_with_subcommand(user_command_data_with_subcommand):\n    cli_args = user_command_data_with_subcommand.to_cli_args(True)\n    assert cli_args == [\n        \"test\",\n        \"--option1\",\n        \"value1\",\n        \"--option2\",\n        \"42\",",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #627",
        "line": 92,
        "description": [
          "        disabled: bool = False,"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -89,7 +89,7 @@\n         name: str | None = None,\n         id: str | None = None,\n         classes: str | None = None,\n-        disabled: bool = False,\n+        disabled: bool = True,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #628",
        "line": 95,
        "description": [
          "        self.command_schema = command_schema"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -92,7 +92,7 @@\n         disabled: bool = False,\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n-        self.command_schema = command_schema\n+        self.command_schema = None\n         self.command_schemas = command_schemas\n         self.first_control: ParameterControls | None = None\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #629",
        "line": 96,
        "description": [
          "        self.command_schemas = command_schemas"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -93,7 +93,7 @@\n     ):\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n-        self.command_schemas = command_schemas\n+        self.command_schemas = None\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #630",
        "line": 97,
        "description": [
          "        self.first_control: ParameterControls | None = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -94,7 +94,7 @@\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n         self.command_schemas = command_schemas\n-        self.first_control: ParameterControls | None = None\n+        self.first_control: ParameterControls & None = None\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #631",
        "line": 97,
        "description": [
          "        self.first_control: ParameterControls | None = None"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -94,7 +94,7 @@\n         super().__init__(name=name, id=id, classes=classes, disabled=disabled)\n         self.command_schema = command_schema\n         self.command_schemas = command_schemas\n-        self.first_control: ParameterControls | None = None\n+        self.first_control: ParameterControls | None = \"\"\n \n     def compose(self) -> ComposeResult:\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #632",
        "line": 100,
        "description": [
          "        path_from_root = iter(reversed(self.command_schema.path_from_root))"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -97,7 +97,7 @@\n         self.first_control: ParameterControls | None = None\n \n     def compose(self) -> ComposeResult:\n-        path_from_root = iter(reversed(self.command_schema.path_from_root))\n+        path_from_root = None\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n             vs.can_focus = False\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "test_to_cli_string_no_subcommand",
    "function_scope": "103-106",
    "patterns": [
      {
        "lineno": 103,
        "coloffset": 0,
        "linematch": "def test_to_cli_string_no_subcommand(user_command_data_no_subcommand):",
        "context": "        \"True\",\n    ]\n\n\ndef test_to_cli_string_no_subcommand(user_command_data_no_subcommand):\n    cli_string = user_command_data_no_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123\"\n\n",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 106,
        "coloffset": 4,
        "linematch": "assert cli_string.plain == \"test --option1 value1 --option2 42 123\"",
        "context": "\ndef test_to_cli_string_no_subcommand(user_command_data_no_subcommand):\n    cli_string = user_command_data_no_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123\"\n\n\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 104,
        "coloffset": 4,
        "linematch": "cli_string = user_command_data_no_subcommand.to_cli_string(True)",
        "context": "    ]\n\n\ndef test_to_cli_string_no_subcommand(user_command_data_no_subcommand):\n    cli_string = user_command_data_no_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123\"\n\n\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 106,
        "coloffset": 4,
        "linematch": "assert cli_string.plain == \"test --option1 value1 --option2 42 123\"",
        "context": "\ndef test_to_cli_string_no_subcommand(user_command_data_no_subcommand):\n    cli_string = user_command_data_no_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123\"\n\n\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 104,
        "coloffset": 4,
        "linematch": "cli_string = user_command_data_no_subcommand.to_cli_string(True)",
        "context": "    ]\n\n\ndef test_to_cli_string_no_subcommand(user_command_data_no_subcommand):\n    cli_string = user_command_data_no_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123\"\n\n\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 106,
        "coloffset": 4,
        "linematch": "assert cli_string.plain == \"test --option1 value1 --option2 42 123\"",
        "context": "\ndef test_to_cli_string_no_subcommand(user_command_data_no_subcommand):\n    cli_string = user_command_data_no_subcommand.to_cli_string(True)\n\n    assert cli_string.plain == \"test --option1 value1 --option2 42 123\"\n\n\ndef test_to_cli_string_with_subcommand(user_command_data_with_subcommand):\n    cli_string = user_command_data_with_subcommand.to_cli_string(True)\n",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #634",
        "line": 103,
        "description": [
          "            vs.can_focus = False"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -100,7 +100,7 @@\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n-            vs.can_focus = False\n+            vs.can_focus = True\n \n             yield Input(\n                 placeholder=\"Search...\",\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #635",
        "line": 103,
        "description": [
          "            vs.can_focus = False"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -100,7 +100,7 @@\n         path_from_root = iter(reversed(self.command_schema.path_from_root))\n         command_node = next(path_from_root)\n         with VerticalScroll() as vs:\n-            vs.can_focus = False\n+            vs.can_focus = None\n \n             yield Input(\n                 placeholder=\"Search...\",\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #636",
        "line": 106,
        "description": [
          "                placeholder=\"Search...\","
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -103,7 +103,7 @@\n             vs.can_focus = False\n \n             yield Input(\n-                placeholder=\"Search...\",\n+                placeholder=\"XXSearch...XX\",\n                 classes=\"command-form-filter-input\",\n                 id=\"search\",\n             )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "default",
    "function_scope": "9-10",
    "patterns": [
      {
        "lineno": 9,
        "coloffset": 0,
        "linematch": "def default():",
        "context": "\n\n@tui()\n@click.group()\ndef default():\n    pass\n\n\n@tui(command=\"custom\")\n@click.group()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "pass",
        "context": "\n@tui()\n@click.group()\ndef default():\n    pass\n\n\n@tui(command=\"custom\")\n@click.group()\ndef custom_command():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "custom_command",
    "function_scope": "15-16",
    "patterns": [
      {
        "lineno": 15,
        "coloffset": 0,
        "linematch": "def custom_command():",
        "context": "\n\n@tui(command=\"custom\")\n@click.group()\ndef custom_command():\n    pass\n\n\n@tui(help=\"Custom help\")\n@click.group()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "pass",
        "context": "\n@tui(command=\"custom\")\n@click.group()\ndef custom_command():\n    pass\n\n\n@tui(help=\"Custom help\")\n@click.group()\ndef custom_help():",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "custom_help",
    "function_scope": "21-22",
    "patterns": [
      {
        "lineno": 21,
        "coloffset": 0,
        "linematch": "def custom_help():",
        "context": "\n\n@tui(help=\"Custom help\")\n@click.group()\ndef custom_help():\n    pass\n\n\ndef test_default_help():\n    result = CliRunner().invoke(default, [\"--help\"])",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "pass",
        "context": "\n@tui(help=\"Custom help\")\n@click.group()\ndef custom_help():\n    pass\n\n\ndef test_default_help():\n    result = CliRunner().invoke(default, [\"--help\"])\n    assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #624",
        "line": 22,
        "description": [
          "@dataclasses.dataclass"
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -18,8 +18,6 @@\n from trogon.run_command import UserCommandData, UserOptionData, UserArgumentData\n from trogon.widgets.parameter_controls import ParameterControls\n \n-\n-@dataclasses.dataclass\n class FormControlMeta:\n     widget: Widget\n     meta: OptionSchema | ArgumentSchema\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "test_default_help",
    "function_scope": "25-27",
    "patterns": [
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def test_default_help():",
        "context": "def custom_help():\n    pass\n\n\ndef test_default_help():\n    result = CliRunner().invoke(default, [\"--help\"])\n    assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_command():",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None",
        "context": "\n\ndef test_default_help():\n    result = CliRunner().invoke(default, [\"--help\"])\n    assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])\n    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "result = CliRunner().invoke(default, [\"--help\"])",
        "context": "    pass\n\n\ndef test_default_help():\n    result = CliRunner().invoke(default, [\"--help\"])\n    assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None",
        "context": "\n\ndef test_default_help():\n    result = CliRunner().invoke(default, [\"--help\"])\n    assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])\n    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "result = CliRunner().invoke(default, [\"--help\"])",
        "context": "    pass\n\n\ndef test_default_help():\n    result = CliRunner().invoke(default, [\"--help\"])\n    assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None",
        "context": "\n\ndef test_default_help():\n    result = CliRunner().invoke(default, [\"--help\"])\n    assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])\n    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_custom_command",
    "function_scope": "30-32",
    "patterns": [
      {
        "lineno": 30,
        "coloffset": 0,
        "linematch": "def test_custom_command():",
        "context": "    result = CliRunner().invoke(default, [\"--help\"])\n    assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])\n    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_help():",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None",
        "context": "\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])\n    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])\n    assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "result = CliRunner().invoke(custom_command, [\"--help\"])",
        "context": "    assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])\n    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None",
        "context": "\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])\n    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])\n    assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "result = CliRunner().invoke(custom_command, [\"--help\"])",
        "context": "    assert re.search(r\"tui\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])\n    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None",
        "context": "\n\ndef test_custom_command():\n    result = CliRunner().invoke(custom_command, [\"--help\"])\n    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])\n    assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #625",
        "line": 32,
        "description": [
          "    DEFAULT_CSS = \"\"\"    "
        ],
        "failure": [
          {
            "inner": "--- trogon/widgets/form.py\n+++ trogon/widgets/form.py\n@@ -29,52 +29,7 @@\n     \"\"\"Form which is constructed from an introspected Click app. Users\n     make use of this form in order to construct CLI invocation strings.\"\"\"\n \n-    DEFAULT_CSS = \"\"\"    \n-    .command-form-heading {\n-        padding: 1 0 0 1;\n-        text-style: u;\n-        color: $text;\n-    }\n-    .command-form-input {        \n-        border: tall transparent;\n-    }\n-    .command-form-label {\n-        padding: 1 0 0 1;\n-    }\n-    .command-form-checkbox {\n-        background: $boost;\n-        margin: 1 0 0 0;\n-        padding-left: 1;\n-        border: tall transparent;\n-    }\n-    .command-form-checkbox:focus {\n-      border: tall $accent;      \n-    }\n-    .command-form-checkbox:focus > .toggle--label {\n-        text-style: none;\n-    }\n-    .command-form-command-group {\n-        \n-        margin: 1 2;\n-        padding: 0 1;\n-        height: auto;\n-        background: $foreground 3%;\n-        border: panel $background;\n-        border-title-color: $text 80%;\n-        border-title-style: bold;\n-        border-subtitle-color: $text 30%;\n-        padding-bottom: 1;\n-    }\n-    .command-form-command-group:focus-within {\n-        border: panel $primary;\n-    }\n-    .command-form-control-help-text {        \n-        height: auto;\n-        color: $text 40%;\n-        padding-top: 0;\n-        padding-left: 1;\n-    }\n-    \"\"\"\n+    DEFAULT_CSS = None\n \n     class Changed(Message):\n         def __init__(self, command_data: UserCommandData):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "test_custom_help",
    "function_scope": "35-37",
    "patterns": [
      {
        "lineno": 35,
        "coloffset": 0,
        "linematch": "def test_custom_help():",
        "context": "    result = CliRunner().invoke(custom_command, [\"--help\"])\n    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])\n    assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "context": "\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])\n    assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "pattern": ".//FunctionDef/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "result = CliRunner().invoke(custom_help, [\"--help\"])",
        "context": "    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])\n    assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "context": "\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])\n    assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "pattern": ".//FunctionDef[starts-with(@name, \"test_\")]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "result = CliRunner().invoke(custom_help, [\"--help\"])",
        "context": "    assert re.search(r\"custom\\s+Open Textual TUI\", result.output) is not None\n\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])\n    assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "context": "\n\ndef test_custom_help():\n    result = CliRunner().invoke(custom_help, [\"--help\"])\n    assert re.search(r\"tui\\s+Custom help\", result.output) is not None",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "cli",
    "function_scope": "12-14",
    "patterns": [
      {
        "lineno": 12,
        "coloffset": 0,
        "linematch": "def cli(ctx, verbose):",
        "context": "@click.option(\n    \"--verbose\", \"-v\", count=True, default=1, help=\"Increase verbosity level.\"\n)\n@click.pass_context\ndef cli(ctx, verbose):\n    ctx.ensure_object(dict)\n    ctx.obj[\"verbose\"] = verbose\n\n\n@cli.command()",
        "pattern": ".//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "ctx.ensure_object(dict)",
        "context": "    \"--verbose\", \"-v\", count=True, default=1, help=\"Increase verbosity level.\"\n)\n@click.pass_context\ndef cli(ctx, verbose):\n    ctx.ensure_object(dict)\n    ctx.obj[\"verbose\"] = verbose\n\n\n@cli.command()\n@click.argument(\"task\")",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "ctx.obj[\"verbose\"] = verbose",
        "context": ")\n@click.pass_context\ndef cli(ctx, verbose):\n    ctx.ensure_object(dict)\n    ctx.obj[\"verbose\"] = verbose\n\n\n@cli.command()\n@click.argument(\"task\")\n@click.option(",
        "pattern": ".//FunctionDef/body/* | .//FunctionDef/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  }
]