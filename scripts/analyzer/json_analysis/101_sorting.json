[
  {
    "function_name": "test_sorting_algorithms_multiple_inputs",
    "function_scope": "21-32",
    "patterns": [
      {
        "lineno": 21,
        "coloffset": 0,
        "linematch": "def test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):",
        "context": "@pytest.mark.parametrize(\n    \"list_inputs, expected_answer\",\n    [([5, 3, 9, 2, 1], [1, 2, 3, 5, 9]), ([7, 2, 10, 3, 1], [1, 2, 3, 7, 10])],\n)\ndef test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 21,
        "coloffset": 0,
        "linematch": "def test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):",
        "context": "@pytest.mark.parametrize(\n    \"list_inputs, expected_answer\",\n    [([5, 3, 9, 2, 1], [1, 2, 3, 5, 9]), ([7, 2, 10, 3, 1], [1, 2, 3, 7, 10])],\n)\ndef test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": ")\ndef test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n\n\n@pytest.mark.parametrize(",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n\n\n@pytest.mark.parametrize(\n    \"list_inputs, expected_answer\",\n    [([10, 3, 1], [1, 3, 10])],",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "\"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"",
        "context": "    \"list_inputs, expected_answer\",\n    [([5, 3, 9, 2, 1], [1, 2, 3, 5, 9]), ([7, 2, 10, 3, 1], [1, 2, 3, 7, 10])],\n)\ndef test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.bubble_sort(list_inputs)",
        "context": "    [([5, 3, 9, 2, 1], [1, 2, 3, 5, 9]), ([7, 2, 10, 3, 1], [1, 2, 3, 7, 10])],\n)\ndef test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": ")\ndef test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.insertion_sort(list_inputs)",
        "context": "def test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.merge_sort(list_inputs)",
        "context": "    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.quick_sort(list_inputs)",
        "context": "    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n\n\n@pytest.mark.parametrize(",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.tim_sort(list_inputs)",
        "context": "    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n\n\n@pytest.mark.parametrize(\n    \"list_inputs, expected_answer\",",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n\n\n@pytest.mark.parametrize(\n    \"list_inputs, expected_answer\",\n    [([10, 3, 1], [1, 3, 10])],",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "\"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"",
        "context": "    \"list_inputs, expected_answer\",\n    [([5, 3, 9, 2, 1], [1, 2, 3, 5, 9]), ([7, 2, 10, 3, 1], [1, 2, 3, 7, 10])],\n)\ndef test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.bubble_sort(list_inputs)",
        "context": "    [([5, 3, 9, 2, 1], [1, 2, 3, 5, 9]), ([7, 2, 10, 3, 1], [1, 2, 3, 7, 10])],\n)\ndef test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": ")\ndef test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.insertion_sort(list_inputs)",
        "context": "def test_sorting_algorithms_multiple_inputs(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    \"\"\"Check the sorting algorithm functions with multiple inputs.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.merge_sort(list_inputs)",
        "context": "    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.quick_sort(list_inputs)",
        "context": "    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 30,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n\n\n@pytest.mark.parametrize(",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.tim_sort(list_inputs)",
        "context": "    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n\n\n@pytest.mark.parametrize(\n    \"list_inputs, expected_answer\",",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer\n\n\n@pytest.mark.parametrize(\n    \"list_inputs, expected_answer\",\n    [([10, 3, 1], [1, 3, 10])],",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #167",
        "line": 21,
        "description": [
          "console = Console()"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -18,7 +18,7 @@\n cli = typer.Typer()\n \n # create a Console objects\n-console = Console()\n+console = None\n \n # define name format\n UNDERSCORE = \"_\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #168",
        "line": 24,
        "description": [
          "UNDERSCORE = \"_\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -21,7 +21,7 @@\n console = Console()\n \n # define name format\n-UNDERSCORE = \"_\"\n+UNDERSCORE = \"XX_XX\"\n SORT = \"sort\"\n \n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #169",
        "line": 24,
        "description": [
          "UNDERSCORE = \"_\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -21,7 +21,7 @@\n console = Console()\n \n # define name format\n-UNDERSCORE = \"_\"\n+UNDERSCORE = None\n SORT = \"sort\"\n \n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #170",
        "line": 25,
        "description": [
          "SORT = \"sort\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n \n # define name format\n UNDERSCORE = \"_\"\n-SORT = \"sort\"\n+SORT = \"XXsortXX\"\n \n \n class ListSortingApproach(str, Enum):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #171",
        "line": 25,
        "description": [
          "SORT = \"sort\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n \n # define name format\n UNDERSCORE = \"_\"\n-SORT = \"sort\"\n+SORT = None\n \n \n class ListSortingApproach(str, Enum):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "test_bubble_sort_single",
    "function_scope": "39-50",
    "patterns": [
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def test_bubble_sort_single(list_inputs, expected_answer):",
        "context": "@pytest.mark.parametrize(\n    \"list_inputs, expected_answer\",\n    [([10, 3, 1], [1, 3, 10])],\n)\ndef test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 50,
        "coloffset": 11,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 50,
        "coloffset": 11,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 50,
        "coloffset": 11,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 50,
        "coloffset": 11,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 50,
        "coloffset": 11,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 50,
        "coloffset": 11,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 50,
        "coloffset": 11,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 50,
        "coloffset": 11,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 50,
        "coloffset": 11,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 50,
        "coloffset": 11,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def test_bubble_sort_single(list_inputs, expected_answer):",
        "context": "@pytest.mark.parametrize(\n    \"list_inputs, expected_answer\",\n    [([10, 3, 1], [1, 3, 10])],\n)\ndef test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": ")\ndef test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "\"\"\"Check the sorting algorithm functions with one input.\"\"\"",
        "context": "    \"list_inputs, expected_answer\",\n    [([10, 3, 1], [1, 3, 10])],\n)\ndef test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.bubble_sort(list_inputs)",
        "context": "    [([10, 3, 1], [1, 3, 10])],\n)\ndef test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": ")\ndef test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.insertion_sort(list_inputs)",
        "context": "def test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.merge_sort(list_inputs)",
        "context": "    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.quick_sort(list_inputs)",
        "context": "    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.tim_sort(list_inputs)",
        "context": "    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "\"\"\"Check the sorting algorithm functions with one input.\"\"\"",
        "context": "    \"list_inputs, expected_answer\",\n    [([10, 3, 1], [1, 3, 10])],\n)\ndef test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.bubble_sort(list_inputs)",
        "context": "    [([10, 3, 1], [1, 3, 10])],\n)\ndef test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": ")\ndef test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.insertion_sort(list_inputs)",
        "context": "def test_bubble_sort_single(list_inputs, expected_answer):\n    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    \"\"\"Check the sorting algorithm functions with one input.\"\"\"\n    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.merge_sort(list_inputs)",
        "context": "    sorted_list = sorting.bubble_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 46,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.quick_sort(list_inputs)",
        "context": "    sorted_list = sorting.insertion_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 49,
        "coloffset": 4,
        "linematch": "sorted_list = sorting.tim_sort(list_inputs)",
        "context": "    sorted_list = sorting.merge_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 50,
        "coloffset": 4,
        "linematch": "assert sorted_list == expected_answer",
        "context": "    assert sorted_list == expected_answer\n    sorted_list = sorting.quick_sort(list_inputs)\n    assert sorted_list == expected_answer\n    sorted_list = sorting.tim_sort(list_inputs)\n    assert sorted_list == expected_answer",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #182",
        "line": 44,
        "description": [
          "@cli.command()"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -40,8 +40,6 @@\n         \"\"\"Define a default string representation.\"\"\"\n         return self.value\n \n-\n-@cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #183",
        "line": 46,
        "description": [
          "    starting_size: int = typer.Option(1000000),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -43,7 +43,7 @@\n \n @cli.command()\n def listsorting(\n-    starting_size: int = typer.Option(1000000),\n+    starting_size: int = typer.Option(1000001),\n     maximum_value: int = typer.Option(10000),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #184",
        "line": 47,
        "description": [
          "    maximum_value: int = typer.Option(10000),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -44,7 +44,7 @@\n @cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n-    maximum_value: int = typer.Option(10000),\n+    maximum_value: int = typer.Option(10001),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #185",
        "line": 48,
        "description": [
          "    number_doubles: int = typer.Option(10),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -45,7 +45,7 @@\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n-    number_doubles: int = typer.Option(10),\n+    number_doubles: int = typer.Option(11),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n     \"\"\"Conduct a doubling experiment to measure the performance of list sorting for various algorithms.\"\"\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "bubble_sort",
    "function_scope": "21-38",
    "patterns": [
      {
        "lineno": 21,
        "coloffset": 0,
        "linematch": "def bubble_sort(array: List[int]) -> List[int]:",
        "context": "# Make sure that you add comments to all of these functions\n# so as to make it clear that you understand how each step works\n\n\ndef bubble_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort an input list called array using bubble sort.\"\"\"\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 21,
        "coloffset": 0,
        "linematch": "def bubble_sort(array: List[int]) -> List[int]:",
        "context": "# Make sure that you add comments to all of these functions\n# so as to make it clear that you understand how each step works\n\n\ndef bubble_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort an input list called array using bubble sort.\"\"\"\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 36,
        "coloffset": 8,
        "linematch": "if already_sorted:",
        "context": "        for j in range(n - i - 1):\n            if array[j] > array[j + 1]:\n                array[j], array[j + 1] = array[j + 1], array[j]\n                already_sorted = False\n        if already_sorted:\n            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 33,
        "coloffset": 12,
        "linematch": "if array[j] > array[j + 1]:",
        "context": "        # Start looking at each item of the list one by one,\n        # comparing it with its adjacent value. With each iteration\n        # the portion of the array that you look at shrinks because the remaining items have already been sorted\n        for j in range(n - i - 1):\n            if array[j] > array[j + 1]:\n                array[j], array[j + 1] = array[j + 1], array[j]\n                already_sorted = False\n        if already_sorted:\n            break\n    return array",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 21,
        "coloffset": 0,
        "linematch": "def bubble_sort(array: List[int]) -> List[int]:",
        "context": "# Make sure that you add comments to all of these functions\n# so as to make it clear that you understand how each step works\n\n\ndef bubble_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort an input list called array using bubble sort.\"\"\"\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 21,
        "coloffset": 0,
        "linematch": "def bubble_sort(array: List[int]) -> List[int]:",
        "context": "# Make sure that you add comments to all of these functions\n# so as to make it clear that you understand how each step works\n\n\ndef bubble_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort an input list called array using bubble sort.\"\"\"\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):",
        "pattern": "//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "The number of nested loop-conditions (e.g., for{if{}}) in a Function"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "for i in range(n):",
        "context": "    \"\"\"Sort an input list called array using bubble sort.\"\"\"\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):\n        # create a flag that will allow the function to terminate early if there's nothing left to sort\n        already_sorted = True\n        # Start looking at each item of the list one by one,\n        # comparing it with its adjacent value. With each iteration\n        # the portion of the array that you look at shrinks because the remaining items have already been sorted",
        "pattern": "//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "The number of nested loop-conditions (e.g., for{for{}}) in a Function"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "\"\"\"Sort an input list called array using bubble sort.\"\"\"",
        "context": "# so as to make it clear that you understand how each step works\n\n\ndef bubble_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort an input list called array using bubble sort.\"\"\"\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):\n        # create a flag that will allow the function to terminate early if there's nothing left to sort",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "n = len(array)",
        "context": "\ndef bubble_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort an input list called array using bubble sort.\"\"\"\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):\n        # create a flag that will allow the function to terminate early if there's nothing left to sort\n        already_sorted = True\n        # Start looking at each item of the list one by one,",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "for i in range(n):",
        "context": "    \"\"\"Sort an input list called array using bubble sort.\"\"\"\n    # count of value in the list\n    n = len(array)\n    # iterate through the number of value in list\n    for i in range(n):\n        # create a flag that will allow the function to terminate early if there's nothing left to sort\n        already_sorted = True\n        # Start looking at each item of the list one by one,\n        # comparing it with its adjacent value. With each iteration\n        # the portion of the array that you look at shrinks because the remaining items have already been sorted",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 38,
        "coloffset": 4,
        "linematch": "return array",
        "context": "                array[j], array[j + 1] = array[j + 1], array[j]\n                already_sorted = False\n        if already_sorted:\n            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    \"\"\"Run an insertion sort on the provided array.\"\"\"\n    # Loop from the second element of the array until the last element",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #167",
        "line": 21,
        "description": [
          "console = Console()"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -18,7 +18,7 @@\n cli = typer.Typer()\n \n # create a Console objects\n-console = Console()\n+console = None\n \n # define name format\n UNDERSCORE = \"_\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #168",
        "line": 24,
        "description": [
          "UNDERSCORE = \"_\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -21,7 +21,7 @@\n console = Console()\n \n # define name format\n-UNDERSCORE = \"_\"\n+UNDERSCORE = \"XX_XX\"\n SORT = \"sort\"\n \n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #169",
        "line": 24,
        "description": [
          "UNDERSCORE = \"_\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -21,7 +21,7 @@\n console = Console()\n \n # define name format\n-UNDERSCORE = \"_\"\n+UNDERSCORE = None\n SORT = \"sort\"\n \n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #170",
        "line": 25,
        "description": [
          "SORT = \"sort\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n \n # define name format\n UNDERSCORE = \"_\"\n-SORT = \"sort\"\n+SORT = \"XXsortXX\"\n \n \n class ListSortingApproach(str, Enum):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #171",
        "line": 25,
        "description": [
          "SORT = \"sort\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n \n # define name format\n UNDERSCORE = \"_\"\n-SORT = \"sort\"\n+SORT = None\n \n \n class ListSortingApproach(str, Enum):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #172",
        "line": 33,
        "description": [
          "    BUBBLESORT = \"bubble\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -30,7 +30,7 @@\n \n     # define name for each approach\n \n-    BUBBLESORT = \"bubble\"\n+    BUBBLESORT = \"XXbubbleXX\"\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n     QUICKSORT = \"quick\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #173",
        "line": 33,
        "description": [
          "    BUBBLESORT = \"bubble\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -30,7 +30,7 @@\n \n     # define name for each approach\n \n-    BUBBLESORT = \"bubble\"\n+    BUBBLESORT = None\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n     QUICKSORT = \"quick\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #174",
        "line": 34,
        "description": [
          "    INSERTIONSORT = \"insertion\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -31,7 +31,7 @@\n     # define name for each approach\n \n     BUBBLESORT = \"bubble\"\n-    INSERTIONSORT = \"insertion\"\n+    INSERTIONSORT = \"XXinsertionXX\"\n     MERGESORT = \"merge\"\n     QUICKSORT = \"quick\"\n     TIMSORT = \"tim\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #175",
        "line": 34,
        "description": [
          "    INSERTIONSORT = \"insertion\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -31,7 +31,7 @@\n     # define name for each approach\n \n     BUBBLESORT = \"bubble\"\n-    INSERTIONSORT = \"insertion\"\n+    INSERTIONSORT = None\n     MERGESORT = \"merge\"\n     QUICKSORT = \"quick\"\n     TIMSORT = \"tim\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #176",
        "line": 35,
        "description": [
          "    MERGESORT = \"merge\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -32,7 +32,7 @@\n \n     BUBBLESORT = \"bubble\"\n     INSERTIONSORT = \"insertion\"\n-    MERGESORT = \"merge\"\n+    MERGESORT = \"XXmergeXX\"\n     QUICKSORT = \"quick\"\n     TIMSORT = \"tim\"\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #177",
        "line": 35,
        "description": [
          "    MERGESORT = \"merge\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -32,7 +32,7 @@\n \n     BUBBLESORT = \"bubble\"\n     INSERTIONSORT = \"insertion\"\n-    MERGESORT = \"merge\"\n+    MERGESORT = None\n     QUICKSORT = \"quick\"\n     TIMSORT = \"tim\"\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #178",
        "line": 36,
        "description": [
          "    QUICKSORT = \"quick\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     BUBBLESORT = \"bubble\"\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n-    QUICKSORT = \"quick\"\n+    QUICKSORT = \"XXquickXX\"\n     TIMSORT = \"tim\"\n \n     def __str__(self):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #179",
        "line": 36,
        "description": [
          "    QUICKSORT = \"quick\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     BUBBLESORT = \"bubble\"\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n-    QUICKSORT = \"quick\"\n+    QUICKSORT = None\n     TIMSORT = \"tim\"\n \n     def __str__(self):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #180",
        "line": 37,
        "description": [
          "    TIMSORT = \"tim\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -34,7 +34,7 @@\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n     QUICKSORT = \"quick\"\n-    TIMSORT = \"tim\"\n+    TIMSORT = \"XXtimXX\"\n \n     def __str__(self):\n         \"\"\"Define a default string representation.\"\"\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #181",
        "line": 37,
        "description": [
          "    TIMSORT = \"tim\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -34,7 +34,7 @@\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n     QUICKSORT = \"quick\"\n-    TIMSORT = \"tim\"\n+    TIMSORT = None\n \n     def __str__(self):\n         \"\"\"Define a default string representation.\"\"\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "insertion_sort",
    "function_scope": "41-60",
    "patterns": [
      {
        "lineno": 41,
        "coloffset": 0,
        "linematch": "def insertion_sort(array: List[int]) -> List[int]:",
        "context": "            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    \"\"\"Run an insertion sort on the provided array.\"\"\"\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 41,
        "coloffset": 0,
        "linematch": "def insertion_sort(array: List[int]) -> List[int]:",
        "context": "            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    \"\"\"Run an insertion sort on the provided array.\"\"\"\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 41,
        "coloffset": 0,
        "linematch": "def insertion_sort(array: List[int]) -> List[int]:",
        "context": "            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    \"\"\"Run an insertion sort on the provided array.\"\"\"\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 41,
        "coloffset": 0,
        "linematch": "def insertion_sort(array: List[int]) -> List[int]:",
        "context": "            break\n    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    \"\"\"Run an insertion sort on the provided array.\"\"\"\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]",
        "pattern": "//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "The number of nested loop-conditions (e.g., for{if{}}) in a Function"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "\"\"\"Run an insertion sort on the provided array.\"\"\"",
        "context": "    return array\n\n\ndef insertion_sort(array: List[int]) -> List[int]:\n    \"\"\"Run an insertion sort on the provided array.\"\"\"\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]\n        # Initialize the variable that will be used to find the correct position of the element referenced by the `key_item`",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "for i in range(1, len(array)):",
        "context": "\ndef insertion_sort(array: List[int]) -> List[int]:\n    \"\"\"Run an insertion sort on the provided array.\"\"\"\n    # Loop from the second element of the array until the last element\n    for i in range(1, len(array)):\n        # This is the element we want to position in its correct place\n        key_item = array[i]\n        # Initialize the variable that will be used to find the correct position of the element referenced by the `key_item`\n        j = i - 1\n        # Run through the list of the items (the left portion of the array) and find the correct position",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 60,
        "coloffset": 4,
        "linematch": "return array",
        "context": "            j -= 1\n        # When you finish shifting the elements, you can position\n        # `key_item` in its correct location\n        array[j + 1] = key_item\n    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Define a convenience method that supports the merging of lists.\"\"\"\n    # If the first array is empty, then nothing needs to be merged",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #182",
        "line": 44,
        "description": [
          "@cli.command()"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -40,8 +40,6 @@\n         \"\"\"Define a default string representation.\"\"\"\n         return self.value\n \n-\n-@cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #183",
        "line": 46,
        "description": [
          "    starting_size: int = typer.Option(1000000),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -43,7 +43,7 @@\n \n @cli.command()\n def listsorting(\n-    starting_size: int = typer.Option(1000000),\n+    starting_size: int = typer.Option(1000001),\n     maximum_value: int = typer.Option(10000),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #184",
        "line": 47,
        "description": [
          "    maximum_value: int = typer.Option(10000),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -44,7 +44,7 @@\n @cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n-    maximum_value: int = typer.Option(10000),\n+    maximum_value: int = typer.Option(10001),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #185",
        "line": 48,
        "description": [
          "    number_doubles: int = typer.Option(10),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -45,7 +45,7 @@\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n-    number_doubles: int = typer.Option(10),\n+    number_doubles: int = typer.Option(11),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n     \"\"\"Conduct a doubling experiment to measure the performance of list sorting for various algorithms.\"\"\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #186",
        "line": 54,
        "description": [
          "        \"\u2728 Conducting an experiment to measure the performance of list sorting!\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -51,7 +51,7 @@\n     \"\"\"Conduct a doubling experiment to measure the performance of list sorting for various algorithms.\"\"\"\n     # display diagnostics messages of the experiment\n     console.print(\n-        \"\u2728 Conducting an experiment to measure the performance of list sorting!\"\n+        \"XX\u2728 Conducting an experiment to measure the performance of list sorting!XX\"\n     )\n     console.print()\n     console.print(f\"The chosen sorting algorithm: {approach}\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #187",
        "line": 57,
        "description": [
          "    console.print(f\"The chosen sorting algorithm: {approach}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -54,7 +54,7 @@\n         \"\u2728 Conducting an experiment to measure the performance of list sorting!\"\n     )\n     console.print()\n-    console.print(f\"The chosen sorting algorithm: {approach}\")\n+    console.print(f\"XXThe chosen sorting algorithm: {approach}XX\")\n     console.print(f\"Starting size of the data container {starting_size}\")\n     console.print(f\"Number of doubles to execute: {number_doubles}\")\n     console.print()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #188",
        "line": 58,
        "description": [
          "    console.print(f\"Starting size of the data container {starting_size}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -55,7 +55,7 @@\n     )\n     console.print()\n     console.print(f\"The chosen sorting algorithm: {approach}\")\n-    console.print(f\"Starting size of the data container {starting_size}\")\n+    console.print(f\"XXStarting size of the data container {starting_size}XX\")\n     console.print(f\"Number of doubles to execute: {number_doubles}\")\n     console.print()\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #189",
        "line": 59,
        "description": [
          "    console.print(f\"Number of doubles to execute: {number_doubles}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -56,7 +56,7 @@\n     console.print()\n     console.print(f\"The chosen sorting algorithm: {approach}\")\n     console.print(f\"Starting size of the data container {starting_size}\")\n-    console.print(f\"Number of doubles to execute: {number_doubles}\")\n+    console.print(f\"XXNumber of doubles to execute: {number_doubles}XX\")\n     console.print()\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "merge",
    "function_scope": "63-93",
    "patterns": [
      {
        "lineno": 63,
        "coloffset": 0,
        "linematch": "def merge(left: List[int], right: List[int]) -> List[int]:",
        "context": "        array[j + 1] = key_item\n    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Define a convenience method that supports the merging of lists.\"\"\"\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 63,
        "coloffset": 0,
        "linematch": "def merge(left: List[int], right: List[int]) -> List[int]:",
        "context": "        array[j + 1] = key_item\n    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Define a convenience method that supports the merging of lists.\"\"\"\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 67,
        "coloffset": 4,
        "linematch": "if len(left) == 0:",
        "context": "def merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Define a convenience method that supports the merging of lists.\"\"\"\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged\n    # and you can return the second array as the result\n    if len(right) == 0:\n        return left",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 71,
        "coloffset": 4,
        "linematch": "if len(right) == 0:",
        "context": "    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged\n    # and you can return the second array as the result\n    if len(right) == 0:\n        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 77,
        "coloffset": 8,
        "linematch": "if left[index_left] <= right[index_right]:",
        "context": "\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):\n        if left[index_left] <= right[index_right]:\n            result.append(left[index_left])\n            index_left += 1\n        else:\n            result.append(right[index_right])\n            index_right += 1",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 86,
        "coloffset": 8,
        "linematch": "if index_right == len(right):",
        "context": "            index_right += 1\n        # If the reach the end of either array, then you can\n        # add the remaining elements from the other array to\n        # the result and break the loop\n        if index_right == len(right):\n            result += left[index_left:]\n            break\n        if index_left == len(left):\n            result += right[index_right:]\n            break",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 89,
        "coloffset": 8,
        "linematch": "if index_left == len(left):",
        "context": "        # the result and break the loop\n        if index_right == len(right):\n            result += left[index_left:]\n            break\n        if index_left == len(left):\n            result += right[index_right:]\n            break\n\n    return result\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 63,
        "coloffset": 0,
        "linematch": "def merge(left: List[int], right: List[int]) -> List[int]:",
        "context": "        array[j + 1] = key_item\n    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Define a convenience method that supports the merging of lists.\"\"\"\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 71,
        "coloffset": 4,
        "linematch": "if len(right) == 0:",
        "context": "    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged\n    # and you can return the second array as the result\n    if len(right) == 0:\n        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):",
        "pattern": "//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "Number of conditions (if, if-else, and switch) in a Function"
      },
      {
        "lineno": 86,
        "coloffset": 8,
        "linematch": "if index_right == len(right):",
        "context": "            index_right += 1\n        # If the reach the end of either array, then you can\n        # add the remaining elements from the other array to\n        # the result and break the loop\n        if index_right == len(right):\n            result += left[index_left:]\n            break\n        if index_left == len(left):\n            result += right[index_right:]\n            break",
        "pattern": "//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "Number of conditions (if, if-else, and switch) in a Function"
      },
      {
        "lineno": 89,
        "coloffset": 8,
        "linematch": "if index_left == len(left):",
        "context": "        # the result and break the loop\n        if index_right == len(right):\n            result += left[index_left:]\n            break\n        if index_left == len(left):\n            result += right[index_right:]\n            break\n\n    return result\n",
        "pattern": "//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "Number of conditions (if, if-else, and switch) in a Function"
      },
      {
        "lineno": 63,
        "coloffset": 0,
        "linematch": "def merge(left: List[int], right: List[int]) -> List[int]:",
        "context": "        array[j + 1] = key_item\n    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Define a convenience method that supports the merging of lists.\"\"\"\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right",
        "pattern": "//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "The number of nested loop-conditions (e.g., for{if{}}) in a Function"
      },
      {
        "lineno": 64,
        "coloffset": 4,
        "linematch": "\"\"\"Define a convenience method that supports the merging of lists.\"\"\"",
        "context": "    return array\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Define a convenience method that supports the merging of lists.\"\"\"\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 67,
        "coloffset": 4,
        "linematch": "if len(left) == 0:",
        "context": "def merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Define a convenience method that supports the merging of lists.\"\"\"\n    # If the first array is empty, then nothing needs to be merged\n    # and you can return the second array as the result\n    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged\n    # and you can return the second array as the result\n    if len(right) == 0:\n        return left",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 71,
        "coloffset": 4,
        "linematch": "if len(right) == 0:",
        "context": "    if len(left) == 0:\n        return right\n    # If the second array is empty, the nothing needs to be merged\n    # and you can return the second array as the result\n    if len(right) == 0:\n        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 74,
        "coloffset": 4,
        "linematch": "result: List[int] = []",
        "context": "    # and you can return the second array as the result\n    if len(right) == 0:\n        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):\n        if left[index_left] <= right[index_right]:\n            result.append(left[index_left])\n            index_left += 1",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 75,
        "coloffset": 4,
        "linematch": "index_left = index_right = 0",
        "context": "    if len(right) == 0:\n        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):\n        if left[index_left] <= right[index_right]:\n            result.append(left[index_left])\n            index_left += 1\n        else:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 76,
        "coloffset": 4,
        "linematch": "while len(result) < len(left) + len(right):",
        "context": "        return left\n\n    result: List[int] = []\n    index_left = index_right = 0\n    while len(result) < len(left) + len(right):\n        if left[index_left] <= right[index_right]:\n            result.append(left[index_left])\n            index_left += 1\n        else:\n            result.append(right[index_right])",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 93,
        "coloffset": 4,
        "linematch": "return result",
        "context": "        if index_left == len(left):\n            result += right[index_right:]\n            break\n\n    return result\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"\n    if len(array) < 2:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #191",
        "line": 64,
        "description": [
          "    algorithm = approach + UNDERSCORE + SORT"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach - UNDERSCORE + SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #192",
        "line": 64,
        "description": [
          "    algorithm = approach + UNDERSCORE + SORT"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach + UNDERSCORE - SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #193",
        "line": 64,
        "description": [
          "    algorithm = approach + UNDERSCORE + SORT"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = None\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #194",
        "line": 67,
        "description": [
          "    )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -62,9 +62,7 @@\n     console.print()\n     # define the name approach\n     algorithm = approach + UNDERSCORE + SORT\n-    result = experiment.run_sorting_algorithm_experiment_campaign(\n-        algorithm, starting_size, maximum_value, number_doubles\n-    )\n+    result = None\n     data = [\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #195",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"XXInput SizeXX\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #196",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"Input Size\", \"XXMin time (s)XX\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #197",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"Input Size\", \"Min time (s)\", \"XXMax time (s)XX\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #198",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"XXAvg time (s)XX\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #199",
        "line": 70,
        "description": [
          "        result[0],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -67,7 +67,7 @@\n     )\n     data = [\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n-        result[0],\n+        result[1],\n         result[1],\n         result[2],\n         result[3],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #200",
        "line": 71,
        "description": [
          "        result[1],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -68,7 +68,7 @@\n     data = [\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n-        result[1],\n+        result[2],\n         result[2],\n         result[3],\n         result[4],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #201",
        "line": 72,
        "description": [
          "        result[2],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -69,7 +69,7 @@\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n-        result[2],\n+        result[3],\n         result[3],\n         result[4],\n     ]\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #202",
        "line": 73,
        "description": [
          "        result[3],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -70,7 +70,7 @@\n         result[0],\n         result[1],\n         result[2],\n-        result[3],\n+        result[4],\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #203",
        "line": 74,
        "description": [
          "        result[4],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -71,7 +71,7 @@\n         result[1],\n         result[2],\n         result[3],\n-        result[4],\n+        result[5],\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=\"firstrow\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #204",
        "line": 75,
        "description": [
          "    ]"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -65,14 +65,7 @@\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n-    data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n-        result[0],\n-        result[1],\n-        result[2],\n-        result[3],\n-        result[4],\n-    ]\n+    data = None\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=\"firstrow\")\n     print(table)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #205",
        "line": 77,
        "description": [
          "    table = tabulate(data, headers=\"firstrow\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=\"firstrow\")\n+    table = tabulate(data, headers=\"XXfirstrowXX\")\n     print(table)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #206",
        "line": 77,
        "description": [
          "    table = tabulate(data, headers=\"firstrow\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=\"firstrow\")\n+    table = None\n     print(table)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #207",
        "line": 78,
        "description": [
          "    print(table)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -75,5 +75,5 @@\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=\"firstrow\")\n-    print(table)\n+    print(None)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "merge_sort",
    "function_scope": "96-101",
    "patterns": [
      {
        "lineno": 96,
        "coloffset": 0,
        "linematch": "def merge_sort(array: List[int]) -> List[int]:",
        "context": "\n    return result\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 96,
        "coloffset": 0,
        "linematch": "def merge_sort(array: List[int]) -> List[int]:",
        "context": "\n    return result\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 98,
        "coloffset": 4,
        "linematch": "if len(array) < 2:",
        "context": "\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 96,
        "coloffset": 0,
        "linematch": "def merge_sort(array: List[int]) -> List[int]:",
        "context": "\n    return result\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 96,
        "coloffset": 0,
        "linematch": "def merge_sort(array: List[int]) -> List[int]:",
        "context": "\n    return result\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))",
        "pattern": "//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "The number of nested loop-conditions (e.g., for{if{}}) in a Function"
      },
      {
        "lineno": 97,
        "coloffset": 4,
        "linematch": "\"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"",
        "context": "    return result\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 98,
        "coloffset": 4,
        "linematch": "if len(array) < 2:",
        "context": "\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 100,
        "coloffset": 4,
        "linematch": "midpoint = len(array) // 2",
        "context": "def merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))\n\n\ndef quick_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 101,
        "coloffset": 4,
        "linematch": "return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))",
        "context": "    \"\"\"Sort the provided list called array with the merge sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))\n\n\ndef quick_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"\n    if len(array) < 2:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "quick_sort",
    "function_scope": "104-118",
    "patterns": [
      {
        "lineno": 104,
        "coloffset": 0,
        "linematch": "def quick_sort(array: List[int]) -> List[int]:",
        "context": "    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))\n\n\ndef quick_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 104,
        "coloffset": 0,
        "linematch": "def quick_sort(array: List[int]) -> List[int]:",
        "context": "    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))\n\n\ndef quick_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 106,
        "coloffset": 4,
        "linematch": "if len(array) < 2:",
        "context": "\n\ndef quick_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 111,
        "coloffset": 8,
        "linematch": "if item < pivot:",
        "context": "        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:\n            high.append(item)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 113,
        "coloffset": 8,
        "linematch": "elif item == pivot:",
        "context": "    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:\n            high.append(item)\n\n    return quick_sort(low) + same + quick_sort(high)",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 115,
        "coloffset": 8,
        "linematch": "elif item > pivot:",
        "context": "        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:\n            high.append(item)\n\n    return quick_sort(low) + same + quick_sort(high)\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 113,
        "coloffset": 13,
        "linematch": "elif item == pivot:",
        "context": "    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:\n            high.append(item)\n\n    return quick_sort(low) + same + quick_sort(high)",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 113,
        "coloffset": 13,
        "linematch": "elif item == pivot:",
        "context": "    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:\n            high.append(item)\n\n    return quick_sort(low) + same + quick_sort(high)",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 113,
        "coloffset": 13,
        "linematch": "elif item == pivot:",
        "context": "    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:\n            high.append(item)\n\n    return quick_sort(low) + same + quick_sort(high)",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 113,
        "coloffset": 13,
        "linematch": "elif item == pivot:",
        "context": "    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:\n            high.append(item)\n\n    return quick_sort(low) + same + quick_sort(high)",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 113,
        "coloffset": 13,
        "linematch": "elif item == pivot:",
        "context": "    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:\n            high.append(item)\n\n    return quick_sort(low) + same + quick_sort(high)",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 104,
        "coloffset": 0,
        "linematch": "def quick_sort(array: List[int]) -> List[int]:",
        "context": "    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))\n\n\ndef quick_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 113,
        "coloffset": 8,
        "linematch": "elif item == pivot:",
        "context": "    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:\n            high.append(item)\n\n    return quick_sort(low) + same + quick_sort(high)",
        "pattern": "//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "The number of nested conditions (e.g., if{if{}}) in a Function"
      },
      {
        "lineno": 115,
        "coloffset": 8,
        "linematch": "elif item > pivot:",
        "context": "        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:\n            high.append(item)\n\n    return quick_sort(low) + same + quick_sort(high)\n\n",
        "pattern": "//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "The number of nested conditions (e.g., if{if{}}) in a Function"
      },
      {
        "lineno": 104,
        "coloffset": 0,
        "linematch": "def quick_sort(array: List[int]) -> List[int]:",
        "context": "    midpoint = len(array) // 2\n    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))\n\n\ndef quick_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]",
        "pattern": "//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "The number of nested loop-conditions (e.g., for{if{}}) in a Function"
      },
      {
        "lineno": 105,
        "coloffset": 4,
        "linematch": "\"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"",
        "context": "    return merge(left=merge_sort(array[:midpoint]), right=merge_sort(array[midpoint:]))\n\n\ndef quick_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]\n    for item in array:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 106,
        "coloffset": 4,
        "linematch": "if len(array) < 2:",
        "context": "\n\ndef quick_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 108,
        "coloffset": 4,
        "linematch": "low, same, high = [], [], []",
        "context": "def quick_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 109,
        "coloffset": 4,
        "linematch": "pivot = array[randint(0, len(array) - 1)]",
        "context": "    \"\"\"Sort the provided list called array with the quick sort algorithm.\"\"\"\n    if len(array) < 2:\n        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 110,
        "coloffset": 4,
        "linematch": "for item in array:",
        "context": "    if len(array) < 2:\n        return array\n    low, same, high = [], [], []\n    pivot = array[randint(0, len(array) - 1)]\n    for item in array:\n        if item < pivot:\n            low.append(item)\n        elif item == pivot:\n            same.append(item)\n        elif item > pivot:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 118,
        "coloffset": 4,
        "linematch": "return quick_sort(low) + same + quick_sort(high)",
        "context": "            same.append(item)\n        elif item > pivot:\n            high.append(item)\n\n    return quick_sort(low) + same + quick_sort(high)\n\n\ndef insertion_sort_time(array: List[int], left: int = 0, right=None):\n    \"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"\n    if right is None:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "insertion_sort_time",
    "function_scope": "121-132",
    "patterns": [
      {
        "lineno": 121,
        "coloffset": 0,
        "linematch": "def insertion_sort_time(array: List[int], left: int = 0, right=None):",
        "context": "\n    return quick_sort(low) + same + quick_sort(high)\n\n\ndef insertion_sort_time(array: List[int], left: int = 0, right=None):\n    \"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"\n    if right is None:\n        right = len(array) - 1\n    for i in range(left + 1, right + 1):\n        key_item = array[i]",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 121,
        "coloffset": 0,
        "linematch": "def insertion_sort_time(array: List[int], left: int = 0, right=None):",
        "context": "\n    return quick_sort(low) + same + quick_sort(high)\n\n\ndef insertion_sort_time(array: List[int], left: int = 0, right=None):\n    \"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"\n    if right is None:\n        right = len(array) - 1\n    for i in range(left + 1, right + 1):\n        key_item = array[i]",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 123,
        "coloffset": 4,
        "linematch": "if right is None:",
        "context": "\n\ndef insertion_sort_time(array: List[int], left: int = 0, right=None):\n    \"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"\n    if right is None:\n        right = len(array) - 1\n    for i in range(left + 1, right + 1):\n        key_item = array[i]\n        j = i - 1\n        while j >= left and array[j] > key_item:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 123,
        "coloffset": 7,
        "linematch": "if right is None:",
        "context": "\n\ndef insertion_sort_time(array: List[int], left: int = 0, right=None):\n    \"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"\n    if right is None:\n        right = len(array) - 1\n    for i in range(left + 1, right + 1):\n        key_item = array[i]\n        j = i - 1\n        while j >= left and array[j] > key_item:",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 121,
        "coloffset": 0,
        "linematch": "def insertion_sort_time(array: List[int], left: int = 0, right=None):",
        "context": "\n    return quick_sort(low) + same + quick_sort(high)\n\n\ndef insertion_sort_time(array: List[int], left: int = 0, right=None):\n    \"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"\n    if right is None:\n        right = len(array) - 1\n    for i in range(left + 1, right + 1):\n        key_item = array[i]",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 121,
        "coloffset": 0,
        "linematch": "def insertion_sort_time(array: List[int], left: int = 0, right=None):",
        "context": "\n    return quick_sort(low) + same + quick_sort(high)\n\n\ndef insertion_sort_time(array: List[int], left: int = 0, right=None):\n    \"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"\n    if right is None:\n        right = len(array) - 1\n    for i in range(left + 1, right + 1):\n        key_item = array[i]",
        "pattern": "//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "The number of nested loop-conditions (e.g., for{if{}}) in a Function"
      },
      {
        "lineno": 122,
        "coloffset": 4,
        "linematch": "\"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"",
        "context": "    return quick_sort(low) + same + quick_sort(high)\n\n\ndef insertion_sort_time(array: List[int], left: int = 0, right=None):\n    \"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"\n    if right is None:\n        right = len(array) - 1\n    for i in range(left + 1, right + 1):\n        key_item = array[i]\n        j = i - 1",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 123,
        "coloffset": 4,
        "linematch": "if right is None:",
        "context": "\n\ndef insertion_sort_time(array: List[int], left: int = 0, right=None):\n    \"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"\n    if right is None:\n        right = len(array) - 1\n    for i in range(left + 1, right + 1):\n        key_item = array[i]\n        j = i - 1\n        while j >= left and array[j] > key_item:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 125,
        "coloffset": 4,
        "linematch": "for i in range(left + 1, right + 1):",
        "context": "def insertion_sort_time(array: List[int], left: int = 0, right=None):\n    \"\"\"Use an internal sorting algorithm for the timsort algorithm.\"\"\"\n    if right is None:\n        right = len(array) - 1\n    for i in range(left + 1, right + 1):\n        key_item = array[i]\n        j = i - 1\n        while j >= left and array[j] > key_item:\n            array[j + 1] = array[j]\n            j -= 1",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 132,
        "coloffset": 4,
        "linematch": "return array",
        "context": "        while j >= left and array[j] > key_item:\n            array[j + 1] = array[j]\n            j -= 1\n        array[j + 1] = key_item\n    return array\n\n\ndef tim_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the list called array with the tim sort algorithm using a special insertion sort.\"\"\"\n    min_run = 32",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "tim_sort",
    "function_scope": "135-153",
    "patterns": [
      {
        "lineno": 135,
        "coloffset": 0,
        "linematch": "def tim_sort(array: List[int]) -> List[int]:",
        "context": "        array[j + 1] = key_item\n    return array\n\n\ndef tim_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the list called array with the tim sort algorithm using a special insertion sort.\"\"\"\n    min_run = 32\n    n = len(array)\n    for i in range(0, n, min_run):\n        insertion_sort(array)",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 135,
        "coloffset": 0,
        "linematch": "def tim_sort(array: List[int]) -> List[int]:",
        "context": "        array[j + 1] = key_item\n    return array\n\n\ndef tim_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the list called array with the tim sort algorithm using a special insertion sort.\"\"\"\n    min_run = 32\n    n = len(array)\n    for i in range(0, n, min_run):\n        insertion_sort(array)",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 135,
        "coloffset": 0,
        "linematch": "def tim_sort(array: List[int]) -> List[int]:",
        "context": "        array[j + 1] = key_item\n    return array\n\n\ndef tim_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the list called array with the tim sort algorithm using a special insertion sort.\"\"\"\n    min_run = 32\n    n = len(array)\n    for i in range(0, n, min_run):\n        insertion_sort(array)",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 135,
        "coloffset": 0,
        "linematch": "def tim_sort(array: List[int]) -> List[int]:",
        "context": "        array[j + 1] = key_item\n    return array\n\n\ndef tim_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the list called array with the tim sort algorithm using a special insertion sort.\"\"\"\n    min_run = 32\n    n = len(array)\n    for i in range(0, n, min_run):\n        insertion_sort(array)",
        "pattern": "//FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]",
        "check_id": "C002",
        "check_name": "The number of nested loop-conditions (e.g., for{if{}}) in a Function"
      },
      {
        "lineno": 136,
        "coloffset": 4,
        "linematch": "\"\"\"Sort the list called array with the tim sort algorithm using a special insertion sort.\"\"\"",
        "context": "    return array\n\n\ndef tim_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the list called array with the tim sort algorithm using a special insertion sort.\"\"\"\n    min_run = 32\n    n = len(array)\n    for i in range(0, n, min_run):\n        insertion_sort(array)\n    size = min_run",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 137,
        "coloffset": 4,
        "linematch": "min_run = 32",
        "context": "\n\ndef tim_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the list called array with the tim sort algorithm using a special insertion sort.\"\"\"\n    min_run = 32\n    n = len(array)\n    for i in range(0, n, min_run):\n        insertion_sort(array)\n    size = min_run\n    while size < n:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 138,
        "coloffset": 4,
        "linematch": "n = len(array)",
        "context": "\ndef tim_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the list called array with the tim sort algorithm using a special insertion sort.\"\"\"\n    min_run = 32\n    n = len(array)\n    for i in range(0, n, min_run):\n        insertion_sort(array)\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 139,
        "coloffset": 4,
        "linematch": "for i in range(0, n, min_run):",
        "context": "def tim_sort(array: List[int]) -> List[int]:\n    \"\"\"Sort the list called array with the tim sort algorithm using a special insertion sort.\"\"\"\n    min_run = 32\n    n = len(array)\n    for i in range(0, n, min_run):\n        insertion_sort(array)\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 141,
        "coloffset": 4,
        "linematch": "size = min_run",
        "context": "    min_run = 32\n    n = len(array)\n    for i in range(0, n, min_run):\n        insertion_sort(array)\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min((start + size * 2 - 1), (n - 1))\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 142,
        "coloffset": 4,
        "linematch": "while size < n:",
        "context": "    n = len(array)\n    for i in range(0, n, min_run):\n        insertion_sort(array)\n    size = min_run\n    while size < n:\n        for start in range(0, n, size * 2):\n            midpoint = start + size - 1\n            end = min((start + size * 2 - 1), (n - 1))\n\n            merged_array = merge(",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 153,
        "coloffset": 4,
        "linematch": "return array",
        "context": "            )\n            array[start : start + len(merged_array)] = merged_array\n\n        size *= 2\n    return array",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "format_decimal",
    "function_scope": "10-14",
    "patterns": [
      {
        "lineno": 10,
        "coloffset": 0,
        "linematch": "def format_decimal(number: float):",
        "context": "from typing import List\nfrom typing import Tuple\n\n\ndef format_decimal(number: float):\n    \"\"\"Round a number up and then encode with five decimal places.\"\"\"\n    # round the provided floating point value with format function\n    format_float = \"{:.5f}\".format(number)\n    return format_float\n",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 10,
        "coloffset": 0,
        "linematch": "def format_decimal(number: float):",
        "context": "from typing import List\nfrom typing import Tuple\n\n\ndef format_decimal(number: float):\n    \"\"\"Round a number up and then encode with five decimal places.\"\"\"\n    # round the provided floating point value with format function\n    format_float = \"{:.5f}\".format(number)\n    return format_float\n",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 10,
        "coloffset": 0,
        "linematch": "def format_decimal(number: float):",
        "context": "from typing import List\nfrom typing import Tuple\n\n\ndef format_decimal(number: float):\n    \"\"\"Round a number up and then encode with five decimal places.\"\"\"\n    # round the provided floating point value with format function\n    format_float = \"{:.5f}\".format(number)\n    return format_float\n",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 11,
        "coloffset": 4,
        "linematch": "\"\"\"Round a number up and then encode with five decimal places.\"\"\"",
        "context": "from typing import Tuple\n\n\ndef format_decimal(number: float):\n    \"\"\"Round a number up and then encode with five decimal places.\"\"\"\n    # round the provided floating point value with format function\n    format_float = \"{:.5f}\".format(number)\n    return format_float\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 13,
        "coloffset": 4,
        "linematch": "format_float = \"{:.5f}\".format(number)",
        "context": "\ndef format_decimal(number: float):\n    \"\"\"Round a number up and then encode with five decimal places.\"\"\"\n    # round the provided floating point value with format function\n    format_float = \"{:.5f}\".format(number)\n    return format_float\n\n\ndef generate_random_number(maximum: int) -> int:\n    \"\"\"Generate a random list defined by the size.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 14,
        "coloffset": 4,
        "linematch": "return format_float",
        "context": "def format_decimal(number: float):\n    \"\"\"Round a number up and then encode with five decimal places.\"\"\"\n    # round the provided floating point value with format function\n    format_float = \"{:.5f}\".format(number)\n    return format_float\n\n\ndef generate_random_number(maximum: int) -> int:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a random value that is bound by 0 and a maximum",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "generate_random_number",
    "function_scope": "17-22",
    "patterns": [
      {
        "lineno": 17,
        "coloffset": 0,
        "linematch": "def generate_random_number(maximum: int) -> int:",
        "context": "    format_float = \"{:.5f}\".format(number)\n    return format_float\n\n\ndef generate_random_number(maximum: int) -> int:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 17,
        "coloffset": 0,
        "linematch": "def generate_random_number(maximum: int) -> int:",
        "context": "    format_float = \"{:.5f}\".format(number)\n    return format_float\n\n\ndef generate_random_number(maximum: int) -> int:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 17,
        "coloffset": 0,
        "linematch": "def generate_random_number(maximum: int) -> int:",
        "context": "    format_float = \"{:.5f}\".format(number)\n    return format_float\n\n\ndef generate_random_number(maximum: int) -> int:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 18,
        "coloffset": 4,
        "linematch": "\"\"\"Generate a random list defined by the size.\"\"\"",
        "context": "    return format_float\n\n\ndef generate_random_number(maximum: int) -> int:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 20,
        "coloffset": 4,
        "linematch": "random_value = random.randint(0, maximum)",
        "context": "\ndef generate_random_number(maximum: int) -> int:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "return random_value",
        "context": "    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a random value that is bound by 0 and a maximum\n    random_value = random.randint(0, maximum)\n    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(\n    size: int,\n    maximum: int,",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #166",
        "line": 18,
        "description": [
          "cli = typer.Typer()"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -15,7 +15,7 @@\n from listsorting import experiment\n \n # create a Typer object\n-cli = typer.Typer()\n+cli = None\n \n # create a Console objects\n console = Console()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #167",
        "line": 21,
        "description": [
          "console = Console()"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -18,7 +18,7 @@\n cli = typer.Typer()\n \n # create a Console objects\n-console = Console()\n+console = None\n \n # define name format\n UNDERSCORE = \"_\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "generate_random_container",
    "function_scope": "25-33",
    "patterns": [
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def generate_random_container(",
        "context": "    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(\n    size: int,\n    maximum: int,\n) -> List[int]:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a list of random values for a specific size",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def generate_random_container(",
        "context": "    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(\n    size: int,\n    maximum: int,\n) -> List[int]:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a list of random values for a specific size",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def generate_random_container(",
        "context": "    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(\n    size: int,\n    maximum: int,\n) -> List[int]:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a list of random values for a specific size",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 25,
        "coloffset": 0,
        "linematch": "def generate_random_container(",
        "context": "    # return the randomly generated number\n    return random_value\n\n\ndef generate_random_container(\n    size: int,\n    maximum: int,\n) -> List[int]:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a list of random values for a specific size",
        "pattern": "//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "Function uses loop variable"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "\"\"\"Generate a random list defined by the size.\"\"\"",
        "context": "def generate_random_container(\n    size: int,\n    maximum: int,\n) -> List[int]:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a list of random values for a specific size\n    # and with a number up to a specific maximum\n    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 32,
        "coloffset": 4,
        "linematch": "random_list = [random.randrange(1, maximum, 1) for _ in range(size)]",
        "context": ") -> List[int]:\n    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a list of random values for a specific size\n    # and with a number up to a specific maximum\n    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    \"\"\"Run a sorting algorithm and profile it with the timeit package.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "return random_list",
        "context": "    \"\"\"Generate a random list defined by the size.\"\"\"\n    # generate a list of random values for a specific size\n    # and with a number up to a specific maximum\n    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    \"\"\"Run a sorting algorithm and profile it with the timeit package.\"\"\"\n    # set up the context and prepare the call to the specified",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #170",
        "line": 25,
        "description": [
          "SORT = \"sort\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n \n # define name format\n UNDERSCORE = \"_\"\n-SORT = \"sort\"\n+SORT = \"XXsortXX\"\n \n \n class ListSortingApproach(str, Enum):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #171",
        "line": 25,
        "description": [
          "SORT = \"sort\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n \n # define name format\n UNDERSCORE = \"_\"\n-SORT = \"sort\"\n+SORT = None\n \n \n class ListSortingApproach(str, Enum):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #172",
        "line": 33,
        "description": [
          "    BUBBLESORT = \"bubble\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -30,7 +30,7 @@\n \n     # define name for each approach\n \n-    BUBBLESORT = \"bubble\"\n+    BUBBLESORT = \"XXbubbleXX\"\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n     QUICKSORT = \"quick\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #173",
        "line": 33,
        "description": [
          "    BUBBLESORT = \"bubble\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -30,7 +30,7 @@\n \n     # define name for each approach\n \n-    BUBBLESORT = \"bubble\"\n+    BUBBLESORT = None\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n     QUICKSORT = \"quick\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "run_sorting_algorithm",
    "function_scope": "36-52",
    "patterns": [
      {
        "lineno": 36,
        "coloffset": 0,
        "linematch": "def run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:",
        "context": "    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    \"\"\"Run a sorting algorithm and profile it with the timeit package.\"\"\"\n    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it's not the built-in `sorted()`.\n    setup_code = f\"from listsorting.sorting import {algorithm}\"",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 36,
        "coloffset": 0,
        "linematch": "def run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:",
        "context": "    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    \"\"\"Run a sorting algorithm and profile it with the timeit package.\"\"\"\n    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it's not the built-in `sorted()`.\n    setup_code = f\"from listsorting.sorting import {algorithm}\"",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 36,
        "coloffset": 0,
        "linematch": "def run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:",
        "context": "    random_list = [random.randrange(1, maximum, 1) for _ in range(size)]\n    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    \"\"\"Run a sorting algorithm and profile it with the timeit package.\"\"\"\n    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it's not the built-in `sorted()`.\n    setup_code = f\"from listsorting.sorting import {algorithm}\"",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "\"\"\"Run a sorting algorithm and profile it with the timeit package.\"\"\"",
        "context": "    return random_list\n\n\ndef run_sorting_algorithm(algorithm: str, array: List[int]) -> Tuple[str, str, str]:\n    \"\"\"Run a sorting algorithm and profile it with the timeit package.\"\"\"\n    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it's not the built-in `sorted()`.\n    setup_code = f\"from listsorting.sorting import {algorithm}\"\n    stmt = f\"{algorithm}({array})\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 4,
        "linematch": "setup_code = f\"from listsorting.sorting import {algorithm}\"",
        "context": "    \"\"\"Run a sorting algorithm and profile it with the timeit package.\"\"\"\n    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it's not the built-in `sorted()`.\n    setup_code = f\"from listsorting.sorting import {algorithm}\"\n    stmt = f\"{algorithm}({array})\"\n    # execute the code ten different times and return the time\n    # in seconds that each execution took\n    times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)\n    # finally, return the amount of execution time summarized as:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "stmt = f\"{algorithm}({array})\"",
        "context": "    # set up the context and prepare the call to the specified\n    # algorithm using the supplied array. Only import the\n    # algorithm function if it's not the built-in `sorted()`.\n    setup_code = f\"from listsorting.sorting import {algorithm}\"\n    stmt = f\"{algorithm}({array})\"\n    # execute the code ten different times and return the time\n    # in seconds that each execution took\n    times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)\n    # finally, return the amount of execution time summarized as:\n    # (minimum execution time, maximum execution time, average execution time)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)",
        "context": "    setup_code = f\"from listsorting.sorting import {algorithm}\"\n    stmt = f\"{algorithm}({array})\"\n    # execute the code ten different times and return the time\n    # in seconds that each execution took\n    times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)\n    # finally, return the amount of execution time summarized as:\n    # (minimum execution time, maximum execution time, average execution time)\n    return (\n        format_decimal(min(times)),\n        format_decimal(max(times)),",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 48,
        "coloffset": 4,
        "linematch": "return (",
        "context": "    # in seconds that each execution took\n    times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)\n    # finally, return the amount of execution time summarized as:\n    # (minimum execution time, maximum execution time, average execution time)\n    return (\n        format_decimal(min(times)),\n        format_decimal(max(times)),\n        format_decimal((sum(times) / len(times))),\n    )\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #178",
        "line": 36,
        "description": [
          "    QUICKSORT = \"quick\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     BUBBLESORT = \"bubble\"\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n-    QUICKSORT = \"quick\"\n+    QUICKSORT = \"XXquickXX\"\n     TIMSORT = \"tim\"\n \n     def __str__(self):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #179",
        "line": 36,
        "description": [
          "    QUICKSORT = \"quick\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     BUBBLESORT = \"bubble\"\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n-    QUICKSORT = \"quick\"\n+    QUICKSORT = None\n     TIMSORT = \"tim\"\n \n     def __str__(self):\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #180",
        "line": 37,
        "description": [
          "    TIMSORT = \"tim\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -34,7 +34,7 @@\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n     QUICKSORT = \"quick\"\n-    TIMSORT = \"tim\"\n+    TIMSORT = \"XXtimXX\"\n \n     def __str__(self):\n         \"\"\"Define a default string representation.\"\"\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #181",
        "line": 37,
        "description": [
          "    TIMSORT = \"tim\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -34,7 +34,7 @@\n     INSERTIONSORT = \"insertion\"\n     MERGESORT = \"merge\"\n     QUICKSORT = \"quick\"\n-    TIMSORT = \"tim\"\n+    TIMSORT = None\n \n     def __str__(self):\n         \"\"\"Define a default string representation.\"\"\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #182",
        "line": 44,
        "description": [
          "@cli.command()"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -40,8 +40,6 @@\n         \"\"\"Define a default string representation.\"\"\"\n         return self.value\n \n-\n-@cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #183",
        "line": 46,
        "description": [
          "    starting_size: int = typer.Option(1000000),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -43,7 +43,7 @@\n \n @cli.command()\n def listsorting(\n-    starting_size: int = typer.Option(1000000),\n+    starting_size: int = typer.Option(1000001),\n     maximum_value: int = typer.Option(10000),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #184",
        "line": 47,
        "description": [
          "    maximum_value: int = typer.Option(10000),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -44,7 +44,7 @@\n @cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n-    maximum_value: int = typer.Option(10000),\n+    maximum_value: int = typer.Option(10001),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #185",
        "line": 48,
        "description": [
          "    number_doubles: int = typer.Option(10),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -45,7 +45,7 @@\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n-    number_doubles: int = typer.Option(10),\n+    number_doubles: int = typer.Option(11),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n     \"\"\"Conduct a doubling experiment to measure the performance of list sorting for various algorithms.\"\"\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "run_sorting_algorithm_experiment_campaign",
    "function_scope": "55-81",
    "patterns": [
      {
        "lineno": 55,
        "coloffset": 0,
        "linematch": "def run_sorting_algorithm_experiment_campaign(",
        "context": "        format_decimal((sum(times) / len(times))),\n    )\n\n\ndef run_sorting_algorithm_experiment_campaign(\n    algorithm: str,\n    starting_size: int,\n    maximum_value: int,\n    number_doubles: int,\n) -> List[List[Any]]:",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 55,
        "coloffset": 0,
        "linematch": "def run_sorting_algorithm_experiment_campaign(",
        "context": "        format_decimal((sum(times) / len(times))),\n    )\n\n\ndef run_sorting_algorithm_experiment_campaign(\n    algorithm: str,\n    starting_size: int,\n    maximum_value: int,\n    number_doubles: int,\n) -> List[List[Any]]:",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 55,
        "coloffset": 0,
        "linematch": "def run_sorting_algorithm_experiment_campaign(",
        "context": "        format_decimal((sum(times) / len(times))),\n    )\n\n\ndef run_sorting_algorithm_experiment_campaign(\n    algorithm: str,\n    starting_size: int,\n    maximum_value: int,\n    number_doubles: int,\n) -> List[List[Any]]:",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "\"\"\"Run an entire sorting algorithm experiment campaign.\"\"\"",
        "context": "    starting_size: int,\n    maximum_value: int,\n    number_doubles: int,\n) -> List[List[Any]]:\n    \"\"\"Run an entire sorting algorithm experiment campaign.\"\"\"\n    data_table = []\n    # run a total of number_doubles number of doubles for the input size\n    while number_doubles > 0:\n        # generate a random list based on the current size of the data\n        random_list = generate_random_container(starting_size, maximum_value)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 62,
        "coloffset": 4,
        "linematch": "data_table = []",
        "context": "    maximum_value: int,\n    number_doubles: int,\n) -> List[List[Any]]:\n    \"\"\"Run an entire sorting algorithm experiment campaign.\"\"\"\n    data_table = []\n    # run a total of number_doubles number of doubles for the input size\n    while number_doubles > 0:\n        # generate a random list based on the current size of the data\n        random_list = generate_random_container(starting_size, maximum_value)\n        # run the sorting algorithm and collect the timing data from timeit",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 64,
        "coloffset": 4,
        "linematch": "while number_doubles > 0:",
        "context": ") -> List[List[Any]]:\n    \"\"\"Run an entire sorting algorithm experiment campaign.\"\"\"\n    data_table = []\n    # run a total of number_doubles number of doubles for the input size\n    while number_doubles > 0:\n        # generate a random list based on the current size of the data\n        random_list = generate_random_container(starting_size, maximum_value)\n        # run the sorting algorithm and collect the timing data from timeit\n        performance_data = run_sorting_algorithm(algorithm, random_list)\n        # create the row of data from this specific execution of the algorithm",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 81,
        "coloffset": 4,
        "linematch": "return data_table",
        "context": "        data_table.append(data_table_row)\n        # move to the next round of the doubling experiment\n        number_doubles = number_doubles - 1\n        starting_size = starting_size * 2\n    return data_table",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #187",
        "line": 57,
        "description": [
          "    console.print(f\"The chosen sorting algorithm: {approach}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -54,7 +54,7 @@\n         \"\u2728 Conducting an experiment to measure the performance of list sorting!\"\n     )\n     console.print()\n-    console.print(f\"The chosen sorting algorithm: {approach}\")\n+    console.print(f\"XXThe chosen sorting algorithm: {approach}XX\")\n     console.print(f\"Starting size of the data container {starting_size}\")\n     console.print(f\"Number of doubles to execute: {number_doubles}\")\n     console.print()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #188",
        "line": 58,
        "description": [
          "    console.print(f\"Starting size of the data container {starting_size}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -55,7 +55,7 @@\n     )\n     console.print()\n     console.print(f\"The chosen sorting algorithm: {approach}\")\n-    console.print(f\"Starting size of the data container {starting_size}\")\n+    console.print(f\"XXStarting size of the data container {starting_size}XX\")\n     console.print(f\"Number of doubles to execute: {number_doubles}\")\n     console.print()\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #189",
        "line": 59,
        "description": [
          "    console.print(f\"Number of doubles to execute: {number_doubles}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -56,7 +56,7 @@\n     console.print()\n     console.print(f\"The chosen sorting algorithm: {approach}\")\n     console.print(f\"Starting size of the data container {starting_size}\")\n-    console.print(f\"Number of doubles to execute: {number_doubles}\")\n+    console.print(f\"XXNumber of doubles to execute: {number_doubles}XX\")\n     console.print()\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #190",
        "line": 61,
        "description": [
          "    console.print(\"\u2728 Here are the results from running the experiment!\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -58,7 +58,7 @@\n     console.print(f\"Starting size of the data container {starting_size}\")\n     console.print(f\"Number of doubles to execute: {number_doubles}\")\n     console.print()\n-    console.print(\"\u2728 Here are the results from running the experiment!\")\n+    console.print(\"XX\u2728 Here are the results from running the experiment!XX\")\n     console.print()\n     # define the name approach\n     algorithm = approach + UNDERSCORE + SORT\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #191",
        "line": 64,
        "description": [
          "    algorithm = approach + UNDERSCORE + SORT"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach - UNDERSCORE + SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #192",
        "line": 64,
        "description": [
          "    algorithm = approach + UNDERSCORE + SORT"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach + UNDERSCORE - SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #193",
        "line": 64,
        "description": [
          "    algorithm = approach + UNDERSCORE + SORT"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = None\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #194",
        "line": 67,
        "description": [
          "    )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -62,9 +62,7 @@\n     console.print()\n     # define the name approach\n     algorithm = approach + UNDERSCORE + SORT\n-    result = experiment.run_sorting_algorithm_experiment_campaign(\n-        algorithm, starting_size, maximum_value, number_doubles\n-    )\n+    result = None\n     data = [\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #195",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"XXInput SizeXX\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #196",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"Input Size\", \"XXMin time (s)XX\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #197",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"Input Size\", \"Min time (s)\", \"XXMax time (s)XX\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #198",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"XXAvg time (s)XX\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #199",
        "line": 70,
        "description": [
          "        result[0],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -67,7 +67,7 @@\n     )\n     data = [\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n-        result[0],\n+        result[1],\n         result[1],\n         result[2],\n         result[3],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #200",
        "line": 71,
        "description": [
          "        result[1],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -68,7 +68,7 @@\n     data = [\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n-        result[1],\n+        result[2],\n         result[2],\n         result[3],\n         result[4],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #201",
        "line": 72,
        "description": [
          "        result[2],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -69,7 +69,7 @@\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n-        result[2],\n+        result[3],\n         result[3],\n         result[4],\n     ]\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #202",
        "line": 73,
        "description": [
          "        result[3],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -70,7 +70,7 @@\n         result[0],\n         result[1],\n         result[2],\n-        result[3],\n+        result[4],\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #203",
        "line": 74,
        "description": [
          "        result[4],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -71,7 +71,7 @@\n         result[1],\n         result[2],\n         result[3],\n-        result[4],\n+        result[5],\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=\"firstrow\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #204",
        "line": 75,
        "description": [
          "    ]"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -65,14 +65,7 @@\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n-    data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n-        result[0],\n-        result[1],\n-        result[2],\n-        result[3],\n-        result[4],\n-    ]\n+    data = None\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=\"firstrow\")\n     print(table)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #205",
        "line": 77,
        "description": [
          "    table = tabulate(data, headers=\"firstrow\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=\"firstrow\")\n+    table = tabulate(data, headers=\"XXfirstrowXX\")\n     print(table)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #206",
        "line": 77,
        "description": [
          "    table = tabulate(data, headers=\"firstrow\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=\"firstrow\")\n+    table = None\n     print(table)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #207",
        "line": 78,
        "description": [
          "    print(table)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -75,5 +75,5 @@\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=\"firstrow\")\n-    print(table)\n+    print(None)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "listsorting",
    "function_scope": "45-78",
    "patterns": [
      {
        "lineno": 45,
        "coloffset": 0,
        "linematch": "def listsorting(",
        "context": "        return self.value\n\n\n@cli.command()\ndef listsorting(\n    starting_size: int = typer.Option(1000000),\n    maximum_value: int = typer.Option(10000),\n    number_doubles: int = typer.Option(10),\n    approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n) -> None:",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 45,
        "coloffset": 0,
        "linematch": "def listsorting(",
        "context": "        return self.value\n\n\n@cli.command()\ndef listsorting(\n    starting_size: int = typer.Option(1000000),\n    maximum_value: int = typer.Option(10000),\n    number_doubles: int = typer.Option(10),\n    approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n) -> None:",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 45,
        "coloffset": 0,
        "linematch": "def listsorting(",
        "context": "        return self.value\n\n\n@cli.command()\ndef listsorting(\n    starting_size: int = typer.Option(1000000),\n    maximum_value: int = typer.Option(10000),\n    number_doubles: int = typer.Option(10),\n    approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n) -> None:",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 51,
        "coloffset": 4,
        "linematch": "\"\"\"Conduct a doubling experiment to measure the performance of list sorting for various algorithms.\"\"\"",
        "context": "    maximum_value: int = typer.Option(10000),\n    number_doubles: int = typer.Option(10),\n    approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n) -> None:\n    \"\"\"Conduct a doubling experiment to measure the performance of list sorting for various algorithms.\"\"\"\n    # display diagnostics messages of the experiment\n    console.print(\n        \"\u2728 Conducting an experiment to measure the performance of list sorting!\"\n    )\n    console.print()",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "console.print(",
        "context": "    approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n) -> None:\n    \"\"\"Conduct a doubling experiment to measure the performance of list sorting for various algorithms.\"\"\"\n    # display diagnostics messages of the experiment\n    console.print(\n        \"\u2728 Conducting an experiment to measure the performance of list sorting!\"\n    )\n    console.print()\n    console.print(f\"The chosen sorting algorithm: {approach}\")\n    console.print(f\"Starting size of the data container {starting_size}\")",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 56,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "    # display diagnostics messages of the experiment\n    console.print(\n        \"\u2728 Conducting an experiment to measure the performance of list sorting!\"\n    )\n    console.print()\n    console.print(f\"The chosen sorting algorithm: {approach}\")\n    console.print(f\"Starting size of the data container {starting_size}\")\n    console.print(f\"Number of doubles to execute: {number_doubles}\")\n    console.print()\n    console.print(\"\u2728 Here are the results from running the experiment!\")",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 57,
        "coloffset": 4,
        "linematch": "console.print(f\"The chosen sorting algorithm: {approach}\")",
        "context": "    console.print(\n        \"\u2728 Conducting an experiment to measure the performance of list sorting!\"\n    )\n    console.print()\n    console.print(f\"The chosen sorting algorithm: {approach}\")\n    console.print(f\"Starting size of the data container {starting_size}\")\n    console.print(f\"Number of doubles to execute: {number_doubles}\")\n    console.print()\n    console.print(\"\u2728 Here are the results from running the experiment!\")\n    console.print()",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 58,
        "coloffset": 4,
        "linematch": "console.print(f\"Starting size of the data container {starting_size}\")",
        "context": "        \"\u2728 Conducting an experiment to measure the performance of list sorting!\"\n    )\n    console.print()\n    console.print(f\"The chosen sorting algorithm: {approach}\")\n    console.print(f\"Starting size of the data container {starting_size}\")\n    console.print(f\"Number of doubles to execute: {number_doubles}\")\n    console.print()\n    console.print(\"\u2728 Here are the results from running the experiment!\")\n    console.print()\n    # define the name approach",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 4,
        "linematch": "console.print(f\"Number of doubles to execute: {number_doubles}\")",
        "context": "    )\n    console.print()\n    console.print(f\"The chosen sorting algorithm: {approach}\")\n    console.print(f\"Starting size of the data container {starting_size}\")\n    console.print(f\"Number of doubles to execute: {number_doubles}\")\n    console.print()\n    console.print(\"\u2728 Here are the results from running the experiment!\")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 60,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "    console.print()\n    console.print(f\"The chosen sorting algorithm: {approach}\")\n    console.print(f\"Starting size of the data container {starting_size}\")\n    console.print(f\"Number of doubles to execute: {number_doubles}\")\n    console.print()\n    console.print(\"\u2728 Here are the results from running the experiment!\")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 61,
        "coloffset": 4,
        "linematch": "console.print(\"\u2728 Here are the results from running the experiment!\")",
        "context": "    console.print(f\"The chosen sorting algorithm: {approach}\")\n    console.print(f\"Starting size of the data container {starting_size}\")\n    console.print(f\"Number of doubles to execute: {number_doubles}\")\n    console.print()\n    console.print(\"\u2728 Here are the results from running the experiment!\")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(\n        algorithm, starting_size, maximum_value, number_doubles",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 62,
        "coloffset": 4,
        "linematch": "console.print()",
        "context": "    console.print(f\"Starting size of the data container {starting_size}\")\n    console.print(f\"Number of doubles to execute: {number_doubles}\")\n    console.print()\n    console.print(\"\u2728 Here are the results from running the experiment!\")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(\n        algorithm, starting_size, maximum_value, number_doubles\n    )",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 64,
        "coloffset": 4,
        "linematch": "algorithm = approach + UNDERSCORE + SORT",
        "context": "    console.print()\n    console.print(\"\u2728 Here are the results from running the experiment!\")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(\n        algorithm, starting_size, maximum_value, number_doubles\n    )\n    data = [\n        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 65,
        "coloffset": 4,
        "linematch": "result = experiment.run_sorting_algorithm_experiment_campaign(",
        "context": "    console.print(\"\u2728 Here are the results from running the experiment!\")\n    console.print()\n    # define the name approach\n    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(\n        algorithm, starting_size, maximum_value, number_doubles\n    )\n    data = [\n        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n        result[0],",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 68,
        "coloffset": 4,
        "linematch": "data = [",
        "context": "    algorithm = approach + UNDERSCORE + SORT\n    result = experiment.run_sorting_algorithm_experiment_campaign(\n        algorithm, starting_size, maximum_value, number_doubles\n    )\n    data = [\n        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n        result[0],\n        result[1],\n        result[2],\n        result[3],",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 77,
        "coloffset": 4,
        "linematch": "table = tabulate(data, headers=\"firstrow\")",
        "context": "        result[3],\n        result[4],\n    ]\n    # call tabulate function to construct a table based of data\n    table = tabulate(data, headers=\"firstrow\")\n    print(table)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "print(table)",
        "context": "        result[4],\n    ]\n    # call tabulate function to construct a table based of data\n    table = tabulate(data, headers=\"firstrow\")\n    print(table)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #183",
        "line": 46,
        "description": [
          "    starting_size: int = typer.Option(1000000),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -43,7 +43,7 @@\n \n @cli.command()\n def listsorting(\n-    starting_size: int = typer.Option(1000000),\n+    starting_size: int = typer.Option(1000001),\n     maximum_value: int = typer.Option(10000),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #184",
        "line": 47,
        "description": [
          "    maximum_value: int = typer.Option(10000),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -44,7 +44,7 @@\n @cli.command()\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n-    maximum_value: int = typer.Option(10000),\n+    maximum_value: int = typer.Option(10001),\n     number_doubles: int = typer.Option(10),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #185",
        "line": 48,
        "description": [
          "    number_doubles: int = typer.Option(10),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -45,7 +45,7 @@\n def listsorting(\n     starting_size: int = typer.Option(1000000),\n     maximum_value: int = typer.Option(10000),\n-    number_doubles: int = typer.Option(10),\n+    number_doubles: int = typer.Option(11),\n     approach: ListSortingApproach = ListSortingApproach.BUBBLESORT,\n ) -> None:\n     \"\"\"Conduct a doubling experiment to measure the performance of list sorting for various algorithms.\"\"\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #186",
        "line": 54,
        "description": [
          "        \"\u2728 Conducting an experiment to measure the performance of list sorting!\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -51,7 +51,7 @@\n     \"\"\"Conduct a doubling experiment to measure the performance of list sorting for various algorithms.\"\"\"\n     # display diagnostics messages of the experiment\n     console.print(\n-        \"\u2728 Conducting an experiment to measure the performance of list sorting!\"\n+        \"XX\u2728 Conducting an experiment to measure the performance of list sorting!XX\"\n     )\n     console.print()\n     console.print(f\"The chosen sorting algorithm: {approach}\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #187",
        "line": 57,
        "description": [
          "    console.print(f\"The chosen sorting algorithm: {approach}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -54,7 +54,7 @@\n         \"\u2728 Conducting an experiment to measure the performance of list sorting!\"\n     )\n     console.print()\n-    console.print(f\"The chosen sorting algorithm: {approach}\")\n+    console.print(f\"XXThe chosen sorting algorithm: {approach}XX\")\n     console.print(f\"Starting size of the data container {starting_size}\")\n     console.print(f\"Number of doubles to execute: {number_doubles}\")\n     console.print()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #188",
        "line": 58,
        "description": [
          "    console.print(f\"Starting size of the data container {starting_size}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -55,7 +55,7 @@\n     )\n     console.print()\n     console.print(f\"The chosen sorting algorithm: {approach}\")\n-    console.print(f\"Starting size of the data container {starting_size}\")\n+    console.print(f\"XXStarting size of the data container {starting_size}XX\")\n     console.print(f\"Number of doubles to execute: {number_doubles}\")\n     console.print()\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #189",
        "line": 59,
        "description": [
          "    console.print(f\"Number of doubles to execute: {number_doubles}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -56,7 +56,7 @@\n     console.print()\n     console.print(f\"The chosen sorting algorithm: {approach}\")\n     console.print(f\"Starting size of the data container {starting_size}\")\n-    console.print(f\"Number of doubles to execute: {number_doubles}\")\n+    console.print(f\"XXNumber of doubles to execute: {number_doubles}XX\")\n     console.print()\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #190",
        "line": 61,
        "description": [
          "    console.print(\"\u2728 Here are the results from running the experiment!\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -58,7 +58,7 @@\n     console.print(f\"Starting size of the data container {starting_size}\")\n     console.print(f\"Number of doubles to execute: {number_doubles}\")\n     console.print()\n-    console.print(\"\u2728 Here are the results from running the experiment!\")\n+    console.print(\"XX\u2728 Here are the results from running the experiment!XX\")\n     console.print()\n     # define the name approach\n     algorithm = approach + UNDERSCORE + SORT\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #191",
        "line": 64,
        "description": [
          "    algorithm = approach + UNDERSCORE + SORT"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach - UNDERSCORE + SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #192",
        "line": 64,
        "description": [
          "    algorithm = approach + UNDERSCORE + SORT"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = approach + UNDERSCORE - SORT\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #193",
        "line": 64,
        "description": [
          "    algorithm = approach + UNDERSCORE + SORT"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -61,7 +61,7 @@\n     console.print(\"\u2728 Here are the results from running the experiment!\")\n     console.print()\n     # define the name approach\n-    algorithm = approach + UNDERSCORE + SORT\n+    algorithm = None\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #194",
        "line": 67,
        "description": [
          "    )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -62,9 +62,7 @@\n     console.print()\n     # define the name approach\n     algorithm = approach + UNDERSCORE + SORT\n-    result = experiment.run_sorting_algorithm_experiment_campaign(\n-        algorithm, starting_size, maximum_value, number_doubles\n-    )\n+    result = None\n     data = [\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #195",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"XXInput SizeXX\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #196",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"Input Size\", \"XXMin time (s)XX\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #197",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"Input Size\", \"Min time (s)\", \"XXMax time (s)XX\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #198",
        "line": 69,
        "description": [
          "        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -66,7 +66,7 @@\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n     data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n+        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"XXAvg time (s)XX\"],\n         result[0],\n         result[1],\n         result[2],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #199",
        "line": 70,
        "description": [
          "        result[0],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -67,7 +67,7 @@\n     )\n     data = [\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n-        result[0],\n+        result[1],\n         result[1],\n         result[2],\n         result[3],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #200",
        "line": 71,
        "description": [
          "        result[1],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -68,7 +68,7 @@\n     data = [\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n-        result[1],\n+        result[2],\n         result[2],\n         result[3],\n         result[4],\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #201",
        "line": 72,
        "description": [
          "        result[2],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -69,7 +69,7 @@\n         [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n         result[0],\n         result[1],\n-        result[2],\n+        result[3],\n         result[3],\n         result[4],\n     ]\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #202",
        "line": 73,
        "description": [
          "        result[3],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -70,7 +70,7 @@\n         result[0],\n         result[1],\n         result[2],\n-        result[3],\n+        result[4],\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #203",
        "line": 74,
        "description": [
          "        result[4],"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -71,7 +71,7 @@\n         result[1],\n         result[2],\n         result[3],\n-        result[4],\n+        result[5],\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=\"firstrow\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #204",
        "line": 75,
        "description": [
          "    ]"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -65,14 +65,7 @@\n     result = experiment.run_sorting_algorithm_experiment_campaign(\n         algorithm, starting_size, maximum_value, number_doubles\n     )\n-    data = [\n-        [\"Input Size\", \"Min time (s)\", \"Max time (s)\", \"Avg time (s)\"],\n-        result[0],\n-        result[1],\n-        result[2],\n-        result[3],\n-        result[4],\n-    ]\n+    data = None\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=\"firstrow\")\n     print(table)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #205",
        "line": 77,
        "description": [
          "    table = tabulate(data, headers=\"firstrow\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=\"firstrow\")\n+    table = tabulate(data, headers=\"XXfirstrowXX\")\n     print(table)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #206",
        "line": 77,
        "description": [
          "    table = tabulate(data, headers=\"firstrow\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -74,6 +74,6 @@\n         result[4],\n     ]\n     # call tabulate function to construct a table based of data\n-    table = tabulate(data, headers=\"firstrow\")\n+    table = None\n     print(table)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #207",
        "line": 78,
        "description": [
          "    print(table)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -75,5 +75,5 @@\n     ]\n     # call tabulate function to construct a table based of data\n     table = tabulate(data, headers=\"firstrow\")\n-    print(table)\n+    print(None)\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "__str__",
    "function_scope": "39-41",
    "patterns": [
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "def __str__(self):",
        "context": "    MERGESORT = \"merge\"\n    QUICKSORT = \"quick\"\n    TIMSORT = \"tim\"\n\n    def __str__(self):\n        \"\"\"Define a default string representation.\"\"\"\n        return self.value\n\n\n@cli.command()",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "def __str__(self):",
        "context": "    MERGESORT = \"merge\"\n    QUICKSORT = \"quick\"\n    TIMSORT = \"tim\"\n\n    def __str__(self):\n        \"\"\"Define a default string representation.\"\"\"\n        return self.value\n\n\n@cli.command()",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 39,
        "coloffset": 4,
        "linematch": "def __str__(self):",
        "context": "    MERGESORT = \"merge\"\n    QUICKSORT = \"quick\"\n    TIMSORT = \"tim\"\n\n    def __str__(self):\n        \"\"\"Define a default string representation.\"\"\"\n        return self.value\n\n\n@cli.command()",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 40,
        "coloffset": 8,
        "linematch": "\"\"\"Define a default string representation.\"\"\"",
        "context": "    QUICKSORT = \"quick\"\n    TIMSORT = \"tim\"\n\n    def __str__(self):\n        \"\"\"Define a default string representation.\"\"\"\n        return self.value\n\n\n@cli.command()\ndef listsorting(",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 41,
        "coloffset": 8,
        "linematch": "return self.value",
        "context": "    TIMSORT = \"tim\"\n\n    def __str__(self):\n        \"\"\"Define a default string representation.\"\"\"\n        return self.value\n\n\n@cli.command()\ndef listsorting(\n    starting_size: int = typer.Option(1000000),",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  }
]