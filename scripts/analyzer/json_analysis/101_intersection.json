[
  {
    "function_name": "test_version",
    "function_scope": "8-10",
    "patterns": [
      {
        "lineno": 8,
        "coloffset": 0,
        "linematch": "def test_version():",
        "context": "from src import main\n\n\n# confirm version\ndef test_version():\n    \"\"\"Confirm that the version of the program is correct.\"\"\"\n    assert __version__ == \"0.1.0\"\n\n\n# Testing random generate containers with 10 values",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 8,
        "coloffset": 0,
        "linematch": "def test_version():",
        "context": "from src import main\n\n\n# confirm version\ndef test_version():\n    \"\"\"Confirm that the version of the program is correct.\"\"\"\n    assert __version__ == \"0.1.0\"\n\n\n# Testing random generate containers with 10 values",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "assert __version__ == \"0.1.0\"",
        "context": "\n# confirm version\ndef test_version():\n    \"\"\"Confirm that the version of the program is correct.\"\"\"\n    assert __version__ == \"0.1.0\"\n\n\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the version of the program is correct.\"\"\"",
        "context": "\n\n# confirm version\ndef test_version():\n    \"\"\"Confirm that the version of the program is correct.\"\"\"\n    assert __version__ == \"0.1.0\"\n\n\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "assert __version__ == \"0.1.0\"",
        "context": "\n# confirm version\ndef test_version():\n    \"\"\"Confirm that the version of the program is correct.\"\"\"\n    assert __version__ == \"0.1.0\"\n\n\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 9,
        "coloffset": 4,
        "linematch": "\"\"\"Confirm that the version of the program is correct.\"\"\"",
        "context": "\n\n# confirm version\ndef test_version():\n    \"\"\"Confirm that the version of the program is correct.\"\"\"\n    assert __version__ == \"0.1.0\"\n\n\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 10,
        "coloffset": 4,
        "linematch": "assert __version__ == \"0.1.0\"",
        "context": "\n# confirm version\ndef test_version():\n    \"\"\"Confirm that the version of the program is correct.\"\"\"\n    assert __version__ == \"0.1.0\"\n\n\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [],
    "mutation_score": null
  },
  {
    "function_name": "test_generate_random_container_list",
    "function_scope": "14-17",
    "patterns": [
      {
        "lineno": 14,
        "coloffset": 0,
        "linematch": "def test_generate_random_container_list():",
        "context": "    assert __version__ == \"0.1.0\"\n\n\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"\n    random_container = main.generate_random_container(10, 100, False)\n    assert len(random_container) == 10\n\n",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 14,
        "coloffset": 0,
        "linematch": "def test_generate_random_container_list():",
        "context": "    assert __version__ == \"0.1.0\"\n\n\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"\n    random_container = main.generate_random_container(10, 100, False)\n    assert len(random_container) == 10\n\n",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "assert len(random_container) == 10",
        "context": "# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"\n    random_container = main.generate_random_container(10, 100, False)\n    assert len(random_container) == 10\n\n\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that generation of random container is correct size.\"\"\"",
        "context": "\n\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"\n    random_container = main.generate_random_container(10, 100, False)\n    assert len(random_container) == 10\n\n\n# testing intersection that works for both of the list algorithms",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "random_container = main.generate_random_container(10, 100, False)",
        "context": "\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"\n    random_container = main.generate_random_container(10, 100, False)\n    assert len(random_container) == 10\n\n\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "assert len(random_container) == 10",
        "context": "# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"\n    random_container = main.generate_random_container(10, 100, False)\n    assert len(random_container) == 10\n\n\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 15,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that generation of random container is correct size.\"\"\"",
        "context": "\n\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"\n    random_container = main.generate_random_container(10, 100, False)\n    assert len(random_container) == 10\n\n\n# testing intersection that works for both of the list algorithms",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 16,
        "coloffset": 4,
        "linematch": "random_container = main.generate_random_container(10, 100, False)",
        "context": "\n# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"\n    random_container = main.generate_random_container(10, 100, False)\n    assert len(random_container) == 10\n\n\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 17,
        "coloffset": 4,
        "linematch": "assert len(random_container) == 10",
        "context": "# Testing random generate containers with 10 values\ndef test_generate_random_container_list():\n    \"\"\"Ensure that generation of random container is correct size.\"\"\"\n    random_container = main.generate_random_container(10, 100, False)\n    assert len(random_container) == 10\n\n\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #1",
        "line": 15,
        "description": [
          "cli = typer.Typer()"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -12,7 +12,7 @@\n from rich.console import Console\n \n # create a Typer object to support the command-line interface\n-cli = typer.Typer()\n+cli = None\n \n # create a Profiler object to support timing program code segments\n profiler = Profiler()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "test_intersection_list_single_double",
    "function_scope": "21-29",
    "patterns": [
      {
        "lineno": 21,
        "coloffset": 0,
        "linematch": "def test_intersection_list_single_double():",
        "context": "    assert len(random_container) == 10\n\n\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 21,
        "coloffset": 0,
        "linematch": "def test_intersection_list_single_double():",
        "context": "    assert len(random_container) == 10\n\n\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert len(intersection_single) == 2",
        "context": "    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert len(intersection_double) == 2",
        "context": "    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "assert intersection_single == intersection_double",
        "context": "    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"",
        "context": "\n\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "first_list = [1, 2, 3, 4, 5]",
        "context": "\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "second_list = [4, 5, 6, 7, 8]",
        "context": "# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "intersection_single = main.compute_intersection_list_single(first_list, second_list)",
        "context": "def test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "intersection_double = main.compute_intersection_list_double(first_list, second_list)",
        "context": "    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert len(intersection_single) == 2",
        "context": "    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert len(intersection_double) == 2",
        "context": "    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "assert intersection_single == intersection_double",
        "context": "    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 22,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"",
        "context": "\n\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 23,
        "coloffset": 4,
        "linematch": "first_list = [1, 2, 3, 4, 5]",
        "context": "\n# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 24,
        "coloffset": 4,
        "linematch": "second_list = [4, 5, 6, 7, 8]",
        "context": "# testing intersection that works for both of the list algorithms\ndef test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 25,
        "coloffset": 4,
        "linematch": "intersection_single = main.compute_intersection_list_single(first_list, second_list)",
        "context": "def test_intersection_list_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 26,
        "coloffset": 4,
        "linematch": "intersection_double = main.compute_intersection_list_double(first_list, second_list)",
        "context": "    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 27,
        "coloffset": 4,
        "linematch": "assert len(intersection_single) == 2",
        "context": "    first_list = [1, 2, 3, 4, 5]\n    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 28,
        "coloffset": 4,
        "linematch": "assert len(intersection_double) == 2",
        "context": "    second_list = [4, 5, 6, 7, 8]\n    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 29,
        "coloffset": 4,
        "linematch": "assert intersection_single == intersection_double",
        "context": "    intersection_single = main.compute_intersection_list_single(first_list, second_list)\n    intersection_double = main.compute_intersection_list_double(first_list, second_list)\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #3",
        "line": 24,
        "description": [
          "    LIST_SINGLE = \"ListSingle\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -21,7 +21,7 @@\n class IntersectionApproach(str, Enum):\n     \"\"\"Define the name for the approach for performing intersection of structured types.\"\"\"\n \n-    LIST_SINGLE = \"ListSingle\"\n+    LIST_SINGLE = \"XXListSingleXX\"\n     TUPLE_SINGLE = \"TupleSingle\"\n     LIST_DOUBLE = \"ListDouble\"\n     TUPLE_DOUBLE = \"TupleDouble\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #4",
        "line": 24,
        "description": [
          "    LIST_SINGLE = \"ListSingle\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -21,7 +21,7 @@\n class IntersectionApproach(str, Enum):\n     \"\"\"Define the name for the approach for performing intersection of structured types.\"\"\"\n \n-    LIST_SINGLE = \"ListSingle\"\n+    LIST_SINGLE = None\n     TUPLE_SINGLE = \"TupleSingle\"\n     LIST_DOUBLE = \"ListDouble\"\n     TUPLE_DOUBLE = \"TupleDouble\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #5",
        "line": 25,
        "description": [
          "    TUPLE_SINGLE = \"TupleSingle\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n     \"\"\"Define the name for the approach for performing intersection of structured types.\"\"\"\n \n     LIST_SINGLE = \"ListSingle\"\n-    TUPLE_SINGLE = \"TupleSingle\"\n+    TUPLE_SINGLE = \"XXTupleSingleXX\"\n     LIST_DOUBLE = \"ListDouble\"\n     TUPLE_DOUBLE = \"TupleDouble\"\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #6",
        "line": 25,
        "description": [
          "    TUPLE_SINGLE = \"TupleSingle\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -22,7 +22,7 @@\n     \"\"\"Define the name for the approach for performing intersection of structured types.\"\"\"\n \n     LIST_SINGLE = \"ListSingle\"\n-    TUPLE_SINGLE = \"TupleSingle\"\n+    TUPLE_SINGLE = None\n     LIST_DOUBLE = \"ListDouble\"\n     TUPLE_DOUBLE = \"TupleDouble\"\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #7",
        "line": 26,
        "description": [
          "    LIST_DOUBLE = \"ListDouble\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -23,7 +23,7 @@\n \n     LIST_SINGLE = \"ListSingle\"\n     TUPLE_SINGLE = \"TupleSingle\"\n-    LIST_DOUBLE = \"ListDouble\"\n+    LIST_DOUBLE = \"XXListDoubleXX\"\n     TUPLE_DOUBLE = \"TupleDouble\"\n \n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #8",
        "line": 26,
        "description": [
          "    LIST_DOUBLE = \"ListDouble\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -23,7 +23,7 @@\n \n     LIST_SINGLE = \"ListSingle\"\n     TUPLE_SINGLE = \"TupleSingle\"\n-    LIST_DOUBLE = \"ListDouble\"\n+    LIST_DOUBLE = None\n     TUPLE_DOUBLE = \"TupleDouble\"\n \n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #9",
        "line": 27,
        "description": [
          "    TUPLE_DOUBLE = \"TupleDouble\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -24,7 +24,7 @@\n     LIST_SINGLE = \"ListSingle\"\n     TUPLE_SINGLE = \"TupleSingle\"\n     LIST_DOUBLE = \"ListDouble\"\n-    TUPLE_DOUBLE = \"TupleDouble\"\n+    TUPLE_DOUBLE = \"XXTupleDoubleXX\"\n \n \n def human_readable_boolean(answer: bool) -> str:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #10",
        "line": 27,
        "description": [
          "    TUPLE_DOUBLE = \"TupleDouble\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -24,7 +24,7 @@\n     LIST_SINGLE = \"ListSingle\"\n     TUPLE_SINGLE = \"TupleSingle\"\n     LIST_DOUBLE = \"ListDouble\"\n-    TUPLE_DOUBLE = \"TupleDouble\"\n+    TUPLE_DOUBLE = None\n \n \n def human_readable_boolean(answer: bool) -> str:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "test_intersection_tuple_single_double",
    "function_scope": "33-45",
    "patterns": [
      {
        "lineno": 33,
        "coloffset": 0,
        "linematch": "def test_intersection_tuple_single_double():",
        "context": "    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_tuple = (1, 2, 3, 4, 5)\n    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 45,
        "coloffset": 11,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 33,
        "coloffset": 0,
        "linematch": "def test_intersection_tuple_single_double():",
        "context": "    assert intersection_single == intersection_double\n\n\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_tuple = (1, 2, 3, 4, 5)\n    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "assert len(intersection_single) == 2",
        "context": "    )\n    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert len(intersection_double) == 2",
        "context": "    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str']/body/Assert",
        "check_id": "NOA001",
        "check_name": "number-of-assertions"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"",
        "context": "\n\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_tuple = (1, 2, 3, 4, 5)\n    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple\n    )",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "first_tuple = (1, 2, 3, 4, 5)",
        "context": "\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_tuple = (1, 2, 3, 4, 5)\n    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple\n    )\n    intersection_double = main.compute_intersection_tuple_double(",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "second_tuple = (4, 5, 6, 7, 8)",
        "context": "# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_tuple = (1, 2, 3, 4, 5)\n    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple\n    )\n    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "intersection_single = main.compute_intersection_tuple_single(",
        "context": "def test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_tuple = (1, 2, 3, 4, 5)\n    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple\n    )\n    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple\n    )",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "intersection_double = main.compute_intersection_tuple_double(",
        "context": "    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple\n    )\n    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "assert len(intersection_single) == 2",
        "context": "    )\n    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert len(intersection_double) == 2",
        "context": "    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str' and starts-with(@name, 'test_')]/body/*",
        "check_id": "LOF001",
        "check_name": "count-test-method-lines"
      },
      {
        "lineno": 34,
        "coloffset": 4,
        "linematch": "\"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"",
        "context": "\n\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_tuple = (1, 2, 3, 4, 5)\n    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple\n    )",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 35,
        "coloffset": 4,
        "linematch": "first_tuple = (1, 2, 3, 4, 5)",
        "context": "\n# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_tuple = (1, 2, 3, 4, 5)\n    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple\n    )\n    intersection_double = main.compute_intersection_tuple_double(",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "second_tuple = (4, 5, 6, 7, 8)",
        "context": "# testing intersection that works for both of the list algorithm\ndef test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_tuple = (1, 2, 3, 4, 5)\n    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple\n    )\n    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 37,
        "coloffset": 4,
        "linematch": "intersection_single = main.compute_intersection_tuple_single(",
        "context": "def test_intersection_tuple_single_double():\n    \"\"\"Ensure that intersection works for both of the list algorithms.\"\"\"\n    first_tuple = (1, 2, 3, 4, 5)\n    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple\n    )\n    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple\n    )",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 40,
        "coloffset": 4,
        "linematch": "intersection_double = main.compute_intersection_tuple_double(",
        "context": "    second_tuple = (4, 5, 6, 7, 8)\n    intersection_single = main.compute_intersection_tuple_single(\n        first_tuple, second_tuple\n    )\n    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 43,
        "coloffset": 4,
        "linematch": "assert len(intersection_single) == 2",
        "context": "    )\n    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "assert len(intersection_double) == 2",
        "context": "    intersection_double = main.compute_intersection_tuple_double(\n        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "assert intersection_single == intersection_double",
        "context": "        first_tuple, second_tuple\n    )\n    assert len(intersection_single) == 2\n    assert len(intersection_double) == 2\n    assert intersection_single == intersection_double",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #11",
        "line": 34,
        "description": [
          "        return \"Yes\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -31,7 +31,7 @@\n     \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n     # the provided answer is True\n     if answer:\n-        return \"Yes\"\n+        return \"XXYesXX\"\n     # the provided answer is False\n     return \"No\"\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #12",
        "line": 36,
        "description": [
          "    return \"No\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     if answer:\n         return \"Yes\"\n     # the provided answer is False\n-    return \"No\"\n+    return \"XXNoXX\"\n \n \n def generate_random_container(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #13",
        "line": 40,
        "description": [
          "    size: int, maximum: int, make_tuple: bool = False"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -37,7 +37,7 @@\n \n \n def generate_random_container(\n-    size: int, maximum: int, make_tuple: bool = False\n+    size: int, maximum: int, make_tuple: bool = True\n ) -> Union[List[int], Tuple[int, ...]]:\n     \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n     # generate a list of random values\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #14",
        "line": 44,
        "description": [
          "    list_builder = [random.randint(0, maximum) for _ in range(size)]"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -41,7 +41,7 @@\n ) -> Union[List[int], Tuple[int, ...]]:\n     \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n     # generate a list of random values\n-    list_builder = [random.randint(0, maximum) for _ in range(size)]\n+    list_builder = [random.randint(1, maximum) for _ in range(size)]\n     if make_tuple:\n         return tuple(list_builder)\n     return list_builder\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #15",
        "line": 44,
        "description": [
          "    list_builder = [random.randint(0, maximum) for _ in range(size)]"
        ],
        "failure": []
      }
    ],
    "mutation_score": 20.0
  },
  {
    "function_name": "human_readable_boolean",
    "function_scope": "30-36",
    "patterns": [
      {
        "lineno": 30,
        "coloffset": 0,
        "linematch": "def human_readable_boolean(answer: bool) -> str:",
        "context": "    LIST_DOUBLE = \"ListDouble\"\n    TUPLE_DOUBLE = \"TupleDouble\"\n\n\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is True\n    if answer:\n        return \"Yes\"\n    # the provided answer is False",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 30,
        "coloffset": 0,
        "linematch": "def human_readable_boolean(answer: bool) -> str:",
        "context": "    LIST_DOUBLE = \"ListDouble\"\n    TUPLE_DOUBLE = \"TupleDouble\"\n\n\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is True\n    if answer:\n        return \"Yes\"\n    # the provided answer is False",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is True\n    if answer:\n        return \"Yes\"\n    # the provided answer is False\n    return \"No\"\n\n",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 30,
        "coloffset": 0,
        "linematch": "def human_readable_boolean(answer: bool) -> str:",
        "context": "    LIST_DOUBLE = \"ListDouble\"\n    TUPLE_DOUBLE = \"TupleDouble\"\n\n\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is True\n    if answer:\n        return \"Yes\"\n    # the provided answer is False",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 31,
        "coloffset": 4,
        "linematch": "\"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"",
        "context": "    TUPLE_DOUBLE = \"TupleDouble\"\n\n\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is True\n    if answer:\n        return \"Yes\"\n    # the provided answer is False\n    return \"No\"",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 33,
        "coloffset": 4,
        "linematch": "if answer:",
        "context": "\ndef human_readable_boolean(answer: bool) -> str:\n    \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n    # the provided answer is True\n    if answer:\n        return \"Yes\"\n    # the provided answer is False\n    return \"No\"\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 36,
        "coloffset": 4,
        "linematch": "return \"No\"",
        "context": "    # the provided answer is True\n    if answer:\n        return \"Yes\"\n    # the provided answer is False\n    return \"No\"\n\n\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #11",
        "line": 34,
        "description": [
          "        return \"Yes\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -31,7 +31,7 @@\n     \"\"\"Produce a human-readable Yes or No for a boolean value of True or False.\"\"\"\n     # the provided answer is True\n     if answer:\n-        return \"Yes\"\n+        return \"XXYesXX\"\n     # the provided answer is False\n     return \"No\"\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #12",
        "line": 36,
        "description": [
          "    return \"No\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -33,7 +33,7 @@\n     if answer:\n         return \"Yes\"\n     # the provided answer is False\n-    return \"No\"\n+    return \"XXNoXX\"\n \n \n def generate_random_container(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  },
  {
    "function_name": "generate_random_container",
    "function_scope": "39-47",
    "patterns": [
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def generate_random_container(",
        "context": "    # the provided answer is False\n    return \"No\"\n\n\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def generate_random_container(",
        "context": "    # the provided answer is False\n    return \"No\"\n\n\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "if make_tuple:",
        "context": ") -> Union[List[int], Tuple[int, ...]]:\n    \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]\n    if make_tuple:\n        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def generate_random_container(",
        "context": "    # the provided answer is False\n    return \"No\"\n\n\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 39,
        "coloffset": 0,
        "linematch": "def generate_random_container(",
        "context": "    # the provided answer is False\n    return \"No\"\n\n\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]",
        "pattern": "//FunctionDef[body//comprehension/target/Name]",
        "check_id": "FLV001",
        "check_name": "Function uses loop variable"
      },
      {
        "lineno": 42,
        "coloffset": 4,
        "linematch": "\"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"",
        "context": "\ndef generate_random_container(\n    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]\n    if make_tuple:\n        return tuple(list_builder)\n    return list_builder",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 44,
        "coloffset": 4,
        "linematch": "list_builder = [random.randint(0, maximum) for _ in range(size)]",
        "context": "    size: int, maximum: int, make_tuple: bool = False\n) -> Union[List[int], Tuple[int, ...]]:\n    \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]\n    if make_tuple:\n        return tuple(list_builder)\n    return list_builder\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 45,
        "coloffset": 4,
        "linematch": "if make_tuple:",
        "context": ") -> Union[List[int], Tuple[int, ...]]:\n    \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]\n    if make_tuple:\n        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 47,
        "coloffset": 4,
        "linematch": "return list_builder",
        "context": "    # generate a list of random values\n    list_builder = [random.randint(0, maximum) for _ in range(size)]\n    if make_tuple:\n        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #13",
        "line": 40,
        "description": [
          "    size: int, maximum: int, make_tuple: bool = False"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -37,7 +37,7 @@\n \n \n def generate_random_container(\n-    size: int, maximum: int, make_tuple: bool = False\n+    size: int, maximum: int, make_tuple: bool = True\n ) -> Union[List[int], Tuple[int, ...]]:\n     \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n     # generate a list of random values\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #14",
        "line": 44,
        "description": [
          "    list_builder = [random.randint(0, maximum) for _ in range(size)]"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -41,7 +41,7 @@\n ) -> Union[List[int], Tuple[int, ...]]:\n     \"\"\"Generate a random list defined by the size and with no number bigger than maximum.\"\"\"\n     # generate a list of random values\n-    list_builder = [random.randint(0, maximum) for _ in range(size)]\n+    list_builder = [random.randint(1, maximum) for _ in range(size)]\n     if make_tuple:\n         return tuple(list_builder)\n     return list_builder\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #15",
        "line": 44,
        "description": [
          "    list_builder = [random.randint(0, maximum) for _ in range(size)]"
        ],
        "failure": []
      }
    ],
    "mutation_score": 33.33333333333333
  },
  {
    "function_name": "compute_intersection_list_double",
    "function_scope": "50-59",
    "patterns": [
      {
        "lineno": 50,
        "coloffset": 0,
        "linematch": "def compute_intersection_list_double(",
        "context": "        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result = []\n    for x in input_one:",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 50,
        "coloffset": 0,
        "linematch": "def compute_intersection_list_double(",
        "context": "        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result = []\n    for x in input_one:",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 57,
        "coloffset": 12,
        "linematch": "if x == y:",
        "context": "    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result = []\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)\n    return result\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_double\n    # this function must use a double for loop",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 50,
        "coloffset": 0,
        "linematch": "def compute_intersection_list_double(",
        "context": "        return tuple(list_builder)\n    return list_builder\n\n\ndef compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result = []\n    for x in input_one:",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "for x in input_one:",
        "context": "    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result = []\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)\n    return result\n    # implement this function in a manner",
        "pattern": "//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "The number of nested loop-conditions (e.g., for{for{}}) in a Function"
      },
      {
        "lineno": 53,
        "coloffset": 4,
        "linematch": "\"\"\"Compute the intersection of two provided lists.\"\"\"",
        "context": "\ndef compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result = []\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 54,
        "coloffset": 4,
        "linematch": "result = []",
        "context": "def compute_intersection_list_double(\n    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result = []\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)\n    return result",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 55,
        "coloffset": 4,
        "linematch": "for x in input_one:",
        "context": "    input_one: List[int], input_two: List[int]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result = []\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)\n    return result\n    # implement this function in a manner",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 59,
        "coloffset": 4,
        "linematch": "return result",
        "context": "    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result.append(y)\n    return result\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_double\n    # this function must use a double for loop\n    # delete this placeholder return statement\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #16",
        "line": 54,
        "description": [
          "    result = []"
        ],
        "failure": []
      },
      {
        "name": "Mutant #17",
        "line": 57,
        "description": [
          "            if x == y:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "compute_intersection_list_single",
    "function_scope": "66-78",
    "patterns": [
      {
        "lineno": 66,
        "coloffset": 0,
        "linematch": "def compute_intersection_list_single(",
        "context": "    # this function must use a double for loop\n    # delete this placeholder return statement\n\n\ndef compute_intersection_list_single(\n    input_one: List[Any], input_two: List[Any]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_single",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 66,
        "coloffset": 0,
        "linematch": "def compute_intersection_list_single(",
        "context": "    # this function must use a double for loop\n    # delete this placeholder return statement\n\n\ndef compute_intersection_list_single(\n    input_one: List[Any], input_two: List[Any]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_single",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 76,
        "coloffset": 8,
        "linematch": "if element in input_two:",
        "context": "    # this function must use a single for loop and an if statement\n    # delete this placeholder return statement\n    result = []\n    for element in input_one:\n        if element in input_two:\n            result.append(element)\n    return result\n\n\ndef compute_intersection_tuple_double(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 66,
        "coloffset": 0,
        "linematch": "def compute_intersection_list_single(",
        "context": "    # this function must use a double for loop\n    # delete this placeholder return statement\n\n\ndef compute_intersection_list_single(\n    input_one: List[Any], input_two: List[Any]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_single",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 69,
        "coloffset": 4,
        "linematch": "\"\"\"Compute the intersection of two provided lists.\"\"\"",
        "context": "\ndef compute_intersection_list_single(\n    input_one: List[Any], input_two: List[Any]\n) -> List[Any]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    # implement this function in a manner\n    # that follows the compute_intersection_tuple_single\n    # this function must use a single for loop and an if statement\n    # delete this placeholder return statement\n    result = []",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 74,
        "coloffset": 4,
        "linematch": "result = []",
        "context": "    # implement this function in a manner\n    # that follows the compute_intersection_tuple_single\n    # this function must use a single for loop and an if statement\n    # delete this placeholder return statement\n    result = []\n    for element in input_one:\n        if element in input_two:\n            result.append(element)\n    return result\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 75,
        "coloffset": 4,
        "linematch": "for element in input_one:",
        "context": "    # that follows the compute_intersection_tuple_single\n    # this function must use a single for loop and an if statement\n    # delete this placeholder return statement\n    result = []\n    for element in input_one:\n        if element in input_two:\n            result.append(element)\n    return result\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 78,
        "coloffset": 4,
        "linematch": "return result",
        "context": "    result = []\n    for element in input_one:\n        if element in input_two:\n            result.append(element)\n    return result\n\n\ndef compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #18",
        "line": 74,
        "description": [
          "    result = []"
        ],
        "failure": []
      },
      {
        "name": "Mutant #19",
        "line": 76,
        "description": [
          "        if element in input_two:"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "compute_intersection_tuple_double",
    "function_scope": "81-91",
    "patterns": [
      {
        "lineno": 81,
        "coloffset": 0,
        "linematch": "def compute_intersection_tuple_double(",
        "context": "            result.append(element)\n    return result\n\n\ndef compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 81,
        "coloffset": 0,
        "linematch": "def compute_intersection_tuple_double(",
        "context": "            result.append(element)\n    return result\n\n\ndef compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 89,
        "coloffset": 12,
        "linematch": "if x == y:",
        "context": "    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result += (y,)\n    return result\n\n\ndef compute_intersection_tuple_single(",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 81,
        "coloffset": 0,
        "linematch": "def compute_intersection_tuple_double(",
        "context": "            result.append(element)\n    return result\n\n\ndef compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 87,
        "coloffset": 4,
        "linematch": "for x in input_one:",
        "context": ") -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result += (y,)\n    return result\n",
        "pattern": "//FunctionDef//For[.//For]",
        "check_id": "F001",
        "check_name": "The number of nested loop-conditions (e.g., for{for{}}) in a Function"
      },
      {
        "lineno": 84,
        "coloffset": 4,
        "linematch": "\"\"\"Compute the intersection of two provided lists.\"\"\"",
        "context": "\ndef compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for x in input_one:\n        for y in input_two:\n            if x == y:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 85,
        "coloffset": 4,
        "linematch": "result: Tuple[Any, ...] = ()",
        "context": "def compute_intersection_tuple_double(\n    input_one: Tuple[int, ...], input_two: Tuple[int, ...]\n) -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result += (y,)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 87,
        "coloffset": 4,
        "linematch": "for x in input_one:",
        "context": ") -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided lists.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result += (y,)\n    return result\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 91,
        "coloffset": 4,
        "linematch": "return result",
        "context": "    for x in input_one:\n        for y in input_two:\n            if x == y:\n                result += (y,)\n    return result\n\n\ndef compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #20",
        "line": 85,
        "description": [
          "    result: Tuple[Any, ...] = ()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #21",
        "line": 89,
        "description": [
          "            if x == y:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #22",
        "line": 90,
        "description": [
          "                result += (y,)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #23",
        "line": 90,
        "description": [
          "                result += (y,)"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "compute_intersection_tuple_single",
    "function_scope": "94-103",
    "patterns": [
      {
        "lineno": 94,
        "coloffset": 0,
        "linematch": "def compute_intersection_tuple_single(",
        "context": "                result += (y,)\n    return result\n\n\ndef compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided tuples.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 94,
        "coloffset": 0,
        "linematch": "def compute_intersection_tuple_single(",
        "context": "                result += (y,)\n    return result\n\n\ndef compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided tuples.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 101,
        "coloffset": 8,
        "linematch": "if element in input_two:",
        "context": "    \"\"\"Compute the intersection of two provided tuples.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for element in input_one:\n        if element in input_two:\n            result += (element,)\n    return result\n\n\n@cli.command()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 94,
        "coloffset": 0,
        "linematch": "def compute_intersection_tuple_single(",
        "context": "                result += (y,)\n    return result\n\n\ndef compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided tuples.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 97,
        "coloffset": 4,
        "linematch": "\"\"\"Compute the intersection of two provided tuples.\"\"\"",
        "context": "\ndef compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided tuples.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for element in input_one:\n        if element in input_two:\n            result += (element,)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 98,
        "coloffset": 4,
        "linematch": "result: Tuple[Any, ...] = ()",
        "context": "def compute_intersection_tuple_single(\n    input_one: Tuple, input_two: Tuple\n) -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided tuples.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for element in input_one:\n        if element in input_two:\n            result += (element,)\n    return result",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 100,
        "coloffset": 4,
        "linematch": "for element in input_one:",
        "context": ") -> Tuple[Any, ...]:\n    \"\"\"Compute the intersection of two provided tuples.\"\"\"\n    result: Tuple[Any, ...] = ()\n    # make sure that you understand how this function works\n    for element in input_one:\n        if element in input_two:\n            result += (element,)\n    return result\n\n",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 103,
        "coloffset": 4,
        "linematch": "return result",
        "context": "    # make sure that you understand how this function works\n    for element in input_one:\n        if element in input_two:\n            result += (element,)\n    return result\n\n\n@cli.command()\ndef intersection(\n    number: int = typer.Option(5),",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #24",
        "line": 98,
        "description": [
          "    result: Tuple[Any, ...] = ()"
        ],
        "failure": []
      },
      {
        "name": "Mutant #25",
        "line": 101,
        "description": [
          "        if element in input_two:"
        ],
        "failure": []
      },
      {
        "name": "Mutant #26",
        "line": 102,
        "description": [
          "            result += (element,)"
        ],
        "failure": []
      },
      {
        "name": "Mutant #27",
        "line": 102,
        "description": [
          "            result += (element,)"
        ],
        "failure": []
      }
    ],
    "mutation_score": 100.0
  },
  {
    "function_name": "intersection",
    "function_scope": "107-209",
    "patterns": [
      {
        "lineno": 107,
        "coloffset": 0,
        "linematch": "def intersection(",
        "context": "    return result\n\n\n@cli.command()\ndef intersection(\n    number: int = typer.Option(5),\n    maximum: int = typer.Option(25),\n    profile: bool = typer.Option(False),\n    display: bool = typer.Option(False),\n    approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,",
        "pattern": ".//FunctionDef",
        "check_id": "F001",
        "check_name": "all-function-definition"
      },
      {
        "lineno": 107,
        "coloffset": 0,
        "linematch": "def intersection(",
        "context": "    return result\n\n\n@cli.command()\ndef intersection(\n    number: int = typer.Option(5),\n    maximum: int = typer.Option(25),\n    profile: bool = typer.Option(False),\n    display: bool = typer.Option(False),\n    approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,",
        "pattern": ".//FunctionDef[not(contains(@name, \"test_\"))]",
        "check_id": "F002",
        "check_name": "dummy-test-non-test-function-definition"
      },
      {
        "lineno": 124,
        "coloffset": 4,
        "linematch": "if approach.value == IntersectionApproach.TUPLE_SINGLE:",
        "context": "    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]\n    # TupleSingle: the intersection algorithm that works on an input list\n    if approach.value == IntersectionApproach.TUPLE_SINGLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 192,
        "coloffset": 4,
        "linematch": "if display:",
        "context": "            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n    # display the input sets and the result of running the computation\n    if display:\n        console.print(\n            \":sparkles: Here are the details about the intersection computation!\"\n        )\n        console.print()\n        console.print(\"Performed intersection with:\")",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 204,
        "coloffset": 4,
        "linematch": "if profile:",
        "context": "        console.print(\n            f\"Computed the intersection as the data container: {intersection_output}\"\n        )\n    # display the results of the profiling if that option was requested\n    if profile:\n        console.print()\n        console.print(\n            f\":microscope: Here's profiling data from computing an intersection with random data containers of {number}!\"\n        )\n        profiler.print()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 129,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_single(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 141,
        "coloffset": 4,
        "linematch": "elif approach.value == IntersectionApproach.TUPLE_DOUBLE:",
        "context": "            intersection_output = compute_intersection_tuple_single(\n                tuple(input_one), tuple(input_two)\n            )\n    # TupleDouble: use the intersection algorithm that works on an input tuple\n    elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n        # generate the two tuples of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 146,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two tuples of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_double(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 158,
        "coloffset": 4,
        "linematch": "elif approach.value == IntersectionApproach.LIST_SINGLE:",
        "context": "            intersection_output = compute_intersection_tuple_double(\n                tuple(input_one), tuple(input_two)\n            )\n    # ListSingle: the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_SINGLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 163,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 175,
        "coloffset": 4,
        "linematch": "elif approach.value == IntersectionApproach.LIST_DOUBLE:",
        "context": "            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 180,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()",
        "pattern": ".//FunctionDef/body//If",
        "check_id": "CL001",
        "check_name": "dummy-test-single-nested-if"
      },
      {
        "lineno": 129,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_single(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "dummy-test-double-nested-if"
      },
      {
        "lineno": 146,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two tuples of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_double(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "dummy-test-double-nested-if"
      },
      {
        "lineno": 163,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "dummy-test-double-nested-if"
      },
      {
        "lineno": 180,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()",
        "pattern": ".//FunctionDef/body//If[ancestor::If and not(parent::orelse)]",
        "check_id": "CL002",
        "check_name": "dummy-test-double-nested-if"
      },
      {
        "lineno": 175,
        "coloffset": 9,
        "linematch": "elif approach.value == IntersectionApproach.LIST_DOUBLE:",
        "context": "            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 175,
        "coloffset": 9,
        "linematch": "elif approach.value == IntersectionApproach.LIST_DOUBLE:",
        "context": "            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 175,
        "coloffset": 9,
        "linematch": "elif approach.value == IntersectionApproach.LIST_DOUBLE:",
        "context": "            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 175,
        "coloffset": 9,
        "linematch": "elif approach.value == IntersectionApproach.LIST_DOUBLE:",
        "context": "            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 175,
        "coloffset": 9,
        "linematch": "elif approach.value == IntersectionApproach.LIST_DOUBLE:",
        "context": "            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 175,
        "coloffset": 9,
        "linematch": "elif approach.value == IntersectionApproach.LIST_DOUBLE:",
        "context": "            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": "//Compare/ops/Is | //Compare/ops/Eq",
        "check_id": "BOOL001",
        "check_name": "boolean-comparison"
      },
      {
        "lineno": 107,
        "coloffset": 0,
        "linematch": "def intersection(",
        "context": "    return result\n\n\n@cli.command()\ndef intersection(\n    number: int = typer.Option(5),\n    maximum: int = typer.Option(25),\n    profile: bool = typer.Option(False),\n    display: bool = typer.Option(False),\n    approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,",
        "pattern": "//FunctionDef[not(args/arg/annotation) or not(returns)]",
        "check_id": "ANNOT001",
        "check_name": "missing-annotations"
      },
      {
        "lineno": 192,
        "coloffset": 4,
        "linematch": "if display:",
        "context": "            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n    # display the input sets and the result of running the computation\n    if display:\n        console.print(\n            \":sparkles: Here are the details about the intersection computation!\"\n        )\n        console.print()\n        console.print(\"Performed intersection with:\")",
        "pattern": "//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "Number of conditions (if, if-else, and switch) in a Function"
      },
      {
        "lineno": 204,
        "coloffset": 4,
        "linematch": "if profile:",
        "context": "        console.print(\n            f\"Computed the intersection as the data container: {intersection_output}\"\n        )\n    # display the results of the profiling if that option was requested\n    if profile:\n        console.print()\n        console.print(\n            f\":microscope: Here's profiling data from computing an intersection with random data containers of {number}!\"\n        )\n        profiler.print()",
        "pattern": "//FunctionDef//If/following-sibling::If | //FunctionDef//If/following-sibling::Elif | //FunctionDef//If/following-sibling::Else",
        "check_id": "F002",
        "check_name": "Number of conditions (if, if-else, and switch) in a Function"
      },
      {
        "lineno": 129,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_single(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()",
        "pattern": "//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "The number of nested conditions (e.g., if{if{}}) in a Function"
      },
      {
        "lineno": 141,
        "coloffset": 4,
        "linematch": "elif approach.value == IntersectionApproach.TUPLE_DOUBLE:",
        "context": "            intersection_output = compute_intersection_tuple_single(\n                tuple(input_one), tuple(input_two)\n            )\n    # TupleDouble: use the intersection algorithm that works on an input tuple\n    elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n        # generate the two tuples of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": "//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "The number of nested conditions (e.g., if{if{}}) in a Function"
      },
      {
        "lineno": 146,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two tuples of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_tuple_double(\n                tuple(input_one), tuple(input_two)\n            )\n            profiler.stop()",
        "pattern": "//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "The number of nested conditions (e.g., if{if{}}) in a Function"
      },
      {
        "lineno": 158,
        "coloffset": 4,
        "linematch": "elif approach.value == IntersectionApproach.LIST_SINGLE:",
        "context": "            intersection_output = compute_intersection_tuple_double(\n                tuple(input_one), tuple(input_two)\n            )\n    # ListSingle: the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_SINGLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": "//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "The number of nested conditions (e.g., if{if{}}) in a Function"
      },
      {
        "lineno": 163,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()",
        "pattern": "//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "The number of nested conditions (e.g., if{if{}}) in a Function"
      },
      {
        "lineno": 175,
        "coloffset": 4,
        "linematch": "elif approach.value == IntersectionApproach.LIST_DOUBLE:",
        "context": "            intersection_output = compute_intersection_list_single(\n                list(input_one), list(input_two)\n            )\n    # ListDouble: use the intersection algorithm that works on an input list\n    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": "//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "The number of nested conditions (e.g., if{if{}}) in a Function"
      },
      {
        "lineno": 180,
        "coloffset": 8,
        "linematch": "if profile:",
        "context": "        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=False)\n        input_two = generate_random_container(number, maximum, make_tuple=False)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:\n            profiler.start()\n            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n            profiler.stop()",
        "pattern": "//FunctionDef//If/descendant::If",
        "check_id": "CL001",
        "check_name": "The number of nested conditions (e.g., if{if{}}) in a Function"
      },
      {
        "lineno": 114,
        "coloffset": 4,
        "linematch": "\"\"\"Compute the intersection of data containers.\"\"\"",
        "context": "    profile: bool = typer.Option(False),\n    display: bool = typer.Option(False),\n    approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,\n) -> None:\n    \"\"\"Compute the intersection of data containers.\"\"\"\n    # make sure that you understand how this function works\n    # create a console for rich text output\n    console = Console()\n    # create the starting data containers with no contents\n    input_one = None",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 117,
        "coloffset": 4,
        "linematch": "console = Console()",
        "context": ") -> None:\n    \"\"\"Compute the intersection of data containers.\"\"\"\n    # make sure that you understand how this function works\n    # create a console for rich text output\n    console = Console()\n    # create the starting data containers with no contents\n    input_one = None\n    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 119,
        "coloffset": 4,
        "linematch": "input_one = None",
        "context": "    # make sure that you understand how this function works\n    # create a console for rich text output\n    console = Console()\n    # create the starting data containers with no contents\n    input_one = None\n    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]\n    # TupleSingle: the intersection algorithm that works on an input list\n    if approach.value == IntersectionApproach.TUPLE_SINGLE:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 120,
        "coloffset": 4,
        "linematch": "input_two = None",
        "context": "    # create a console for rich text output\n    console = Console()\n    # create the starting data containers with no contents\n    input_one = None\n    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]\n    # TupleSingle: the intersection algorithm that works on an input list\n    if approach.value == IntersectionApproach.TUPLE_SINGLE:\n        # generate the two inputs consisting of random values",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 122,
        "coloffset": 4,
        "linematch": "intersection_output: Union[List[Any], Tuple[Any, ...]]",
        "context": "    # create the starting data containers with no contents\n    input_one = None\n    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]\n    # TupleSingle: the intersection algorithm that works on an input list\n    if approach.value == IntersectionApproach.TUPLE_SINGLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 124,
        "coloffset": 4,
        "linematch": "if approach.value == IntersectionApproach.TUPLE_SINGLE:",
        "context": "    input_two = None\n    # create a starting output variable for the intersection computation\n    intersection_output: Union[List[Any], Tuple[Any, ...]]\n    # TupleSingle: the intersection algorithm that works on an input list\n    if approach.value == IntersectionApproach.TUPLE_SINGLE:\n        # generate the two inputs consisting of random values\n        input_one = generate_random_container(number, maximum, make_tuple=True)\n        input_two = generate_random_container(number, maximum, make_tuple=True)\n        # perform profiling on the execution of the intersection algorithm\n        if profile:",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 192,
        "coloffset": 4,
        "linematch": "if display:",
        "context": "            intersection_output = compute_intersection_list_double(\n                list(input_one), list(input_two)\n            )\n    # display the input sets and the result of running the computation\n    if display:\n        console.print(\n            \":sparkles: Here are the details about the intersection computation!\"\n        )\n        console.print()\n        console.print(\"Performed intersection with:\")",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      },
      {
        "lineno": 204,
        "coloffset": 4,
        "linematch": "if profile:",
        "context": "        console.print(\n            f\"Computed the intersection as the data container: {intersection_output}\"\n        )\n    # display the results of the profiling if that option was requested\n    if profile:\n        console.print()\n        console.print(\n            f\":microscope: Here's profiling data from computing an intersection with random data containers of {number}!\"\n        )\n        profiler.print()",
        "pattern": "//FunctionDef[@type='str']/body/* | //FunctionDef[@type='str']/body/Return",
        "check_id": "CML001",
        "check_name": "count-method-lines"
      }
    ],
    "mutants": [
      {
        "name": "Mutant #29",
        "line": 108,
        "description": [
          "    number: int = typer.Option(5),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -105,7 +105,7 @@\n \n @cli.command()\n def intersection(\n-    number: int = typer.Option(5),\n+    number: int = typer.Option(6),\n     maximum: int = typer.Option(25),\n     profile: bool = typer.Option(False),\n     display: bool = typer.Option(False),\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #30",
        "line": 109,
        "description": [
          "    maximum: int = typer.Option(25),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -106,7 +106,7 @@\n @cli.command()\n def intersection(\n     number: int = typer.Option(5),\n-    maximum: int = typer.Option(25),\n+    maximum: int = typer.Option(26),\n     profile: bool = typer.Option(False),\n     display: bool = typer.Option(False),\n     approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #31",
        "line": 110,
        "description": [
          "    profile: bool = typer.Option(False),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -107,7 +107,7 @@\n def intersection(\n     number: int = typer.Option(5),\n     maximum: int = typer.Option(25),\n-    profile: bool = typer.Option(False),\n+    profile: bool = typer.Option(True),\n     display: bool = typer.Option(False),\n     approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,\n ) -> None:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #32",
        "line": 111,
        "description": [
          "    display: bool = typer.Option(False),"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -108,7 +108,7 @@\n     number: int = typer.Option(5),\n     maximum: int = typer.Option(25),\n     profile: bool = typer.Option(False),\n-    display: bool = typer.Option(False),\n+    display: bool = typer.Option(True),\n     approach: IntersectionApproach = IntersectionApproach.TUPLE_SINGLE,\n ) -> None:\n     \"\"\"Compute the intersection of data containers.\"\"\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #33",
        "line": 117,
        "description": [
          "    console = Console()"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -114,7 +114,7 @@\n     \"\"\"Compute the intersection of data containers.\"\"\"\n     # make sure that you understand how this function works\n     # create a console for rich text output\n-    console = Console()\n+    console = None\n     # create the starting data containers with no contents\n     input_one = None\n     input_two = None\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #34",
        "line": 119,
        "description": [
          "    input_one = None"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -116,7 +116,7 @@\n     # create a console for rich text output\n     console = Console()\n     # create the starting data containers with no contents\n-    input_one = None\n+    input_one = \"\"\n     input_two = None\n     # create a starting output variable for the intersection computation\n     intersection_output: Union[List[Any], Tuple[Any, ...]]\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #35",
        "line": 120,
        "description": [
          "    input_two = None"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -117,7 +117,7 @@\n     console = Console()\n     # create the starting data containers with no contents\n     input_one = None\n-    input_two = None\n+    input_two = \"\"\n     # create a starting output variable for the intersection computation\n     intersection_output: Union[List[Any], Tuple[Any, ...]]\n     # TupleSingle: the intersection algorithm that works on an input list\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #36",
        "line": 124,
        "description": [
          "    if approach.value == IntersectionApproach.TUPLE_SINGLE:"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -121,7 +121,7 @@\n     # create a starting output variable for the intersection computation\n     intersection_output: Union[List[Any], Tuple[Any, ...]]\n     # TupleSingle: the intersection algorithm that works on an input list\n-    if approach.value == IntersectionApproach.TUPLE_SINGLE:\n+    if approach.value != IntersectionApproach.TUPLE_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #37",
        "line": 126,
        "description": [
          "        input_one = generate_random_container(number, maximum, make_tuple=True)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -123,7 +123,7 @@\n     # TupleSingle: the intersection algorithm that works on an input list\n     if approach.value == IntersectionApproach.TUPLE_SINGLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=True)\n+        input_one = generate_random_container(number, maximum, make_tuple=False)\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #38",
        "line": 126,
        "description": [
          "        input_one = generate_random_container(number, maximum, make_tuple=True)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -123,7 +123,7 @@\n     # TupleSingle: the intersection algorithm that works on an input list\n     if approach.value == IntersectionApproach.TUPLE_SINGLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=True)\n+        input_one = None\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #39",
        "line": 127,
        "description": [
          "        input_two = generate_random_container(number, maximum, make_tuple=True)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -124,7 +124,7 @@\n     if approach.value == IntersectionApproach.TUPLE_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n-        input_two = generate_random_container(number, maximum, make_tuple=True)\n+        input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #40",
        "line": 127,
        "description": [
          "        input_two = generate_random_container(number, maximum, make_tuple=True)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -124,7 +124,7 @@\n     if approach.value == IntersectionApproach.TUPLE_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n-        input_two = generate_random_container(number, maximum, make_tuple=True)\n+        input_two = None\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #41",
        "line": 133,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -128,9 +128,7 @@\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n-            intersection_output = compute_intersection_tuple_single(\n-                tuple(input_one), tuple(input_two)\n-            )\n+            intersection_output = None\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #42",
        "line": 139,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -134,9 +134,7 @@\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n-            intersection_output = compute_intersection_tuple_single(\n-                tuple(input_one), tuple(input_two)\n-            )\n+            intersection_output = None\n     # TupleDouble: use the intersection algorithm that works on an input tuple\n     elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #43",
        "line": 141,
        "description": [
          "    elif approach.value == IntersectionApproach.TUPLE_DOUBLE:"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -138,7 +138,7 @@\n                 tuple(input_one), tuple(input_two)\n             )\n     # TupleDouble: use the intersection algorithm that works on an input tuple\n-    elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n+    elif approach.value != IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #44",
        "line": 143,
        "description": [
          "        input_one = generate_random_container(number, maximum, make_tuple=True)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -140,7 +140,7 @@\n     # TupleDouble: use the intersection algorithm that works on an input tuple\n     elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=True)\n+        input_one = generate_random_container(number, maximum, make_tuple=False)\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #45",
        "line": 143,
        "description": [
          "        input_one = generate_random_container(number, maximum, make_tuple=True)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -140,7 +140,7 @@\n     # TupleDouble: use the intersection algorithm that works on an input tuple\n     elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=True)\n+        input_one = None\n         input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #46",
        "line": 144,
        "description": [
          "        input_two = generate_random_container(number, maximum, make_tuple=True)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -141,7 +141,7 @@\n     elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n-        input_two = generate_random_container(number, maximum, make_tuple=True)\n+        input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #47",
        "line": 144,
        "description": [
          "        input_two = generate_random_container(number, maximum, make_tuple=True)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -141,7 +141,7 @@\n     elif approach.value == IntersectionApproach.TUPLE_DOUBLE:\n         # generate the two tuples of random values\n         input_one = generate_random_container(number, maximum, make_tuple=True)\n-        input_two = generate_random_container(number, maximum, make_tuple=True)\n+        input_two = None\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #48",
        "line": 150,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -145,9 +145,7 @@\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n-            intersection_output = compute_intersection_tuple_double(\n-                tuple(input_one), tuple(input_two)\n-            )\n+            intersection_output = None\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #49",
        "line": 156,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -151,9 +151,7 @@\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n-            intersection_output = compute_intersection_tuple_double(\n-                tuple(input_one), tuple(input_two)\n-            )\n+            intersection_output = None\n     # ListSingle: the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #50",
        "line": 158,
        "description": [
          "    elif approach.value == IntersectionApproach.LIST_SINGLE:"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -155,7 +155,7 @@\n                 tuple(input_one), tuple(input_two)\n             )\n     # ListSingle: the intersection algorithm that works on an input list\n-    elif approach.value == IntersectionApproach.LIST_SINGLE:\n+    elif approach.value != IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #51",
        "line": 160,
        "description": [
          "        input_one = generate_random_container(number, maximum, make_tuple=False)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -157,7 +157,7 @@\n     # ListSingle: the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=False)\n+        input_one = generate_random_container(number, maximum, make_tuple=True)\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #52",
        "line": 160,
        "description": [
          "        input_one = generate_random_container(number, maximum, make_tuple=False)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -157,7 +157,7 @@\n     # ListSingle: the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=False)\n+        input_one = None\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #53",
        "line": 161,
        "description": [
          "        input_two = generate_random_container(number, maximum, make_tuple=False)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -158,7 +158,7 @@\n     elif approach.value == IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n-        input_two = generate_random_container(number, maximum, make_tuple=False)\n+        input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #54",
        "line": 161,
        "description": [
          "        input_two = generate_random_container(number, maximum, make_tuple=False)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -158,7 +158,7 @@\n     elif approach.value == IntersectionApproach.LIST_SINGLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n-        input_two = generate_random_container(number, maximum, make_tuple=False)\n+        input_two = None\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #55",
        "line": 167,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -162,9 +162,7 @@\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n-            intersection_output = compute_intersection_list_single(\n-                list(input_one), list(input_two)\n-            )\n+            intersection_output = None\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #56",
        "line": 173,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -168,9 +168,7 @@\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n-            intersection_output = compute_intersection_list_single(\n-                list(input_one), list(input_two)\n-            )\n+            intersection_output = None\n     # ListDouble: use the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #57",
        "line": 175,
        "description": [
          "    elif approach.value == IntersectionApproach.LIST_DOUBLE:"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -172,7 +172,7 @@\n                 list(input_one), list(input_two)\n             )\n     # ListDouble: use the intersection algorithm that works on an input list\n-    elif approach.value == IntersectionApproach.LIST_DOUBLE:\n+    elif approach.value != IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #58",
        "line": 177,
        "description": [
          "        input_one = generate_random_container(number, maximum, make_tuple=False)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -174,7 +174,7 @@\n     # ListDouble: use the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=False)\n+        input_one = generate_random_container(number, maximum, make_tuple=True)\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #59",
        "line": 177,
        "description": [
          "        input_one = generate_random_container(number, maximum, make_tuple=False)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -174,7 +174,7 @@\n     # ListDouble: use the intersection algorithm that works on an input list\n     elif approach.value == IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n-        input_one = generate_random_container(number, maximum, make_tuple=False)\n+        input_one = None\n         input_two = generate_random_container(number, maximum, make_tuple=False)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #60",
        "line": 178,
        "description": [
          "        input_two = generate_random_container(number, maximum, make_tuple=False)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -175,7 +175,7 @@\n     elif approach.value == IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n-        input_two = generate_random_container(number, maximum, make_tuple=False)\n+        input_two = generate_random_container(number, maximum, make_tuple=True)\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #61",
        "line": 178,
        "description": [
          "        input_two = generate_random_container(number, maximum, make_tuple=False)"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -175,7 +175,7 @@\n     elif approach.value == IntersectionApproach.LIST_DOUBLE:\n         # generate the two inputs consisting of random values\n         input_one = generate_random_container(number, maximum, make_tuple=False)\n-        input_two = generate_random_container(number, maximum, make_tuple=False)\n+        input_two = None\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #62",
        "line": 184,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -179,9 +179,7 @@\n         # perform profiling on the execution of the intersection algorithm\n         if profile:\n             profiler.start()\n-            intersection_output = compute_intersection_list_double(\n-                list(input_one), list(input_two)\n-            )\n+            intersection_output = None\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #63",
        "line": 190,
        "description": [
          "            )"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -185,9 +185,7 @@\n             profiler.stop()\n         # do not perform profiling on the intersection algorithm\n         else:\n-            intersection_output = compute_intersection_list_double(\n-                list(input_one), list(input_two)\n-            )\n+            intersection_output = None\n     # display the input sets and the result of running the computation\n     if display:\n         console.print(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #64",
        "line": 194,
        "description": [
          "            \":sparkles: Here are the details about the intersection computation!\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -191,7 +191,7 @@\n     # display the input sets and the result of running the computation\n     if display:\n         console.print(\n-            \":sparkles: Here are the details about the intersection computation!\"\n+            \"XX:sparkles: Here are the details about the intersection computation!XX\"\n         )\n         console.print()\n         console.print(\"Performed intersection with:\")\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #65",
        "line": 197,
        "description": [
          "        console.print(\"Performed intersection with:\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -194,7 +194,7 @@\n             \":sparkles: Here are the details about the intersection computation!\"\n         )\n         console.print()\n-        console.print(\"Performed intersection with:\")\n+        console.print(\"XXPerformed intersection with:XX\")\n         console.print(f\"---> the first data container: {input_one}\")\n         console.print(f\"---> the second data container: {input_two}\")\n         console.print(\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #66",
        "line": 198,
        "description": [
          "        console.print(f\"---> the first data container: {input_one}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -195,7 +195,7 @@\n         )\n         console.print()\n         console.print(\"Performed intersection with:\")\n-        console.print(f\"---> the first data container: {input_one}\")\n+        console.print(f\"XX---> the first data container: {input_one}XX\")\n         console.print(f\"---> the second data container: {input_two}\")\n         console.print(\n             f\"Computed the intersection as the data container: {intersection_output}\"\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #67",
        "line": 199,
        "description": [
          "        console.print(f\"---> the second data container: {input_two}\")"
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -196,7 +196,7 @@\n         console.print()\n         console.print(\"Performed intersection with:\")\n         console.print(f\"---> the first data container: {input_one}\")\n-        console.print(f\"---> the second data container: {input_two}\")\n+        console.print(f\"XX---> the second data container: {input_two}XX\")\n         console.print(\n             f\"Computed the intersection as the data container: {intersection_output}\"\n         )\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #68",
        "line": 201,
        "description": [
          "            f\"Computed the intersection as the data container: {intersection_output}\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -198,7 +198,7 @@\n         console.print(f\"---> the first data container: {input_one}\")\n         console.print(f\"---> the second data container: {input_two}\")\n         console.print(\n-            f\"Computed the intersection as the data container: {intersection_output}\"\n+            f\"XXComputed the intersection as the data container: {intersection_output}XX\"\n         )\n     # display the results of the profiling if that option was requested\n     if profile:\n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      },
      {
        "name": "Mutant #69",
        "line": 207,
        "description": [
          "            f\":microscope: Here's profiling data from computing an intersection with random data containers of {number}!\""
        ],
        "failure": [
          {
            "inner": "--- src/main.py\n+++ src/main.py\n@@ -204,7 +204,7 @@\n     if profile:\n         console.print()\n         console.print(\n-            f\":microscope: Here's profiling data from computing an intersection with random data containers of {number}!\"\n+            f\"XX:microscope: Here's profiling data from computing an intersection with random data containers of {number}!XX\"\n         )\n         profiler.print()\n \n",
            "type": "failure",
            "message": "bad_survived"
          }
        ]
      }
    ],
    "mutation_score": 0.0
  }
]