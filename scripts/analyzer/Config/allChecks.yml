checks:
  - name: "single-nested-if"
    code: "SNI"
    id: "CL001"
    description: "Ensure the presence of single nested 'if' statements within function bodies."
    pattern: './/FunctionDef/body//If'
    count:
      min: 1
      max: 10

  - name: "double-nested-if"
    code: "DNI"
    id: "CL002"
    description: "Ensure the presence of double nested 'if' statements within function bodies."
    pattern: './/FunctionDef/body//If[ancestor::If and not(parent::orelse)]'
    count:
      min: 1
      max: 10

  - name: "explicit-return-in-init"
    code: "RET"
    id: "RET001"
    description: "Using an explicit return statement in the __init__ function"
    pattern: './/FunctionDef[@name="__init__"]/body/Return'
    count:
      min: 1
      max: 10

  - name: "none-comparison"
    code: "NONE"
    id: "NONE001"
    description: "Using != None to check for non-None values"
    pattern: './/FunctionDef//Compare/left[@id="input_dirs"]/following-sibling::Compare/ops/NotEq | .//FunctionDef//Compare/comparators[@id="input_dirs"]/following-sibling::Compare/ops/NotEq'
    count:
      min: 1
      max: 10

  - name: "no-exception-type"
    code: "EXC"
    id: "EXC001"
    description: "No exception type(s)"
    pattern: './/FunctionDef//Try/ExceptHandler[not(ExceptHandler/type)]'
    count:
      min: 1
      max: 10

  - name: "boolean-comparison"
    code: "BOOL"
    id: "BOOL001"
    description: "Using = or == operators to compare boolean values"
    pattern: './/FunctionDef//Compare/ops/Is | .//FunctionDef//Compare/ops/Eq'
    count:
      min: 1
      max: 10

  - name: "missing-annotations"
    code: "ANNOT"
    id: "ANNOT001"
    description: "A function does not explicitly annotate arguments/parameters or the expected output"
    pattern: './/FunctionDef[not(args/arg/annotation) or not(returns)]'
    count:
      min: 1
      max: 10

  - name: "key-function"
    code: "KFUN"
    id: "KF001"
    description: "The use of .keys() function"
    pattern: './/FunctionDef//Call/func/Attribute[@attr="keys"]'
    count:
      min: 1
      max: 10

  - name: "multi-value-key-literal"
    code: "MVKL"
    id: "MVKL001"
    description: "Looks to see if a key has been repeated"
    pattern: './/FunctionDef/body/Assign/value/Dict/keys/Name[preceding-sibling::Name/@id = @id]'
    count:
      min: 1
      max: 10

  - name: "assert-tuple"
    code: "AT"
    id: "AT001"
    description: "Looks to see if assert is used on a tuple"
    pattern: './/FunctionDef[./body/Assert/test/Tuple]'
    count:
      min: 1
      max: 10

  - name: "loop-variable-iterates-overrides-iterator"
    code: "LVITOI"
    id: "LVITOI001"
    description: "If the iterator has the same name as the things it's iterating through"
    pattern: './/FunctionDef/body/For[target/Name/@id = iter/Name/@id]'
    count:
      min: 1
      max: 10

  - name: "function-uses-loop-variable"
    code: "FLV"
    id: "FLV001"
    description: "The loop variable is not bound in the function definition, so it will always have the value it had in the last iteration"
    pattern: './/FunctionDef[body//comprehension/target/Name]'
    count:
      min: 1
      max: 10

  - name: "nested-depth"
    code: "ND"
    id: "F001"
    description: "Ensure the depth of nesting within functions does not exceed the set value."
    pattern: './/FunctionDef//FunctionDef/ancestor::*'
    count:
      min: 1
      max: 10

  - name: "number-of-conditions-in-function"
    code: "#Cond"
    id: "F002"
    description: "Ensure the number of conditions (if, if-else, and switch) in a function is within acceptable limits."
    pattern: './/FunctionDef//If/following-sibling::If | .//FunctionDef//If/following-sibling::Elif | .//FunctionDef//If/following-sibling::Else'
    count:
      min: 1
      max: 10

  - name: "nested-conditions"
    code: "IFIF"
    id: "CL001"
    description: "Ensure there is at least one nested condition (e.g., if{if{}}) in a function."
    pattern: './/FunctionDef//If/descendant::If'
    count:
      min: 1
      max: 1

  - name: "nested-condition-loops"
    code: "IFOR"
    id: "CL002"
    description: "Ensure the presence of nested condition-loops (e.g., if{for{}}) in a function."
    pattern: './/FunctionDef//if//For'
    count:
      min: 1
      max: 10

  - name: "nested-loop-conditions"
    code: "VFF"
    id: "C002"
    description: "Ensure the presence of nested loop-conditions (e.g., for{if{}}) in a function."
    pattern: './/FunctionDef[//(If/following-sibling::For | For/following-sibling::If)]'
    count:
      min: 1
      max: 10

  - name: "nested-loop-conditions-ff"
    code: "FF"
    id: "F001"
    description: "Ensure the presence of nested loop-conditions (e.g., for{for{}}) in a function."
    pattern: './/FunctionDef//For[.//For]'
    count:
      min: 1
      max: 10

  - name: "number-of-assertions"
    code: "NOA"
    id: "NOA001"
    description: "Ensure the presence of assertions within function bodies."
    pattern: './/FunctionDef/body/Assert'
    count:
      min: 1
      max: 10

  - name: "count-test-method-lines"
    code: "LOF"
    id: "LOF001"
    description: "Count the lines within test methods that start with 'test_'."
    pattern: './/FunctionDef[starts-with(@name, "test_")]/body/*'
    count:
      min: 1
      max: 10

  - name: "count-method-lines"
    code: "CML"
    id: "CML001"
    description: "Count the lines within methods."
    pattern: './/FunctionDef/body/* | .//FunctionDef/body/Return'
    count:
      min: 1
      max: 10

  - name: "test-methods-invoking-method"
    code: "TMIM"
    id: "TMIM001"
    description: "Identify test methods invoking specific methods."
    pattern: './/FunctionDef[starts-with(@name, "test_")]//Assert[count(.//Call[func/Name/@id="test_function"]) > 0]'
    count:
      min: 1
      max: 10

  - name: "not-using-context-manager"
    code: "DUCM"
    id: "DUCM001"
    description: "Detect file handling without using the context manager."
    pattern: './/FunctionDef//*[starts-with(., "with open")]'
    count:
      min: 1
      max: 10

  - name: "multiple-returns-in-function"
    code: "MRET"
    id: "MRET001"
    description: "Detect functions with multiple return statements."
    pattern: './/FunctionDef[count(body//Return) > 2]'
    count:
      min: 1
      max: 10

  - name: "complex-expressions"
    code: "COMPLEX"
    id: "COMPLEX001"
    description: "Detect complex expressions with multiple operators."
    pattern: './/FunctionDef//BinOp[count(descendant::BinOp) > 2]'
    count:
      min: 1
      max: 10

  - name: "unused-variables"
    code: "UNUSED"
    id: "UNUSED001"
    description: "Detect variables that are defined but not used."
    pattern: '//FunctionDef[starts-with(@name, "test_")]//Assert[count(.//Call[func/Name]) > 0]'


#jss paper
  - name: "method-too-long"
    code: "MTL"
    id: "F026"
    description: "Methods with too many lines of code can be hard to understand and maintain."
    pattern: './/FunctionDef[count(./body/*) > 50]'

  - name: "high-cyclomatic-complexity"
    code: "HCC"
    id: "F027"
    description: "Methods with high cyclomatic complexity are hard to test and understand."
    pattern: './/FunctionDef[count(.//If | .//For | .//While | .//And | .//Or) > 10]'

  - name: "long-parameter-list"
    code: "LPL"
    id: "F028"
    description: "Functions with long parameter lists are hard to understand and use."
    pattern: './/FunctionDef[count(./args/args) > 5]'

  - name: "long-method-chaining"
    code: "LMC"
    id: "F029"
    description: "Long method chaining can reduce code readability and maintainability."
    pattern: './/Call[count(./func/Attribute) > 3]'

  - name: "deeply-nested-control-structures"
    code: "DNCS"
    id: "F030"
    description: "Deeply nested control structures make the code hard to read and understand."
    pattern: './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]'

  - name: "god-function"
    code: "GF"
    id: "F031"
    description: "Functions that try to do too much are hard to understand and maintain."
    pattern: './/FunctionDef[count(./body/*) > 100]'

  - name: "empty-catch-block"
    code: "ECB"
    id: "F032"
    description: "Catch blocks that are empty can hide errors and make debugging difficult."
    pattern: './/ExceptHandler[not(./body/*)]'

  - name: "magic-numbers"
    code: "MN"
    id: "F033"
    description: "Using hardcoded values in the code can reduce readability and make maintenance harder."
    pattern: './/Num'

  - name: "inconsistent-naming-convention"
    code: "INC"
    id: "F034"
    description: "Inconsistent naming conventions can reduce code readability and maintainability."
    pattern: './/FunctionDef[not(re:test(@name, "^[a-z_][a-z0-9_]*$"))]'

  - name: "use-of-global-variables"
    code: "UGV"
    id: "F035"
    description: "Use of global variables can lead to code that is hard to debug and maintain."
    pattern: './/Global'

#Detecting Code Smells in Python Programs paper 
  - name: "large-class"
    code: "LC"
    id: "P001"
    description: "A class that is too large."
    pattern: './/ClassDef[count(./body/*) > 50]'

  - name: "long-parameter-list"
    code: "LPL"
    id: "P002"
    description: "A method or function with too many parameters."
    pattern: './/FunctionDef[count(./args/args) > 5]'

  - name: "long-method"
    code: "LM"
    id: "P003"
    description: "A method or function that is too long."
    pattern: './/FunctionDef[count(./body/*) > 50]'

  - name: "long-message-chain"
    code: "LMC"
    id: "P004"
    description: "An expression accessing an object through a long chain of attributes or methods using the dot operator."
    pattern: './/Call[count(./func/Attribute) > 3]'

  - name: "long-scope-chaining"
    code: "LSC"
    id: "P005"
    description: "A multiply-nested method or function."
    pattern: './/FunctionDef[count(.//If | .//For | .//While | .//Try) > 3]'